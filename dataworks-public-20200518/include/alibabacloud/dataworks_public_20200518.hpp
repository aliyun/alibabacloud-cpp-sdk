// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_DATAWORKS-PUBLIC20200518_H_
#define ALIBABACLOUD_DATAWORKS-PUBLIC20200518_H_

#include <alibabacloud/rpc.hpp>
#include <boost/any.hpp>
#include <boost/throw_exception.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Dataworks-public20200518 {
class GenerateDISyncTaskConfigForCreatingRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> taskType{};
  shared_ptr<string> taskParam{};
  shared_ptr<string> clientToken{};

  GenerateDISyncTaskConfigForCreatingRequest() {}

  explicit GenerateDISyncTaskConfigForCreatingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!taskType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskType is required.")));
    }
    if (!taskParam) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskParam is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (taskParam) {
      res["TaskParam"] = boost::any(*taskParam);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("TaskParam") != m.end() && !m["TaskParam"].empty()) {
      taskParam = make_shared<string>(boost::any_cast<string>(m["TaskParam"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
  }


  virtual ~GenerateDISyncTaskConfigForCreatingRequest() = default;
};
class GenerateDISyncTaskConfigForCreatingResponseData : public Darabonba::Model {
public:
  shared_ptr<long> processId{};
  shared_ptr<string> status{};
  shared_ptr<string> message{};

  GenerateDISyncTaskConfigForCreatingResponseData() {}

  explicit GenerateDISyncTaskConfigForCreatingResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!processId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("processId is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!message) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("message is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (processId) {
      res["ProcessId"] = boost::any(*processId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProcessId") != m.end() && !m["ProcessId"].empty()) {
      processId = make_shared<long>(boost::any_cast<long>(m["ProcessId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~GenerateDISyncTaskConfigForCreatingResponseData() = default;
};
class GenerateDISyncTaskConfigForCreatingResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<GenerateDISyncTaskConfigForCreatingResponseData> data{};

  GenerateDISyncTaskConfigForCreatingResponse() {}

  explicit GenerateDISyncTaskConfigForCreatingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GenerateDISyncTaskConfigForCreatingResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GenerateDISyncTaskConfigForCreatingResponseData>(model1);
      }
    }
  }


  virtual ~GenerateDISyncTaskConfigForCreatingResponse() = default;
};
class GenerateDISyncTaskConfigForUpdatingRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> taskType{};
  shared_ptr<string> taskParam{};
  shared_ptr<string> clientToken{};
  shared_ptr<long> taskId{};

  GenerateDISyncTaskConfigForUpdatingRequest() {}

  explicit GenerateDISyncTaskConfigForUpdatingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!taskType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskType is required.")));
    }
    if (!taskParam) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskParam is required.")));
    }
    if (!taskId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (taskParam) {
      res["TaskParam"] = boost::any(*taskParam);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("TaskParam") != m.end() && !m["TaskParam"].empty()) {
      taskParam = make_shared<string>(boost::any_cast<string>(m["TaskParam"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
  }


  virtual ~GenerateDISyncTaskConfigForUpdatingRequest() = default;
};
class GenerateDISyncTaskConfigForUpdatingResponseData : public Darabonba::Model {
public:
  shared_ptr<long> processId{};
  shared_ptr<string> status{};
  shared_ptr<string> message{};

  GenerateDISyncTaskConfigForUpdatingResponseData() {}

  explicit GenerateDISyncTaskConfigForUpdatingResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!processId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("processId is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!message) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("message is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (processId) {
      res["ProcessId"] = boost::any(*processId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProcessId") != m.end() && !m["ProcessId"].empty()) {
      processId = make_shared<long>(boost::any_cast<long>(m["ProcessId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~GenerateDISyncTaskConfigForUpdatingResponseData() = default;
};
class GenerateDISyncTaskConfigForUpdatingResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<GenerateDISyncTaskConfigForUpdatingResponseData> data{};

  GenerateDISyncTaskConfigForUpdatingResponse() {}

  explicit GenerateDISyncTaskConfigForUpdatingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GenerateDISyncTaskConfigForUpdatingResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GenerateDISyncTaskConfigForUpdatingResponseData>(model1);
      }
    }
  }


  virtual ~GenerateDISyncTaskConfigForUpdatingResponse() = default;
};
class QueryDISyncTaskConfigProcessResultRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> taskType{};
  shared_ptr<long> asyncProcessId{};

  QueryDISyncTaskConfigProcessResultRequest() {}

  explicit QueryDISyncTaskConfigProcessResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!taskType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskType is required.")));
    }
    if (!asyncProcessId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("asyncProcessId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (asyncProcessId) {
      res["AsyncProcessId"] = boost::any(*asyncProcessId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("AsyncProcessId") != m.end() && !m["AsyncProcessId"].empty()) {
      asyncProcessId = make_shared<long>(boost::any_cast<long>(m["AsyncProcessId"]));
    }
  }


  virtual ~QueryDISyncTaskConfigProcessResultRequest() = default;
};
class QueryDISyncTaskConfigProcessResultResponseData : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> message{};
  shared_ptr<string> taskContent{};

  QueryDISyncTaskConfigProcessResultResponseData() {}

  explicit QueryDISyncTaskConfigProcessResultResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!message) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("message is required.")));
    }
    if (!taskContent) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskContent is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (taskContent) {
      res["TaskContent"] = boost::any(*taskContent);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("TaskContent") != m.end() && !m["TaskContent"].empty()) {
      taskContent = make_shared<string>(boost::any_cast<string>(m["TaskContent"]));
    }
  }


  virtual ~QueryDISyncTaskConfigProcessResultResponseData() = default;
};
class QueryDISyncTaskConfigProcessResultResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<QueryDISyncTaskConfigProcessResultResponseData> data{};

  QueryDISyncTaskConfigProcessResultResponse() {}

  explicit QueryDISyncTaskConfigProcessResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDISyncTaskConfigProcessResultResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDISyncTaskConfigProcessResultResponseData>(model1);
      }
    }
  }


  virtual ~QueryDISyncTaskConfigProcessResultResponse() = default;
};
class ListProjectIdsRequest : public Darabonba::Model {
public:
  shared_ptr<string> userId{};

  ListProjectIdsRequest() {}

  explicit ListProjectIdsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!userId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("userId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListProjectIdsRequest() = default;
};
class ListProjectIdsResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<long>> projectIds{};

  ListProjectIdsResponse() {}

  explicit ListProjectIdsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!projectIds) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectIds is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (projectIds) {
      res["ProjectIds"] = boost::any(*projectIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ProjectIds") != m.end() && !m["ProjectIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["ProjectIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ProjectIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      projectIds = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~ListProjectIdsResponse() = default;
};
class TerminateDISyncInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> taskType{};
  shared_ptr<long> fileId{};

  TerminateDISyncInstanceRequest() {}

  explicit TerminateDISyncInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!taskType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskType is required.")));
    }
    if (!fileId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("fileId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
  }


  virtual ~TerminateDISyncInstanceRequest() = default;
};
class TerminateDISyncInstanceResponseData : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> message{};

  TerminateDISyncInstanceResponseData() {}

  explicit TerminateDISyncInstanceResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!message) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("message is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~TerminateDISyncInstanceResponseData() = default;
};
class TerminateDISyncInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<TerminateDISyncInstanceResponseData> data{};

  TerminateDISyncInstanceResponse() {}

  explicit TerminateDISyncInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        TerminateDISyncInstanceResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<TerminateDISyncInstanceResponseData>(model1);
      }
    }
  }


  virtual ~TerminateDISyncInstanceResponse() = default;
};
class DeleteDISyncTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> taskType{};
  shared_ptr<long> fileId{};

  DeleteDISyncTaskRequest() {}

  explicit DeleteDISyncTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!taskType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskType is required.")));
    }
    if (!fileId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("fileId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
  }


  virtual ~DeleteDISyncTaskRequest() = default;
};
class DeleteDISyncTaskResponseData : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> message{};

  DeleteDISyncTaskResponseData() {}

  explicit DeleteDISyncTaskResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!message) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("message is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~DeleteDISyncTaskResponseData() = default;
};
class DeleteDISyncTaskResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<DeleteDISyncTaskResponseData> data{};

  DeleteDISyncTaskResponse() {}

  explicit DeleteDISyncTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DeleteDISyncTaskResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DeleteDISyncTaskResponseData>(model1);
      }
    }
  }


  virtual ~DeleteDISyncTaskResponse() = default;
};
class DeployDISyncTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> taskType{};
  shared_ptr<long> fileId{};

  DeployDISyncTaskRequest() {}

  explicit DeployDISyncTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!taskType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskType is required.")));
    }
    if (!fileId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("fileId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
  }


  virtual ~DeployDISyncTaskRequest() = default;
};
class DeployDISyncTaskResponseData : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> message{};

  DeployDISyncTaskResponseData() {}

  explicit DeployDISyncTaskResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!message) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("message is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~DeployDISyncTaskResponseData() = default;
};
class DeployDISyncTaskResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<DeployDISyncTaskResponseData> data{};

  DeployDISyncTaskResponse() {}

  explicit DeployDISyncTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DeployDISyncTaskResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DeployDISyncTaskResponseData>(model1);
      }
    }
  }


  virtual ~DeployDISyncTaskResponse() = default;
};
class StartDISyncInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> taskType{};
  shared_ptr<long> fileId{};
  shared_ptr<string> startParam{};

  StartDISyncInstanceRequest() {}

  explicit StartDISyncInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!taskType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskType is required.")));
    }
    if (!fileId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("fileId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (startParam) {
      res["StartParam"] = boost::any(*startParam);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
    if (m.find("StartParam") != m.end() && !m["StartParam"].empty()) {
      startParam = make_shared<string>(boost::any_cast<string>(m["StartParam"]));
    }
  }


  virtual ~StartDISyncInstanceRequest() = default;
};
class StartDISyncInstanceResponseData : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> message{};

  StartDISyncInstanceResponseData() {}

  explicit StartDISyncInstanceResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!message) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("message is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~StartDISyncInstanceResponseData() = default;
};
class StartDISyncInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<StartDISyncInstanceResponseData> data{};

  StartDISyncInstanceResponse() {}

  explicit StartDISyncInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        StartDISyncInstanceResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<StartDISyncInstanceResponseData>(model1);
      }
    }
  }


  virtual ~StartDISyncInstanceResponse() = default;
};
class GetDISyncInstanceInfoRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> taskType{};
  shared_ptr<long> fileId{};

  GetDISyncInstanceInfoRequest() {}

  explicit GetDISyncInstanceInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!taskType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskType is required.")));
    }
    if (!fileId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("fileId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
  }


  virtual ~GetDISyncInstanceInfoRequest() = default;
};
class GetDISyncInstanceInfoResponseDataSolutionInfoStepDetail : public Darabonba::Model {
public:
  shared_ptr<string> stepName{};
  shared_ptr<long> stepId{};
  shared_ptr<string> status{};

  GetDISyncInstanceInfoResponseDataSolutionInfoStepDetail() {}

  explicit GetDISyncInstanceInfoResponseDataSolutionInfoStepDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!stepName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("stepName is required.")));
    }
    if (!stepId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("stepId is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (stepName) {
      res["StepName"] = boost::any(*stepName);
    }
    if (stepId) {
      res["StepId"] = boost::any(*stepId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StepName") != m.end() && !m["StepName"].empty()) {
      stepName = make_shared<string>(boost::any_cast<string>(m["StepName"]));
    }
    if (m.find("StepId") != m.end() && !m["StepId"].empty()) {
      stepId = make_shared<long>(boost::any_cast<long>(m["StepId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetDISyncInstanceInfoResponseDataSolutionInfoStepDetail() = default;
};
class GetDISyncInstanceInfoResponseDataSolutionInfo : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> status{};
  shared_ptr<string> creatorName{};
  shared_ptr<vector<GetDISyncInstanceInfoResponseDataSolutionInfoStepDetail>> stepDetail{};

  GetDISyncInstanceInfoResponseDataSolutionInfo() {}

  explicit GetDISyncInstanceInfoResponseDataSolutionInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!id) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("id is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!creatorName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("creatorName is required.")));
    }
    if (!stepDetail) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("stepDetail is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (creatorName) {
      res["CreatorName"] = boost::any(*creatorName);
    }
    if (stepDetail) {
      vector<boost::any> temp1;
      for(auto item1:*stepDetail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StepDetail"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("CreatorName") != m.end() && !m["CreatorName"].empty()) {
      creatorName = make_shared<string>(boost::any_cast<string>(m["CreatorName"]));
    }
    if (m.find("StepDetail") != m.end() && !m["StepDetail"].empty()) {
      if (typeid(vector<boost::any>) == m["StepDetail"].type()) {
        vector<GetDISyncInstanceInfoResponseDataSolutionInfoStepDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StepDetail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDISyncInstanceInfoResponseDataSolutionInfoStepDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        stepDetail = make_shared<vector<GetDISyncInstanceInfoResponseDataSolutionInfoStepDetail>>(expect1);
      }
    }
  }


  virtual ~GetDISyncInstanceInfoResponseDataSolutionInfo() = default;
};
class GetDISyncInstanceInfoResponseData : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> name{};
  shared_ptr<string> message{};
  shared_ptr<GetDISyncInstanceInfoResponseDataSolutionInfo> solutionInfo{};

  GetDISyncInstanceInfoResponseData() {}

  explicit GetDISyncInstanceInfoResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!name) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("name is required.")));
    }
    if (!message) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("message is required.")));
    }
    if (!solutionInfo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("solutionInfo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (solutionInfo) {
      res["SolutionInfo"] = solutionInfo ? boost::any(solutionInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("SolutionInfo") != m.end() && !m["SolutionInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["SolutionInfo"].type()) {
        GetDISyncInstanceInfoResponseDataSolutionInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SolutionInfo"]));
        solutionInfo = make_shared<GetDISyncInstanceInfoResponseDataSolutionInfo>(model1);
      }
    }
  }


  virtual ~GetDISyncInstanceInfoResponseData() = default;
};
class GetDISyncInstanceInfoResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<GetDISyncInstanceInfoResponseData> data{};

  GetDISyncInstanceInfoResponse() {}

  explicit GetDISyncInstanceInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetDISyncInstanceInfoResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetDISyncInstanceInfoResponseData>(model1);
      }
    }
  }


  virtual ~GetDISyncInstanceInfoResponse() = default;
};
class StopDISyncInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> taskType{};
  shared_ptr<long> fileId{};

  StopDISyncInstanceRequest() {}

  explicit StopDISyncInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!taskType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskType is required.")));
    }
    if (!fileId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("fileId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
  }


  virtual ~StopDISyncInstanceRequest() = default;
};
class StopDISyncInstanceResponseData : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> message{};

  StopDISyncInstanceResponseData() {}

  explicit StopDISyncInstanceResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!message) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("message is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~StopDISyncInstanceResponseData() = default;
};
class StopDISyncInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<StopDISyncInstanceResponseData> data{};

  StopDISyncInstanceResponse() {}

  explicit StopDISyncInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        StopDISyncInstanceResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<StopDISyncInstanceResponseData>(model1);
      }
    }
  }


  virtual ~StopDISyncInstanceResponse() = default;
};
class GetDISyncTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> taskType{};
  shared_ptr<long> fileId{};

  GetDISyncTaskRequest() {}

  explicit GetDISyncTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!taskType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskType is required.")));
    }
    if (!fileId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("fileId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
  }


  virtual ~GetDISyncTaskRequest() = default;
};
class GetDISyncTaskResponseDataSolutionDetail : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> type{};
  shared_ptr<long> projectId{};
  shared_ptr<string> status{};
  shared_ptr<string> processContent{};
  shared_ptr<string> startTime{};
  shared_ptr<string> name{};
  shared_ptr<string> creatorName{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> submitTime{};
  shared_ptr<string> processExtra{};

  GetDISyncTaskResponseDataSolutionDetail() {}

  explicit GetDISyncTaskResponseDataSolutionDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!id) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("id is required.")));
    }
    if (!type) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("type is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!processContent) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("processContent is required.")));
    }
    if (!startTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("startTime is required.")));
    }
    if (!name) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("name is required.")));
    }
    if (!creatorName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("creatorName is required.")));
    }
    if (!sourceType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("sourceType is required.")));
    }
    if (!submitTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("submitTime is required.")));
    }
    if (!processExtra) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("processExtra is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (processContent) {
      res["ProcessContent"] = boost::any(*processContent);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (creatorName) {
      res["CreatorName"] = boost::any(*creatorName);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (submitTime) {
      res["SubmitTime"] = boost::any(*submitTime);
    }
    if (processExtra) {
      res["ProcessExtra"] = boost::any(*processExtra);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("ProcessContent") != m.end() && !m["ProcessContent"].empty()) {
      processContent = make_shared<string>(boost::any_cast<string>(m["ProcessContent"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("CreatorName") != m.end() && !m["CreatorName"].empty()) {
      creatorName = make_shared<string>(boost::any_cast<string>(m["CreatorName"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("SubmitTime") != m.end() && !m["SubmitTime"].empty()) {
      submitTime = make_shared<string>(boost::any_cast<string>(m["SubmitTime"]));
    }
    if (m.find("ProcessExtra") != m.end() && !m["ProcessExtra"].empty()) {
      processExtra = make_shared<string>(boost::any_cast<string>(m["ProcessExtra"]));
    }
  }


  virtual ~GetDISyncTaskResponseDataSolutionDetail() = default;
};
class GetDISyncTaskResponseData : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> status{};
  shared_ptr<string> message{};
  shared_ptr<GetDISyncTaskResponseDataSolutionDetail> solutionDetail{};

  GetDISyncTaskResponseData() {}

  explicit GetDISyncTaskResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!message) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("message is required.")));
    }
    if (!solutionDetail) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("solutionDetail is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (solutionDetail) {
      res["SolutionDetail"] = solutionDetail ? boost::any(solutionDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("SolutionDetail") != m.end() && !m["SolutionDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["SolutionDetail"].type()) {
        GetDISyncTaskResponseDataSolutionDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SolutionDetail"]));
        solutionDetail = make_shared<GetDISyncTaskResponseDataSolutionDetail>(model1);
      }
    }
  }


  virtual ~GetDISyncTaskResponseData() = default;
};
class GetDISyncTaskResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<GetDISyncTaskResponseData> data{};

  GetDISyncTaskResponse() {}

  explicit GetDISyncTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetDISyncTaskResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetDISyncTaskResponseData>(model1);
      }
    }
  }


  virtual ~GetDISyncTaskResponse() = default;
};
class CheckMetaTableTaskRequest : public Darabonba::Model {
public:

  CheckMetaTableTaskRequest() {}

  explicit CheckMetaTableTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
  }


  virtual ~CheckMetaTableTaskRequest() = default;
};
class CheckMetaTableTaskResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> data{};

  CheckMetaTableTaskResponse() {}

  explicit CheckMetaTableTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
  }


  virtual ~CheckMetaTableTaskResponse() = default;
};
class CheckEngineMetaPartitionRequest : public Darabonba::Model {
public:
  shared_ptr<string> tableGuid{};
  shared_ptr<string> partition{};
  shared_ptr<string> dataSourceType{};

  CheckEngineMetaPartitionRequest() {}

  explicit CheckEngineMetaPartitionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!tableGuid) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tableGuid is required.")));
    }
    if (!partition) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("partition is required.")));
    }
    if (!dataSourceType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dataSourceType is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (partition) {
      res["Partition"] = boost::any(*partition);
    }
    if (dataSourceType) {
      res["DataSourceType"] = boost::any(*dataSourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("Partition") != m.end() && !m["Partition"].empty()) {
      partition = make_shared<string>(boost::any_cast<string>(m["Partition"]));
    }
    if (m.find("DataSourceType") != m.end() && !m["DataSourceType"].empty()) {
      dataSourceType = make_shared<string>(boost::any_cast<string>(m["DataSourceType"]));
    }
  }


  virtual ~CheckEngineMetaPartitionRequest() = default;
};
class CheckEngineMetaPartitionResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> data{};

  CheckEngineMetaPartitionResponse() {}

  explicit CheckEngineMetaPartitionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
  }


  virtual ~CheckEngineMetaPartitionResponse() = default;
};
class CheckEngineMetaTableRequest : public Darabonba::Model {
public:
  shared_ptr<string> tableGuid{};
  shared_ptr<string> dataSourceType{};

  CheckEngineMetaTableRequest() {}

  explicit CheckEngineMetaTableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!tableGuid) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tableGuid is required.")));
    }
    if (!dataSourceType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dataSourceType is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (dataSourceType) {
      res["DataSourceType"] = boost::any(*dataSourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("DataSourceType") != m.end() && !m["DataSourceType"].empty()) {
      dataSourceType = make_shared<string>(boost::any_cast<string>(m["DataSourceType"]));
    }
  }


  virtual ~CheckEngineMetaTableRequest() = default;
};
class CheckEngineMetaTableResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> data{};

  CheckEngineMetaTableResponse() {}

  explicit CheckEngineMetaTableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
  }


  virtual ~CheckEngineMetaTableResponse() = default;
};
class ImportDataSourcesRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> dataSources{};

  ImportDataSourcesRequest() {}

  explicit ImportDataSourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!dataSources) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dataSources is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (dataSources) {
      res["DataSources"] = boost::any(*dataSources);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("DataSources") != m.end() && !m["DataSources"].empty()) {
      dataSources = make_shared<string>(boost::any_cast<string>(m["DataSources"]));
    }
  }


  virtual ~ImportDataSourcesRequest() = default;
};
class ImportDataSourcesResponseData : public Darabonba::Model {
public:
  shared_ptr<bool> status{};
  shared_ptr<string> message{};

  ImportDataSourcesResponseData() {}

  explicit ImportDataSourcesResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!message) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("message is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<bool>(boost::any_cast<bool>(m["Status"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~ImportDataSourcesResponseData() = default;
};
class ImportDataSourcesResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<ImportDataSourcesResponseData> data{};

  ImportDataSourcesResponse() {}

  explicit ImportDataSourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ImportDataSourcesResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ImportDataSourcesResponseData>(model1);
      }
    }
  }


  virtual ~ImportDataSourcesResponse() = default;
};
class ExportDataSourcesRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> name{};
  shared_ptr<string> dataSourceType{};
  shared_ptr<string> subType{};
  shared_ptr<int> envType{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> pageNumber{};

  ExportDataSourcesRequest() {}

  explicit ExportDataSourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (dataSourceType) {
      res["DataSourceType"] = boost::any(*dataSourceType);
    }
    if (subType) {
      res["SubType"] = boost::any(*subType);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("DataSourceType") != m.end() && !m["DataSourceType"].empty()) {
      dataSourceType = make_shared<string>(boost::any_cast<string>(m["DataSourceType"]));
    }
    if (m.find("SubType") != m.end() && !m["SubType"].empty()) {
      subType = make_shared<string>(boost::any_cast<string>(m["SubType"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<int>(boost::any_cast<int>(m["EnvType"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
  }


  virtual ~ExportDataSourcesRequest() = default;
};
class ExportDataSourcesResponseDataDataSources : public Darabonba::Model {
public:
  shared_ptr<bool> shared{};
  shared_ptr<string> gmtModified{};
  shared_ptr<int> connectStatus{};
  shared_ptr<int> bindingCalcEngineId{};
  shared_ptr<string> description{};
  shared_ptr<string> dataSourceType{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<bool> defaultEngine{};
  shared_ptr<string> operator_{};
  shared_ptr<int> sequence{};
  shared_ptr<int> envType{};
  shared_ptr<long> tenantId{};
  shared_ptr<string> name{};
  shared_ptr<string> subType{};
  shared_ptr<int> id{};
  shared_ptr<int> projectId{};
  shared_ptr<int> status{};
  shared_ptr<string> content{};

  ExportDataSourcesResponseDataDataSources() {}

  explicit ExportDataSourcesResponseDataDataSources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!shared) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("shared is required.")));
    }
    if (!gmtModified) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtModified is required.")));
    }
    if (!connectStatus) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("connectStatus is required.")));
    }
    if (!bindingCalcEngineId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("bindingCalcEngineId is required.")));
    }
    if (!description) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("description is required.")));
    }
    if (!dataSourceType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dataSourceType is required.")));
    }
    if (!gmtCreate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtCreate is required.")));
    }
    if (!defaultEngine) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("defaultEngine is required.")));
    }
    if (!operator_) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("operator is required.")));
    }
    if (!sequence) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("sequence is required.")));
    }
    if (!envType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("envType is required.")));
    }
    if (!tenantId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tenantId is required.")));
    }
    if (!name) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("name is required.")));
    }
    if (!subType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("subType is required.")));
    }
    if (!id) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("id is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!content) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("content is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (shared) {
      res["Shared"] = boost::any(*shared);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (connectStatus) {
      res["ConnectStatus"] = boost::any(*connectStatus);
    }
    if (bindingCalcEngineId) {
      res["BindingCalcEngineId"] = boost::any(*bindingCalcEngineId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dataSourceType) {
      res["DataSourceType"] = boost::any(*dataSourceType);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (defaultEngine) {
      res["DefaultEngine"] = boost::any(*defaultEngine);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (subType) {
      res["SubType"] = boost::any(*subType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Shared") != m.end() && !m["Shared"].empty()) {
      shared = make_shared<bool>(boost::any_cast<bool>(m["Shared"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("ConnectStatus") != m.end() && !m["ConnectStatus"].empty()) {
      connectStatus = make_shared<int>(boost::any_cast<int>(m["ConnectStatus"]));
    }
    if (m.find("BindingCalcEngineId") != m.end() && !m["BindingCalcEngineId"].empty()) {
      bindingCalcEngineId = make_shared<int>(boost::any_cast<int>(m["BindingCalcEngineId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DataSourceType") != m.end() && !m["DataSourceType"].empty()) {
      dataSourceType = make_shared<string>(boost::any_cast<string>(m["DataSourceType"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("DefaultEngine") != m.end() && !m["DefaultEngine"].empty()) {
      defaultEngine = make_shared<bool>(boost::any_cast<bool>(m["DefaultEngine"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<int>(boost::any_cast<int>(m["Sequence"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<int>(boost::any_cast<int>(m["EnvType"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SubType") != m.end() && !m["SubType"].empty()) {
      subType = make_shared<string>(boost::any_cast<string>(m["SubType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<int>(boost::any_cast<int>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<int>(boost::any_cast<int>(m["ProjectId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<int>(boost::any_cast<int>(m["Status"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
  }


  virtual ~ExportDataSourcesResponseDataDataSources() = default;
};
class ExportDataSourcesResponseData : public Darabonba::Model {
public:
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> totalCount{};
  shared_ptr<vector<ExportDataSourcesResponseDataDataSources>> dataSources{};

  ExportDataSourcesResponseData() {}

  explicit ExportDataSourcesResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageNumber) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNumber is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!totalCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("totalCount is required.")));
    }
    if (!dataSources) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dataSources is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (dataSources) {
      vector<boost::any> temp1;
      for(auto item1:*dataSources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataSources"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<int>(boost::any_cast<int>(m["TotalCount"]));
    }
    if (m.find("DataSources") != m.end() && !m["DataSources"].empty()) {
      if (typeid(vector<boost::any>) == m["DataSources"].type()) {
        vector<ExportDataSourcesResponseDataDataSources> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataSources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ExportDataSourcesResponseDataDataSources model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataSources = make_shared<vector<ExportDataSourcesResponseDataDataSources>>(expect1);
      }
    }
  }


  virtual ~ExportDataSourcesResponseData() = default;
};
class ExportDataSourcesResponse : public Darabonba::Model {
public:
  shared_ptr<int> httpStatusCode{};
  shared_ptr<bool> success{};
  shared_ptr<string> requestId{};
  shared_ptr<ExportDataSourcesResponseData> data{};

  ExportDataSourcesResponse() {}

  explicit ExportDataSourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ExportDataSourcesResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ExportDataSourcesResponseData>(model1);
      }
    }
  }


  virtual ~ExportDataSourcesResponse() = default;
};
class GetDataSourceMetaRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> datasourceName{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> envType{};

  GetDataSourceMetaRequest() {}

  explicit GetDataSourceMetaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!datasourceName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("datasourceName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (datasourceName) {
      res["DatasourceName"] = boost::any(*datasourceName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("DatasourceName") != m.end() && !m["DatasourceName"].empty()) {
      datasourceName = make_shared<string>(boost::any_cast<string>(m["DatasourceName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
  }


  virtual ~GetDataSourceMetaRequest() = default;
};
class GetDataSourceMetaResponseData : public Darabonba::Model {
public:
  shared_ptr<string> meta{};
  shared_ptr<string> status{};
  shared_ptr<string> message{};

  GetDataSourceMetaResponseData() {}

  explicit GetDataSourceMetaResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!meta) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("meta is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!message) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("message is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (meta) {
      res["Meta"] = boost::any(*meta);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Meta") != m.end() && !m["Meta"].empty()) {
      meta = make_shared<string>(boost::any_cast<string>(m["Meta"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~GetDataSourceMetaResponseData() = default;
};
class GetDataSourceMetaResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<GetDataSourceMetaResponseData> data{};

  GetDataSourceMetaResponse() {}

  explicit GetDataSourceMetaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetDataSourceMetaResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetDataSourceMetaResponseData>(model1);
      }
    }
  }


  virtual ~GetDataSourceMetaResponse() = default;
};
class SetDataSourceShareRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> datasourceName{};
  shared_ptr<string> envType{};
  shared_ptr<string> projectPermissions{};
  shared_ptr<string> userPermissions{};

  SetDataSourceShareRequest() {}

  explicit SetDataSourceShareRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!datasourceName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("datasourceName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (datasourceName) {
      res["DatasourceName"] = boost::any(*datasourceName);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (projectPermissions) {
      res["ProjectPermissions"] = boost::any(*projectPermissions);
    }
    if (userPermissions) {
      res["UserPermissions"] = boost::any(*userPermissions);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("DatasourceName") != m.end() && !m["DatasourceName"].empty()) {
      datasourceName = make_shared<string>(boost::any_cast<string>(m["DatasourceName"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("ProjectPermissions") != m.end() && !m["ProjectPermissions"].empty()) {
      projectPermissions = make_shared<string>(boost::any_cast<string>(m["ProjectPermissions"]));
    }
    if (m.find("UserPermissions") != m.end() && !m["UserPermissions"].empty()) {
      userPermissions = make_shared<string>(boost::any_cast<string>(m["UserPermissions"]));
    }
  }


  virtual ~SetDataSourceShareRequest() = default;
};
class SetDataSourceShareResponseData : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> message{};

  SetDataSourceShareResponseData() {}

  explicit SetDataSourceShareResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!message) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("message is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~SetDataSourceShareResponseData() = default;
};
class SetDataSourceShareResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<SetDataSourceShareResponseData> data{};

  SetDataSourceShareResponse() {}

  explicit SetDataSourceShareResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        SetDataSourceShareResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<SetDataSourceShareResponseData>(model1);
      }
    }
  }


  virtual ~SetDataSourceShareResponse() = default;
};
class ListDIProjectConfigRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> destinationType{};
  shared_ptr<string> sourceType{};

  ListDIProjectConfigRequest() {}

  explicit ListDIProjectConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!destinationType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("destinationType is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (destinationType) {
      res["DestinationType"] = boost::any(*destinationType);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("DestinationType") != m.end() && !m["DestinationType"].empty()) {
      destinationType = make_shared<string>(boost::any_cast<string>(m["DestinationType"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
  }


  virtual ~ListDIProjectConfigRequest() = default;
};
class ListDIProjectConfigResponseData : public Darabonba::Model {
public:
  shared_ptr<string> config{};

  ListDIProjectConfigResponseData() {}

  explicit ListDIProjectConfigResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!config) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("config is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = boost::any(*config);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
  }


  virtual ~ListDIProjectConfigResponseData() = default;
};
class ListDIProjectConfigResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<ListDIProjectConfigResponseData> data{};

  ListDIProjectConfigResponse() {}

  explicit ListDIProjectConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListDIProjectConfigResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListDIProjectConfigResponseData>(model1);
      }
    }
  }


  virtual ~ListDIProjectConfigResponse() = default;
};
class ExportConnectionsRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> name{};
  shared_ptr<string> dataSourceType{};
  shared_ptr<string> subType{};
  shared_ptr<int> envType{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> pageNumber{};

  ExportConnectionsRequest() {}

  explicit ExportConnectionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (dataSourceType) {
      res["DataSourceType"] = boost::any(*dataSourceType);
    }
    if (subType) {
      res["SubType"] = boost::any(*subType);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("DataSourceType") != m.end() && !m["DataSourceType"].empty()) {
      dataSourceType = make_shared<string>(boost::any_cast<string>(m["DataSourceType"]));
    }
    if (m.find("SubType") != m.end() && !m["SubType"].empty()) {
      subType = make_shared<string>(boost::any_cast<string>(m["SubType"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<int>(boost::any_cast<int>(m["EnvType"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
  }


  virtual ~ExportConnectionsRequest() = default;
};
class ExportConnectionsResponseDataDataSources : public Darabonba::Model {
public:
  shared_ptr<bool> shared{};
  shared_ptr<string> gmtModified{};
  shared_ptr<int> connectStatus{};
  shared_ptr<int> bindingCalcEngineId{};
  shared_ptr<string> description{};
  shared_ptr<string> dataSourceType{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<bool> defaultEngine{};
  shared_ptr<string> operator_{};
  shared_ptr<int> sequence{};
  shared_ptr<int> envType{};
  shared_ptr<long> tenantId{};
  shared_ptr<string> name{};
  shared_ptr<string> subType{};
  shared_ptr<int> id{};
  shared_ptr<int> projectId{};
  shared_ptr<int> status{};
  shared_ptr<string> content{};

  ExportConnectionsResponseDataDataSources() {}

  explicit ExportConnectionsResponseDataDataSources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!shared) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("shared is required.")));
    }
    if (!gmtModified) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtModified is required.")));
    }
    if (!connectStatus) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("connectStatus is required.")));
    }
    if (!bindingCalcEngineId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("bindingCalcEngineId is required.")));
    }
    if (!description) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("description is required.")));
    }
    if (!dataSourceType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dataSourceType is required.")));
    }
    if (!gmtCreate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtCreate is required.")));
    }
    if (!defaultEngine) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("defaultEngine is required.")));
    }
    if (!operator_) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("operator is required.")));
    }
    if (!sequence) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("sequence is required.")));
    }
    if (!envType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("envType is required.")));
    }
    if (!tenantId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tenantId is required.")));
    }
    if (!name) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("name is required.")));
    }
    if (!subType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("subType is required.")));
    }
    if (!id) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("id is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!content) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("content is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (shared) {
      res["Shared"] = boost::any(*shared);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (connectStatus) {
      res["ConnectStatus"] = boost::any(*connectStatus);
    }
    if (bindingCalcEngineId) {
      res["BindingCalcEngineId"] = boost::any(*bindingCalcEngineId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dataSourceType) {
      res["DataSourceType"] = boost::any(*dataSourceType);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (defaultEngine) {
      res["DefaultEngine"] = boost::any(*defaultEngine);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (subType) {
      res["SubType"] = boost::any(*subType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Shared") != m.end() && !m["Shared"].empty()) {
      shared = make_shared<bool>(boost::any_cast<bool>(m["Shared"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("ConnectStatus") != m.end() && !m["ConnectStatus"].empty()) {
      connectStatus = make_shared<int>(boost::any_cast<int>(m["ConnectStatus"]));
    }
    if (m.find("BindingCalcEngineId") != m.end() && !m["BindingCalcEngineId"].empty()) {
      bindingCalcEngineId = make_shared<int>(boost::any_cast<int>(m["BindingCalcEngineId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DataSourceType") != m.end() && !m["DataSourceType"].empty()) {
      dataSourceType = make_shared<string>(boost::any_cast<string>(m["DataSourceType"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("DefaultEngine") != m.end() && !m["DefaultEngine"].empty()) {
      defaultEngine = make_shared<bool>(boost::any_cast<bool>(m["DefaultEngine"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<int>(boost::any_cast<int>(m["Sequence"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<int>(boost::any_cast<int>(m["EnvType"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SubType") != m.end() && !m["SubType"].empty()) {
      subType = make_shared<string>(boost::any_cast<string>(m["SubType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<int>(boost::any_cast<int>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<int>(boost::any_cast<int>(m["ProjectId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<int>(boost::any_cast<int>(m["Status"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
  }


  virtual ~ExportConnectionsResponseDataDataSources() = default;
};
class ExportConnectionsResponseData : public Darabonba::Model {
public:
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> totalCount{};
  shared_ptr<vector<ExportConnectionsResponseDataDataSources>> dataSources{};

  ExportConnectionsResponseData() {}

  explicit ExportConnectionsResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageNumber) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNumber is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!totalCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("totalCount is required.")));
    }
    if (!dataSources) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dataSources is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (dataSources) {
      vector<boost::any> temp1;
      for(auto item1:*dataSources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataSources"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<int>(boost::any_cast<int>(m["TotalCount"]));
    }
    if (m.find("DataSources") != m.end() && !m["DataSources"].empty()) {
      if (typeid(vector<boost::any>) == m["DataSources"].type()) {
        vector<ExportConnectionsResponseDataDataSources> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataSources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ExportConnectionsResponseDataDataSources model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataSources = make_shared<vector<ExportConnectionsResponseDataDataSources>>(expect1);
      }
    }
  }


  virtual ~ExportConnectionsResponseData() = default;
};
class ExportConnectionsResponse : public Darabonba::Model {
public:
  shared_ptr<int> httpStatusCode{};
  shared_ptr<bool> success{};
  shared_ptr<string> requestId{};
  shared_ptr<ExportConnectionsResponseData> data{};

  ExportConnectionsResponse() {}

  explicit ExportConnectionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ExportConnectionsResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ExportConnectionsResponseData>(model1);
      }
    }
  }


  virtual ~ExportConnectionsResponse() = default;
};
class ListRefDISyncTasksRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> datasourceName{};
  shared_ptr<string> taskType{};
  shared_ptr<string> refType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListRefDISyncTasksRequest() {}

  explicit ListRefDISyncTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!datasourceName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("datasourceName is required.")));
    }
    if (!taskType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskType is required.")));
    }
    if (!refType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("refType is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (datasourceName) {
      res["DatasourceName"] = boost::any(*datasourceName);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (refType) {
      res["RefType"] = boost::any(*refType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("DatasourceName") != m.end() && !m["DatasourceName"].empty()) {
      datasourceName = make_shared<string>(boost::any_cast<string>(m["DatasourceName"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("RefType") != m.end() && !m["RefType"].empty()) {
      refType = make_shared<string>(boost::any_cast<string>(m["RefType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListRefDISyncTasksRequest() = default;
};
class ListRefDISyncTasksResponseDataDISyncTasks : public Darabonba::Model {
public:
  shared_ptr<string> nodeName{};
  shared_ptr<long> nodeId{};
  shared_ptr<string> taskType{};
  shared_ptr<string> diDestinationDatasource{};
  shared_ptr<string> diSourceDatasource{};

  ListRefDISyncTasksResponseDataDISyncTasks() {}

  explicit ListRefDISyncTasksResponseDataDISyncTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!nodeName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeName is required.")));
    }
    if (!nodeId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeId is required.")));
    }
    if (!taskType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskType is required.")));
    }
    if (!diDestinationDatasource) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("diDestinationDatasource is required.")));
    }
    if (!diSourceDatasource) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("diSourceDatasource is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (diDestinationDatasource) {
      res["DiDestinationDatasource"] = boost::any(*diDestinationDatasource);
    }
    if (diSourceDatasource) {
      res["DiSourceDatasource"] = boost::any(*diSourceDatasource);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("DiDestinationDatasource") != m.end() && !m["DiDestinationDatasource"].empty()) {
      diDestinationDatasource = make_shared<string>(boost::any_cast<string>(m["DiDestinationDatasource"]));
    }
    if (m.find("DiSourceDatasource") != m.end() && !m["DiSourceDatasource"].empty()) {
      diSourceDatasource = make_shared<string>(boost::any_cast<string>(m["DiSourceDatasource"]));
    }
  }


  virtual ~ListRefDISyncTasksResponseDataDISyncTasks() = default;
};
class ListRefDISyncTasksResponseData : public Darabonba::Model {
public:
  shared_ptr<vector<ListRefDISyncTasksResponseDataDISyncTasks>> DISyncTasks{};

  ListRefDISyncTasksResponseData() {}

  explicit ListRefDISyncTasksResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!DISyncTasks) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("DISyncTasks is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DISyncTasks) {
      vector<boost::any> temp1;
      for(auto item1:*DISyncTasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DISyncTasks"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DISyncTasks") != m.end() && !m["DISyncTasks"].empty()) {
      if (typeid(vector<boost::any>) == m["DISyncTasks"].type()) {
        vector<ListRefDISyncTasksResponseDataDISyncTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DISyncTasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRefDISyncTasksResponseDataDISyncTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        DISyncTasks = make_shared<vector<ListRefDISyncTasksResponseDataDISyncTasks>>(expect1);
      }
    }
  }


  virtual ~ListRefDISyncTasksResponseData() = default;
};
class ListRefDISyncTasksResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<ListRefDISyncTasksResponseData> data{};

  ListRefDISyncTasksResponse() {}

  explicit ListRefDISyncTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListRefDISyncTasksResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListRefDISyncTasksResponseData>(model1);
      }
    }
  }


  virtual ~ListRefDISyncTasksResponse() = default;
};
class SetConnectionShareRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> datasourceName{};
  shared_ptr<string> envType{};
  shared_ptr<string> projectPermissions{};
  shared_ptr<string> userPermissions{};

  SetConnectionShareRequest() {}

  explicit SetConnectionShareRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!datasourceName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("datasourceName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (datasourceName) {
      res["DatasourceName"] = boost::any(*datasourceName);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (projectPermissions) {
      res["ProjectPermissions"] = boost::any(*projectPermissions);
    }
    if (userPermissions) {
      res["UserPermissions"] = boost::any(*userPermissions);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("DatasourceName") != m.end() && !m["DatasourceName"].empty()) {
      datasourceName = make_shared<string>(boost::any_cast<string>(m["DatasourceName"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("ProjectPermissions") != m.end() && !m["ProjectPermissions"].empty()) {
      projectPermissions = make_shared<string>(boost::any_cast<string>(m["ProjectPermissions"]));
    }
    if (m.find("UserPermissions") != m.end() && !m["UserPermissions"].empty()) {
      userPermissions = make_shared<string>(boost::any_cast<string>(m["UserPermissions"]));
    }
  }


  virtual ~SetConnectionShareRequest() = default;
};
class SetConnectionShareResponseData : public Darabonba::Model {
public:
  shared_ptr<string> status{};

  SetConnectionShareResponseData() {}

  explicit SetConnectionShareResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~SetConnectionShareResponseData() = default;
};
class SetConnectionShareResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<SetConnectionShareResponseData> data{};

  SetConnectionShareResponse() {}

  explicit SetConnectionShareResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        SetConnectionShareResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<SetConnectionShareResponseData>(model1);
      }
    }
  }


  virtual ~SetConnectionShareResponse() = default;
};
class ImportConnectionsRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> connections{};

  ImportConnectionsRequest() {}

  explicit ImportConnectionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!connections) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("connections is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (connections) {
      res["Connections"] = boost::any(*connections);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Connections") != m.end() && !m["Connections"].empty()) {
      connections = make_shared<string>(boost::any_cast<string>(m["Connections"]));
    }
  }


  virtual ~ImportConnectionsRequest() = default;
};
class ImportConnectionsResponseData : public Darabonba::Model {
public:
  shared_ptr<bool> status{};
  shared_ptr<string> message{};

  ImportConnectionsResponseData() {}

  explicit ImportConnectionsResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!message) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("message is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<bool>(boost::any_cast<bool>(m["Status"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~ImportConnectionsResponseData() = default;
};
class ImportConnectionsResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<ImportConnectionsResponseData> data{};

  ImportConnectionsResponse() {}

  explicit ImportConnectionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ImportConnectionsResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ImportConnectionsResponseData>(model1);
      }
    }
  }


  virtual ~ImportConnectionsResponse() = default;
};
class GetConnectionMetaRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> datasourceName{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> envType{};

  GetConnectionMetaRequest() {}

  explicit GetConnectionMetaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!datasourceName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("datasourceName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (datasourceName) {
      res["DatasourceName"] = boost::any(*datasourceName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("DatasourceName") != m.end() && !m["DatasourceName"].empty()) {
      datasourceName = make_shared<string>(boost::any_cast<string>(m["DatasourceName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
  }


  virtual ~GetConnectionMetaRequest() = default;
};
class GetConnectionMetaResponseData : public Darabonba::Model {
public:
  shared_ptr<string> meta{};

  GetConnectionMetaResponseData() {}

  explicit GetConnectionMetaResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!meta) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("meta is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (meta) {
      res["Meta"] = boost::any(*meta);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Meta") != m.end() && !m["Meta"].empty()) {
      meta = make_shared<string>(boost::any_cast<string>(m["Meta"]));
    }
  }


  virtual ~GetConnectionMetaResponseData() = default;
};
class GetConnectionMetaResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<GetConnectionMetaResponseData> data{};

  GetConnectionMetaResponse() {}

  explicit GetConnectionMetaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetConnectionMetaResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetConnectionMetaResponseData>(model1);
      }
    }
  }


  virtual ~GetConnectionMetaResponse() = default;
};
class UpdateDIProjectConfigRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> destinationType{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> projectConfig{};

  UpdateDIProjectConfigRequest() {}

  explicit UpdateDIProjectConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!destinationType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("destinationType is required.")));
    }
    if (!projectConfig) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectConfig is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (destinationType) {
      res["DestinationType"] = boost::any(*destinationType);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (projectConfig) {
      res["ProjectConfig"] = boost::any(*projectConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("DestinationType") != m.end() && !m["DestinationType"].empty()) {
      destinationType = make_shared<string>(boost::any_cast<string>(m["DestinationType"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("ProjectConfig") != m.end() && !m["ProjectConfig"].empty()) {
      projectConfig = make_shared<string>(boost::any_cast<string>(m["ProjectConfig"]));
    }
  }


  virtual ~UpdateDIProjectConfigRequest() = default;
};
class UpdateDIProjectConfigResponseData : public Darabonba::Model {
public:
  shared_ptr<string> status{};

  UpdateDIProjectConfigResponseData() {}

  explicit UpdateDIProjectConfigResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~UpdateDIProjectConfigResponseData() = default;
};
class UpdateDIProjectConfigResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<UpdateDIProjectConfigResponseData> data{};

  UpdateDIProjectConfigResponse() {}

  explicit UpdateDIProjectConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        UpdateDIProjectConfigResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<UpdateDIProjectConfigResponseData>(model1);
      }
    }
  }


  virtual ~UpdateDIProjectConfigResponse() = default;
};
class CreateDISyncTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> taskType{};
  shared_ptr<string> taskContent{};
  shared_ptr<string> taskParam{};
  shared_ptr<string> taskName{};
  shared_ptr<string> clientToken{};

  CreateDISyncTaskRequest() {}

  explicit CreateDISyncTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!taskType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskType is required.")));
    }
    if (!taskContent) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskContent is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (taskContent) {
      res["TaskContent"] = boost::any(*taskContent);
    }
    if (taskParam) {
      res["TaskParam"] = boost::any(*taskParam);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("TaskContent") != m.end() && !m["TaskContent"].empty()) {
      taskContent = make_shared<string>(boost::any_cast<string>(m["TaskContent"]));
    }
    if (m.find("TaskParam") != m.end() && !m["TaskParam"].empty()) {
      taskParam = make_shared<string>(boost::any_cast<string>(m["TaskParam"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
  }


  virtual ~CreateDISyncTaskRequest() = default;
};
class CreateDISyncTaskResponseData : public Darabonba::Model {
public:
  shared_ptr<long> fileId{};
  shared_ptr<string> status{};
  shared_ptr<string> message{};

  CreateDISyncTaskResponseData() {}

  explicit CreateDISyncTaskResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!fileId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("fileId is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!message) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("message is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~CreateDISyncTaskResponseData() = default;
};
class CreateDISyncTaskResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<CreateDISyncTaskResponseData> data{};

  CreateDISyncTaskResponse() {}

  explicit CreateDISyncTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateDISyncTaskResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateDISyncTaskResponseData>(model1);
      }
    }
  }


  virtual ~CreateDISyncTaskResponse() = default;
};
class UpdateDISyncTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> taskType{};
  shared_ptr<string> taskContent{};
  shared_ptr<string> taskParam{};
  shared_ptr<long> fileId{};

  UpdateDISyncTaskRequest() {}

  explicit UpdateDISyncTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!taskType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskType is required.")));
    }
    if (!fileId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("fileId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (taskContent) {
      res["TaskContent"] = boost::any(*taskContent);
    }
    if (taskParam) {
      res["TaskParam"] = boost::any(*taskParam);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("TaskContent") != m.end() && !m["TaskContent"].empty()) {
      taskContent = make_shared<string>(boost::any_cast<string>(m["TaskContent"]));
    }
    if (m.find("TaskParam") != m.end() && !m["TaskParam"].empty()) {
      taskParam = make_shared<string>(boost::any_cast<string>(m["TaskParam"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
  }


  virtual ~UpdateDISyncTaskRequest() = default;
};
class UpdateDISyncTaskResponseData : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> message{};

  UpdateDISyncTaskResponseData() {}

  explicit UpdateDISyncTaskResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!message) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("message is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~UpdateDISyncTaskResponseData() = default;
};
class UpdateDISyncTaskResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<UpdateDISyncTaskResponseData> data{};

  UpdateDISyncTaskResponse() {}

  explicit UpdateDISyncTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        UpdateDISyncTaskResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<UpdateDISyncTaskResponseData>(model1);
      }
    }
  }


  virtual ~UpdateDISyncTaskResponse() = default;
};
class TestNetworkConnectionRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> datasourceName{};
  shared_ptr<string> envType{};
  shared_ptr<string> resourceGroup{};

  TestNetworkConnectionRequest() {}

  explicit TestNetworkConnectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!datasourceName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("datasourceName is required.")));
    }
    if (!envType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("envType is required.")));
    }
    if (!resourceGroup) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("resourceGroup is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (datasourceName) {
      res["DatasourceName"] = boost::any(*datasourceName);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (resourceGroup) {
      res["ResourceGroup"] = boost::any(*resourceGroup);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("DatasourceName") != m.end() && !m["DatasourceName"].empty()) {
      datasourceName = make_shared<string>(boost::any_cast<string>(m["DatasourceName"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("ResourceGroup") != m.end() && !m["ResourceGroup"].empty()) {
      resourceGroup = make_shared<string>(boost::any_cast<string>(m["ResourceGroup"]));
    }
  }


  virtual ~TestNetworkConnectionRequest() = default;
};
class TestNetworkConnectionResponseTaskList : public Darabonba::Model {
public:
  shared_ptr<bool> connectStatus{};
  shared_ptr<string> connectMessage{};

  TestNetworkConnectionResponseTaskList() {}

  explicit TestNetworkConnectionResponseTaskList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!connectStatus) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("connectStatus is required.")));
    }
    if (!connectMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("connectMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connectStatus) {
      res["ConnectStatus"] = boost::any(*connectStatus);
    }
    if (connectMessage) {
      res["ConnectMessage"] = boost::any(*connectMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConnectStatus") != m.end() && !m["ConnectStatus"].empty()) {
      connectStatus = make_shared<bool>(boost::any_cast<bool>(m["ConnectStatus"]));
    }
    if (m.find("ConnectMessage") != m.end() && !m["ConnectMessage"].empty()) {
      connectMessage = make_shared<string>(boost::any_cast<string>(m["ConnectMessage"]));
    }
  }


  virtual ~TestNetworkConnectionResponseTaskList() = default;
};
class TestNetworkConnectionResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<TestNetworkConnectionResponseTaskList> taskList{};

  TestNetworkConnectionResponse() {}

  explicit TestNetworkConnectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!taskList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (taskList) {
      res["TaskList"] = taskList ? boost::any(taskList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TaskList") != m.end() && !m["TaskList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TaskList"].type()) {
        TestNetworkConnectionResponseTaskList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TaskList"]));
        taskList = make_shared<TestNetworkConnectionResponseTaskList>(model1);
      }
    }
  }


  virtual ~TestNetworkConnectionResponse() = default;
};
class UpdateNodeRunModeRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectEnv{};
  shared_ptr<long> nodeId{};
  shared_ptr<int> schedulerType{};

  UpdateNodeRunModeRequest() {}

  explicit UpdateNodeRunModeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectEnv) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectEnv is required.")));
    }
    if (!nodeId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeId is required.")));
    }
    if (!schedulerType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("schedulerType is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (schedulerType) {
      res["SchedulerType"] = boost::any(*schedulerType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("SchedulerType") != m.end() && !m["SchedulerType"].empty()) {
      schedulerType = make_shared<int>(boost::any_cast<int>(m["SchedulerType"]));
    }
  }


  virtual ~UpdateNodeRunModeRequest() = default;
};
class UpdateNodeRunModeResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateNodeRunModeResponse() {}

  explicit UpdateNodeRunModeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateNodeRunModeResponse() = default;
};
class UpdateNodeOwnerRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectEnv{};
  shared_ptr<long> nodeId{};
  shared_ptr<string> userId{};

  UpdateNodeOwnerRequest() {}

  explicit UpdateNodeOwnerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectEnv) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectEnv is required.")));
    }
    if (!nodeId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeId is required.")));
    }
    if (!userId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("userId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~UpdateNodeOwnerRequest() = default;
};
class UpdateNodeOwnerResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateNodeOwnerResponse() {}

  explicit UpdateNodeOwnerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateNodeOwnerResponse() = default;
};
class QueryPublicModelEngineRequest : public Darabonba::Model {
public:
  shared_ptr<string> text{};
  shared_ptr<string> projectId{};

  QueryPublicModelEngineRequest() {}

  explicit QueryPublicModelEngineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!text) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("text is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (text) {
      res["Text"] = boost::any(*text);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~QueryPublicModelEngineRequest() = default;
};
class QueryPublicModelEngineResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<map<string, boost::any>>> returnValue{};

  QueryPublicModelEngineResponse() {}

  explicit QueryPublicModelEngineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!returnValue) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("returnValue is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (returnValue) {
      res["ReturnValue"] = boost::any(*returnValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ReturnValue") != m.end() && !m["ReturnValue"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["ReturnValue"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReturnValue"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      returnValue = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
  }


  virtual ~QueryPublicModelEngineResponse() = default;
};
class DeleteViewRequest : public Darabonba::Model {
public:
  shared_ptr<string> viewName{};
  shared_ptr<string> appGuid{};

  DeleteViewRequest() {}

  explicit DeleteViewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!viewName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("viewName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (viewName) {
      res["ViewName"] = boost::any(*viewName);
    }
    if (appGuid) {
      res["AppGuid"] = boost::any(*appGuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ViewName") != m.end() && !m["ViewName"].empty()) {
      viewName = make_shared<string>(boost::any_cast<string>(m["ViewName"]));
    }
    if (m.find("AppGuid") != m.end() && !m["AppGuid"].empty()) {
      appGuid = make_shared<string>(boost::any_cast<string>(m["AppGuid"]));
    }
  }


  virtual ~DeleteViewRequest() = default;
};
class DeleteViewResponseTaskInfo : public Darabonba::Model {
public:
  shared_ptr<string> taskId{};
  shared_ptr<string> content{};
  shared_ptr<string> status{};
  shared_ptr<string> nextTaskId{};

  DeleteViewResponseTaskInfo() {}

  explicit DeleteViewResponseTaskInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!taskId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskId is required.")));
    }
    if (!content) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("content is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!nextTaskId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nextTaskId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (nextTaskId) {
      res["NextTaskId"] = boost::any(*nextTaskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("NextTaskId") != m.end() && !m["NextTaskId"].empty()) {
      nextTaskId = make_shared<string>(boost::any_cast<string>(m["NextTaskId"]));
    }
  }


  virtual ~DeleteViewResponseTaskInfo() = default;
};
class DeleteViewResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DeleteViewResponseTaskInfo> taskInfo{};

  DeleteViewResponse() {}

  explicit DeleteViewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!taskInfo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskInfo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskInfo) {
      res["TaskInfo"] = taskInfo ? boost::any(taskInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskInfo") != m.end() && !m["TaskInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["TaskInfo"].type()) {
        DeleteViewResponseTaskInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TaskInfo"]));
        taskInfo = make_shared<DeleteViewResponseTaskInfo>(model1);
      }
    }
  }


  virtual ~DeleteViewResponse() = default;
};
class CreateViewRequestViewColumn : public Darabonba::Model {
public:
  shared_ptr<string> columnName{};
  shared_ptr<string> comment{};

  CreateViewRequestViewColumn() {}

  explicit CreateViewRequestViewColumn(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
  }


  virtual ~CreateViewRequestViewColumn() = default;
};
class CreateViewRequest : public Darabonba::Model {
public:
  shared_ptr<string> viewName{};
  shared_ptr<string> selectColumn{};
  shared_ptr<string> selectTableName{};
  shared_ptr<string> selectWhere{};
  shared_ptr<string> selectSQL{};
  shared_ptr<string> appGuid{};
  shared_ptr<string> comment{};
  shared_ptr<vector<CreateViewRequestViewColumn>> viewColumn{};
  shared_ptr<string> clientToken{};

  CreateViewRequest() {}

  explicit CreateViewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!viewName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("viewName is required.")));
    }
    if (!appGuid) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("appGuid is required.")));
    }
    if (!viewColumn) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("viewColumn is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (viewName) {
      res["ViewName"] = boost::any(*viewName);
    }
    if (selectColumn) {
      res["SelectColumn"] = boost::any(*selectColumn);
    }
    if (selectTableName) {
      res["SelectTableName"] = boost::any(*selectTableName);
    }
    if (selectWhere) {
      res["SelectWhere"] = boost::any(*selectWhere);
    }
    if (selectSQL) {
      res["SelectSQL"] = boost::any(*selectSQL);
    }
    if (appGuid) {
      res["AppGuid"] = boost::any(*appGuid);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (viewColumn) {
      vector<boost::any> temp1;
      for(auto item1:*viewColumn){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ViewColumn"] = boost::any(temp1);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ViewName") != m.end() && !m["ViewName"].empty()) {
      viewName = make_shared<string>(boost::any_cast<string>(m["ViewName"]));
    }
    if (m.find("SelectColumn") != m.end() && !m["SelectColumn"].empty()) {
      selectColumn = make_shared<string>(boost::any_cast<string>(m["SelectColumn"]));
    }
    if (m.find("SelectTableName") != m.end() && !m["SelectTableName"].empty()) {
      selectTableName = make_shared<string>(boost::any_cast<string>(m["SelectTableName"]));
    }
    if (m.find("SelectWhere") != m.end() && !m["SelectWhere"].empty()) {
      selectWhere = make_shared<string>(boost::any_cast<string>(m["SelectWhere"]));
    }
    if (m.find("SelectSQL") != m.end() && !m["SelectSQL"].empty()) {
      selectSQL = make_shared<string>(boost::any_cast<string>(m["SelectSQL"]));
    }
    if (m.find("AppGuid") != m.end() && !m["AppGuid"].empty()) {
      appGuid = make_shared<string>(boost::any_cast<string>(m["AppGuid"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("ViewColumn") != m.end() && !m["ViewColumn"].empty()) {
      if (typeid(vector<boost::any>) == m["ViewColumn"].type()) {
        vector<CreateViewRequestViewColumn> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ViewColumn"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateViewRequestViewColumn model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        viewColumn = make_shared<vector<CreateViewRequestViewColumn>>(expect1);
      }
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
  }


  virtual ~CreateViewRequest() = default;
};
class CreateViewResponseTaskInfo : public Darabonba::Model {
public:
  shared_ptr<string> taskId{};
  shared_ptr<string> content{};
  shared_ptr<string> status{};
  shared_ptr<string> nextTaskId{};

  CreateViewResponseTaskInfo() {}

  explicit CreateViewResponseTaskInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!taskId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskId is required.")));
    }
    if (!content) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("content is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!nextTaskId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nextTaskId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (nextTaskId) {
      res["NextTaskId"] = boost::any(*nextTaskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("NextTaskId") != m.end() && !m["NextTaskId"].empty()) {
      nextTaskId = make_shared<string>(boost::any_cast<string>(m["NextTaskId"]));
    }
  }


  virtual ~CreateViewResponseTaskInfo() = default;
};
class CreateViewResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<CreateViewResponseTaskInfo> taskInfo{};

  CreateViewResponse() {}

  explicit CreateViewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!taskInfo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskInfo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskInfo) {
      res["TaskInfo"] = taskInfo ? boost::any(taskInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskInfo") != m.end() && !m["TaskInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["TaskInfo"].type()) {
        CreateViewResponseTaskInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TaskInfo"]));
        taskInfo = make_shared<CreateViewResponseTaskInfo>(model1);
      }
    }
  }


  virtual ~CreateViewResponse() = default;
};
class CheckFileDeploymentRequest : public Darabonba::Model {
public:
  shared_ptr<string> checkerInstanceId{};
  shared_ptr<string> status{};
  shared_ptr<string> checkDetailUrl{};

  CheckFileDeploymentRequest() {}

  explicit CheckFileDeploymentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!checkerInstanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("checkerInstanceId is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkerInstanceId) {
      res["CheckerInstanceId"] = boost::any(*checkerInstanceId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (checkDetailUrl) {
      res["CheckDetailUrl"] = boost::any(*checkDetailUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckerInstanceId") != m.end() && !m["CheckerInstanceId"].empty()) {
      checkerInstanceId = make_shared<string>(boost::any_cast<string>(m["CheckerInstanceId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("CheckDetailUrl") != m.end() && !m["CheckDetailUrl"].empty()) {
      checkDetailUrl = make_shared<string>(boost::any_cast<string>(m["CheckDetailUrl"]));
    }
  }


  virtual ~CheckFileDeploymentRequest() = default;
};
class CheckFileDeploymentResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CheckFileDeploymentResponse() {}

  explicit CheckFileDeploymentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CheckFileDeploymentResponse() = default;
};
class ImportDISyncTasksRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> taskType{};
  shared_ptr<string> taskContent{};
  shared_ptr<string> taskParam{};

  ImportDISyncTasksRequest() {}

  explicit ImportDISyncTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!taskType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskType is required.")));
    }
    if (!taskContent) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskContent is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (taskContent) {
      res["TaskContent"] = boost::any(*taskContent);
    }
    if (taskParam) {
      res["TaskParam"] = boost::any(*taskParam);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("TaskContent") != m.end() && !m["TaskContent"].empty()) {
      taskContent = make_shared<string>(boost::any_cast<string>(m["TaskContent"]));
    }
    if (m.find("TaskParam") != m.end() && !m["TaskParam"].empty()) {
      taskParam = make_shared<string>(boost::any_cast<string>(m["TaskParam"]));
    }
  }


  virtual ~ImportDISyncTasksRequest() = default;
};
class ImportDISyncTasksResponseTaskInfo : public Darabonba::Model {
public:
  shared_ptr<long> taskId{};

  ImportDISyncTasksResponseTaskInfo() {}

  explicit ImportDISyncTasksResponseTaskInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!taskId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
  }


  virtual ~ImportDISyncTasksResponseTaskInfo() = default;
};
class ImportDISyncTasksResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<ImportDISyncTasksResponseTaskInfo> taskInfo{};

  ImportDISyncTasksResponse() {}

  explicit ImportDISyncTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!taskInfo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskInfo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (taskInfo) {
      res["TaskInfo"] = taskInfo ? boost::any(taskInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TaskInfo") != m.end() && !m["TaskInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["TaskInfo"].type()) {
        ImportDISyncTasksResponseTaskInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TaskInfo"]));
        taskInfo = make_shared<ImportDISyncTasksResponseTaskInfo>(model1);
      }
    }
  }


  virtual ~ImportDISyncTasksResponse() = default;
};
class ExportDISyncTasksRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> taskType{};
  shared_ptr<string> taskParam{};

  ExportDISyncTasksRequest() {}

  explicit ExportDISyncTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!taskType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskType is required.")));
    }
    if (!taskParam) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskParam is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (taskParam) {
      res["TaskParam"] = boost::any(*taskParam);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("TaskParam") != m.end() && !m["TaskParam"].empty()) {
      taskParam = make_shared<string>(boost::any_cast<string>(m["TaskParam"]));
    }
  }


  virtual ~ExportDISyncTasksRequest() = default;
};
class ExportDISyncTasksResponseTaskDetail : public Darabonba::Model {
public:
  shared_ptr<string> realTimeSolution{};

  ExportDISyncTasksResponseTaskDetail() {}

  explicit ExportDISyncTasksResponseTaskDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!realTimeSolution) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("realTimeSolution is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (realTimeSolution) {
      res["RealTimeSolution"] = boost::any(*realTimeSolution);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RealTimeSolution") != m.end() && !m["RealTimeSolution"].empty()) {
      realTimeSolution = make_shared<string>(boost::any_cast<string>(m["RealTimeSolution"]));
    }
  }


  virtual ~ExportDISyncTasksResponseTaskDetail() = default;
};
class ExportDISyncTasksResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<ExportDISyncTasksResponseTaskDetail> taskDetail{};

  ExportDISyncTasksResponse() {}

  explicit ExportDISyncTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!taskDetail) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskDetail is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (taskDetail) {
      res["TaskDetail"] = taskDetail ? boost::any(taskDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TaskDetail") != m.end() && !m["TaskDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["TaskDetail"].type()) {
        ExportDISyncTasksResponseTaskDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TaskDetail"]));
        taskDetail = make_shared<ExportDISyncTasksResponseTaskDetail>(model1);
      }
    }
  }


  virtual ~ExportDISyncTasksResponse() = default;
};
class ListDISyncTasksRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> taskType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListDISyncTasksRequest() {}

  explicit ListDISyncTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!taskType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskType is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListDISyncTasksRequest() = default;
};
class ListDISyncTasksResponseTaskListRealTimeSolutionList : public Darabonba::Model {
public:
  shared_ptr<long> processId{};
  shared_ptr<string> processName{};
  shared_ptr<string> taskStatus{};
  shared_ptr<string> taskType{};
  shared_ptr<long> createTime{};

  ListDISyncTasksResponseTaskListRealTimeSolutionList() {}

  explicit ListDISyncTasksResponseTaskListRealTimeSolutionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!processId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("processId is required.")));
    }
    if (!processName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("processName is required.")));
    }
    if (!taskStatus) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskStatus is required.")));
    }
    if (!taskType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskType is required.")));
    }
    if (!createTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("createTime is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (processId) {
      res["ProcessId"] = boost::any(*processId);
    }
    if (processName) {
      res["ProcessName"] = boost::any(*processName);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProcessId") != m.end() && !m["ProcessId"].empty()) {
      processId = make_shared<long>(boost::any_cast<long>(m["ProcessId"]));
    }
    if (m.find("ProcessName") != m.end() && !m["ProcessName"].empty()) {
      processName = make_shared<string>(boost::any_cast<string>(m["ProcessName"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<string>(boost::any_cast<string>(m["TaskStatus"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
  }


  virtual ~ListDISyncTasksResponseTaskListRealTimeSolutionList() = default;
};
class ListDISyncTasksResponseTaskList : public Darabonba::Model {
public:
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> totalCount{};
  shared_ptr<vector<ListDISyncTasksResponseTaskListRealTimeSolutionList>> realTimeSolutionList{};

  ListDISyncTasksResponseTaskList() {}

  explicit ListDISyncTasksResponseTaskList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageNumber) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNumber is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!totalCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("totalCount is required.")));
    }
    if (!realTimeSolutionList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("realTimeSolutionList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (realTimeSolutionList) {
      vector<boost::any> temp1;
      for(auto item1:*realTimeSolutionList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RealTimeSolutionList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<int>(boost::any_cast<int>(m["TotalCount"]));
    }
    if (m.find("RealTimeSolutionList") != m.end() && !m["RealTimeSolutionList"].empty()) {
      if (typeid(vector<boost::any>) == m["RealTimeSolutionList"].type()) {
        vector<ListDISyncTasksResponseTaskListRealTimeSolutionList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RealTimeSolutionList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDISyncTasksResponseTaskListRealTimeSolutionList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        realTimeSolutionList = make_shared<vector<ListDISyncTasksResponseTaskListRealTimeSolutionList>>(expect1);
      }
    }
  }


  virtual ~ListDISyncTasksResponseTaskList() = default;
};
class ListDISyncTasksResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<ListDISyncTasksResponseTaskList> taskList{};

  ListDISyncTasksResponse() {}

  explicit ListDISyncTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!taskList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (taskList) {
      res["TaskList"] = taskList ? boost::any(taskList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TaskList") != m.end() && !m["TaskList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TaskList"].type()) {
        ListDISyncTasksResponseTaskList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TaskList"]));
        taskList = make_shared<ListDISyncTasksResponseTaskList>(model1);
      }
    }
  }


  virtual ~ListDISyncTasksResponse() = default;
};
class RevokeColumnPermissionRequest : public Darabonba::Model {
public:
  shared_ptr<long> workspaceId{};
  shared_ptr<string> maxComputeProjectName{};
  shared_ptr<string> tableName{};
  shared_ptr<string> columns{};
  shared_ptr<string> revokeUserName{};
  shared_ptr<string> revokeUserId{};

  RevokeColumnPermissionRequest() {}

  explicit RevokeColumnPermissionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!workspaceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("workspaceId is required.")));
    }
    if (!maxComputeProjectName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("maxComputeProjectName is required.")));
    }
    if (!tableName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tableName is required.")));
    }
    if (!columns) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("columns is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    if (maxComputeProjectName) {
      res["MaxComputeProjectName"] = boost::any(*maxComputeProjectName);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (columns) {
      res["Columns"] = boost::any(*columns);
    }
    if (revokeUserName) {
      res["RevokeUserName"] = boost::any(*revokeUserName);
    }
    if (revokeUserId) {
      res["RevokeUserId"] = boost::any(*revokeUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<long>(boost::any_cast<long>(m["WorkspaceId"]));
    }
    if (m.find("MaxComputeProjectName") != m.end() && !m["MaxComputeProjectName"].empty()) {
      maxComputeProjectName = make_shared<string>(boost::any_cast<string>(m["MaxComputeProjectName"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("Columns") != m.end() && !m["Columns"].empty()) {
      columns = make_shared<string>(boost::any_cast<string>(m["Columns"]));
    }
    if (m.find("RevokeUserName") != m.end() && !m["RevokeUserName"].empty()) {
      revokeUserName = make_shared<string>(boost::any_cast<string>(m["RevokeUserName"]));
    }
    if (m.find("RevokeUserId") != m.end() && !m["RevokeUserId"].empty()) {
      revokeUserId = make_shared<string>(boost::any_cast<string>(m["RevokeUserId"]));
    }
  }


  virtual ~RevokeColumnPermissionRequest() = default;
};
class RevokeColumnPermissionResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> revokeSuccess{};

  RevokeColumnPermissionResponse() {}

  explicit RevokeColumnPermissionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!revokeSuccess) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("revokeSuccess is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (revokeSuccess) {
      res["RevokeSuccess"] = boost::any(*revokeSuccess);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RevokeSuccess") != m.end() && !m["RevokeSuccess"].empty()) {
      revokeSuccess = make_shared<bool>(boost::any_cast<bool>(m["RevokeSuccess"]));
    }
  }


  virtual ~RevokeColumnPermissionResponse() = default;
};
class RevokeTablePermissionRequest : public Darabonba::Model {
public:
  shared_ptr<long> workspaceId{};
  shared_ptr<string> maxComputeProjectName{};
  shared_ptr<string> tableName{};
  shared_ptr<string> actions{};
  shared_ptr<string> revokeUserName{};
  shared_ptr<string> revokeUserId{};

  RevokeTablePermissionRequest() {}

  explicit RevokeTablePermissionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!workspaceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("workspaceId is required.")));
    }
    if (!maxComputeProjectName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("maxComputeProjectName is required.")));
    }
    if (!tableName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tableName is required.")));
    }
    if (!actions) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("actions is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    if (maxComputeProjectName) {
      res["MaxComputeProjectName"] = boost::any(*maxComputeProjectName);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (actions) {
      res["Actions"] = boost::any(*actions);
    }
    if (revokeUserName) {
      res["RevokeUserName"] = boost::any(*revokeUserName);
    }
    if (revokeUserId) {
      res["RevokeUserId"] = boost::any(*revokeUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<long>(boost::any_cast<long>(m["WorkspaceId"]));
    }
    if (m.find("MaxComputeProjectName") != m.end() && !m["MaxComputeProjectName"].empty()) {
      maxComputeProjectName = make_shared<string>(boost::any_cast<string>(m["MaxComputeProjectName"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("Actions") != m.end() && !m["Actions"].empty()) {
      actions = make_shared<string>(boost::any_cast<string>(m["Actions"]));
    }
    if (m.find("RevokeUserName") != m.end() && !m["RevokeUserName"].empty()) {
      revokeUserName = make_shared<string>(boost::any_cast<string>(m["RevokeUserName"]));
    }
    if (m.find("RevokeUserId") != m.end() && !m["RevokeUserId"].empty()) {
      revokeUserId = make_shared<string>(boost::any_cast<string>(m["RevokeUserId"]));
    }
  }


  virtual ~RevokeTablePermissionRequest() = default;
};
class RevokeTablePermissionResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> revokeSuccess{};

  RevokeTablePermissionResponse() {}

  explicit RevokeTablePermissionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!revokeSuccess) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("revokeSuccess is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (revokeSuccess) {
      res["RevokeSuccess"] = boost::any(*revokeSuccess);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RevokeSuccess") != m.end() && !m["RevokeSuccess"].empty()) {
      revokeSuccess = make_shared<bool>(boost::any_cast<bool>(m["RevokeSuccess"]));
    }
  }


  virtual ~RevokeTablePermissionResponse() = default;
};
class GetMetaTableThemeLevelRequest : public Darabonba::Model {
public:
  shared_ptr<string> tableGuid{};
  shared_ptr<string> dataSourceType{};

  GetMetaTableThemeLevelRequest() {}

  explicit GetMetaTableThemeLevelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!tableGuid) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tableGuid is required.")));
    }
    if (!dataSourceType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dataSourceType is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (dataSourceType) {
      res["DataSourceType"] = boost::any(*dataSourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("DataSourceType") != m.end() && !m["DataSourceType"].empty()) {
      dataSourceType = make_shared<string>(boost::any_cast<string>(m["DataSourceType"]));
    }
  }


  virtual ~GetMetaTableThemeLevelRequest() = default;
};
class GetMetaTableThemeLevelResponseEntityTheme : public Darabonba::Model {
public:
  shared_ptr<long> themeId{};
  shared_ptr<string> name{};
  shared_ptr<int> level{};
  shared_ptr<long> parentId{};

  GetMetaTableThemeLevelResponseEntityTheme() {}

  explicit GetMetaTableThemeLevelResponseEntityTheme(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!themeId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("themeId is required.")));
    }
    if (!name) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("name is required.")));
    }
    if (!level) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("level is required.")));
    }
    if (!parentId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parentId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (themeId) {
      res["ThemeId"] = boost::any(*themeId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ThemeId") != m.end() && !m["ThemeId"].empty()) {
      themeId = make_shared<long>(boost::any_cast<long>(m["ThemeId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<int>(boost::any_cast<int>(m["Level"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
  }


  virtual ~GetMetaTableThemeLevelResponseEntityTheme() = default;
};
class GetMetaTableThemeLevelResponseEntityLevel : public Darabonba::Model {
public:
  shared_ptr<long> levelId{};
  shared_ptr<string> name{};
  shared_ptr<int> type{};
  shared_ptr<string> description{};

  GetMetaTableThemeLevelResponseEntityLevel() {}

  explicit GetMetaTableThemeLevelResponseEntityLevel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!levelId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("levelId is required.")));
    }
    if (!name) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("name is required.")));
    }
    if (!type) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("type is required.")));
    }
    if (!description) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("description is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (levelId) {
      res["LevelId"] = boost::any(*levelId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LevelId") != m.end() && !m["LevelId"].empty()) {
      levelId = make_shared<long>(boost::any_cast<long>(m["LevelId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<int>(boost::any_cast<int>(m["Type"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~GetMetaTableThemeLevelResponseEntityLevel() = default;
};
class GetMetaTableThemeLevelResponseEntity : public Darabonba::Model {
public:
  shared_ptr<vector<GetMetaTableThemeLevelResponseEntityTheme>> theme{};
  shared_ptr<vector<GetMetaTableThemeLevelResponseEntityLevel>> level{};

  GetMetaTableThemeLevelResponseEntity() {}

  explicit GetMetaTableThemeLevelResponseEntity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!theme) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("theme is required.")));
    }
    if (!level) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("level is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (theme) {
      vector<boost::any> temp1;
      for(auto item1:*theme){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Theme"] = boost::any(temp1);
    }
    if (level) {
      vector<boost::any> temp1;
      for(auto item1:*level){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Level"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Theme") != m.end() && !m["Theme"].empty()) {
      if (typeid(vector<boost::any>) == m["Theme"].type()) {
        vector<GetMetaTableThemeLevelResponseEntityTheme> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Theme"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMetaTableThemeLevelResponseEntityTheme model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        theme = make_shared<vector<GetMetaTableThemeLevelResponseEntityTheme>>(expect1);
      }
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      if (typeid(vector<boost::any>) == m["Level"].type()) {
        vector<GetMetaTableThemeLevelResponseEntityLevel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Level"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMetaTableThemeLevelResponseEntityLevel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        level = make_shared<vector<GetMetaTableThemeLevelResponseEntityLevel>>(expect1);
      }
    }
  }


  virtual ~GetMetaTableThemeLevelResponseEntity() = default;
};
class GetMetaTableThemeLevelResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<bool> success{};
  shared_ptr<GetMetaTableThemeLevelResponseEntity> entity{};

  GetMetaTableThemeLevelResponse() {}

  explicit GetMetaTableThemeLevelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!entity) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("entity is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (entity) {
      res["Entity"] = entity ? boost::any(entity->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Entity") != m.end() && !m["Entity"].empty()) {
      if (typeid(map<string, boost::any>) == m["Entity"].type()) {
        GetMetaTableThemeLevelResponseEntity model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Entity"]));
        entity = make_shared<GetMetaTableThemeLevelResponseEntity>(model1);
      }
    }
  }


  virtual ~GetMetaTableThemeLevelResponse() = default;
};
class GetPermissionApplyOrderDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> flowId{};

  GetPermissionApplyOrderDetailRequest() {}

  explicit GetPermissionApplyOrderDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!flowId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("flowId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flowId) {
      res["FlowId"] = boost::any(*flowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FlowId") != m.end() && !m["FlowId"].empty()) {
      flowId = make_shared<string>(boost::any_cast<string>(m["FlowId"]));
    }
  }


  virtual ~GetPermissionApplyOrderDetailRequest() = default;
};
class GetPermissionApplyOrderDetailResponseApplyOrderDetailApproveAccountList : public Darabonba::Model {
public:
  shared_ptr<string> baseId{};

  GetPermissionApplyOrderDetailResponseApplyOrderDetailApproveAccountList() {}

  explicit GetPermissionApplyOrderDetailResponseApplyOrderDetailApproveAccountList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!baseId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("baseId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baseId) {
      res["BaseId"] = boost::any(*baseId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaseId") != m.end() && !m["BaseId"].empty()) {
      baseId = make_shared<string>(boost::any_cast<string>(m["BaseId"]));
    }
  }


  virtual ~GetPermissionApplyOrderDetailResponseApplyOrderDetailApproveAccountList() = default;
};
class GetPermissionApplyOrderDetailResponseApplyOrderDetailGranteeObjectList : public Darabonba::Model {
public:
  shared_ptr<string> granteeId{};
  shared_ptr<string> granteeName{};
  shared_ptr<int> granteeType{};
  shared_ptr<int> granteeTypeSub{};

  GetPermissionApplyOrderDetailResponseApplyOrderDetailGranteeObjectList() {}

  explicit GetPermissionApplyOrderDetailResponseApplyOrderDetailGranteeObjectList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!granteeId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("granteeId is required.")));
    }
    if (!granteeName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("granteeName is required.")));
    }
    if (!granteeType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("granteeType is required.")));
    }
    if (!granteeTypeSub) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("granteeTypeSub is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (granteeId) {
      res["GranteeId"] = boost::any(*granteeId);
    }
    if (granteeName) {
      res["GranteeName"] = boost::any(*granteeName);
    }
    if (granteeType) {
      res["GranteeType"] = boost::any(*granteeType);
    }
    if (granteeTypeSub) {
      res["GranteeTypeSub"] = boost::any(*granteeTypeSub);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GranteeId") != m.end() && !m["GranteeId"].empty()) {
      granteeId = make_shared<string>(boost::any_cast<string>(m["GranteeId"]));
    }
    if (m.find("GranteeName") != m.end() && !m["GranteeName"].empty()) {
      granteeName = make_shared<string>(boost::any_cast<string>(m["GranteeName"]));
    }
    if (m.find("GranteeType") != m.end() && !m["GranteeType"].empty()) {
      granteeType = make_shared<int>(boost::any_cast<int>(m["GranteeType"]));
    }
    if (m.find("GranteeTypeSub") != m.end() && !m["GranteeTypeSub"].empty()) {
      granteeTypeSub = make_shared<int>(boost::any_cast<int>(m["GranteeTypeSub"]));
    }
  }


  virtual ~GetPermissionApplyOrderDetailResponseApplyOrderDetailGranteeObjectList() = default;
};
class GetPermissionApplyOrderDetailResponseApplyOrderDetailApproveContentProjectMetaObjectMetaListColumnMetaList : public Darabonba::Model {
public:
  shared_ptr<string> columnComment{};
  shared_ptr<string> columnName{};

  GetPermissionApplyOrderDetailResponseApplyOrderDetailApproveContentProjectMetaObjectMetaListColumnMetaList() {}

  explicit GetPermissionApplyOrderDetailResponseApplyOrderDetailApproveContentProjectMetaObjectMetaListColumnMetaList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!columnComment) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("columnComment is required.")));
    }
    if (!columnName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("columnName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnComment) {
      res["ColumnComment"] = boost::any(*columnComment);
    }
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnComment") != m.end() && !m["ColumnComment"].empty()) {
      columnComment = make_shared<string>(boost::any_cast<string>(m["ColumnComment"]));
    }
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
  }


  virtual ~GetPermissionApplyOrderDetailResponseApplyOrderDetailApproveContentProjectMetaObjectMetaListColumnMetaList() = default;
};
class GetPermissionApplyOrderDetailResponseApplyOrderDetailApproveContentProjectMetaObjectMetaList : public Darabonba::Model {
public:
  shared_ptr<string> objectName{};
  shared_ptr<vector<GetPermissionApplyOrderDetailResponseApplyOrderDetailApproveContentProjectMetaObjectMetaListColumnMetaList>> columnMetaList{};

  GetPermissionApplyOrderDetailResponseApplyOrderDetailApproveContentProjectMetaObjectMetaList() {}

  explicit GetPermissionApplyOrderDetailResponseApplyOrderDetailApproveContentProjectMetaObjectMetaList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!objectName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("objectName is required.")));
    }
    if (!columnMetaList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("columnMetaList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (objectName) {
      res["ObjectName"] = boost::any(*objectName);
    }
    if (columnMetaList) {
      vector<boost::any> temp1;
      for(auto item1:*columnMetaList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ColumnMetaList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ObjectName") != m.end() && !m["ObjectName"].empty()) {
      objectName = make_shared<string>(boost::any_cast<string>(m["ObjectName"]));
    }
    if (m.find("ColumnMetaList") != m.end() && !m["ColumnMetaList"].empty()) {
      if (typeid(vector<boost::any>) == m["ColumnMetaList"].type()) {
        vector<GetPermissionApplyOrderDetailResponseApplyOrderDetailApproveContentProjectMetaObjectMetaListColumnMetaList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ColumnMetaList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetPermissionApplyOrderDetailResponseApplyOrderDetailApproveContentProjectMetaObjectMetaListColumnMetaList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        columnMetaList = make_shared<vector<GetPermissionApplyOrderDetailResponseApplyOrderDetailApproveContentProjectMetaObjectMetaListColumnMetaList>>(expect1);
      }
    }
  }


  virtual ~GetPermissionApplyOrderDetailResponseApplyOrderDetailApproveContentProjectMetaObjectMetaList() = default;
};
class GetPermissionApplyOrderDetailResponseApplyOrderDetailApproveContentProjectMeta : public Darabonba::Model {
public:
  shared_ptr<int> workspaceId{};
  shared_ptr<string> maxComputeProjectName{};
  shared_ptr<vector<GetPermissionApplyOrderDetailResponseApplyOrderDetailApproveContentProjectMetaObjectMetaList>> objectMetaList{};

  GetPermissionApplyOrderDetailResponseApplyOrderDetailApproveContentProjectMeta() {}

  explicit GetPermissionApplyOrderDetailResponseApplyOrderDetailApproveContentProjectMeta(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!workspaceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("workspaceId is required.")));
    }
    if (!maxComputeProjectName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("maxComputeProjectName is required.")));
    }
    if (!objectMetaList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("objectMetaList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    if (maxComputeProjectName) {
      res["MaxComputeProjectName"] = boost::any(*maxComputeProjectName);
    }
    if (objectMetaList) {
      vector<boost::any> temp1;
      for(auto item1:*objectMetaList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ObjectMetaList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<int>(boost::any_cast<int>(m["WorkspaceId"]));
    }
    if (m.find("MaxComputeProjectName") != m.end() && !m["MaxComputeProjectName"].empty()) {
      maxComputeProjectName = make_shared<string>(boost::any_cast<string>(m["MaxComputeProjectName"]));
    }
    if (m.find("ObjectMetaList") != m.end() && !m["ObjectMetaList"].empty()) {
      if (typeid(vector<boost::any>) == m["ObjectMetaList"].type()) {
        vector<GetPermissionApplyOrderDetailResponseApplyOrderDetailApproveContentProjectMetaObjectMetaList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ObjectMetaList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetPermissionApplyOrderDetailResponseApplyOrderDetailApproveContentProjectMetaObjectMetaList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        objectMetaList = make_shared<vector<GetPermissionApplyOrderDetailResponseApplyOrderDetailApproveContentProjectMetaObjectMetaList>>(expect1);
      }
    }
  }


  virtual ~GetPermissionApplyOrderDetailResponseApplyOrderDetailApproveContentProjectMeta() = default;
};
class GetPermissionApplyOrderDetailResponseApplyOrderDetailApproveContent : public Darabonba::Model {
public:
  shared_ptr<string> applyReason{};
  shared_ptr<long> deadline{};
  shared_ptr<int> orderType{};
  shared_ptr<GetPermissionApplyOrderDetailResponseApplyOrderDetailApproveContentProjectMeta> projectMeta{};

  GetPermissionApplyOrderDetailResponseApplyOrderDetailApproveContent() {}

  explicit GetPermissionApplyOrderDetailResponseApplyOrderDetailApproveContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!applyReason) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("applyReason is required.")));
    }
    if (!deadline) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deadline is required.")));
    }
    if (!orderType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("orderType is required.")));
    }
    if (!projectMeta) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectMeta is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyReason) {
      res["ApplyReason"] = boost::any(*applyReason);
    }
    if (deadline) {
      res["Deadline"] = boost::any(*deadline);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    if (projectMeta) {
      res["ProjectMeta"] = projectMeta ? boost::any(projectMeta->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplyReason") != m.end() && !m["ApplyReason"].empty()) {
      applyReason = make_shared<string>(boost::any_cast<string>(m["ApplyReason"]));
    }
    if (m.find("Deadline") != m.end() && !m["Deadline"].empty()) {
      deadline = make_shared<long>(boost::any_cast<long>(m["Deadline"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<int>(boost::any_cast<int>(m["OrderType"]));
    }
    if (m.find("ProjectMeta") != m.end() && !m["ProjectMeta"].empty()) {
      if (typeid(map<string, boost::any>) == m["ProjectMeta"].type()) {
        GetPermissionApplyOrderDetailResponseApplyOrderDetailApproveContentProjectMeta model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ProjectMeta"]));
        projectMeta = make_shared<GetPermissionApplyOrderDetailResponseApplyOrderDetailApproveContentProjectMeta>(model1);
      }
    }
  }


  virtual ~GetPermissionApplyOrderDetailResponseApplyOrderDetailApproveContent() = default;
};
class GetPermissionApplyOrderDetailResponseApplyOrderDetail : public Darabonba::Model {
public:
  shared_ptr<string> applyBaseId{};
  shared_ptr<long> applyTimestamp{};
  shared_ptr<string> flowId{};
  shared_ptr<int> flowStatus{};
  shared_ptr<vector<GetPermissionApplyOrderDetailResponseApplyOrderDetailApproveAccountList>> approveAccountList{};
  shared_ptr<vector<GetPermissionApplyOrderDetailResponseApplyOrderDetailGranteeObjectList>> granteeObjectList{};
  shared_ptr<GetPermissionApplyOrderDetailResponseApplyOrderDetailApproveContent> approveContent{};

  GetPermissionApplyOrderDetailResponseApplyOrderDetail() {}

  explicit GetPermissionApplyOrderDetailResponseApplyOrderDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!applyBaseId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("applyBaseId is required.")));
    }
    if (!applyTimestamp) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("applyTimestamp is required.")));
    }
    if (!flowId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("flowId is required.")));
    }
    if (!flowStatus) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("flowStatus is required.")));
    }
    if (!approveAccountList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("approveAccountList is required.")));
    }
    if (!granteeObjectList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("granteeObjectList is required.")));
    }
    if (!approveContent) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("approveContent is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyBaseId) {
      res["ApplyBaseId"] = boost::any(*applyBaseId);
    }
    if (applyTimestamp) {
      res["ApplyTimestamp"] = boost::any(*applyTimestamp);
    }
    if (flowId) {
      res["FlowId"] = boost::any(*flowId);
    }
    if (flowStatus) {
      res["FlowStatus"] = boost::any(*flowStatus);
    }
    if (approveAccountList) {
      vector<boost::any> temp1;
      for(auto item1:*approveAccountList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApproveAccountList"] = boost::any(temp1);
    }
    if (granteeObjectList) {
      vector<boost::any> temp1;
      for(auto item1:*granteeObjectList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GranteeObjectList"] = boost::any(temp1);
    }
    if (approveContent) {
      res["ApproveContent"] = approveContent ? boost::any(approveContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplyBaseId") != m.end() && !m["ApplyBaseId"].empty()) {
      applyBaseId = make_shared<string>(boost::any_cast<string>(m["ApplyBaseId"]));
    }
    if (m.find("ApplyTimestamp") != m.end() && !m["ApplyTimestamp"].empty()) {
      applyTimestamp = make_shared<long>(boost::any_cast<long>(m["ApplyTimestamp"]));
    }
    if (m.find("FlowId") != m.end() && !m["FlowId"].empty()) {
      flowId = make_shared<string>(boost::any_cast<string>(m["FlowId"]));
    }
    if (m.find("FlowStatus") != m.end() && !m["FlowStatus"].empty()) {
      flowStatus = make_shared<int>(boost::any_cast<int>(m["FlowStatus"]));
    }
    if (m.find("ApproveAccountList") != m.end() && !m["ApproveAccountList"].empty()) {
      if (typeid(vector<boost::any>) == m["ApproveAccountList"].type()) {
        vector<GetPermissionApplyOrderDetailResponseApplyOrderDetailApproveAccountList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApproveAccountList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetPermissionApplyOrderDetailResponseApplyOrderDetailApproveAccountList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        approveAccountList = make_shared<vector<GetPermissionApplyOrderDetailResponseApplyOrderDetailApproveAccountList>>(expect1);
      }
    }
    if (m.find("GranteeObjectList") != m.end() && !m["GranteeObjectList"].empty()) {
      if (typeid(vector<boost::any>) == m["GranteeObjectList"].type()) {
        vector<GetPermissionApplyOrderDetailResponseApplyOrderDetailGranteeObjectList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GranteeObjectList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetPermissionApplyOrderDetailResponseApplyOrderDetailGranteeObjectList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        granteeObjectList = make_shared<vector<GetPermissionApplyOrderDetailResponseApplyOrderDetailGranteeObjectList>>(expect1);
      }
    }
    if (m.find("ApproveContent") != m.end() && !m["ApproveContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApproveContent"].type()) {
        GetPermissionApplyOrderDetailResponseApplyOrderDetailApproveContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApproveContent"]));
        approveContent = make_shared<GetPermissionApplyOrderDetailResponseApplyOrderDetailApproveContent>(model1);
      }
    }
  }


  virtual ~GetPermissionApplyOrderDetailResponseApplyOrderDetail() = default;
};
class GetPermissionApplyOrderDetailResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetPermissionApplyOrderDetailResponseApplyOrderDetail> applyOrderDetail{};

  GetPermissionApplyOrderDetailResponse() {}

  explicit GetPermissionApplyOrderDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!applyOrderDetail) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("applyOrderDetail is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (applyOrderDetail) {
      res["ApplyOrderDetail"] = applyOrderDetail ? boost::any(applyOrderDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ApplyOrderDetail") != m.end() && !m["ApplyOrderDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApplyOrderDetail"].type()) {
        GetPermissionApplyOrderDetailResponseApplyOrderDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApplyOrderDetail"]));
        applyOrderDetail = make_shared<GetPermissionApplyOrderDetailResponseApplyOrderDetail>(model1);
      }
    }
  }


  virtual ~GetPermissionApplyOrderDetailResponse() = default;
};
class ListPermissionApplyOrdersRequest : public Darabonba::Model {
public:
  shared_ptr<int> flowStatus{};
  shared_ptr<int> workspaceId{};
  shared_ptr<int> orderType{};
  shared_ptr<string> maxComputeProjectName{};
  shared_ptr<string> tableName{};
  shared_ptr<long> startTime{};
  shared_ptr<long> endTime{};
  shared_ptr<string> engineType{};
  shared_ptr<int> pageNum{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> queryType{};

  ListPermissionApplyOrdersRequest() {}

  explicit ListPermissionApplyOrdersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!orderType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("orderType is required.")));
    }
    if (!engineType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("engineType is required.")));
    }
    if (!queryType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("queryType is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flowStatus) {
      res["FlowStatus"] = boost::any(*flowStatus);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    if (maxComputeProjectName) {
      res["MaxComputeProjectName"] = boost::any(*maxComputeProjectName);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (engineType) {
      res["EngineType"] = boost::any(*engineType);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (queryType) {
      res["QueryType"] = boost::any(*queryType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FlowStatus") != m.end() && !m["FlowStatus"].empty()) {
      flowStatus = make_shared<int>(boost::any_cast<int>(m["FlowStatus"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<int>(boost::any_cast<int>(m["WorkspaceId"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<int>(boost::any_cast<int>(m["OrderType"]));
    }
    if (m.find("MaxComputeProjectName") != m.end() && !m["MaxComputeProjectName"].empty()) {
      maxComputeProjectName = make_shared<string>(boost::any_cast<string>(m["MaxComputeProjectName"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("EngineType") != m.end() && !m["EngineType"].empty()) {
      engineType = make_shared<string>(boost::any_cast<string>(m["EngineType"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<int>(boost::any_cast<int>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("QueryType") != m.end() && !m["QueryType"].empty()) {
      queryType = make_shared<int>(boost::any_cast<int>(m["QueryType"]));
    }
  }


  virtual ~ListPermissionApplyOrdersRequest() = default;
};
class ListPermissionApplyOrdersResponseApplyOrdersApplyOrderApproveContentProjectMetaObjectMetaList : public Darabonba::Model {
public:
  shared_ptr<string> objectName{};
  shared_ptr<vector<string>> actions{};

  ListPermissionApplyOrdersResponseApplyOrdersApplyOrderApproveContentProjectMetaObjectMetaList() {}

  explicit ListPermissionApplyOrdersResponseApplyOrdersApplyOrderApproveContentProjectMetaObjectMetaList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!objectName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("objectName is required.")));
    }
    if (!actions) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("actions is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (objectName) {
      res["ObjectName"] = boost::any(*objectName);
    }
    if (actions) {
      res["Actions"] = boost::any(*actions);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ObjectName") != m.end() && !m["ObjectName"].empty()) {
      objectName = make_shared<string>(boost::any_cast<string>(m["ObjectName"]));
    }
    if (m.find("Actions") != m.end() && !m["Actions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Actions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Actions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      actions = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListPermissionApplyOrdersResponseApplyOrdersApplyOrderApproveContentProjectMetaObjectMetaList() = default;
};
class ListPermissionApplyOrdersResponseApplyOrdersApplyOrderApproveContentProjectMeta : public Darabonba::Model {
public:
  shared_ptr<string> workspaceName{};
  shared_ptr<vector<ListPermissionApplyOrdersResponseApplyOrdersApplyOrderApproveContentProjectMetaObjectMetaList>> objectMetaList{};

  ListPermissionApplyOrdersResponseApplyOrdersApplyOrderApproveContentProjectMeta() {}

  explicit ListPermissionApplyOrdersResponseApplyOrdersApplyOrderApproveContentProjectMeta(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!workspaceName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("workspaceName is required.")));
    }
    if (!objectMetaList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("objectMetaList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (workspaceName) {
      res["WorkspaceName"] = boost::any(*workspaceName);
    }
    if (objectMetaList) {
      vector<boost::any> temp1;
      for(auto item1:*objectMetaList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ObjectMetaList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WorkspaceName") != m.end() && !m["WorkspaceName"].empty()) {
      workspaceName = make_shared<string>(boost::any_cast<string>(m["WorkspaceName"]));
    }
    if (m.find("ObjectMetaList") != m.end() && !m["ObjectMetaList"].empty()) {
      if (typeid(vector<boost::any>) == m["ObjectMetaList"].type()) {
        vector<ListPermissionApplyOrdersResponseApplyOrdersApplyOrderApproveContentProjectMetaObjectMetaList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ObjectMetaList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPermissionApplyOrdersResponseApplyOrdersApplyOrderApproveContentProjectMetaObjectMetaList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        objectMetaList = make_shared<vector<ListPermissionApplyOrdersResponseApplyOrdersApplyOrderApproveContentProjectMetaObjectMetaList>>(expect1);
      }
    }
  }


  virtual ~ListPermissionApplyOrdersResponseApplyOrdersApplyOrderApproveContentProjectMeta() = default;
};
class ListPermissionApplyOrdersResponseApplyOrdersApplyOrderApproveContent : public Darabonba::Model {
public:
  shared_ptr<string> applyReason{};
  shared_ptr<int> orderType{};
  shared_ptr<ListPermissionApplyOrdersResponseApplyOrdersApplyOrderApproveContentProjectMeta> projectMeta{};

  ListPermissionApplyOrdersResponseApplyOrdersApplyOrderApproveContent() {}

  explicit ListPermissionApplyOrdersResponseApplyOrdersApplyOrderApproveContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!applyReason) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("applyReason is required.")));
    }
    if (!orderType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("orderType is required.")));
    }
    if (!projectMeta) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectMeta is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyReason) {
      res["ApplyReason"] = boost::any(*applyReason);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    if (projectMeta) {
      res["ProjectMeta"] = projectMeta ? boost::any(projectMeta->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplyReason") != m.end() && !m["ApplyReason"].empty()) {
      applyReason = make_shared<string>(boost::any_cast<string>(m["ApplyReason"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<int>(boost::any_cast<int>(m["OrderType"]));
    }
    if (m.find("ProjectMeta") != m.end() && !m["ProjectMeta"].empty()) {
      if (typeid(map<string, boost::any>) == m["ProjectMeta"].type()) {
        ListPermissionApplyOrdersResponseApplyOrdersApplyOrderApproveContentProjectMeta model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ProjectMeta"]));
        projectMeta = make_shared<ListPermissionApplyOrdersResponseApplyOrdersApplyOrderApproveContentProjectMeta>(model1);
      }
    }
  }


  virtual ~ListPermissionApplyOrdersResponseApplyOrdersApplyOrderApproveContent() = default;
};
class ListPermissionApplyOrdersResponseApplyOrdersApplyOrder : public Darabonba::Model {
public:
  shared_ptr<string> flowId{};
  shared_ptr<string> applyBaseId{};
  shared_ptr<long> applyTimestamp{};
  shared_ptr<int> flowStatus{};
  shared_ptr<ListPermissionApplyOrdersResponseApplyOrdersApplyOrderApproveContent> approveContent{};

  ListPermissionApplyOrdersResponseApplyOrdersApplyOrder() {}

  explicit ListPermissionApplyOrdersResponseApplyOrdersApplyOrder(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!flowId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("flowId is required.")));
    }
    if (!applyBaseId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("applyBaseId is required.")));
    }
    if (!applyTimestamp) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("applyTimestamp is required.")));
    }
    if (!flowStatus) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("flowStatus is required.")));
    }
    if (!approveContent) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("approveContent is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flowId) {
      res["FlowId"] = boost::any(*flowId);
    }
    if (applyBaseId) {
      res["ApplyBaseId"] = boost::any(*applyBaseId);
    }
    if (applyTimestamp) {
      res["ApplyTimestamp"] = boost::any(*applyTimestamp);
    }
    if (flowStatus) {
      res["FlowStatus"] = boost::any(*flowStatus);
    }
    if (approveContent) {
      res["ApproveContent"] = approveContent ? boost::any(approveContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FlowId") != m.end() && !m["FlowId"].empty()) {
      flowId = make_shared<string>(boost::any_cast<string>(m["FlowId"]));
    }
    if (m.find("ApplyBaseId") != m.end() && !m["ApplyBaseId"].empty()) {
      applyBaseId = make_shared<string>(boost::any_cast<string>(m["ApplyBaseId"]));
    }
    if (m.find("ApplyTimestamp") != m.end() && !m["ApplyTimestamp"].empty()) {
      applyTimestamp = make_shared<long>(boost::any_cast<long>(m["ApplyTimestamp"]));
    }
    if (m.find("FlowStatus") != m.end() && !m["FlowStatus"].empty()) {
      flowStatus = make_shared<int>(boost::any_cast<int>(m["FlowStatus"]));
    }
    if (m.find("ApproveContent") != m.end() && !m["ApproveContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApproveContent"].type()) {
        ListPermissionApplyOrdersResponseApplyOrdersApplyOrderApproveContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApproveContent"]));
        approveContent = make_shared<ListPermissionApplyOrdersResponseApplyOrdersApplyOrderApproveContent>(model1);
      }
    }
  }


  virtual ~ListPermissionApplyOrdersResponseApplyOrdersApplyOrder() = default;
};
class ListPermissionApplyOrdersResponseApplyOrders : public Darabonba::Model {
public:
  shared_ptr<int> pageSize{};
  shared_ptr<int> pageNumber{};
  shared_ptr<int> totalCount{};
  shared_ptr<vector<ListPermissionApplyOrdersResponseApplyOrdersApplyOrder>> applyOrder{};

  ListPermissionApplyOrdersResponseApplyOrders() {}

  explicit ListPermissionApplyOrdersResponseApplyOrders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!pageNumber) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNumber is required.")));
    }
    if (!totalCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("totalCount is required.")));
    }
    if (!applyOrder) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("applyOrder is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (applyOrder) {
      vector<boost::any> temp1;
      for(auto item1:*applyOrder){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApplyOrder"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<int>(boost::any_cast<int>(m["TotalCount"]));
    }
    if (m.find("ApplyOrder") != m.end() && !m["ApplyOrder"].empty()) {
      if (typeid(vector<boost::any>) == m["ApplyOrder"].type()) {
        vector<ListPermissionApplyOrdersResponseApplyOrdersApplyOrder> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApplyOrder"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPermissionApplyOrdersResponseApplyOrdersApplyOrder model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        applyOrder = make_shared<vector<ListPermissionApplyOrdersResponseApplyOrdersApplyOrder>>(expect1);
      }
    }
  }


  virtual ~ListPermissionApplyOrdersResponseApplyOrders() = default;
};
class ListPermissionApplyOrdersResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListPermissionApplyOrdersResponseApplyOrders> applyOrders{};

  ListPermissionApplyOrdersResponse() {}

  explicit ListPermissionApplyOrdersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!applyOrders) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("applyOrders is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (applyOrders) {
      res["ApplyOrders"] = applyOrders ? boost::any(applyOrders->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ApplyOrders") != m.end() && !m["ApplyOrders"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApplyOrders"].type()) {
        ListPermissionApplyOrdersResponseApplyOrders model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApplyOrders"]));
        applyOrders = make_shared<ListPermissionApplyOrdersResponseApplyOrders>(model1);
      }
    }
  }


  virtual ~ListPermissionApplyOrdersResponse() = default;
};
class CreatePermissionApplyOrderRequestApplyObjectColumnMetaList : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  CreatePermissionApplyOrderRequestApplyObjectColumnMetaList() {}

  explicit CreatePermissionApplyOrderRequestApplyObjectColumnMetaList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!name) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("name is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~CreatePermissionApplyOrderRequestApplyObjectColumnMetaList() = default;
};
class CreatePermissionApplyOrderRequestApplyObject : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<vector<CreatePermissionApplyOrderRequestApplyObjectColumnMetaList>> columnMetaList{};
  shared_ptr<string> actions{};

  CreatePermissionApplyOrderRequestApplyObject() {}

  explicit CreatePermissionApplyOrderRequestApplyObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!name) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("name is required.")));
    }
    if (!columnMetaList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("columnMetaList is required.")));
    }
    if (!actions) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("actions is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (columnMetaList) {
      vector<boost::any> temp1;
      for(auto item1:*columnMetaList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ColumnMetaList"] = boost::any(temp1);
    }
    if (actions) {
      res["Actions"] = boost::any(*actions);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ColumnMetaList") != m.end() && !m["ColumnMetaList"].empty()) {
      if (typeid(vector<boost::any>) == m["ColumnMetaList"].type()) {
        vector<CreatePermissionApplyOrderRequestApplyObjectColumnMetaList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ColumnMetaList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreatePermissionApplyOrderRequestApplyObjectColumnMetaList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        columnMetaList = make_shared<vector<CreatePermissionApplyOrderRequestApplyObjectColumnMetaList>>(expect1);
      }
    }
    if (m.find("Actions") != m.end() && !m["Actions"].empty()) {
      actions = make_shared<string>(boost::any_cast<string>(m["Actions"]));
    }
  }


  virtual ~CreatePermissionApplyOrderRequestApplyObject() = default;
};
class CreatePermissionApplyOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> applyUserIds{};
  shared_ptr<long> deadline{};
  shared_ptr<string> applyReason{};
  shared_ptr<string> maxComputeProjectName{};
  shared_ptr<int> workspaceId{};
  shared_ptr<int> orderType{};
  shared_ptr<string> engineType{};
  shared_ptr<vector<CreatePermissionApplyOrderRequestApplyObject>> applyObject{};

  CreatePermissionApplyOrderRequest() {}

  explicit CreatePermissionApplyOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!applyUserIds) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("applyUserIds is required.")));
    }
    if (!applyReason) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("applyReason is required.")));
    }
    if (!maxComputeProjectName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("maxComputeProjectName is required.")));
    }
    if (!workspaceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("workspaceId is required.")));
    }
    if (!applyObject) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("applyObject is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyUserIds) {
      res["ApplyUserIds"] = boost::any(*applyUserIds);
    }
    if (deadline) {
      res["Deadline"] = boost::any(*deadline);
    }
    if (applyReason) {
      res["ApplyReason"] = boost::any(*applyReason);
    }
    if (maxComputeProjectName) {
      res["MaxComputeProjectName"] = boost::any(*maxComputeProjectName);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    if (engineType) {
      res["EngineType"] = boost::any(*engineType);
    }
    if (applyObject) {
      vector<boost::any> temp1;
      for(auto item1:*applyObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApplyObject"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplyUserIds") != m.end() && !m["ApplyUserIds"].empty()) {
      applyUserIds = make_shared<string>(boost::any_cast<string>(m["ApplyUserIds"]));
    }
    if (m.find("Deadline") != m.end() && !m["Deadline"].empty()) {
      deadline = make_shared<long>(boost::any_cast<long>(m["Deadline"]));
    }
    if (m.find("ApplyReason") != m.end() && !m["ApplyReason"].empty()) {
      applyReason = make_shared<string>(boost::any_cast<string>(m["ApplyReason"]));
    }
    if (m.find("MaxComputeProjectName") != m.end() && !m["MaxComputeProjectName"].empty()) {
      maxComputeProjectName = make_shared<string>(boost::any_cast<string>(m["MaxComputeProjectName"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<int>(boost::any_cast<int>(m["WorkspaceId"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<int>(boost::any_cast<int>(m["OrderType"]));
    }
    if (m.find("EngineType") != m.end() && !m["EngineType"].empty()) {
      engineType = make_shared<string>(boost::any_cast<string>(m["EngineType"]));
    }
    if (m.find("ApplyObject") != m.end() && !m["ApplyObject"].empty()) {
      if (typeid(vector<boost::any>) == m["ApplyObject"].type()) {
        vector<CreatePermissionApplyOrderRequestApplyObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApplyObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreatePermissionApplyOrderRequestApplyObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        applyObject = make_shared<vector<CreatePermissionApplyOrderRequestApplyObject>>(expect1);
      }
    }
  }


  virtual ~CreatePermissionApplyOrderRequest() = default;
};
class CreatePermissionApplyOrderResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> flowId{};

  CreatePermissionApplyOrderResponse() {}

  explicit CreatePermissionApplyOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!flowId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("flowId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (flowId) {
      res["FlowId"] = boost::any(*flowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("FlowId") != m.end() && !m["FlowId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FlowId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FlowId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      flowId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreatePermissionApplyOrderResponse() = default;
};
class ApprovePermissionApplyOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> flowId{};
  shared_ptr<string> approveComment{};
  shared_ptr<int> approveAction{};

  ApprovePermissionApplyOrderRequest() {}

  explicit ApprovePermissionApplyOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!flowId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("flowId is required.")));
    }
    if (!approveComment) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("approveComment is required.")));
    }
    if (!approveAction) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("approveAction is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flowId) {
      res["FlowId"] = boost::any(*flowId);
    }
    if (approveComment) {
      res["ApproveComment"] = boost::any(*approveComment);
    }
    if (approveAction) {
      res["ApproveAction"] = boost::any(*approveAction);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FlowId") != m.end() && !m["FlowId"].empty()) {
      flowId = make_shared<string>(boost::any_cast<string>(m["FlowId"]));
    }
    if (m.find("ApproveComment") != m.end() && !m["ApproveComment"].empty()) {
      approveComment = make_shared<string>(boost::any_cast<string>(m["ApproveComment"]));
    }
    if (m.find("ApproveAction") != m.end() && !m["ApproveAction"].empty()) {
      approveAction = make_shared<int>(boost::any_cast<int>(m["ApproveAction"]));
    }
  }


  virtual ~ApprovePermissionApplyOrderRequest() = default;
};
class ApprovePermissionApplyOrderResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> approveSuccess{};

  ApprovePermissionApplyOrderResponse() {}

  explicit ApprovePermissionApplyOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!approveSuccess) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("approveSuccess is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (approveSuccess) {
      res["ApproveSuccess"] = boost::any(*approveSuccess);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ApproveSuccess") != m.end() && !m["ApproveSuccess"].empty()) {
      approveSuccess = make_shared<bool>(boost::any_cast<bool>(m["ApproveSuccess"]));
    }
  }


  virtual ~ApprovePermissionApplyOrderResponse() = default;
};
class ListSuccessInstanceAmountRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};

  ListSuccessInstanceAmountRequest() {}

  explicit ListSuccessInstanceAmountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~ListSuccessInstanceAmountRequest() = default;
};
class ListSuccessInstanceAmountResponseInstanceStatusTrendTodayTrend : public Darabonba::Model {
public:
  shared_ptr<int> count{};
  shared_ptr<string> timePoint{};

  ListSuccessInstanceAmountResponseInstanceStatusTrendTodayTrend() {}

  explicit ListSuccessInstanceAmountResponseInstanceStatusTrendTodayTrend(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!count) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("count is required.")));
    }
    if (!timePoint) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("timePoint is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (timePoint) {
      res["TimePoint"] = boost::any(*timePoint);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<int>(boost::any_cast<int>(m["Count"]));
    }
    if (m.find("TimePoint") != m.end() && !m["TimePoint"].empty()) {
      timePoint = make_shared<string>(boost::any_cast<string>(m["TimePoint"]));
    }
  }


  virtual ~ListSuccessInstanceAmountResponseInstanceStatusTrendTodayTrend() = default;
};
class ListSuccessInstanceAmountResponseInstanceStatusTrendYesterdayTrend : public Darabonba::Model {
public:
  shared_ptr<int> count{};
  shared_ptr<string> timePoint{};

  ListSuccessInstanceAmountResponseInstanceStatusTrendYesterdayTrend() {}

  explicit ListSuccessInstanceAmountResponseInstanceStatusTrendYesterdayTrend(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!count) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("count is required.")));
    }
    if (!timePoint) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("timePoint is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (timePoint) {
      res["TimePoint"] = boost::any(*timePoint);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<int>(boost::any_cast<int>(m["Count"]));
    }
    if (m.find("TimePoint") != m.end() && !m["TimePoint"].empty()) {
      timePoint = make_shared<string>(boost::any_cast<string>(m["TimePoint"]));
    }
  }


  virtual ~ListSuccessInstanceAmountResponseInstanceStatusTrendYesterdayTrend() = default;
};
class ListSuccessInstanceAmountResponseInstanceStatusTrendAvgTrend : public Darabonba::Model {
public:
  shared_ptr<int> count{};
  shared_ptr<string> timePoint{};

  ListSuccessInstanceAmountResponseInstanceStatusTrendAvgTrend() {}

  explicit ListSuccessInstanceAmountResponseInstanceStatusTrendAvgTrend(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!count) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("count is required.")));
    }
    if (!timePoint) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("timePoint is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (timePoint) {
      res["TimePoint"] = boost::any(*timePoint);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<int>(boost::any_cast<int>(m["Count"]));
    }
    if (m.find("TimePoint") != m.end() && !m["TimePoint"].empty()) {
      timePoint = make_shared<string>(boost::any_cast<string>(m["TimePoint"]));
    }
  }


  virtual ~ListSuccessInstanceAmountResponseInstanceStatusTrendAvgTrend() = default;
};
class ListSuccessInstanceAmountResponseInstanceStatusTrend : public Darabonba::Model {
public:
  shared_ptr<vector<ListSuccessInstanceAmountResponseInstanceStatusTrendTodayTrend>> todayTrend{};
  shared_ptr<vector<ListSuccessInstanceAmountResponseInstanceStatusTrendYesterdayTrend>> yesterdayTrend{};
  shared_ptr<vector<ListSuccessInstanceAmountResponseInstanceStatusTrendAvgTrend>> avgTrend{};

  ListSuccessInstanceAmountResponseInstanceStatusTrend() {}

  explicit ListSuccessInstanceAmountResponseInstanceStatusTrend(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!todayTrend) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("todayTrend is required.")));
    }
    if (!yesterdayTrend) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("yesterdayTrend is required.")));
    }
    if (!avgTrend) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("avgTrend is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (todayTrend) {
      vector<boost::any> temp1;
      for(auto item1:*todayTrend){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TodayTrend"] = boost::any(temp1);
    }
    if (yesterdayTrend) {
      vector<boost::any> temp1;
      for(auto item1:*yesterdayTrend){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["YesterdayTrend"] = boost::any(temp1);
    }
    if (avgTrend) {
      vector<boost::any> temp1;
      for(auto item1:*avgTrend){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AvgTrend"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TodayTrend") != m.end() && !m["TodayTrend"].empty()) {
      if (typeid(vector<boost::any>) == m["TodayTrend"].type()) {
        vector<ListSuccessInstanceAmountResponseInstanceStatusTrendTodayTrend> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TodayTrend"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSuccessInstanceAmountResponseInstanceStatusTrendTodayTrend model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        todayTrend = make_shared<vector<ListSuccessInstanceAmountResponseInstanceStatusTrendTodayTrend>>(expect1);
      }
    }
    if (m.find("YesterdayTrend") != m.end() && !m["YesterdayTrend"].empty()) {
      if (typeid(vector<boost::any>) == m["YesterdayTrend"].type()) {
        vector<ListSuccessInstanceAmountResponseInstanceStatusTrendYesterdayTrend> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["YesterdayTrend"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSuccessInstanceAmountResponseInstanceStatusTrendYesterdayTrend model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        yesterdayTrend = make_shared<vector<ListSuccessInstanceAmountResponseInstanceStatusTrendYesterdayTrend>>(expect1);
      }
    }
    if (m.find("AvgTrend") != m.end() && !m["AvgTrend"].empty()) {
      if (typeid(vector<boost::any>) == m["AvgTrend"].type()) {
        vector<ListSuccessInstanceAmountResponseInstanceStatusTrendAvgTrend> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AvgTrend"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSuccessInstanceAmountResponseInstanceStatusTrendAvgTrend model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        avgTrend = make_shared<vector<ListSuccessInstanceAmountResponseInstanceStatusTrendAvgTrend>>(expect1);
      }
    }
  }


  virtual ~ListSuccessInstanceAmountResponseInstanceStatusTrend() = default;
};
class ListSuccessInstanceAmountResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListSuccessInstanceAmountResponseInstanceStatusTrend> instanceStatusTrend{};

  ListSuccessInstanceAmountResponse() {}

  explicit ListSuccessInstanceAmountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!instanceStatusTrend) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceStatusTrend is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (instanceStatusTrend) {
      res["InstanceStatusTrend"] = instanceStatusTrend ? boost::any(instanceStatusTrend->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("InstanceStatusTrend") != m.end() && !m["InstanceStatusTrend"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceStatusTrend"].type()) {
        ListSuccessInstanceAmountResponseInstanceStatusTrend model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceStatusTrend"]));
        instanceStatusTrend = make_shared<ListSuccessInstanceAmountResponseInstanceStatusTrend>(model1);
      }
    }
  }


  virtual ~ListSuccessInstanceAmountResponse() = default;
};
class ListFileTypeRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<string> keyword{};
  shared_ptr<string> locale{};

  ListFileTypeRequest() {}

  explicit ListFileTypeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageNumber) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNumber is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (locale) {
      res["Locale"] = boost::any(*locale);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("Locale") != m.end() && !m["Locale"].empty()) {
      locale = make_shared<string>(boost::any_cast<string>(m["Locale"]));
    }
  }


  virtual ~ListFileTypeRequest() = default;
};
class ListFileTypeResponseNodeTypeInfoListNodeTypeInfo : public Darabonba::Model {
public:
  shared_ptr<int> nodeType{};
  shared_ptr<string> nodeTypeName{};

  ListFileTypeResponseNodeTypeInfoListNodeTypeInfo() {}

  explicit ListFileTypeResponseNodeTypeInfoListNodeTypeInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!nodeType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeType is required.")));
    }
    if (!nodeTypeName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeTypeName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    if (nodeTypeName) {
      res["NodeTypeName"] = boost::any(*nodeTypeName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<int>(boost::any_cast<int>(m["NodeType"]));
    }
    if (m.find("NodeTypeName") != m.end() && !m["NodeTypeName"].empty()) {
      nodeTypeName = make_shared<string>(boost::any_cast<string>(m["NodeTypeName"]));
    }
  }


  virtual ~ListFileTypeResponseNodeTypeInfoListNodeTypeInfo() = default;
};
class ListFileTypeResponseNodeTypeInfoList : public Darabonba::Model {
public:
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> totalCount{};
  shared_ptr<vector<ListFileTypeResponseNodeTypeInfoListNodeTypeInfo>> nodeTypeInfo{};

  ListFileTypeResponseNodeTypeInfoList() {}

  explicit ListFileTypeResponseNodeTypeInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageNumber) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNumber is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!totalCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("totalCount is required.")));
    }
    if (!nodeTypeInfo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeTypeInfo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (nodeTypeInfo) {
      vector<boost::any> temp1;
      for(auto item1:*nodeTypeInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NodeTypeInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<int>(boost::any_cast<int>(m["TotalCount"]));
    }
    if (m.find("NodeTypeInfo") != m.end() && !m["NodeTypeInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["NodeTypeInfo"].type()) {
        vector<ListFileTypeResponseNodeTypeInfoListNodeTypeInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NodeTypeInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFileTypeResponseNodeTypeInfoListNodeTypeInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodeTypeInfo = make_shared<vector<ListFileTypeResponseNodeTypeInfoListNodeTypeInfo>>(expect1);
      }
    }
  }


  virtual ~ListFileTypeResponseNodeTypeInfoList() = default;
};
class ListFileTypeResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListFileTypeResponseNodeTypeInfoList> nodeTypeInfoList{};

  ListFileTypeResponse() {}

  explicit ListFileTypeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!nodeTypeInfoList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeTypeInfoList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (nodeTypeInfoList) {
      res["NodeTypeInfoList"] = nodeTypeInfoList ? boost::any(nodeTypeInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("NodeTypeInfoList") != m.end() && !m["NodeTypeInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["NodeTypeInfoList"].type()) {
        ListFileTypeResponseNodeTypeInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NodeTypeInfoList"]));
        nodeTypeInfoList = make_shared<ListFileTypeResponseNodeTypeInfoList>(model1);
      }
    }
  }


  virtual ~ListFileTypeResponse() = default;
};
class ListInstanceAmountRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> beginDate{};
  shared_ptr<string> endDate{};

  ListInstanceAmountRequest() {}

  explicit ListInstanceAmountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!beginDate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("beginDate is required.")));
    }
    if (!endDate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("endDate is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (beginDate) {
      res["BeginDate"] = boost::any(*beginDate);
    }
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("BeginDate") != m.end() && !m["BeginDate"].empty()) {
      beginDate = make_shared<string>(boost::any_cast<string>(m["BeginDate"]));
    }
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
  }


  virtual ~ListInstanceAmountRequest() = default;
};
class ListInstanceAmountResponseInstanceCounts : public Darabonba::Model {
public:
  shared_ptr<long> date{};
  shared_ptr<int> count{};

  ListInstanceAmountResponseInstanceCounts() {}

  explicit ListInstanceAmountResponseInstanceCounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!date) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("date is required.")));
    }
    if (!count) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("count is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (date) {
      res["Date"] = boost::any(*date);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Date") != m.end() && !m["Date"].empty()) {
      date = make_shared<long>(boost::any_cast<long>(m["Date"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<int>(boost::any_cast<int>(m["Count"]));
    }
  }


  virtual ~ListInstanceAmountResponseInstanceCounts() = default;
};
class ListInstanceAmountResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListInstanceAmountResponseInstanceCounts>> instanceCounts{};

  ListInstanceAmountResponse() {}

  explicit ListInstanceAmountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!instanceCounts) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceCounts is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (instanceCounts) {
      vector<boost::any> temp1;
      for(auto item1:*instanceCounts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceCounts"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("InstanceCounts") != m.end() && !m["InstanceCounts"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceCounts"].type()) {
        vector<ListInstanceAmountResponseInstanceCounts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceCounts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInstanceAmountResponseInstanceCounts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceCounts = make_shared<vector<ListInstanceAmountResponseInstanceCounts>>(expect1);
      }
    }
  }


  virtual ~ListInstanceAmountResponse() = default;
};
class ListDataSourcesRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> name{};
  shared_ptr<string> dataSourceType{};
  shared_ptr<string> subType{};
  shared_ptr<string> status{};
  shared_ptr<int> envType{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> pageNumber{};

  ListDataSourcesRequest() {}

  explicit ListDataSourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (dataSourceType) {
      res["DataSourceType"] = boost::any(*dataSourceType);
    }
    if (subType) {
      res["SubType"] = boost::any(*subType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("DataSourceType") != m.end() && !m["DataSourceType"].empty()) {
      dataSourceType = make_shared<string>(boost::any_cast<string>(m["DataSourceType"]));
    }
    if (m.find("SubType") != m.end() && !m["SubType"].empty()) {
      subType = make_shared<string>(boost::any_cast<string>(m["SubType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<int>(boost::any_cast<int>(m["EnvType"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
  }


  virtual ~ListDataSourcesRequest() = default;
};
class ListDataSourcesResponseDataDataSources : public Darabonba::Model {
public:
  shared_ptr<bool> shared{};
  shared_ptr<string> gmtModified{};
  shared_ptr<int> connectStatus{};
  shared_ptr<int> bindingCalcEngineId{};
  shared_ptr<string> description{};
  shared_ptr<string> dataSourceType{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<bool> defaultEngine{};
  shared_ptr<string> operator_{};
  shared_ptr<int> sequence{};
  shared_ptr<int> envType{};
  shared_ptr<long> tenantId{};
  shared_ptr<string> name{};
  shared_ptr<string> subType{};
  shared_ptr<int> id{};
  shared_ptr<int> projectId{};
  shared_ptr<int> status{};
  shared_ptr<string> content{};

  ListDataSourcesResponseDataDataSources() {}

  explicit ListDataSourcesResponseDataDataSources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!shared) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("shared is required.")));
    }
    if (!gmtModified) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtModified is required.")));
    }
    if (!connectStatus) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("connectStatus is required.")));
    }
    if (!bindingCalcEngineId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("bindingCalcEngineId is required.")));
    }
    if (!description) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("description is required.")));
    }
    if (!dataSourceType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dataSourceType is required.")));
    }
    if (!gmtCreate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtCreate is required.")));
    }
    if (!defaultEngine) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("defaultEngine is required.")));
    }
    if (!operator_) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("operator is required.")));
    }
    if (!sequence) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("sequence is required.")));
    }
    if (!envType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("envType is required.")));
    }
    if (!tenantId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tenantId is required.")));
    }
    if (!name) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("name is required.")));
    }
    if (!subType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("subType is required.")));
    }
    if (!id) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("id is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!content) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("content is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (shared) {
      res["Shared"] = boost::any(*shared);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (connectStatus) {
      res["ConnectStatus"] = boost::any(*connectStatus);
    }
    if (bindingCalcEngineId) {
      res["BindingCalcEngineId"] = boost::any(*bindingCalcEngineId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dataSourceType) {
      res["DataSourceType"] = boost::any(*dataSourceType);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (defaultEngine) {
      res["DefaultEngine"] = boost::any(*defaultEngine);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (subType) {
      res["SubType"] = boost::any(*subType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Shared") != m.end() && !m["Shared"].empty()) {
      shared = make_shared<bool>(boost::any_cast<bool>(m["Shared"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("ConnectStatus") != m.end() && !m["ConnectStatus"].empty()) {
      connectStatus = make_shared<int>(boost::any_cast<int>(m["ConnectStatus"]));
    }
    if (m.find("BindingCalcEngineId") != m.end() && !m["BindingCalcEngineId"].empty()) {
      bindingCalcEngineId = make_shared<int>(boost::any_cast<int>(m["BindingCalcEngineId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DataSourceType") != m.end() && !m["DataSourceType"].empty()) {
      dataSourceType = make_shared<string>(boost::any_cast<string>(m["DataSourceType"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("DefaultEngine") != m.end() && !m["DefaultEngine"].empty()) {
      defaultEngine = make_shared<bool>(boost::any_cast<bool>(m["DefaultEngine"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<int>(boost::any_cast<int>(m["Sequence"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<int>(boost::any_cast<int>(m["EnvType"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SubType") != m.end() && !m["SubType"].empty()) {
      subType = make_shared<string>(boost::any_cast<string>(m["SubType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<int>(boost::any_cast<int>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<int>(boost::any_cast<int>(m["ProjectId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<int>(boost::any_cast<int>(m["Status"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
  }


  virtual ~ListDataSourcesResponseDataDataSources() = default;
};
class ListDataSourcesResponseData : public Darabonba::Model {
public:
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> totalCount{};
  shared_ptr<vector<ListDataSourcesResponseDataDataSources>> dataSources{};

  ListDataSourcesResponseData() {}

  explicit ListDataSourcesResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageNumber) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNumber is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!totalCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("totalCount is required.")));
    }
    if (!dataSources) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dataSources is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (dataSources) {
      vector<boost::any> temp1;
      for(auto item1:*dataSources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataSources"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<int>(boost::any_cast<int>(m["TotalCount"]));
    }
    if (m.find("DataSources") != m.end() && !m["DataSources"].empty()) {
      if (typeid(vector<boost::any>) == m["DataSources"].type()) {
        vector<ListDataSourcesResponseDataDataSources> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataSources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataSourcesResponseDataDataSources model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataSources = make_shared<vector<ListDataSourcesResponseDataDataSources>>(expect1);
      }
    }
  }


  virtual ~ListDataSourcesResponseData() = default;
};
class ListDataSourcesResponse : public Darabonba::Model {
public:
  shared_ptr<int> httpStatusCode{};
  shared_ptr<bool> success{};
  shared_ptr<string> requestId{};
  shared_ptr<ListDataSourcesResponseData> data{};

  ListDataSourcesResponse() {}

  explicit ListDataSourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListDataSourcesResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListDataSourcesResponseData>(model1);
      }
    }
  }


  virtual ~ListDataSourcesResponse() = default;
};
class ListNodesByBaselineRequest : public Darabonba::Model {
public:
  shared_ptr<long> baselineId{};

  ListNodesByBaselineRequest() {}

  explicit ListNodesByBaselineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!baselineId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("baselineId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
  }


  virtual ~ListNodesByBaselineRequest() = default;
};
class ListNodesByBaselineResponseData : public Darabonba::Model {
public:
  shared_ptr<long> nodeId{};
  shared_ptr<string> nodeName{};
  shared_ptr<string> owner{};
  shared_ptr<long> projectId{};

  ListNodesByBaselineResponseData() {}

  explicit ListNodesByBaselineResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!nodeId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeId is required.")));
    }
    if (!nodeName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeName is required.")));
    }
    if (!owner) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("owner is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~ListNodesByBaselineResponseData() = default;
};
class ListNodesByBaselineResponse : public Darabonba::Model {
public:
  shared_ptr<string> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListNodesByBaselineResponseData>> data{};

  ListNodesByBaselineResponse() {}

  explicit ListNodesByBaselineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListNodesByBaselineResponseData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNodesByBaselineResponseData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListNodesByBaselineResponseData>>(expect1);
      }
    }
  }


  virtual ~ListNodesByBaselineResponse() = default;
};
class ListManualDagInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectEnv{};
  shared_ptr<string> projectName{};
  shared_ptr<string> dagId{};

  ListManualDagInstancesRequest() {}

  explicit ListManualDagInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectEnv) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectEnv is required.")));
    }
    if (!projectName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectName is required.")));
    }
    if (!dagId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dagId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<string>(boost::any_cast<string>(m["DagId"]));
    }
  }


  virtual ~ListManualDagInstancesRequest() = default;
};
class ListManualDagInstancesResponseInstances : public Darabonba::Model {
public:
  shared_ptr<long> nodeId{};
  shared_ptr<long> instanceId{};
  shared_ptr<long> dagId{};
  shared_ptr<string> dagType{};
  shared_ptr<string> status{};
  shared_ptr<long> bizDate{};
  shared_ptr<long> cycTime{};
  shared_ptr<long> createTime{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> nodeName{};
  shared_ptr<long> beginWaitTimeTime{};
  shared_ptr<long> beginWaitResTime{};
  shared_ptr<long> beginRunningTime{};
  shared_ptr<string> paramValues{};
  shared_ptr<long> finishTime{};
  shared_ptr<string> taskType{};

  ListManualDagInstancesResponseInstances() {}

  explicit ListManualDagInstancesResponseInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!nodeId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeId is required.")));
    }
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
    if (!dagId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dagId is required.")));
    }
    if (!dagType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dagType is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!bizDate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("bizDate is required.")));
    }
    if (!cycTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("cycTime is required.")));
    }
    if (!createTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("createTime is required.")));
    }
    if (!modifyTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("modifyTime is required.")));
    }
    if (!nodeName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeName is required.")));
    }
    if (!beginWaitTimeTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("beginWaitTimeTime is required.")));
    }
    if (!beginWaitResTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("beginWaitResTime is required.")));
    }
    if (!beginRunningTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("beginRunningTime is required.")));
    }
    if (!paramValues) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("paramValues is required.")));
    }
    if (!finishTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("finishTime is required.")));
    }
    if (!taskType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskType is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (dagType) {
      res["DagType"] = boost::any(*dagType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (bizDate) {
      res["BizDate"] = boost::any(*bizDate);
    }
    if (cycTime) {
      res["CycTime"] = boost::any(*cycTime);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (beginWaitTimeTime) {
      res["BeginWaitTimeTime"] = boost::any(*beginWaitTimeTime);
    }
    if (beginWaitResTime) {
      res["BeginWaitResTime"] = boost::any(*beginWaitResTime);
    }
    if (beginRunningTime) {
      res["BeginRunningTime"] = boost::any(*beginRunningTime);
    }
    if (paramValues) {
      res["ParamValues"] = boost::any(*paramValues);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("DagType") != m.end() && !m["DagType"].empty()) {
      dagType = make_shared<string>(boost::any_cast<string>(m["DagType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("BizDate") != m.end() && !m["BizDate"].empty()) {
      bizDate = make_shared<long>(boost::any_cast<long>(m["BizDate"]));
    }
    if (m.find("CycTime") != m.end() && !m["CycTime"].empty()) {
      cycTime = make_shared<long>(boost::any_cast<long>(m["CycTime"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("BeginWaitTimeTime") != m.end() && !m["BeginWaitTimeTime"].empty()) {
      beginWaitTimeTime = make_shared<long>(boost::any_cast<long>(m["BeginWaitTimeTime"]));
    }
    if (m.find("BeginWaitResTime") != m.end() && !m["BeginWaitResTime"].empty()) {
      beginWaitResTime = make_shared<long>(boost::any_cast<long>(m["BeginWaitResTime"]));
    }
    if (m.find("BeginRunningTime") != m.end() && !m["BeginRunningTime"].empty()) {
      beginRunningTime = make_shared<long>(boost::any_cast<long>(m["BeginRunningTime"]));
    }
    if (m.find("ParamValues") != m.end() && !m["ParamValues"].empty()) {
      paramValues = make_shared<string>(boost::any_cast<string>(m["ParamValues"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<long>(boost::any_cast<long>(m["FinishTime"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
  }


  virtual ~ListManualDagInstancesResponseInstances() = default;
};
class ListManualDagInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListManualDagInstancesResponseInstances>> instances{};

  ListManualDagInstancesResponse() {}

  explicit ListManualDagInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!instances) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instances is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (instances) {
      vector<boost::any> temp1;
      for(auto item1:*instances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Instances"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      if (typeid(vector<boost::any>) == m["Instances"].type()) {
        vector<ListManualDagInstancesResponseInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Instances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListManualDagInstancesResponseInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instances = make_shared<vector<ListManualDagInstancesResponseInstances>>(expect1);
      }
    }
  }


  virtual ~ListManualDagInstancesResponse() = default;
};
class GetInstanceStatusStatisticRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> projectEnv{};
  shared_ptr<string> bizDate{};

  GetInstanceStatusStatisticRequest() {}

  explicit GetInstanceStatusStatisticRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!projectEnv) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectEnv is required.")));
    }
    if (!bizDate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("bizDate is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (bizDate) {
      res["BizDate"] = boost::any(*bizDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("BizDate") != m.end() && !m["BizDate"].empty()) {
      bizDate = make_shared<string>(boost::any_cast<string>(m["BizDate"]));
    }
  }


  virtual ~GetInstanceStatusStatisticRequest() = default;
};
class GetInstanceStatusStatisticResponseStatusCount : public Darabonba::Model {
public:
  shared_ptr<int> totalCount{};
  shared_ptr<int> notRunCount{};
  shared_ptr<int> waitTimeCount{};
  shared_ptr<int> waitResCount{};
  shared_ptr<int> runningCount{};
  shared_ptr<int> failureCount{};
  shared_ptr<int> successCount{};

  GetInstanceStatusStatisticResponseStatusCount() {}

  explicit GetInstanceStatusStatisticResponseStatusCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!totalCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("totalCount is required.")));
    }
    if (!notRunCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("notRunCount is required.")));
    }
    if (!waitTimeCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("waitTimeCount is required.")));
    }
    if (!waitResCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("waitResCount is required.")));
    }
    if (!runningCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("runningCount is required.")));
    }
    if (!failureCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("failureCount is required.")));
    }
    if (!successCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("successCount is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (notRunCount) {
      res["NotRunCount"] = boost::any(*notRunCount);
    }
    if (waitTimeCount) {
      res["WaitTimeCount"] = boost::any(*waitTimeCount);
    }
    if (waitResCount) {
      res["WaitResCount"] = boost::any(*waitResCount);
    }
    if (runningCount) {
      res["RunningCount"] = boost::any(*runningCount);
    }
    if (failureCount) {
      res["FailureCount"] = boost::any(*failureCount);
    }
    if (successCount) {
      res["SuccessCount"] = boost::any(*successCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<int>(boost::any_cast<int>(m["TotalCount"]));
    }
    if (m.find("NotRunCount") != m.end() && !m["NotRunCount"].empty()) {
      notRunCount = make_shared<int>(boost::any_cast<int>(m["NotRunCount"]));
    }
    if (m.find("WaitTimeCount") != m.end() && !m["WaitTimeCount"].empty()) {
      waitTimeCount = make_shared<int>(boost::any_cast<int>(m["WaitTimeCount"]));
    }
    if (m.find("WaitResCount") != m.end() && !m["WaitResCount"].empty()) {
      waitResCount = make_shared<int>(boost::any_cast<int>(m["WaitResCount"]));
    }
    if (m.find("RunningCount") != m.end() && !m["RunningCount"].empty()) {
      runningCount = make_shared<int>(boost::any_cast<int>(m["RunningCount"]));
    }
    if (m.find("FailureCount") != m.end() && !m["FailureCount"].empty()) {
      failureCount = make_shared<int>(boost::any_cast<int>(m["FailureCount"]));
    }
    if (m.find("SuccessCount") != m.end() && !m["SuccessCount"].empty()) {
      successCount = make_shared<int>(boost::any_cast<int>(m["SuccessCount"]));
    }
  }


  virtual ~GetInstanceStatusStatisticResponseStatusCount() = default;
};
class GetInstanceStatusStatisticResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetInstanceStatusStatisticResponseStatusCount> statusCount{};

  GetInstanceStatusStatisticResponse() {}

  explicit GetInstanceStatusStatisticResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!statusCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCount is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (statusCount) {
      res["StatusCount"] = statusCount ? boost::any(statusCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StatusCount") != m.end() && !m["StatusCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["StatusCount"].type()) {
        GetInstanceStatusStatisticResponseStatusCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StatusCount"]));
        statusCount = make_shared<GetInstanceStatusStatisticResponseStatusCount>(model1);
      }
    }
  }


  virtual ~GetInstanceStatusStatisticResponse() = default;
};
class DeleteDataSourceRequest : public Darabonba::Model {
public:
  shared_ptr<long> dataSourceId{};

  DeleteDataSourceRequest() {}

  explicit DeleteDataSourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!dataSourceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dataSourceId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSourceId) {
      res["DataSourceId"] = boost::any(*dataSourceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataSourceId") != m.end() && !m["DataSourceId"].empty()) {
      dataSourceId = make_shared<long>(boost::any_cast<long>(m["DataSourceId"]));
    }
  }


  virtual ~DeleteDataSourceRequest() = default;
};
class DeleteDataSourceResponse : public Darabonba::Model {
public:
  shared_ptr<bool> success{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  DeleteDataSourceResponse() {}

  explicit DeleteDataSourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDataSourceResponse() = default;
};
class CreateDataSourceRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};
  shared_ptr<string> dataSourceType{};
  shared_ptr<string> subType{};
  shared_ptr<int> envType{};
  shared_ptr<string> content{};

  CreateDataSourceRequest() {}

  explicit CreateDataSourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!name) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("name is required.")));
    }
    if (!dataSourceType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dataSourceType is required.")));
    }
    if (!envType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("envType is required.")));
    }
    if (!content) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("content is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dataSourceType) {
      res["DataSourceType"] = boost::any(*dataSourceType);
    }
    if (subType) {
      res["SubType"] = boost::any(*subType);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DataSourceType") != m.end() && !m["DataSourceType"].empty()) {
      dataSourceType = make_shared<string>(boost::any_cast<string>(m["DataSourceType"]));
    }
    if (m.find("SubType") != m.end() && !m["SubType"].empty()) {
      subType = make_shared<string>(boost::any_cast<string>(m["SubType"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<int>(boost::any_cast<int>(m["EnvType"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
  }


  virtual ~CreateDataSourceRequest() = default;
};
class CreateDataSourceResponse : public Darabonba::Model {
public:
  shared_ptr<bool> success{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<long> data{};
  shared_ptr<string> requestId{};

  CreateDataSourceResponse() {}

  explicit CreateDataSourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDataSourceResponse() = default;
};
class TopTenErrorTimesInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};

  TopTenErrorTimesInstanceRequest() {}

  explicit TopTenErrorTimesInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~TopTenErrorTimesInstanceRequest() = default;
};
class TopTenErrorTimesInstanceResponseInstanceErrorRankErrorRank : public Darabonba::Model {
public:
  shared_ptr<long> nodeId{};
  shared_ptr<string> nodeName{};
  shared_ptr<string> owner{};
  shared_ptr<int> count{};
  shared_ptr<long> projectId{};
  shared_ptr<int> programType{};

  TopTenErrorTimesInstanceResponseInstanceErrorRankErrorRank() {}

  explicit TopTenErrorTimesInstanceResponseInstanceErrorRankErrorRank(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!nodeId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeId is required.")));
    }
    if (!nodeName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeName is required.")));
    }
    if (!owner) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("owner is required.")));
    }
    if (!count) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("count is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!programType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("programType is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (programType) {
      res["ProgramType"] = boost::any(*programType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<int>(boost::any_cast<int>(m["Count"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProgramType") != m.end() && !m["ProgramType"].empty()) {
      programType = make_shared<int>(boost::any_cast<int>(m["ProgramType"]));
    }
  }


  virtual ~TopTenErrorTimesInstanceResponseInstanceErrorRankErrorRank() = default;
};
class TopTenErrorTimesInstanceResponseInstanceErrorRank : public Darabonba::Model {
public:
  shared_ptr<long> updateTime{};
  shared_ptr<vector<TopTenErrorTimesInstanceResponseInstanceErrorRankErrorRank>> errorRank{};

  TopTenErrorTimesInstanceResponseInstanceErrorRank() {}

  explicit TopTenErrorTimesInstanceResponseInstanceErrorRank(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!updateTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("updateTime is required.")));
    }
    if (!errorRank) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorRank is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (errorRank) {
      vector<boost::any> temp1;
      for(auto item1:*errorRank){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ErrorRank"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("ErrorRank") != m.end() && !m["ErrorRank"].empty()) {
      if (typeid(vector<boost::any>) == m["ErrorRank"].type()) {
        vector<TopTenErrorTimesInstanceResponseInstanceErrorRankErrorRank> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ErrorRank"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TopTenErrorTimesInstanceResponseInstanceErrorRankErrorRank model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        errorRank = make_shared<vector<TopTenErrorTimesInstanceResponseInstanceErrorRankErrorRank>>(expect1);
      }
    }
  }


  virtual ~TopTenErrorTimesInstanceResponseInstanceErrorRank() = default;
};
class TopTenErrorTimesInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<TopTenErrorTimesInstanceResponseInstanceErrorRank> instanceErrorRank{};

  TopTenErrorTimesInstanceResponse() {}

  explicit TopTenErrorTimesInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!instanceErrorRank) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceErrorRank is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (instanceErrorRank) {
      res["InstanceErrorRank"] = instanceErrorRank ? boost::any(instanceErrorRank->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("InstanceErrorRank") != m.end() && !m["InstanceErrorRank"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceErrorRank"].type()) {
        TopTenErrorTimesInstanceResponseInstanceErrorRank model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceErrorRank"]));
        instanceErrorRank = make_shared<TopTenErrorTimesInstanceResponseInstanceErrorRank>(model1);
      }
    }
  }


  virtual ~TopTenErrorTimesInstanceResponse() = default;
};
class TopTenElapsedTimeInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};

  TopTenElapsedTimeInstanceRequest() {}

  explicit TopTenElapsedTimeInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~TopTenElapsedTimeInstanceRequest() = default;
};
class TopTenElapsedTimeInstanceResponseInstanceConsumeTimeRankConsumeTimeRank : public Darabonba::Model {
public:
  shared_ptr<string> nodeName{};
  shared_ptr<long> nodeId{};
  shared_ptr<long> businessDate{};
  shared_ptr<string> owner{};
  shared_ptr<long> consumed{};
  shared_ptr<long> instanceId{};
  shared_ptr<int> programType{};

  TopTenElapsedTimeInstanceResponseInstanceConsumeTimeRankConsumeTimeRank() {}

  explicit TopTenElapsedTimeInstanceResponseInstanceConsumeTimeRankConsumeTimeRank(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!nodeName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeName is required.")));
    }
    if (!nodeId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeId is required.")));
    }
    if (!businessDate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("businessDate is required.")));
    }
    if (!owner) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("owner is required.")));
    }
    if (!consumed) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("consumed is required.")));
    }
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
    if (!programType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("programType is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (businessDate) {
      res["BusinessDate"] = boost::any(*businessDate);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (consumed) {
      res["Consumed"] = boost::any(*consumed);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (programType) {
      res["ProgramType"] = boost::any(*programType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("BusinessDate") != m.end() && !m["BusinessDate"].empty()) {
      businessDate = make_shared<long>(boost::any_cast<long>(m["BusinessDate"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("Consumed") != m.end() && !m["Consumed"].empty()) {
      consumed = make_shared<long>(boost::any_cast<long>(m["Consumed"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("ProgramType") != m.end() && !m["ProgramType"].empty()) {
      programType = make_shared<int>(boost::any_cast<int>(m["ProgramType"]));
    }
  }


  virtual ~TopTenElapsedTimeInstanceResponseInstanceConsumeTimeRankConsumeTimeRank() = default;
};
class TopTenElapsedTimeInstanceResponseInstanceConsumeTimeRank : public Darabonba::Model {
public:
  shared_ptr<long> updateTime{};
  shared_ptr<vector<TopTenElapsedTimeInstanceResponseInstanceConsumeTimeRankConsumeTimeRank>> consumeTimeRank{};

  TopTenElapsedTimeInstanceResponseInstanceConsumeTimeRank() {}

  explicit TopTenElapsedTimeInstanceResponseInstanceConsumeTimeRank(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!updateTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("updateTime is required.")));
    }
    if (!consumeTimeRank) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("consumeTimeRank is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (consumeTimeRank) {
      vector<boost::any> temp1;
      for(auto item1:*consumeTimeRank){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConsumeTimeRank"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("ConsumeTimeRank") != m.end() && !m["ConsumeTimeRank"].empty()) {
      if (typeid(vector<boost::any>) == m["ConsumeTimeRank"].type()) {
        vector<TopTenElapsedTimeInstanceResponseInstanceConsumeTimeRankConsumeTimeRank> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConsumeTimeRank"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TopTenElapsedTimeInstanceResponseInstanceConsumeTimeRankConsumeTimeRank model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        consumeTimeRank = make_shared<vector<TopTenElapsedTimeInstanceResponseInstanceConsumeTimeRankConsumeTimeRank>>(expect1);
      }
    }
  }


  virtual ~TopTenElapsedTimeInstanceResponseInstanceConsumeTimeRank() = default;
};
class TopTenElapsedTimeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<TopTenElapsedTimeInstanceResponseInstanceConsumeTimeRank> instanceConsumeTimeRank{};

  TopTenElapsedTimeInstanceResponse() {}

  explicit TopTenElapsedTimeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!instanceConsumeTimeRank) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceConsumeTimeRank is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (instanceConsumeTimeRank) {
      res["InstanceConsumeTimeRank"] = instanceConsumeTimeRank ? boost::any(instanceConsumeTimeRank->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("InstanceConsumeTimeRank") != m.end() && !m["InstanceConsumeTimeRank"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceConsumeTimeRank"].type()) {
        TopTenElapsedTimeInstanceResponseInstanceConsumeTimeRank model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceConsumeTimeRank"]));
        instanceConsumeTimeRank = make_shared<TopTenElapsedTimeInstanceResponseInstanceConsumeTimeRank>(model1);
      }
    }
  }


  virtual ~TopTenElapsedTimeInstanceResponse() = default;
};
class GetProjectRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};

  GetProjectRequest() {}

  explicit GetProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~GetProjectRequest() = default;
};
class GetProjectResponseData : public Darabonba::Model {
public:
  shared_ptr<string> gmtModified{};
  shared_ptr<int> maxFlowNode{};
  shared_ptr<string> defaultDiResourceGroupIdentifier{};
  shared_ptr<int> destination{};
  shared_ptr<int> isAllowDownload{};
  shared_ptr<string> prodStorageQuota{};
  shared_ptr<int> schedulerRetryInterval{};
  shared_ptr<string> residentArea{};
  shared_ptr<int> tablePrivacyMode{};
  shared_ptr<string> projectOwnerBaseId{};
  shared_ptr<bool> useProxyOdpsAccount{};
  shared_ptr<bool> disableDevelopment{};
  shared_ptr<int> projectMode{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> devStorageQuota{};
  shared_ptr<int> isDefault{};
  shared_ptr<int> protectedMode{};
  shared_ptr<bool> baseProject{};
  shared_ptr<long> tenantId{};
  shared_ptr<string> projectDescription{};
  shared_ptr<string> appkey{};
  shared_ptr<int> schedulerMaxRetryTimes{};
  shared_ptr<string> projectName{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<int> projectId{};
  shared_ptr<int> status{};
  shared_ptr<int> developmentType{};
  shared_ptr<vector<string>> envTypes{};

  GetProjectResponseData() {}

  explicit GetProjectResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!gmtModified) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtModified is required.")));
    }
    if (!maxFlowNode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("maxFlowNode is required.")));
    }
    if (!defaultDiResourceGroupIdentifier) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("defaultDiResourceGroupIdentifier is required.")));
    }
    if (!destination) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("destination is required.")));
    }
    if (!isAllowDownload) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("isAllowDownload is required.")));
    }
    if (!prodStorageQuota) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("prodStorageQuota is required.")));
    }
    if (!schedulerRetryInterval) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("schedulerRetryInterval is required.")));
    }
    if (!residentArea) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("residentArea is required.")));
    }
    if (!tablePrivacyMode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tablePrivacyMode is required.")));
    }
    if (!projectOwnerBaseId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectOwnerBaseId is required.")));
    }
    if (!useProxyOdpsAccount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("useProxyOdpsAccount is required.")));
    }
    if (!disableDevelopment) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("disableDevelopment is required.")));
    }
    if (!projectMode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectMode is required.")));
    }
    if (!gmtCreate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtCreate is required.")));
    }
    if (!devStorageQuota) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("devStorageQuota is required.")));
    }
    if (!isDefault) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("isDefault is required.")));
    }
    if (!protectedMode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("protectedMode is required.")));
    }
    if (!baseProject) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("baseProject is required.")));
    }
    if (!tenantId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tenantId is required.")));
    }
    if (!projectDescription) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectDescription is required.")));
    }
    if (!appkey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("appkey is required.")));
    }
    if (!schedulerMaxRetryTimes) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("schedulerMaxRetryTimes is required.")));
    }
    if (!projectName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectName is required.")));
    }
    if (!projectIdentifier) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectIdentifier is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!developmentType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("developmentType is required.")));
    }
    if (!envTypes) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("envTypes is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (maxFlowNode) {
      res["MaxFlowNode"] = boost::any(*maxFlowNode);
    }
    if (defaultDiResourceGroupIdentifier) {
      res["DefaultDiResourceGroupIdentifier"] = boost::any(*defaultDiResourceGroupIdentifier);
    }
    if (destination) {
      res["Destination"] = boost::any(*destination);
    }
    if (isAllowDownload) {
      res["IsAllowDownload"] = boost::any(*isAllowDownload);
    }
    if (prodStorageQuota) {
      res["ProdStorageQuota"] = boost::any(*prodStorageQuota);
    }
    if (schedulerRetryInterval) {
      res["SchedulerRetryInterval"] = boost::any(*schedulerRetryInterval);
    }
    if (residentArea) {
      res["ResidentArea"] = boost::any(*residentArea);
    }
    if (tablePrivacyMode) {
      res["TablePrivacyMode"] = boost::any(*tablePrivacyMode);
    }
    if (projectOwnerBaseId) {
      res["ProjectOwnerBaseId"] = boost::any(*projectOwnerBaseId);
    }
    if (useProxyOdpsAccount) {
      res["UseProxyOdpsAccount"] = boost::any(*useProxyOdpsAccount);
    }
    if (disableDevelopment) {
      res["DisableDevelopment"] = boost::any(*disableDevelopment);
    }
    if (projectMode) {
      res["ProjectMode"] = boost::any(*projectMode);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (devStorageQuota) {
      res["DevStorageQuota"] = boost::any(*devStorageQuota);
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    if (protectedMode) {
      res["ProtectedMode"] = boost::any(*protectedMode);
    }
    if (baseProject) {
      res["BaseProject"] = boost::any(*baseProject);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (projectDescription) {
      res["ProjectDescription"] = boost::any(*projectDescription);
    }
    if (appkey) {
      res["Appkey"] = boost::any(*appkey);
    }
    if (schedulerMaxRetryTimes) {
      res["SchedulerMaxRetryTimes"] = boost::any(*schedulerMaxRetryTimes);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (developmentType) {
      res["DevelopmentType"] = boost::any(*developmentType);
    }
    if (envTypes) {
      res["EnvTypes"] = boost::any(*envTypes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("MaxFlowNode") != m.end() && !m["MaxFlowNode"].empty()) {
      maxFlowNode = make_shared<int>(boost::any_cast<int>(m["MaxFlowNode"]));
    }
    if (m.find("DefaultDiResourceGroupIdentifier") != m.end() && !m["DefaultDiResourceGroupIdentifier"].empty()) {
      defaultDiResourceGroupIdentifier = make_shared<string>(boost::any_cast<string>(m["DefaultDiResourceGroupIdentifier"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      destination = make_shared<int>(boost::any_cast<int>(m["Destination"]));
    }
    if (m.find("IsAllowDownload") != m.end() && !m["IsAllowDownload"].empty()) {
      isAllowDownload = make_shared<int>(boost::any_cast<int>(m["IsAllowDownload"]));
    }
    if (m.find("ProdStorageQuota") != m.end() && !m["ProdStorageQuota"].empty()) {
      prodStorageQuota = make_shared<string>(boost::any_cast<string>(m["ProdStorageQuota"]));
    }
    if (m.find("SchedulerRetryInterval") != m.end() && !m["SchedulerRetryInterval"].empty()) {
      schedulerRetryInterval = make_shared<int>(boost::any_cast<int>(m["SchedulerRetryInterval"]));
    }
    if (m.find("ResidentArea") != m.end() && !m["ResidentArea"].empty()) {
      residentArea = make_shared<string>(boost::any_cast<string>(m["ResidentArea"]));
    }
    if (m.find("TablePrivacyMode") != m.end() && !m["TablePrivacyMode"].empty()) {
      tablePrivacyMode = make_shared<int>(boost::any_cast<int>(m["TablePrivacyMode"]));
    }
    if (m.find("ProjectOwnerBaseId") != m.end() && !m["ProjectOwnerBaseId"].empty()) {
      projectOwnerBaseId = make_shared<string>(boost::any_cast<string>(m["ProjectOwnerBaseId"]));
    }
    if (m.find("UseProxyOdpsAccount") != m.end() && !m["UseProxyOdpsAccount"].empty()) {
      useProxyOdpsAccount = make_shared<bool>(boost::any_cast<bool>(m["UseProxyOdpsAccount"]));
    }
    if (m.find("DisableDevelopment") != m.end() && !m["DisableDevelopment"].empty()) {
      disableDevelopment = make_shared<bool>(boost::any_cast<bool>(m["DisableDevelopment"]));
    }
    if (m.find("ProjectMode") != m.end() && !m["ProjectMode"].empty()) {
      projectMode = make_shared<int>(boost::any_cast<int>(m["ProjectMode"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("DevStorageQuota") != m.end() && !m["DevStorageQuota"].empty()) {
      devStorageQuota = make_shared<string>(boost::any_cast<string>(m["DevStorageQuota"]));
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<int>(boost::any_cast<int>(m["IsDefault"]));
    }
    if (m.find("ProtectedMode") != m.end() && !m["ProtectedMode"].empty()) {
      protectedMode = make_shared<int>(boost::any_cast<int>(m["ProtectedMode"]));
    }
    if (m.find("BaseProject") != m.end() && !m["BaseProject"].empty()) {
      baseProject = make_shared<bool>(boost::any_cast<bool>(m["BaseProject"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("ProjectDescription") != m.end() && !m["ProjectDescription"].empty()) {
      projectDescription = make_shared<string>(boost::any_cast<string>(m["ProjectDescription"]));
    }
    if (m.find("Appkey") != m.end() && !m["Appkey"].empty()) {
      appkey = make_shared<string>(boost::any_cast<string>(m["Appkey"]));
    }
    if (m.find("SchedulerMaxRetryTimes") != m.end() && !m["SchedulerMaxRetryTimes"].empty()) {
      schedulerMaxRetryTimes = make_shared<int>(boost::any_cast<int>(m["SchedulerMaxRetryTimes"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<int>(boost::any_cast<int>(m["ProjectId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<int>(boost::any_cast<int>(m["Status"]));
    }
    if (m.find("DevelopmentType") != m.end() && !m["DevelopmentType"].empty()) {
      developmentType = make_shared<int>(boost::any_cast<int>(m["DevelopmentType"]));
    }
    if (m.find("EnvTypes") != m.end() && !m["EnvTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EnvTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EnvTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      envTypes = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetProjectResponseData() = default;
};
class GetProjectResponse : public Darabonba::Model {
public:
  shared_ptr<int> httpStatusCode{};
  shared_ptr<bool> success{};
  shared_ptr<string> requestId{};
  shared_ptr<GetProjectResponseData> data{};

  GetProjectResponse() {}

  explicit GetProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetProjectResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetProjectResponseData>(model1);
      }
    }
  }


  virtual ~GetProjectResponse() = default;
};
class ListNodesByOutputRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectEnv{};
  shared_ptr<string> outputs{};

  ListNodesByOutputRequest() {}

  explicit ListNodesByOutputRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectEnv) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectEnv is required.")));
    }
    if (!outputs) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("outputs is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (outputs) {
      res["Outputs"] = boost::any(*outputs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("Outputs") != m.end() && !m["Outputs"].empty()) {
      outputs = make_shared<string>(boost::any_cast<string>(m["Outputs"]));
    }
  }


  virtual ~ListNodesByOutputRequest() = default;
};
class ListNodesByOutputResponseDataNodeList : public Darabonba::Model {
public:
  shared_ptr<long> nodeId{};
  shared_ptr<string> nodeName{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> description{};
  shared_ptr<string> resGroupName{};
  shared_ptr<string> cronExpress{};
  shared_ptr<bool> repeatability{};
  shared_ptr<string> programType{};
  shared_ptr<long> projectId{};
  shared_ptr<string> schedulerType{};
  shared_ptr<string> paramValues{};
  shared_ptr<int> priority{};
  shared_ptr<long> baselineId{};
  shared_ptr<int> repeatInterval{};
  shared_ptr<string> connection{};
  shared_ptr<int> dqcType{};
  shared_ptr<string> dqcDescription{};
  shared_ptr<long> relatedFlowId{};
  shared_ptr<string> fileType{};

  ListNodesByOutputResponseDataNodeList() {}

  explicit ListNodesByOutputResponseDataNodeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!nodeId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeId is required.")));
    }
    if (!nodeName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeName is required.")));
    }
    if (!ownerId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ownerId is required.")));
    }
    if (!description) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("description is required.")));
    }
    if (!resGroupName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("resGroupName is required.")));
    }
    if (!cronExpress) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("cronExpress is required.")));
    }
    if (!repeatability) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("repeatability is required.")));
    }
    if (!programType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("programType is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!schedulerType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("schedulerType is required.")));
    }
    if (!paramValues) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("paramValues is required.")));
    }
    if (!priority) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("priority is required.")));
    }
    if (!baselineId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("baselineId is required.")));
    }
    if (!repeatInterval) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("repeatInterval is required.")));
    }
    if (!connection) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("connection is required.")));
    }
    if (!dqcType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dqcType is required.")));
    }
    if (!dqcDescription) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dqcDescription is required.")));
    }
    if (!relatedFlowId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("relatedFlowId is required.")));
    }
    if (!fileType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("fileType is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (resGroupName) {
      res["ResGroupName"] = boost::any(*resGroupName);
    }
    if (cronExpress) {
      res["CronExpress"] = boost::any(*cronExpress);
    }
    if (repeatability) {
      res["Repeatability"] = boost::any(*repeatability);
    }
    if (programType) {
      res["ProgramType"] = boost::any(*programType);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (schedulerType) {
      res["SchedulerType"] = boost::any(*schedulerType);
    }
    if (paramValues) {
      res["ParamValues"] = boost::any(*paramValues);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (repeatInterval) {
      res["RepeatInterval"] = boost::any(*repeatInterval);
    }
    if (connection) {
      res["Connection"] = boost::any(*connection);
    }
    if (dqcType) {
      res["DqcType"] = boost::any(*dqcType);
    }
    if (dqcDescription) {
      res["DqcDescription"] = boost::any(*dqcDescription);
    }
    if (relatedFlowId) {
      res["RelatedFlowId"] = boost::any(*relatedFlowId);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ResGroupName") != m.end() && !m["ResGroupName"].empty()) {
      resGroupName = make_shared<string>(boost::any_cast<string>(m["ResGroupName"]));
    }
    if (m.find("CronExpress") != m.end() && !m["CronExpress"].empty()) {
      cronExpress = make_shared<string>(boost::any_cast<string>(m["CronExpress"]));
    }
    if (m.find("Repeatability") != m.end() && !m["Repeatability"].empty()) {
      repeatability = make_shared<bool>(boost::any_cast<bool>(m["Repeatability"]));
    }
    if (m.find("ProgramType") != m.end() && !m["ProgramType"].empty()) {
      programType = make_shared<string>(boost::any_cast<string>(m["ProgramType"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SchedulerType") != m.end() && !m["SchedulerType"].empty()) {
      schedulerType = make_shared<string>(boost::any_cast<string>(m["SchedulerType"]));
    }
    if (m.find("ParamValues") != m.end() && !m["ParamValues"].empty()) {
      paramValues = make_shared<string>(boost::any_cast<string>(m["ParamValues"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<int>(boost::any_cast<int>(m["Priority"]));
    }
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("RepeatInterval") != m.end() && !m["RepeatInterval"].empty()) {
      repeatInterval = make_shared<int>(boost::any_cast<int>(m["RepeatInterval"]));
    }
    if (m.find("Connection") != m.end() && !m["Connection"].empty()) {
      connection = make_shared<string>(boost::any_cast<string>(m["Connection"]));
    }
    if (m.find("DqcType") != m.end() && !m["DqcType"].empty()) {
      dqcType = make_shared<int>(boost::any_cast<int>(m["DqcType"]));
    }
    if (m.find("DqcDescription") != m.end() && !m["DqcDescription"].empty()) {
      dqcDescription = make_shared<string>(boost::any_cast<string>(m["DqcDescription"]));
    }
    if (m.find("RelatedFlowId") != m.end() && !m["RelatedFlowId"].empty()) {
      relatedFlowId = make_shared<long>(boost::any_cast<long>(m["RelatedFlowId"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<string>(boost::any_cast<string>(m["FileType"]));
    }
  }


  virtual ~ListNodesByOutputResponseDataNodeList() = default;
};
class ListNodesByOutputResponseData : public Darabonba::Model {
public:
  shared_ptr<string> output{};
  shared_ptr<vector<ListNodesByOutputResponseDataNodeList>> nodeList{};

  ListNodesByOutputResponseData() {}

  explicit ListNodesByOutputResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!output) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("output is required.")));
    }
    if (!nodeList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = boost::any(*output);
    }
    if (nodeList) {
      vector<boost::any> temp1;
      for(auto item1:*nodeList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NodeList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      output = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
    if (m.find("NodeList") != m.end() && !m["NodeList"].empty()) {
      if (typeid(vector<boost::any>) == m["NodeList"].type()) {
        vector<ListNodesByOutputResponseDataNodeList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NodeList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNodesByOutputResponseDataNodeList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodeList = make_shared<vector<ListNodesByOutputResponseDataNodeList>>(expect1);
      }
    }
  }


  virtual ~ListNodesByOutputResponseData() = default;
};
class ListNodesByOutputResponse : public Darabonba::Model {
public:
  shared_ptr<bool> success{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListNodesByOutputResponseData>> data{};

  ListNodesByOutputResponse() {}

  explicit ListNodesByOutputResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListNodesByOutputResponseData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNodesByOutputResponseData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListNodesByOutputResponseData>>(expect1);
      }
    }
  }


  virtual ~ListNodesByOutputResponse() = default;
};
class GetFileTypeStatisticRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> projectEnv{};

  GetFileTypeStatisticRequest() {}

  explicit GetFileTypeStatisticRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!projectEnv) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectEnv is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
  }


  virtual ~GetFileTypeStatisticRequest() = default;
};
class GetFileTypeStatisticResponseProgramTypeAndCounts : public Darabonba::Model {
public:
  shared_ptr<string> programType{};
  shared_ptr<int> count{};

  GetFileTypeStatisticResponseProgramTypeAndCounts() {}

  explicit GetFileTypeStatisticResponseProgramTypeAndCounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!programType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("programType is required.")));
    }
    if (!count) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("count is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (programType) {
      res["ProgramType"] = boost::any(*programType);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProgramType") != m.end() && !m["ProgramType"].empty()) {
      programType = make_shared<string>(boost::any_cast<string>(m["ProgramType"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<int>(boost::any_cast<int>(m["Count"]));
    }
  }


  virtual ~GetFileTypeStatisticResponseProgramTypeAndCounts() = default;
};
class GetFileTypeStatisticResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetFileTypeStatisticResponseProgramTypeAndCounts>> programTypeAndCounts{};

  GetFileTypeStatisticResponse() {}

  explicit GetFileTypeStatisticResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!programTypeAndCounts) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("programTypeAndCounts is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (programTypeAndCounts) {
      vector<boost::any> temp1;
      for(auto item1:*programTypeAndCounts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProgramTypeAndCounts"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ProgramTypeAndCounts") != m.end() && !m["ProgramTypeAndCounts"].empty()) {
      if (typeid(vector<boost::any>) == m["ProgramTypeAndCounts"].type()) {
        vector<GetFileTypeStatisticResponseProgramTypeAndCounts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProgramTypeAndCounts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetFileTypeStatisticResponseProgramTypeAndCounts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        programTypeAndCounts = make_shared<vector<GetFileTypeStatisticResponseProgramTypeAndCounts>>(expect1);
      }
    }
  }


  virtual ~GetFileTypeStatisticResponse() = default;
};
class RunSmokeTestRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectEnv{};
  shared_ptr<string> bizdate{};
  shared_ptr<string> name{};
  shared_ptr<long> nodeId{};
  shared_ptr<string> nodeParams{};

  RunSmokeTestRequest() {}

  explicit RunSmokeTestRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectEnv) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectEnv is required.")));
    }
    if (!bizdate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("bizdate is required.")));
    }
    if (!name) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("name is required.")));
    }
    if (!nodeId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (bizdate) {
      res["Bizdate"] = boost::any(*bizdate);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeParams) {
      res["NodeParams"] = boost::any(*nodeParams);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("Bizdate") != m.end() && !m["Bizdate"].empty()) {
      bizdate = make_shared<string>(boost::any_cast<string>(m["Bizdate"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("NodeParams") != m.end() && !m["NodeParams"].empty()) {
      nodeParams = make_shared<string>(boost::any_cast<string>(m["NodeParams"]));
    }
  }


  virtual ~RunSmokeTestRequest() = default;
};
class RunSmokeTestResponse : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> data{};

  RunSmokeTestResponse() {}

  explicit RunSmokeTestResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
  }


  virtual ~RunSmokeTestResponse() = default;
};
class ListNodeInputOrOutputRequest : public Darabonba::Model {
public:
  shared_ptr<long> nodeId{};
  shared_ptr<string> projectEnv{};
  shared_ptr<string> ioType{};

  ListNodeInputOrOutputRequest() {}

  explicit ListNodeInputOrOutputRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!nodeId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeId is required.")));
    }
    if (!projectEnv) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectEnv is required.")));
    }
    if (!ioType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ioType is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (ioType) {
      res["IoType"] = boost::any(*ioType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("IoType") != m.end() && !m["IoType"].empty()) {
      ioType = make_shared<string>(boost::any_cast<string>(m["IoType"]));
    }
  }


  virtual ~ListNodeInputOrOutputRequest() = default;
};
class ListNodeInputOrOutputResponseData : public Darabonba::Model {
public:
  shared_ptr<string> tableName{};
  shared_ptr<string> data{};
  shared_ptr<long> nodeId{};

  ListNodeInputOrOutputResponseData() {}

  explicit ListNodeInputOrOutputResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!tableName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tableName is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
    if (!nodeId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
  }


  virtual ~ListNodeInputOrOutputResponseData() = default;
};
class ListNodeInputOrOutputResponse : public Darabonba::Model {
public:
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListNodeInputOrOutputResponseData>> data{};

  ListNodeInputOrOutputResponse() {}

  explicit ListNodeInputOrOutputResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListNodeInputOrOutputResponseData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNodeInputOrOutputResponseData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListNodeInputOrOutputResponseData>>(expect1);
      }
    }
  }


  virtual ~ListNodeInputOrOutputResponse() = default;
};
class RunCycleDagNodesRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectEnv{};
  shared_ptr<string> startBizDate{};
  shared_ptr<string> name{};
  shared_ptr<long> rootNodeId{};
  shared_ptr<string> excludeNodeIds{};
  shared_ptr<string> bizBeginTime{};
  shared_ptr<string> bizEndTime{};
  shared_ptr<bool> parallelism{};
  shared_ptr<string> endBizDate{};
  shared_ptr<string> nodeParams{};
  shared_ptr<string> includeNodeIds{};

  RunCycleDagNodesRequest() {}

  explicit RunCycleDagNodesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectEnv) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectEnv is required.")));
    }
    if (!startBizDate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("startBizDate is required.")));
    }
    if (!name) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("name is required.")));
    }
    if (!rootNodeId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("rootNodeId is required.")));
    }
    if (!parallelism) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parallelism is required.")));
    }
    if (!endBizDate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("endBizDate is required.")));
    }
    if (!includeNodeIds) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("includeNodeIds is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (startBizDate) {
      res["StartBizDate"] = boost::any(*startBizDate);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (rootNodeId) {
      res["RootNodeId"] = boost::any(*rootNodeId);
    }
    if (excludeNodeIds) {
      res["ExcludeNodeIds"] = boost::any(*excludeNodeIds);
    }
    if (bizBeginTime) {
      res["BizBeginTime"] = boost::any(*bizBeginTime);
    }
    if (bizEndTime) {
      res["BizEndTime"] = boost::any(*bizEndTime);
    }
    if (parallelism) {
      res["Parallelism"] = boost::any(*parallelism);
    }
    if (endBizDate) {
      res["EndBizDate"] = boost::any(*endBizDate);
    }
    if (nodeParams) {
      res["NodeParams"] = boost::any(*nodeParams);
    }
    if (includeNodeIds) {
      res["IncludeNodeIds"] = boost::any(*includeNodeIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("StartBizDate") != m.end() && !m["StartBizDate"].empty()) {
      startBizDate = make_shared<string>(boost::any_cast<string>(m["StartBizDate"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RootNodeId") != m.end() && !m["RootNodeId"].empty()) {
      rootNodeId = make_shared<long>(boost::any_cast<long>(m["RootNodeId"]));
    }
    if (m.find("ExcludeNodeIds") != m.end() && !m["ExcludeNodeIds"].empty()) {
      excludeNodeIds = make_shared<string>(boost::any_cast<string>(m["ExcludeNodeIds"]));
    }
    if (m.find("BizBeginTime") != m.end() && !m["BizBeginTime"].empty()) {
      bizBeginTime = make_shared<string>(boost::any_cast<string>(m["BizBeginTime"]));
    }
    if (m.find("BizEndTime") != m.end() && !m["BizEndTime"].empty()) {
      bizEndTime = make_shared<string>(boost::any_cast<string>(m["BizEndTime"]));
    }
    if (m.find("Parallelism") != m.end() && !m["Parallelism"].empty()) {
      parallelism = make_shared<bool>(boost::any_cast<bool>(m["Parallelism"]));
    }
    if (m.find("EndBizDate") != m.end() && !m["EndBizDate"].empty()) {
      endBizDate = make_shared<string>(boost::any_cast<string>(m["EndBizDate"]));
    }
    if (m.find("NodeParams") != m.end() && !m["NodeParams"].empty()) {
      nodeParams = make_shared<string>(boost::any_cast<string>(m["NodeParams"]));
    }
    if (m.find("IncludeNodeIds") != m.end() && !m["IncludeNodeIds"].empty()) {
      includeNodeIds = make_shared<string>(boost::any_cast<string>(m["IncludeNodeIds"]));
    }
  }


  virtual ~RunCycleDagNodesRequest() = default;
};
class RunCycleDagNodesResponse : public Darabonba::Model {
public:
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<vector<long>> data{};

  RunCycleDagNodesResponse() {}

  explicit RunCycleDagNodesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Data"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      data = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~RunCycleDagNodesResponse() = default;
};
class RunManualDagNodesRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectEnv{};
  shared_ptr<string> projectName{};
  shared_ptr<string> flowName{};
  shared_ptr<string> bizDate{};
  shared_ptr<string> nodeParameters{};
  shared_ptr<string> dagParameters{};
  shared_ptr<string> includeNodeIds{};
  shared_ptr<string> excludeNodeIds{};
  shared_ptr<long> projectId{};

  RunManualDagNodesRequest() {}

  explicit RunManualDagNodesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectEnv) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectEnv is required.")));
    }
    if (!projectName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectName is required.")));
    }
    if (!flowName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("flowName is required.")));
    }
    if (!bizDate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("bizDate is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (flowName) {
      res["FlowName"] = boost::any(*flowName);
    }
    if (bizDate) {
      res["BizDate"] = boost::any(*bizDate);
    }
    if (nodeParameters) {
      res["NodeParameters"] = boost::any(*nodeParameters);
    }
    if (dagParameters) {
      res["DagParameters"] = boost::any(*dagParameters);
    }
    if (includeNodeIds) {
      res["IncludeNodeIds"] = boost::any(*includeNodeIds);
    }
    if (excludeNodeIds) {
      res["ExcludeNodeIds"] = boost::any(*excludeNodeIds);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("FlowName") != m.end() && !m["FlowName"].empty()) {
      flowName = make_shared<string>(boost::any_cast<string>(m["FlowName"]));
    }
    if (m.find("BizDate") != m.end() && !m["BizDate"].empty()) {
      bizDate = make_shared<string>(boost::any_cast<string>(m["BizDate"]));
    }
    if (m.find("NodeParameters") != m.end() && !m["NodeParameters"].empty()) {
      nodeParameters = make_shared<string>(boost::any_cast<string>(m["NodeParameters"]));
    }
    if (m.find("DagParameters") != m.end() && !m["DagParameters"].empty()) {
      dagParameters = make_shared<string>(boost::any_cast<string>(m["DagParameters"]));
    }
    if (m.find("IncludeNodeIds") != m.end() && !m["IncludeNodeIds"].empty()) {
      includeNodeIds = make_shared<string>(boost::any_cast<string>(m["IncludeNodeIds"]));
    }
    if (m.find("ExcludeNodeIds") != m.end() && !m["ExcludeNodeIds"].empty()) {
      excludeNodeIds = make_shared<string>(boost::any_cast<string>(m["ExcludeNodeIds"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~RunManualDagNodesRequest() = default;
};
class RunManualDagNodesResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> dagId{};

  RunManualDagNodesResponse() {}

  explicit RunManualDagNodesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!dagId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dagId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
  }


  virtual ~RunManualDagNodesResponse() = default;
};
class UpdateDataSourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<int> envType{};
  shared_ptr<string> content{};
  shared_ptr<string> status{};
  shared_ptr<long> dataSourceId{};

  UpdateDataSourceRequest() {}

  explicit UpdateDataSourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!dataSourceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dataSourceId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (dataSourceId) {
      res["DataSourceId"] = boost::any(*dataSourceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<int>(boost::any_cast<int>(m["EnvType"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("DataSourceId") != m.end() && !m["DataSourceId"].empty()) {
      dataSourceId = make_shared<long>(boost::any_cast<long>(m["DataSourceId"]));
    }
  }


  virtual ~UpdateDataSourceRequest() = default;
};
class UpdateDataSourceResponse : public Darabonba::Model {
public:
  shared_ptr<bool> success{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  UpdateDataSourceResponse() {}

  explicit UpdateDataSourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateDataSourceResponse() = default;
};
class UpdateTableAddColumnRequestColumn : public Darabonba::Model {
public:
  shared_ptr<string> columnName{};
  shared_ptr<string> columnNameCn{};
  shared_ptr<string> columnType{};
  shared_ptr<string> comment{};

  UpdateTableAddColumnRequestColumn() {}

  explicit UpdateTableAddColumnRequestColumn(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!columnName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("columnName is required.")));
    }
    if (!columnType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("columnType is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (columnNameCn) {
      res["ColumnNameCn"] = boost::any(*columnNameCn);
    }
    if (columnType) {
      res["ColumnType"] = boost::any(*columnType);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("ColumnNameCn") != m.end() && !m["ColumnNameCn"].empty()) {
      columnNameCn = make_shared<string>(boost::any_cast<string>(m["ColumnNameCn"]));
    }
    if (m.find("ColumnType") != m.end() && !m["ColumnType"].empty()) {
      columnType = make_shared<string>(boost::any_cast<string>(m["ColumnType"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
  }


  virtual ~UpdateTableAddColumnRequestColumn() = default;
};
class UpdateTableAddColumnRequest : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateTableAddColumnRequestColumn>> column{};
  shared_ptr<string> tableGuid{};

  UpdateTableAddColumnRequest() {}

  explicit UpdateTableAddColumnRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!column) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("column is required.")));
    }
    if (!tableGuid) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tableGuid is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (column) {
      vector<boost::any> temp1;
      for(auto item1:*column){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Column"] = boost::any(temp1);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Column") != m.end() && !m["Column"].empty()) {
      if (typeid(vector<boost::any>) == m["Column"].type()) {
        vector<UpdateTableAddColumnRequestColumn> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Column"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateTableAddColumnRequestColumn model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        column = make_shared<vector<UpdateTableAddColumnRequestColumn>>(expect1);
      }
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
  }


  virtual ~UpdateTableAddColumnRequest() = default;
};
class UpdateTableAddColumnResponseTaskInfo : public Darabonba::Model {
public:
  shared_ptr<string> taskId{};
  shared_ptr<string> content{};
  shared_ptr<string> status{};
  shared_ptr<string> nextTaskId{};

  UpdateTableAddColumnResponseTaskInfo() {}

  explicit UpdateTableAddColumnResponseTaskInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!taskId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskId is required.")));
    }
    if (!content) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("content is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!nextTaskId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nextTaskId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (nextTaskId) {
      res["NextTaskId"] = boost::any(*nextTaskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("NextTaskId") != m.end() && !m["NextTaskId"].empty()) {
      nextTaskId = make_shared<string>(boost::any_cast<string>(m["NextTaskId"]));
    }
  }


  virtual ~UpdateTableAddColumnResponseTaskInfo() = default;
};
class UpdateTableAddColumnResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<UpdateTableAddColumnResponseTaskInfo> taskInfo{};

  UpdateTableAddColumnResponse() {}

  explicit UpdateTableAddColumnResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!taskInfo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskInfo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskInfo) {
      res["TaskInfo"] = taskInfo ? boost::any(taskInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskInfo") != m.end() && !m["TaskInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["TaskInfo"].type()) {
        UpdateTableAddColumnResponseTaskInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TaskInfo"]));
        taskInfo = make_shared<UpdateTableAddColumnResponseTaskInfo>(model1);
      }
    }
  }


  virtual ~UpdateTableAddColumnResponse() = default;
};
class GetMigrationProcessRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<long> migrationId{};

  GetMigrationProcessRequest() {}

  explicit GetMigrationProcessRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!migrationId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("migrationId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (migrationId) {
      res["MigrationId"] = boost::any(*migrationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("MigrationId") != m.end() && !m["MigrationId"].empty()) {
      migrationId = make_shared<long>(boost::any_cast<long>(m["MigrationId"]));
    }
  }


  virtual ~GetMigrationProcessRequest() = default;
};
class GetMigrationProcessResponseData : public Darabonba::Model {
public:
  shared_ptr<string> taskName{};
  shared_ptr<string> taskStatus{};

  GetMigrationProcessResponseData() {}

  explicit GetMigrationProcessResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!taskName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskName is required.")));
    }
    if (!taskStatus) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskStatus is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<string>(boost::any_cast<string>(m["TaskStatus"]));
    }
  }


  virtual ~GetMigrationProcessResponseData() = default;
};
class GetMigrationProcessResponse : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<vector<GetMigrationProcessResponseData>> data{};

  GetMigrationProcessResponse() {}

  explicit GetMigrationProcessResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<GetMigrationProcessResponseData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMigrationProcessResponseData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<GetMigrationProcessResponseData>>(expect1);
      }
    }
  }


  virtual ~GetMigrationProcessResponse() = default;
};
class CreateImportMigrationRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> name{};
  shared_ptr<string> packageType{};
  shared_ptr<string> packageFile{};
  shared_ptr<string> resourceGroupMap{};
  shared_ptr<string> workspaceMap{};
  shared_ptr<string> calculateEngineMap{};
  shared_ptr<string> commitRule{};
  shared_ptr<string> description{};

  CreateImportMigrationRequest() {}

  explicit CreateImportMigrationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!name) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("name is required.")));
    }
    if (!packageType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("packageType is required.")));
    }
    if (!packageFile) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("packageFile is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (packageType) {
      res["PackageType"] = boost::any(*packageType);
    }
    if (packageFile) {
      res["PackageFile"] = boost::any(*packageFile);
    }
    if (resourceGroupMap) {
      res["ResourceGroupMap"] = boost::any(*resourceGroupMap);
    }
    if (workspaceMap) {
      res["WorkspaceMap"] = boost::any(*workspaceMap);
    }
    if (calculateEngineMap) {
      res["CalculateEngineMap"] = boost::any(*calculateEngineMap);
    }
    if (commitRule) {
      res["CommitRule"] = boost::any(*commitRule);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PackageType") != m.end() && !m["PackageType"].empty()) {
      packageType = make_shared<string>(boost::any_cast<string>(m["PackageType"]));
    }
    if (m.find("PackageFile") != m.end() && !m["PackageFile"].empty()) {
      packageFile = make_shared<string>(boost::any_cast<string>(m["PackageFile"]));
    }
    if (m.find("ResourceGroupMap") != m.end() && !m["ResourceGroupMap"].empty()) {
      resourceGroupMap = make_shared<string>(boost::any_cast<string>(m["ResourceGroupMap"]));
    }
    if (m.find("WorkspaceMap") != m.end() && !m["WorkspaceMap"].empty()) {
      workspaceMap = make_shared<string>(boost::any_cast<string>(m["WorkspaceMap"]));
    }
    if (m.find("CalculateEngineMap") != m.end() && !m["CalculateEngineMap"].empty()) {
      calculateEngineMap = make_shared<string>(boost::any_cast<string>(m["CalculateEngineMap"]));
    }
    if (m.find("CommitRule") != m.end() && !m["CommitRule"].empty()) {
      commitRule = make_shared<string>(boost::any_cast<string>(m["CommitRule"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~CreateImportMigrationRequest() = default;
};
class CreateImportMigrationResponse : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> data{};

  CreateImportMigrationResponse() {}

  explicit CreateImportMigrationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
  }


  virtual ~CreateImportMigrationResponse() = default;
};
class CreateImportMigrationAdvanceRequest : public Darabonba::Model {
public:
  shared_ptr<Darabonba::Stream> packageFileObject{};
  shared_ptr<long> projectId{};
  shared_ptr<string> name{};
  shared_ptr<string> packageType{};
  shared_ptr<string> resourceGroupMap{};
  shared_ptr<string> workspaceMap{};
  shared_ptr<string> calculateEngineMap{};
  shared_ptr<string> commitRule{};
  shared_ptr<string> description{};

  CreateImportMigrationAdvanceRequest() {}

  explicit CreateImportMigrationAdvanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!packageFileObject) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("packageFileObject is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!name) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("name is required.")));
    }
    if (!packageType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("packageType is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (packageFileObject) {
      res["PackageFileObject"] = boost::any(*packageFileObject);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (packageType) {
      res["PackageType"] = boost::any(*packageType);
    }
    if (resourceGroupMap) {
      res["ResourceGroupMap"] = boost::any(*resourceGroupMap);
    }
    if (workspaceMap) {
      res["WorkspaceMap"] = boost::any(*workspaceMap);
    }
    if (calculateEngineMap) {
      res["CalculateEngineMap"] = boost::any(*calculateEngineMap);
    }
    if (commitRule) {
      res["CommitRule"] = boost::any(*commitRule);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PackageFileObject") != m.end() && !m["PackageFileObject"].empty()) {
      packageFileObject = make_shared<Darabonba::Stream>(boost::any_cast<Darabonba::Stream>(m["PackageFileObject"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PackageType") != m.end() && !m["PackageType"].empty()) {
      packageType = make_shared<string>(boost::any_cast<string>(m["PackageType"]));
    }
    if (m.find("ResourceGroupMap") != m.end() && !m["ResourceGroupMap"].empty()) {
      resourceGroupMap = make_shared<string>(boost::any_cast<string>(m["ResourceGroupMap"]));
    }
    if (m.find("WorkspaceMap") != m.end() && !m["WorkspaceMap"].empty()) {
      workspaceMap = make_shared<string>(boost::any_cast<string>(m["WorkspaceMap"]));
    }
    if (m.find("CalculateEngineMap") != m.end() && !m["CalculateEngineMap"].empty()) {
      calculateEngineMap = make_shared<string>(boost::any_cast<string>(m["CalculateEngineMap"]));
    }
    if (m.find("CommitRule") != m.end() && !m["CommitRule"].empty()) {
      commitRule = make_shared<string>(boost::any_cast<string>(m["CommitRule"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~CreateImportMigrationAdvanceRequest() = default;
};
class StartMigrationRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<long> migrationId{};

  StartMigrationRequest() {}

  explicit StartMigrationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!migrationId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("migrationId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (migrationId) {
      res["MigrationId"] = boost::any(*migrationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("MigrationId") != m.end() && !m["MigrationId"].empty()) {
      migrationId = make_shared<long>(boost::any_cast<long>(m["MigrationId"]));
    }
  }


  virtual ~StartMigrationRequest() = default;
};
class StartMigrationResponse : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<bool> data{};

  StartMigrationResponse() {}

  explicit StartMigrationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
  }


  virtual ~StartMigrationResponse() = default;
};
class GetNodeParentsRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectEnv{};
  shared_ptr<long> nodeId{};

  GetNodeParentsRequest() {}

  explicit GetNodeParentsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectEnv) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectEnv is required.")));
    }
    if (!nodeId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
  }


  virtual ~GetNodeParentsRequest() = default;
};
class GetNodeParentsResponseDataNodes : public Darabonba::Model {
public:
  shared_ptr<long> nodeId{};
  shared_ptr<string> nodeName{};
  shared_ptr<string> cronExpress{};
  shared_ptr<string> schedulerType{};
  shared_ptr<string> programType{};
  shared_ptr<string> ownerId{};
  shared_ptr<long> projectId{};
  shared_ptr<bool> repeatability{};
  shared_ptr<int> priority{};
  shared_ptr<long> baselineId{};

  GetNodeParentsResponseDataNodes() {}

  explicit GetNodeParentsResponseDataNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!nodeId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeId is required.")));
    }
    if (!nodeName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeName is required.")));
    }
    if (!cronExpress) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("cronExpress is required.")));
    }
    if (!schedulerType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("schedulerType is required.")));
    }
    if (!programType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("programType is required.")));
    }
    if (!ownerId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ownerId is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!repeatability) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("repeatability is required.")));
    }
    if (!priority) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("priority is required.")));
    }
    if (!baselineId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("baselineId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (cronExpress) {
      res["CronExpress"] = boost::any(*cronExpress);
    }
    if (schedulerType) {
      res["SchedulerType"] = boost::any(*schedulerType);
    }
    if (programType) {
      res["ProgramType"] = boost::any(*programType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (repeatability) {
      res["Repeatability"] = boost::any(*repeatability);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("CronExpress") != m.end() && !m["CronExpress"].empty()) {
      cronExpress = make_shared<string>(boost::any_cast<string>(m["CronExpress"]));
    }
    if (m.find("SchedulerType") != m.end() && !m["SchedulerType"].empty()) {
      schedulerType = make_shared<string>(boost::any_cast<string>(m["SchedulerType"]));
    }
    if (m.find("ProgramType") != m.end() && !m["ProgramType"].empty()) {
      programType = make_shared<string>(boost::any_cast<string>(m["ProgramType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Repeatability") != m.end() && !m["Repeatability"].empty()) {
      repeatability = make_shared<bool>(boost::any_cast<bool>(m["Repeatability"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<int>(boost::any_cast<int>(m["Priority"]));
    }
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
  }


  virtual ~GetNodeParentsResponseDataNodes() = default;
};
class GetNodeParentsResponseData : public Darabonba::Model {
public:
  shared_ptr<vector<GetNodeParentsResponseDataNodes>> nodes{};

  GetNodeParentsResponseData() {}

  explicit GetNodeParentsResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!nodes) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodes is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodes) {
      vector<boost::any> temp1;
      for(auto item1:*nodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Nodes"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Nodes") != m.end() && !m["Nodes"].empty()) {
      if (typeid(vector<boost::any>) == m["Nodes"].type()) {
        vector<GetNodeParentsResponseDataNodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Nodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetNodeParentsResponseDataNodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodes = make_shared<vector<GetNodeParentsResponseDataNodes>>(expect1);
      }
    }
  }


  virtual ~GetNodeParentsResponseData() = default;
};
class GetNodeParentsResponse : public Darabonba::Model {
public:
  shared_ptr<bool> success{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<GetNodeParentsResponseData> data{};

  GetNodeParentsResponse() {}

  explicit GetNodeParentsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetNodeParentsResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetNodeParentsResponseData>(model1);
      }
    }
  }


  virtual ~GetNodeParentsResponse() = default;
};
class GetNodeChildrenRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectEnv{};
  shared_ptr<long> nodeId{};

  GetNodeChildrenRequest() {}

  explicit GetNodeChildrenRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectEnv) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectEnv is required.")));
    }
    if (!nodeId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
  }


  virtual ~GetNodeChildrenRequest() = default;
};
class GetNodeChildrenResponseDataNodes : public Darabonba::Model {
public:
  shared_ptr<long> nodeId{};
  shared_ptr<string> nodeName{};
  shared_ptr<string> cronExpress{};
  shared_ptr<string> schedulerType{};
  shared_ptr<string> programType{};
  shared_ptr<string> ownerId{};
  shared_ptr<long> projectId{};
  shared_ptr<bool> repeatability{};
  shared_ptr<int> priority{};
  shared_ptr<long> baselineId{};

  GetNodeChildrenResponseDataNodes() {}

  explicit GetNodeChildrenResponseDataNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!nodeId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeId is required.")));
    }
    if (!nodeName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeName is required.")));
    }
    if (!cronExpress) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("cronExpress is required.")));
    }
    if (!schedulerType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("schedulerType is required.")));
    }
    if (!programType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("programType is required.")));
    }
    if (!ownerId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ownerId is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!repeatability) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("repeatability is required.")));
    }
    if (!priority) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("priority is required.")));
    }
    if (!baselineId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("baselineId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (cronExpress) {
      res["CronExpress"] = boost::any(*cronExpress);
    }
    if (schedulerType) {
      res["SchedulerType"] = boost::any(*schedulerType);
    }
    if (programType) {
      res["ProgramType"] = boost::any(*programType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (repeatability) {
      res["Repeatability"] = boost::any(*repeatability);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("CronExpress") != m.end() && !m["CronExpress"].empty()) {
      cronExpress = make_shared<string>(boost::any_cast<string>(m["CronExpress"]));
    }
    if (m.find("SchedulerType") != m.end() && !m["SchedulerType"].empty()) {
      schedulerType = make_shared<string>(boost::any_cast<string>(m["SchedulerType"]));
    }
    if (m.find("ProgramType") != m.end() && !m["ProgramType"].empty()) {
      programType = make_shared<string>(boost::any_cast<string>(m["ProgramType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Repeatability") != m.end() && !m["Repeatability"].empty()) {
      repeatability = make_shared<bool>(boost::any_cast<bool>(m["Repeatability"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<int>(boost::any_cast<int>(m["Priority"]));
    }
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
  }


  virtual ~GetNodeChildrenResponseDataNodes() = default;
};
class GetNodeChildrenResponseData : public Darabonba::Model {
public:
  shared_ptr<vector<GetNodeChildrenResponseDataNodes>> nodes{};

  GetNodeChildrenResponseData() {}

  explicit GetNodeChildrenResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!nodes) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodes is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodes) {
      vector<boost::any> temp1;
      for(auto item1:*nodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Nodes"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Nodes") != m.end() && !m["Nodes"].empty()) {
      if (typeid(vector<boost::any>) == m["Nodes"].type()) {
        vector<GetNodeChildrenResponseDataNodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Nodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetNodeChildrenResponseDataNodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodes = make_shared<vector<GetNodeChildrenResponseDataNodes>>(expect1);
      }
    }
  }


  virtual ~GetNodeChildrenResponseData() = default;
};
class GetNodeChildrenResponse : public Darabonba::Model {
public:
  shared_ptr<bool> success{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<GetNodeChildrenResponseData> data{};

  GetNodeChildrenResponse() {}

  explicit GetNodeChildrenResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetNodeChildrenResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetNodeChildrenResponseData>(model1);
      }
    }
  }


  virtual ~GetNodeChildrenResponse() = default;
};
class GetSensitiveDataRequest : public Darabonba::Model {
public:
  shared_ptr<int> pageSize{};
  shared_ptr<int> pageNo{};
  shared_ptr<string> name{};

  GetSensitiveDataRequest() {}

  explicit GetSensitiveDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!pageNo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNo is required.")));
    }
    if (!name) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("name is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<int>(boost::any_cast<int>(m["PageNo"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetSensitiveDataRequest() = default;
};
class GetSensitiveDataResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<map<string, boost::any>> sensitiveData{};

  GetSensitiveDataResponse() {}

  explicit GetSensitiveDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!sensitiveData) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("sensitiveData is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sensitiveData) {
      res["SensitiveData"] = boost::any(*sensitiveData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SensitiveData") != m.end() && !m["SensitiveData"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["SensitiveData"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      sensitiveData = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~GetSensitiveDataResponse() = default;
};
class DesensitizeDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> sceneCode{};

  DesensitizeDataRequest() {}

  explicit DesensitizeDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
    if (!sceneCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("sceneCode is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (sceneCode) {
      res["SceneCode"] = boost::any(*sceneCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("SceneCode") != m.end() && !m["SceneCode"].empty()) {
      sceneCode = make_shared<string>(boost::any_cast<string>(m["SceneCode"]));
    }
  }


  virtual ~DesensitizeDataRequest() = default;
};
class DesensitizeDataResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> desensitizeData{};

  DesensitizeDataResponse() {}

  explicit DesensitizeDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!desensitizeData) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("desensitizeData is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (desensitizeData) {
      res["DesensitizeData"] = boost::any(*desensitizeData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DesensitizeData") != m.end() && !m["DesensitizeData"].empty()) {
      desensitizeData = make_shared<string>(boost::any_cast<string>(m["DesensitizeData"]));
    }
  }


  virtual ~DesensitizeDataResponse() = default;
};
class GetOpRiskDataRequest : public Darabonba::Model {
public:
  shared_ptr<int> pageSize{};
  shared_ptr<int> pageNo{};
  shared_ptr<string> name{};
  shared_ptr<string> date{};
  shared_ptr<string> riskType{};

  GetOpRiskDataRequest() {}

  explicit GetOpRiskDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!pageNo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNo is required.")));
    }
    if (!date) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("date is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (date) {
      res["Date"] = boost::any(*date);
    }
    if (riskType) {
      res["RiskType"] = boost::any(*riskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<int>(boost::any_cast<int>(m["PageNo"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Date") != m.end() && !m["Date"].empty()) {
      date = make_shared<string>(boost::any_cast<string>(m["Date"]));
    }
    if (m.find("RiskType") != m.end() && !m["RiskType"].empty()) {
      riskType = make_shared<string>(boost::any_cast<string>(m["RiskType"]));
    }
  }


  virtual ~GetOpRiskDataRequest() = default;
};
class GetOpRiskDataResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> riskData{};

  GetOpRiskDataResponse() {}

  explicit GetOpRiskDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!riskData) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("riskData is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (riskData) {
      res["RiskData"] = boost::any(*riskData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RiskData") != m.end() && !m["RiskData"].empty()) {
      riskData = make_shared<string>(boost::any_cast<string>(m["RiskData"]));
    }
  }


  virtual ~GetOpRiskDataResponse() = default;
};
class ScanSensitiveDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> data{};

  ScanSensitiveDataRequest() {}

  explicit ScanSensitiveDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
  }


  virtual ~ScanSensitiveDataRequest() = default;
};
class ScanSensitiveDataResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<map<string, boost::any>> sensitives{};

  ScanSensitiveDataResponse() {}

  explicit ScanSensitiveDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!sensitives) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("sensitives is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sensitives) {
      res["Sensitives"] = boost::any(*sensitives);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Sensitives") != m.end() && !m["Sensitives"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Sensitives"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      sensitives = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~ScanSensitiveDataResponse() = default;
};
class GetOpSensitiveDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> pageNo{};
  shared_ptr<string> date{};
  shared_ptr<string> opType{};

  GetOpSensitiveDataRequest() {}

  explicit GetOpSensitiveDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!name) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("name is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!pageNo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNo is required.")));
    }
    if (!date) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("date is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (date) {
      res["Date"] = boost::any(*date);
    }
    if (opType) {
      res["OpType"] = boost::any(*opType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<int>(boost::any_cast<int>(m["PageNo"]));
    }
    if (m.find("Date") != m.end() && !m["Date"].empty()) {
      date = make_shared<string>(boost::any_cast<string>(m["Date"]));
    }
    if (m.find("OpType") != m.end() && !m["OpType"].empty()) {
      opType = make_shared<string>(boost::any_cast<string>(m["OpType"]));
    }
  }


  virtual ~GetOpSensitiveDataRequest() = default;
};
class GetOpSensitiveDataResponse : public Darabonba::Model {
public:
  shared_ptr<string> opSensitiveData{};
  shared_ptr<string> requestId{};

  GetOpSensitiveDataResponse() {}

  explicit GetOpSensitiveDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!opSensitiveData) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("opSensitiveData is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opSensitiveData) {
      res["OpSensitiveData"] = boost::any(*opSensitiveData);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpSensitiveData") != m.end() && !m["OpSensitiveData"].empty()) {
      opSensitiveData = make_shared<string>(boost::any_cast<string>(m["OpSensitiveData"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetOpSensitiveDataResponse() = default;
};
class CreateBusinessRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<string> businessName{};
  shared_ptr<string> description{};
  shared_ptr<string> owner{};
  shared_ptr<string> useType{};

  CreateBusinessRequest() {}

  explicit CreateBusinessRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!businessName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("businessName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (businessName) {
      res["BusinessName"] = boost::any(*businessName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (useType) {
      res["UseType"] = boost::any(*useType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("BusinessName") != m.end() && !m["BusinessName"].empty()) {
      businessName = make_shared<string>(boost::any_cast<string>(m["BusinessName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("UseType") != m.end() && !m["UseType"].empty()) {
      useType = make_shared<string>(boost::any_cast<string>(m["UseType"]));
    }
  }


  virtual ~CreateBusinessRequest() = default;
};
class CreateBusinessResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<long> businessId{};

  CreateBusinessResponse() {}

  explicit CreateBusinessResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!businessId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("businessId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (businessId) {
      res["BusinessId"] = boost::any(*businessId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("BusinessId") != m.end() && !m["BusinessId"].empty()) {
      businessId = make_shared<long>(boost::any_cast<long>(m["BusinessId"]));
    }
  }


  virtual ~CreateBusinessResponse() = default;
};
class RunTriggerNodeRequest : public Darabonba::Model {
public:
  shared_ptr<long> nodeId{};
  shared_ptr<long> cycleTime{};
  shared_ptr<long> bizDate{};
  shared_ptr<long> appId{};

  RunTriggerNodeRequest() {}

  explicit RunTriggerNodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!nodeId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeId is required.")));
    }
    if (!cycleTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("cycleTime is required.")));
    }
    if (!bizDate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("bizDate is required.")));
    }
    if (!appId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("appId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (cycleTime) {
      res["CycleTime"] = boost::any(*cycleTime);
    }
    if (bizDate) {
      res["BizDate"] = boost::any(*bizDate);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("CycleTime") != m.end() && !m["CycleTime"].empty()) {
      cycleTime = make_shared<long>(boost::any_cast<long>(m["CycleTime"]));
    }
    if (m.find("BizDate") != m.end() && !m["BizDate"].empty()) {
      bizDate = make_shared<long>(boost::any_cast<long>(m["BizDate"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
  }


  virtual ~RunTriggerNodeRequest() = default;
};
class RunTriggerNodeResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  RunTriggerNodeResponse() {}

  explicit RunTriggerNodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RunTriggerNodeResponse() = default;
};
class GetDagRequest : public Darabonba::Model {
public:
  shared_ptr<long> dagId{};
  shared_ptr<string> projectEnv{};

  GetDagRequest() {}

  explicit GetDagRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!dagId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dagId is required.")));
    }
    if (!projectEnv) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectEnv is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
  }


  virtual ~GetDagRequest() = default;
};
class GetDagResponseData : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<long> dagId{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> status{};
  shared_ptr<long> bizdate{};
  shared_ptr<long> gmtdate{};
  shared_ptr<long> startTime{};
  shared_ptr<long> finishTime{};
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<long> modifyTime{};

  GetDagResponseData() {}

  explicit GetDagResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!dagId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dagId is required.")));
    }
    if (!name) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("name is required.")));
    }
    if (!type) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("type is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!bizdate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("bizdate is required.")));
    }
    if (!gmtdate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtdate is required.")));
    }
    if (!startTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("startTime is required.")));
    }
    if (!finishTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("finishTime is required.")));
    }
    if (!createTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("createTime is required.")));
    }
    if (!createUser) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("createUser is required.")));
    }
    if (!modifyTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("modifyTime is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (bizdate) {
      res["Bizdate"] = boost::any(*bizdate);
    }
    if (gmtdate) {
      res["Gmtdate"] = boost::any(*gmtdate);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Bizdate") != m.end() && !m["Bizdate"].empty()) {
      bizdate = make_shared<long>(boost::any_cast<long>(m["Bizdate"]));
    }
    if (m.find("Gmtdate") != m.end() && !m["Gmtdate"].empty()) {
      gmtdate = make_shared<long>(boost::any_cast<long>(m["Gmtdate"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<long>(boost::any_cast<long>(m["FinishTime"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
  }


  virtual ~GetDagResponseData() = default;
};
class GetDagResponse : public Darabonba::Model {
public:
  shared_ptr<bool> success{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<GetDagResponseData> data{};

  GetDagResponse() {}

  explicit GetDagResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetDagResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetDagResponseData>(model1);
      }
    }
  }


  virtual ~GetDagResponse() = default;
};
class SearchNodesByOutputRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectEnv{};
  shared_ptr<string> outputs{};

  SearchNodesByOutputRequest() {}

  explicit SearchNodesByOutputRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectEnv) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectEnv is required.")));
    }
    if (!outputs) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("outputs is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (outputs) {
      res["Outputs"] = boost::any(*outputs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("Outputs") != m.end() && !m["Outputs"].empty()) {
      outputs = make_shared<string>(boost::any_cast<string>(m["Outputs"]));
    }
  }


  virtual ~SearchNodesByOutputRequest() = default;
};
class SearchNodesByOutputResponse : public Darabonba::Model {
public:
  shared_ptr<bool> success{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<map<string, boost::any>> data{};

  SearchNodesByOutputResponse() {}

  explicit SearchNodesByOutputResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Data"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      data = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~SearchNodesByOutputResponse() = default;
};
class GetManualDagInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectEnv{};
  shared_ptr<string> projectName{};
  shared_ptr<string> dagId{};

  GetManualDagInstancesRequest() {}

  explicit GetManualDagInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectEnv) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectEnv is required.")));
    }
    if (!projectName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectName is required.")));
    }
    if (!dagId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dagId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<string>(boost::any_cast<string>(m["DagId"]));
    }
  }


  virtual ~GetManualDagInstancesRequest() = default;
};
class GetManualDagInstancesResponseInstances : public Darabonba::Model {
public:
  shared_ptr<long> nodeId{};
  shared_ptr<long> instanceId{};
  shared_ptr<long> dagId{};
  shared_ptr<string> dagType{};
  shared_ptr<string> status{};
  shared_ptr<long> bizDate{};
  shared_ptr<long> cycTime{};
  shared_ptr<long> createTime{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> nodeName{};
  shared_ptr<long> beginWaitTimeTime{};
  shared_ptr<long> beginWaitResTime{};
  shared_ptr<long> beginRunningTime{};
  shared_ptr<string> paramValues{};
  shared_ptr<long> finishTime{};
  shared_ptr<string> taskType{};

  GetManualDagInstancesResponseInstances() {}

  explicit GetManualDagInstancesResponseInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!nodeId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeId is required.")));
    }
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
    if (!dagId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dagId is required.")));
    }
    if (!dagType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dagType is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!bizDate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("bizDate is required.")));
    }
    if (!cycTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("cycTime is required.")));
    }
    if (!createTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("createTime is required.")));
    }
    if (!modifyTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("modifyTime is required.")));
    }
    if (!nodeName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeName is required.")));
    }
    if (!beginWaitTimeTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("beginWaitTimeTime is required.")));
    }
    if (!beginWaitResTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("beginWaitResTime is required.")));
    }
    if (!beginRunningTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("beginRunningTime is required.")));
    }
    if (!paramValues) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("paramValues is required.")));
    }
    if (!finishTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("finishTime is required.")));
    }
    if (!taskType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskType is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (dagType) {
      res["DagType"] = boost::any(*dagType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (bizDate) {
      res["BizDate"] = boost::any(*bizDate);
    }
    if (cycTime) {
      res["CycTime"] = boost::any(*cycTime);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (beginWaitTimeTime) {
      res["BeginWaitTimeTime"] = boost::any(*beginWaitTimeTime);
    }
    if (beginWaitResTime) {
      res["BeginWaitResTime"] = boost::any(*beginWaitResTime);
    }
    if (beginRunningTime) {
      res["BeginRunningTime"] = boost::any(*beginRunningTime);
    }
    if (paramValues) {
      res["ParamValues"] = boost::any(*paramValues);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("DagType") != m.end() && !m["DagType"].empty()) {
      dagType = make_shared<string>(boost::any_cast<string>(m["DagType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("BizDate") != m.end() && !m["BizDate"].empty()) {
      bizDate = make_shared<long>(boost::any_cast<long>(m["BizDate"]));
    }
    if (m.find("CycTime") != m.end() && !m["CycTime"].empty()) {
      cycTime = make_shared<long>(boost::any_cast<long>(m["CycTime"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("BeginWaitTimeTime") != m.end() && !m["BeginWaitTimeTime"].empty()) {
      beginWaitTimeTime = make_shared<long>(boost::any_cast<long>(m["BeginWaitTimeTime"]));
    }
    if (m.find("BeginWaitResTime") != m.end() && !m["BeginWaitResTime"].empty()) {
      beginWaitResTime = make_shared<long>(boost::any_cast<long>(m["BeginWaitResTime"]));
    }
    if (m.find("BeginRunningTime") != m.end() && !m["BeginRunningTime"].empty()) {
      beginRunningTime = make_shared<long>(boost::any_cast<long>(m["BeginRunningTime"]));
    }
    if (m.find("ParamValues") != m.end() && !m["ParamValues"].empty()) {
      paramValues = make_shared<string>(boost::any_cast<string>(m["ParamValues"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<long>(boost::any_cast<long>(m["FinishTime"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
  }


  virtual ~GetManualDagInstancesResponseInstances() = default;
};
class GetManualDagInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetManualDagInstancesResponseInstances>> instances{};

  GetManualDagInstancesResponse() {}

  explicit GetManualDagInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!instances) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instances is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (instances) {
      vector<boost::any> temp1;
      for(auto item1:*instances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Instances"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      if (typeid(vector<boost::any>) == m["Instances"].type()) {
        vector<GetManualDagInstancesResponseInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Instances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetManualDagInstancesResponseInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instances = make_shared<vector<GetManualDagInstancesResponseInstances>>(expect1);
      }
    }
  }


  virtual ~GetManualDagInstancesResponse() = default;
};
class CreateManualDagRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectEnv{};
  shared_ptr<string> projectName{};
  shared_ptr<string> flowName{};
  shared_ptr<string> bizDate{};
  shared_ptr<string> nodeParameters{};
  shared_ptr<string> dagParameters{};
  shared_ptr<string> includeNodeIds{};
  shared_ptr<string> excludeNodeIds{};

  CreateManualDagRequest() {}

  explicit CreateManualDagRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectEnv) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectEnv is required.")));
    }
    if (!projectName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectName is required.")));
    }
    if (!flowName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("flowName is required.")));
    }
    if (!bizDate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("bizDate is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (flowName) {
      res["FlowName"] = boost::any(*flowName);
    }
    if (bizDate) {
      res["BizDate"] = boost::any(*bizDate);
    }
    if (nodeParameters) {
      res["NodeParameters"] = boost::any(*nodeParameters);
    }
    if (dagParameters) {
      res["DagParameters"] = boost::any(*dagParameters);
    }
    if (includeNodeIds) {
      res["IncludeNodeIds"] = boost::any(*includeNodeIds);
    }
    if (excludeNodeIds) {
      res["ExcludeNodeIds"] = boost::any(*excludeNodeIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("FlowName") != m.end() && !m["FlowName"].empty()) {
      flowName = make_shared<string>(boost::any_cast<string>(m["FlowName"]));
    }
    if (m.find("BizDate") != m.end() && !m["BizDate"].empty()) {
      bizDate = make_shared<string>(boost::any_cast<string>(m["BizDate"]));
    }
    if (m.find("NodeParameters") != m.end() && !m["NodeParameters"].empty()) {
      nodeParameters = make_shared<string>(boost::any_cast<string>(m["NodeParameters"]));
    }
    if (m.find("DagParameters") != m.end() && !m["DagParameters"].empty()) {
      dagParameters = make_shared<string>(boost::any_cast<string>(m["DagParameters"]));
    }
    if (m.find("IncludeNodeIds") != m.end() && !m["IncludeNodeIds"].empty()) {
      includeNodeIds = make_shared<string>(boost::any_cast<string>(m["IncludeNodeIds"]));
    }
    if (m.find("ExcludeNodeIds") != m.end() && !m["ExcludeNodeIds"].empty()) {
      excludeNodeIds = make_shared<string>(boost::any_cast<string>(m["ExcludeNodeIds"]));
    }
  }


  virtual ~CreateManualDagRequest() = default;
};
class CreateManualDagResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> dagId{};

  CreateManualDagResponse() {}

  explicit CreateManualDagResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!dagId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dagId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
  }


  virtual ~CreateManualDagResponse() = default;
};
class ListQualityResultsByEntityRequest : public Darabonba::Model {
public:
  shared_ptr<int> entityId{};
  shared_ptr<string> startDate{};
  shared_ptr<string> endDate{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> pageNumber{};
  shared_ptr<string> projectName{};

  ListQualityResultsByEntityRequest() {}

  explicit ListQualityResultsByEntityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!entityId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("entityId is required.")));
    }
    if (!startDate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("startDate is required.")));
    }
    if (!endDate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("endDate is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!pageNumber) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNumber is required.")));
    }
    if (!projectName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entityId) {
      res["EntityId"] = boost::any(*entityId);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EntityId") != m.end() && !m["EntityId"].empty()) {
      entityId = make_shared<int>(boost::any_cast<int>(m["EntityId"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
  }


  virtual ~ListQualityResultsByEntityRequest() = default;
};
class ListQualityResultsByEntityResponseDataRuleChecksReferenceValue : public Darabonba::Model {
public:
  shared_ptr<string> bizDate{};
  shared_ptr<string> discreteProperty{};
  shared_ptr<double> value{};
  shared_ptr<double> threshold{};
  shared_ptr<int> singleCheckResult{};

  ListQualityResultsByEntityResponseDataRuleChecksReferenceValue() {}

  explicit ListQualityResultsByEntityResponseDataRuleChecksReferenceValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!bizDate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("bizDate is required.")));
    }
    if (!discreteProperty) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("discreteProperty is required.")));
    }
    if (!value) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("value is required.")));
    }
    if (!threshold) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("threshold is required.")));
    }
    if (!singleCheckResult) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("singleCheckResult is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizDate) {
      res["BizDate"] = boost::any(*bizDate);
    }
    if (discreteProperty) {
      res["DiscreteProperty"] = boost::any(*discreteProperty);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    if (singleCheckResult) {
      res["SingleCheckResult"] = boost::any(*singleCheckResult);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizDate") != m.end() && !m["BizDate"].empty()) {
      bizDate = make_shared<string>(boost::any_cast<string>(m["BizDate"]));
    }
    if (m.find("DiscreteProperty") != m.end() && !m["DiscreteProperty"].empty()) {
      discreteProperty = make_shared<string>(boost::any_cast<string>(m["DiscreteProperty"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<double>(boost::any_cast<double>(m["Threshold"]));
    }
    if (m.find("SingleCheckResult") != m.end() && !m["SingleCheckResult"].empty()) {
      singleCheckResult = make_shared<int>(boost::any_cast<int>(m["SingleCheckResult"]));
    }
  }


  virtual ~ListQualityResultsByEntityResponseDataRuleChecksReferenceValue() = default;
};
class ListQualityResultsByEntityResponseDataRuleChecksSampleValue : public Darabonba::Model {
public:
  shared_ptr<string> bizDate{};
  shared_ptr<string> discreteProperty{};
  shared_ptr<double> value{};

  ListQualityResultsByEntityResponseDataRuleChecksSampleValue() {}

  explicit ListQualityResultsByEntityResponseDataRuleChecksSampleValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!bizDate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("bizDate is required.")));
    }
    if (!discreteProperty) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("discreteProperty is required.")));
    }
    if (!value) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("value is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizDate) {
      res["BizDate"] = boost::any(*bizDate);
    }
    if (discreteProperty) {
      res["DiscreteProperty"] = boost::any(*discreteProperty);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizDate") != m.end() && !m["BizDate"].empty()) {
      bizDate = make_shared<string>(boost::any_cast<string>(m["BizDate"]));
    }
    if (m.find("DiscreteProperty") != m.end() && !m["DiscreteProperty"].empty()) {
      discreteProperty = make_shared<string>(boost::any_cast<string>(m["DiscreteProperty"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListQualityResultsByEntityResponseDataRuleChecksSampleValue() = default;
};
class ListQualityResultsByEntityResponseDataRuleChecks : public Darabonba::Model {
public:
  shared_ptr<int> id{};
  shared_ptr<string> taskId{};
  shared_ptr<int> entityId{};
  shared_ptr<int> ruleId{};
  shared_ptr<string> property{};
  shared_ptr<long> bizDate{};
  shared_ptr<string> dateType{};
  shared_ptr<string> actualExpression{};
  shared_ptr<string> matchExpression{};
  shared_ptr<int> blockType{};
  shared_ptr<int> checkResult{};
  shared_ptr<int> checkResultStatus{};
  shared_ptr<string> methodName{};
  shared_ptr<string> comment{};
  shared_ptr<string> whereCondition{};
  shared_ptr<long> beginTime{};
  shared_ptr<long> endTime{};
  shared_ptr<string> timeCost{};
  shared_ptr<string> externalType{};
  shared_ptr<string> externalId{};
  shared_ptr<bool> discreteCheck{};
  shared_ptr<bool> fixedCheck{};
  shared_ptr<string> trend{};
  shared_ptr<double> warningThreshold{};
  shared_ptr<double> criticalThreshold{};
  shared_ptr<double> expectValue{};
  shared_ptr<string> op{};
  shared_ptr<string> projectName{};
  shared_ptr<string> tableName{};
  shared_ptr<int> templateId{};
  shared_ptr<string> templateName{};
  shared_ptr<string> resultString{};
  shared_ptr<int> checkerId{};
  shared_ptr<int> checkerType{};
  shared_ptr<string> ruleName{};
  shared_ptr<bool> isPrediction{};
  shared_ptr<double> upperValue{};
  shared_ptr<double> lowerValue{};
  shared_ptr<string> checkerName{};
  shared_ptr<vector<ListQualityResultsByEntityResponseDataRuleChecksReferenceValue>> referenceValue{};
  shared_ptr<vector<ListQualityResultsByEntityResponseDataRuleChecksSampleValue>> sampleValue{};

  ListQualityResultsByEntityResponseDataRuleChecks() {}

  explicit ListQualityResultsByEntityResponseDataRuleChecks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!id) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("id is required.")));
    }
    if (!taskId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskId is required.")));
    }
    if (!entityId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("entityId is required.")));
    }
    if (!ruleId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleId is required.")));
    }
    if (!property) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("property is required.")));
    }
    if (!bizDate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("bizDate is required.")));
    }
    if (!dateType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dateType is required.")));
    }
    if (!actualExpression) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("actualExpression is required.")));
    }
    if (!matchExpression) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("matchExpression is required.")));
    }
    if (!blockType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("blockType is required.")));
    }
    if (!checkResult) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("checkResult is required.")));
    }
    if (!checkResultStatus) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("checkResultStatus is required.")));
    }
    if (!methodName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("methodName is required.")));
    }
    if (!comment) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("comment is required.")));
    }
    if (!whereCondition) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("whereCondition is required.")));
    }
    if (!beginTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("beginTime is required.")));
    }
    if (!endTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("endTime is required.")));
    }
    if (!timeCost) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("timeCost is required.")));
    }
    if (!externalType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("externalType is required.")));
    }
    if (!externalId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("externalId is required.")));
    }
    if (!discreteCheck) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("discreteCheck is required.")));
    }
    if (!fixedCheck) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("fixedCheck is required.")));
    }
    if (!trend) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("trend is required.")));
    }
    if (!warningThreshold) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("warningThreshold is required.")));
    }
    if (!criticalThreshold) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("criticalThreshold is required.")));
    }
    if (!expectValue) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("expectValue is required.")));
    }
    if (!op) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("op is required.")));
    }
    if (!projectName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectName is required.")));
    }
    if (!tableName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tableName is required.")));
    }
    if (!templateId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("templateId is required.")));
    }
    if (!templateName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("templateName is required.")));
    }
    if (!resultString) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("resultString is required.")));
    }
    if (!checkerId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("checkerId is required.")));
    }
    if (!checkerType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("checkerType is required.")));
    }
    if (!ruleName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleName is required.")));
    }
    if (!isPrediction) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("isPrediction is required.")));
    }
    if (!upperValue) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("upperValue is required.")));
    }
    if (!lowerValue) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("lowerValue is required.")));
    }
    if (!checkerName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("checkerName is required.")));
    }
    if (!referenceValue) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("referenceValue is required.")));
    }
    if (!sampleValue) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("sampleValue is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (entityId) {
      res["EntityId"] = boost::any(*entityId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (property) {
      res["Property"] = boost::any(*property);
    }
    if (bizDate) {
      res["BizDate"] = boost::any(*bizDate);
    }
    if (dateType) {
      res["DateType"] = boost::any(*dateType);
    }
    if (actualExpression) {
      res["ActualExpression"] = boost::any(*actualExpression);
    }
    if (matchExpression) {
      res["MatchExpression"] = boost::any(*matchExpression);
    }
    if (blockType) {
      res["BlockType"] = boost::any(*blockType);
    }
    if (checkResult) {
      res["CheckResult"] = boost::any(*checkResult);
    }
    if (checkResultStatus) {
      res["CheckResultStatus"] = boost::any(*checkResultStatus);
    }
    if (methodName) {
      res["MethodName"] = boost::any(*methodName);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (whereCondition) {
      res["WhereCondition"] = boost::any(*whereCondition);
    }
    if (beginTime) {
      res["BeginTime"] = boost::any(*beginTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (timeCost) {
      res["TimeCost"] = boost::any(*timeCost);
    }
    if (externalType) {
      res["ExternalType"] = boost::any(*externalType);
    }
    if (externalId) {
      res["ExternalId"] = boost::any(*externalId);
    }
    if (discreteCheck) {
      res["DiscreteCheck"] = boost::any(*discreteCheck);
    }
    if (fixedCheck) {
      res["FixedCheck"] = boost::any(*fixedCheck);
    }
    if (trend) {
      res["Trend"] = boost::any(*trend);
    }
    if (warningThreshold) {
      res["WarningThreshold"] = boost::any(*warningThreshold);
    }
    if (criticalThreshold) {
      res["CriticalThreshold"] = boost::any(*criticalThreshold);
    }
    if (expectValue) {
      res["ExpectValue"] = boost::any(*expectValue);
    }
    if (op) {
      res["Op"] = boost::any(*op);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (resultString) {
      res["ResultString"] = boost::any(*resultString);
    }
    if (checkerId) {
      res["CheckerId"] = boost::any(*checkerId);
    }
    if (checkerType) {
      res["CheckerType"] = boost::any(*checkerType);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (isPrediction) {
      res["IsPrediction"] = boost::any(*isPrediction);
    }
    if (upperValue) {
      res["UpperValue"] = boost::any(*upperValue);
    }
    if (lowerValue) {
      res["LowerValue"] = boost::any(*lowerValue);
    }
    if (checkerName) {
      res["CheckerName"] = boost::any(*checkerName);
    }
    if (referenceValue) {
      vector<boost::any> temp1;
      for(auto item1:*referenceValue){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ReferenceValue"] = boost::any(temp1);
    }
    if (sampleValue) {
      vector<boost::any> temp1;
      for(auto item1:*sampleValue){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SampleValue"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<int>(boost::any_cast<int>(m["Id"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("EntityId") != m.end() && !m["EntityId"].empty()) {
      entityId = make_shared<int>(boost::any_cast<int>(m["EntityId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<int>(boost::any_cast<int>(m["RuleId"]));
    }
    if (m.find("Property") != m.end() && !m["Property"].empty()) {
      property = make_shared<string>(boost::any_cast<string>(m["Property"]));
    }
    if (m.find("BizDate") != m.end() && !m["BizDate"].empty()) {
      bizDate = make_shared<long>(boost::any_cast<long>(m["BizDate"]));
    }
    if (m.find("DateType") != m.end() && !m["DateType"].empty()) {
      dateType = make_shared<string>(boost::any_cast<string>(m["DateType"]));
    }
    if (m.find("ActualExpression") != m.end() && !m["ActualExpression"].empty()) {
      actualExpression = make_shared<string>(boost::any_cast<string>(m["ActualExpression"]));
    }
    if (m.find("MatchExpression") != m.end() && !m["MatchExpression"].empty()) {
      matchExpression = make_shared<string>(boost::any_cast<string>(m["MatchExpression"]));
    }
    if (m.find("BlockType") != m.end() && !m["BlockType"].empty()) {
      blockType = make_shared<int>(boost::any_cast<int>(m["BlockType"]));
    }
    if (m.find("CheckResult") != m.end() && !m["CheckResult"].empty()) {
      checkResult = make_shared<int>(boost::any_cast<int>(m["CheckResult"]));
    }
    if (m.find("CheckResultStatus") != m.end() && !m["CheckResultStatus"].empty()) {
      checkResultStatus = make_shared<int>(boost::any_cast<int>(m["CheckResultStatus"]));
    }
    if (m.find("MethodName") != m.end() && !m["MethodName"].empty()) {
      methodName = make_shared<string>(boost::any_cast<string>(m["MethodName"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("WhereCondition") != m.end() && !m["WhereCondition"].empty()) {
      whereCondition = make_shared<string>(boost::any_cast<string>(m["WhereCondition"]));
    }
    if (m.find("BeginTime") != m.end() && !m["BeginTime"].empty()) {
      beginTime = make_shared<long>(boost::any_cast<long>(m["BeginTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("TimeCost") != m.end() && !m["TimeCost"].empty()) {
      timeCost = make_shared<string>(boost::any_cast<string>(m["TimeCost"]));
    }
    if (m.find("ExternalType") != m.end() && !m["ExternalType"].empty()) {
      externalType = make_shared<string>(boost::any_cast<string>(m["ExternalType"]));
    }
    if (m.find("ExternalId") != m.end() && !m["ExternalId"].empty()) {
      externalId = make_shared<string>(boost::any_cast<string>(m["ExternalId"]));
    }
    if (m.find("DiscreteCheck") != m.end() && !m["DiscreteCheck"].empty()) {
      discreteCheck = make_shared<bool>(boost::any_cast<bool>(m["DiscreteCheck"]));
    }
    if (m.find("FixedCheck") != m.end() && !m["FixedCheck"].empty()) {
      fixedCheck = make_shared<bool>(boost::any_cast<bool>(m["FixedCheck"]));
    }
    if (m.find("Trend") != m.end() && !m["Trend"].empty()) {
      trend = make_shared<string>(boost::any_cast<string>(m["Trend"]));
    }
    if (m.find("WarningThreshold") != m.end() && !m["WarningThreshold"].empty()) {
      warningThreshold = make_shared<double>(boost::any_cast<double>(m["WarningThreshold"]));
    }
    if (m.find("CriticalThreshold") != m.end() && !m["CriticalThreshold"].empty()) {
      criticalThreshold = make_shared<double>(boost::any_cast<double>(m["CriticalThreshold"]));
    }
    if (m.find("ExpectValue") != m.end() && !m["ExpectValue"].empty()) {
      expectValue = make_shared<double>(boost::any_cast<double>(m["ExpectValue"]));
    }
    if (m.find("Op") != m.end() && !m["Op"].empty()) {
      op = make_shared<string>(boost::any_cast<string>(m["Op"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<int>(boost::any_cast<int>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("ResultString") != m.end() && !m["ResultString"].empty()) {
      resultString = make_shared<string>(boost::any_cast<string>(m["ResultString"]));
    }
    if (m.find("CheckerId") != m.end() && !m["CheckerId"].empty()) {
      checkerId = make_shared<int>(boost::any_cast<int>(m["CheckerId"]));
    }
    if (m.find("CheckerType") != m.end() && !m["CheckerType"].empty()) {
      checkerType = make_shared<int>(boost::any_cast<int>(m["CheckerType"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("IsPrediction") != m.end() && !m["IsPrediction"].empty()) {
      isPrediction = make_shared<bool>(boost::any_cast<bool>(m["IsPrediction"]));
    }
    if (m.find("UpperValue") != m.end() && !m["UpperValue"].empty()) {
      upperValue = make_shared<double>(boost::any_cast<double>(m["UpperValue"]));
    }
    if (m.find("LowerValue") != m.end() && !m["LowerValue"].empty()) {
      lowerValue = make_shared<double>(boost::any_cast<double>(m["LowerValue"]));
    }
    if (m.find("CheckerName") != m.end() && !m["CheckerName"].empty()) {
      checkerName = make_shared<string>(boost::any_cast<string>(m["CheckerName"]));
    }
    if (m.find("ReferenceValue") != m.end() && !m["ReferenceValue"].empty()) {
      if (typeid(vector<boost::any>) == m["ReferenceValue"].type()) {
        vector<ListQualityResultsByEntityResponseDataRuleChecksReferenceValue> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ReferenceValue"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListQualityResultsByEntityResponseDataRuleChecksReferenceValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        referenceValue = make_shared<vector<ListQualityResultsByEntityResponseDataRuleChecksReferenceValue>>(expect1);
      }
    }
    if (m.find("SampleValue") != m.end() && !m["SampleValue"].empty()) {
      if (typeid(vector<boost::any>) == m["SampleValue"].type()) {
        vector<ListQualityResultsByEntityResponseDataRuleChecksSampleValue> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SampleValue"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListQualityResultsByEntityResponseDataRuleChecksSampleValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sampleValue = make_shared<vector<ListQualityResultsByEntityResponseDataRuleChecksSampleValue>>(expect1);
      }
    }
  }


  virtual ~ListQualityResultsByEntityResponseDataRuleChecks() = default;
};
class ListQualityResultsByEntityResponseData : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<vector<ListQualityResultsByEntityResponseDataRuleChecks>> ruleChecks{};

  ListQualityResultsByEntityResponseData() {}

  explicit ListQualityResultsByEntityResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!totalCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("totalCount is required.")));
    }
    if (!pageNumber) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNumber is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!ruleChecks) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleChecks is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (ruleChecks) {
      vector<boost::any> temp1;
      for(auto item1:*ruleChecks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuleChecks"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("RuleChecks") != m.end() && !m["RuleChecks"].empty()) {
      if (typeid(vector<boost::any>) == m["RuleChecks"].type()) {
        vector<ListQualityResultsByEntityResponseDataRuleChecks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuleChecks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListQualityResultsByEntityResponseDataRuleChecks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleChecks = make_shared<vector<ListQualityResultsByEntityResponseDataRuleChecks>>(expect1);
      }
    }
  }


  virtual ~ListQualityResultsByEntityResponseData() = default;
};
class ListQualityResultsByEntityResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};
  shared_ptr<ListQualityResultsByEntityResponseData> data{};

  ListQualityResultsByEntityResponse() {}

  explicit ListQualityResultsByEntityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListQualityResultsByEntityResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListQualityResultsByEntityResponseData>(model1);
      }
    }
  }


  virtual ~ListQualityResultsByEntityResponse() = default;
};
class GetNodeTypeListInfoRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<string> keyword{};
  shared_ptr<string> locale{};

  GetNodeTypeListInfoRequest() {}

  explicit GetNodeTypeListInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageNumber) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNumber is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (locale) {
      res["Locale"] = boost::any(*locale);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("Locale") != m.end() && !m["Locale"].empty()) {
      locale = make_shared<string>(boost::any_cast<string>(m["Locale"]));
    }
  }


  virtual ~GetNodeTypeListInfoRequest() = default;
};
class GetNodeTypeListInfoResponseNodeTypeInfoListNodeTypeInfo : public Darabonba::Model {
public:
  shared_ptr<int> nodeType{};
  shared_ptr<string> nodeTypeName{};

  GetNodeTypeListInfoResponseNodeTypeInfoListNodeTypeInfo() {}

  explicit GetNodeTypeListInfoResponseNodeTypeInfoListNodeTypeInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!nodeType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeType is required.")));
    }
    if (!nodeTypeName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeTypeName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    if (nodeTypeName) {
      res["NodeTypeName"] = boost::any(*nodeTypeName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<int>(boost::any_cast<int>(m["NodeType"]));
    }
    if (m.find("NodeTypeName") != m.end() && !m["NodeTypeName"].empty()) {
      nodeTypeName = make_shared<string>(boost::any_cast<string>(m["NodeTypeName"]));
    }
  }


  virtual ~GetNodeTypeListInfoResponseNodeTypeInfoListNodeTypeInfo() = default;
};
class GetNodeTypeListInfoResponseNodeTypeInfoList : public Darabonba::Model {
public:
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> totalCount{};
  shared_ptr<vector<GetNodeTypeListInfoResponseNodeTypeInfoListNodeTypeInfo>> nodeTypeInfo{};

  GetNodeTypeListInfoResponseNodeTypeInfoList() {}

  explicit GetNodeTypeListInfoResponseNodeTypeInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageNumber) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNumber is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!totalCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("totalCount is required.")));
    }
    if (!nodeTypeInfo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeTypeInfo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (nodeTypeInfo) {
      vector<boost::any> temp1;
      for(auto item1:*nodeTypeInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NodeTypeInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<int>(boost::any_cast<int>(m["TotalCount"]));
    }
    if (m.find("NodeTypeInfo") != m.end() && !m["NodeTypeInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["NodeTypeInfo"].type()) {
        vector<GetNodeTypeListInfoResponseNodeTypeInfoListNodeTypeInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NodeTypeInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetNodeTypeListInfoResponseNodeTypeInfoListNodeTypeInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodeTypeInfo = make_shared<vector<GetNodeTypeListInfoResponseNodeTypeInfoListNodeTypeInfo>>(expect1);
      }
    }
  }


  virtual ~GetNodeTypeListInfoResponseNodeTypeInfoList() = default;
};
class GetNodeTypeListInfoResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetNodeTypeListInfoResponseNodeTypeInfoList> nodeTypeInfoList{};

  GetNodeTypeListInfoResponse() {}

  explicit GetNodeTypeListInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!nodeTypeInfoList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeTypeInfoList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (nodeTypeInfoList) {
      res["NodeTypeInfoList"] = nodeTypeInfoList ? boost::any(nodeTypeInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("NodeTypeInfoList") != m.end() && !m["NodeTypeInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["NodeTypeInfoList"].type()) {
        GetNodeTypeListInfoResponseNodeTypeInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NodeTypeInfoList"]));
        nodeTypeInfoList = make_shared<GetNodeTypeListInfoResponseNodeTypeInfoList>(model1);
      }
    }
  }


  virtual ~GetNodeTypeListInfoResponse() = default;
};
class GetInstanceStatusCountRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> projectEnv{};
  shared_ptr<string> bizDate{};

  GetInstanceStatusCountRequest() {}

  explicit GetInstanceStatusCountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!projectEnv) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectEnv is required.")));
    }
    if (!bizDate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("bizDate is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (bizDate) {
      res["BizDate"] = boost::any(*bizDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("BizDate") != m.end() && !m["BizDate"].empty()) {
      bizDate = make_shared<string>(boost::any_cast<string>(m["BizDate"]));
    }
  }


  virtual ~GetInstanceStatusCountRequest() = default;
};
class GetInstanceStatusCountResponseStatusCount : public Darabonba::Model {
public:
  shared_ptr<int> totalCount{};
  shared_ptr<int> notRunCount{};
  shared_ptr<int> waitTimeCount{};
  shared_ptr<int> waitResCount{};
  shared_ptr<int> runningCount{};
  shared_ptr<int> failureCount{};
  shared_ptr<int> successCount{};

  GetInstanceStatusCountResponseStatusCount() {}

  explicit GetInstanceStatusCountResponseStatusCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!totalCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("totalCount is required.")));
    }
    if (!notRunCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("notRunCount is required.")));
    }
    if (!waitTimeCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("waitTimeCount is required.")));
    }
    if (!waitResCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("waitResCount is required.")));
    }
    if (!runningCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("runningCount is required.")));
    }
    if (!failureCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("failureCount is required.")));
    }
    if (!successCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("successCount is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (notRunCount) {
      res["NotRunCount"] = boost::any(*notRunCount);
    }
    if (waitTimeCount) {
      res["WaitTimeCount"] = boost::any(*waitTimeCount);
    }
    if (waitResCount) {
      res["WaitResCount"] = boost::any(*waitResCount);
    }
    if (runningCount) {
      res["RunningCount"] = boost::any(*runningCount);
    }
    if (failureCount) {
      res["FailureCount"] = boost::any(*failureCount);
    }
    if (successCount) {
      res["SuccessCount"] = boost::any(*successCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<int>(boost::any_cast<int>(m["TotalCount"]));
    }
    if (m.find("NotRunCount") != m.end() && !m["NotRunCount"].empty()) {
      notRunCount = make_shared<int>(boost::any_cast<int>(m["NotRunCount"]));
    }
    if (m.find("WaitTimeCount") != m.end() && !m["WaitTimeCount"].empty()) {
      waitTimeCount = make_shared<int>(boost::any_cast<int>(m["WaitTimeCount"]));
    }
    if (m.find("WaitResCount") != m.end() && !m["WaitResCount"].empty()) {
      waitResCount = make_shared<int>(boost::any_cast<int>(m["WaitResCount"]));
    }
    if (m.find("RunningCount") != m.end() && !m["RunningCount"].empty()) {
      runningCount = make_shared<int>(boost::any_cast<int>(m["RunningCount"]));
    }
    if (m.find("FailureCount") != m.end() && !m["FailureCount"].empty()) {
      failureCount = make_shared<int>(boost::any_cast<int>(m["FailureCount"]));
    }
    if (m.find("SuccessCount") != m.end() && !m["SuccessCount"].empty()) {
      successCount = make_shared<int>(boost::any_cast<int>(m["SuccessCount"]));
    }
  }


  virtual ~GetInstanceStatusCountResponseStatusCount() = default;
};
class GetInstanceStatusCountResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetInstanceStatusCountResponseStatusCount> statusCount{};

  GetInstanceStatusCountResponse() {}

  explicit GetInstanceStatusCountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!statusCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCount is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (statusCount) {
      res["StatusCount"] = statusCount ? boost::any(statusCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StatusCount") != m.end() && !m["StatusCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["StatusCount"].type()) {
        GetInstanceStatusCountResponseStatusCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StatusCount"]));
        statusCount = make_shared<GetInstanceStatusCountResponseStatusCount>(model1);
      }
    }
  }


  virtual ~GetInstanceStatusCountResponse() = default;
};
class ListDataServiceFoldersRequest : public Darabonba::Model {
public:
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<long> tenantId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> folderNameKeyword{};

  ListDataServiceFoldersRequest() {}

  explicit ListDataServiceFoldersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!tenantId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tenantId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (folderNameKeyword) {
      res["FolderNameKeyword"] = boost::any(*folderNameKeyword);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("FolderNameKeyword") != m.end() && !m["FolderNameKeyword"].empty()) {
      folderNameKeyword = make_shared<string>(boost::any_cast<string>(m["FolderNameKeyword"]));
    }
  }


  virtual ~ListDataServiceFoldersRequest() = default;
};
class ListDataServiceFoldersResponseFolderPagingResultFolders : public Darabonba::Model {
public:
  shared_ptr<long> folderId{};
  shared_ptr<string> folderName{};
  shared_ptr<long> projectId{};
  shared_ptr<long> tenantId{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> groupId{};
  shared_ptr<long> parentId{};

  ListDataServiceFoldersResponseFolderPagingResultFolders() {}

  explicit ListDataServiceFoldersResponseFolderPagingResultFolders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!folderId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("folderId is required.")));
    }
    if (!folderName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("folderName is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!tenantId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tenantId is required.")));
    }
    if (!createdTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("createdTime is required.")));
    }
    if (!modifiedTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("modifiedTime is required.")));
    }
    if (!groupId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupId is required.")));
    }
    if (!parentId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parentId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (folderId) {
      res["FolderId"] = boost::any(*folderId);
    }
    if (folderName) {
      res["FolderName"] = boost::any(*folderName);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FolderId") != m.end() && !m["FolderId"].empty()) {
      folderId = make_shared<long>(boost::any_cast<long>(m["FolderId"]));
    }
    if (m.find("FolderName") != m.end() && !m["FolderName"].empty()) {
      folderName = make_shared<string>(boost::any_cast<string>(m["FolderName"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
  }


  virtual ~ListDataServiceFoldersResponseFolderPagingResultFolders() = default;
};
class ListDataServiceFoldersResponseFolderPagingResult : public Darabonba::Model {
public:
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> totalCount{};
  shared_ptr<vector<ListDataServiceFoldersResponseFolderPagingResultFolders>> folders{};

  ListDataServiceFoldersResponseFolderPagingResult() {}

  explicit ListDataServiceFoldersResponseFolderPagingResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageNumber) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNumber is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!totalCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("totalCount is required.")));
    }
    if (!folders) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("folders is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (folders) {
      vector<boost::any> temp1;
      for(auto item1:*folders){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Folders"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<int>(boost::any_cast<int>(m["TotalCount"]));
    }
    if (m.find("Folders") != m.end() && !m["Folders"].empty()) {
      if (typeid(vector<boost::any>) == m["Folders"].type()) {
        vector<ListDataServiceFoldersResponseFolderPagingResultFolders> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Folders"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataServiceFoldersResponseFolderPagingResultFolders model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        folders = make_shared<vector<ListDataServiceFoldersResponseFolderPagingResultFolders>>(expect1);
      }
    }
  }


  virtual ~ListDataServiceFoldersResponseFolderPagingResult() = default;
};
class ListDataServiceFoldersResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListDataServiceFoldersResponseFolderPagingResult> folderPagingResult{};

  ListDataServiceFoldersResponse() {}

  explicit ListDataServiceFoldersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!folderPagingResult) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("folderPagingResult is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (folderPagingResult) {
      res["FolderPagingResult"] = folderPagingResult ? boost::any(folderPagingResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("FolderPagingResult") != m.end() && !m["FolderPagingResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["FolderPagingResult"].type()) {
        ListDataServiceFoldersResponseFolderPagingResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FolderPagingResult"]));
        folderPagingResult = make_shared<ListDataServiceFoldersResponseFolderPagingResult>(model1);
      }
    }
  }


  virtual ~ListDataServiceFoldersResponse() = default;
};
class ListQualityResultsByRuleRequest : public Darabonba::Model {
public:
  shared_ptr<int> ruleId{};
  shared_ptr<string> startDate{};
  shared_ptr<string> endDate{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> pageNumber{};
  shared_ptr<string> projectName{};

  ListQualityResultsByRuleRequest() {}

  explicit ListQualityResultsByRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!ruleId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleId is required.")));
    }
    if (!startDate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("startDate is required.")));
    }
    if (!endDate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("endDate is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!pageNumber) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNumber is required.")));
    }
    if (!projectName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<int>(boost::any_cast<int>(m["RuleId"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
  }


  virtual ~ListQualityResultsByRuleRequest() = default;
};
class ListQualityResultsByRuleResponseDataRuleChecksReferenceValue : public Darabonba::Model {
public:
  shared_ptr<string> bizDate{};
  shared_ptr<string> discreteProperty{};
  shared_ptr<double> value{};
  shared_ptr<double> threshold{};
  shared_ptr<int> singleCheckResult{};

  ListQualityResultsByRuleResponseDataRuleChecksReferenceValue() {}

  explicit ListQualityResultsByRuleResponseDataRuleChecksReferenceValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!bizDate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("bizDate is required.")));
    }
    if (!discreteProperty) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("discreteProperty is required.")));
    }
    if (!value) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("value is required.")));
    }
    if (!threshold) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("threshold is required.")));
    }
    if (!singleCheckResult) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("singleCheckResult is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizDate) {
      res["BizDate"] = boost::any(*bizDate);
    }
    if (discreteProperty) {
      res["DiscreteProperty"] = boost::any(*discreteProperty);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    if (singleCheckResult) {
      res["SingleCheckResult"] = boost::any(*singleCheckResult);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizDate") != m.end() && !m["BizDate"].empty()) {
      bizDate = make_shared<string>(boost::any_cast<string>(m["BizDate"]));
    }
    if (m.find("DiscreteProperty") != m.end() && !m["DiscreteProperty"].empty()) {
      discreteProperty = make_shared<string>(boost::any_cast<string>(m["DiscreteProperty"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<double>(boost::any_cast<double>(m["Threshold"]));
    }
    if (m.find("SingleCheckResult") != m.end() && !m["SingleCheckResult"].empty()) {
      singleCheckResult = make_shared<int>(boost::any_cast<int>(m["SingleCheckResult"]));
    }
  }


  virtual ~ListQualityResultsByRuleResponseDataRuleChecksReferenceValue() = default;
};
class ListQualityResultsByRuleResponseDataRuleChecksSampleValue : public Darabonba::Model {
public:
  shared_ptr<string> bizDate{};
  shared_ptr<string> discreteProperty{};
  shared_ptr<double> value{};

  ListQualityResultsByRuleResponseDataRuleChecksSampleValue() {}

  explicit ListQualityResultsByRuleResponseDataRuleChecksSampleValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!bizDate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("bizDate is required.")));
    }
    if (!discreteProperty) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("discreteProperty is required.")));
    }
    if (!value) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("value is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizDate) {
      res["BizDate"] = boost::any(*bizDate);
    }
    if (discreteProperty) {
      res["DiscreteProperty"] = boost::any(*discreteProperty);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizDate") != m.end() && !m["BizDate"].empty()) {
      bizDate = make_shared<string>(boost::any_cast<string>(m["BizDate"]));
    }
    if (m.find("DiscreteProperty") != m.end() && !m["DiscreteProperty"].empty()) {
      discreteProperty = make_shared<string>(boost::any_cast<string>(m["DiscreteProperty"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListQualityResultsByRuleResponseDataRuleChecksSampleValue() = default;
};
class ListQualityResultsByRuleResponseDataRuleChecks : public Darabonba::Model {
public:
  shared_ptr<int> id{};
  shared_ptr<string> taskId{};
  shared_ptr<int> entityId{};
  shared_ptr<int> ruleId{};
  shared_ptr<string> property{};
  shared_ptr<long> bizDate{};
  shared_ptr<string> dateType{};
  shared_ptr<string> actualExpression{};
  shared_ptr<string> matchExpression{};
  shared_ptr<int> blockType{};
  shared_ptr<int> checkResult{};
  shared_ptr<int> checkResultStatus{};
  shared_ptr<string> methodName{};
  shared_ptr<string> comment{};
  shared_ptr<string> whereCondition{};
  shared_ptr<long> beginTime{};
  shared_ptr<long> endTime{};
  shared_ptr<string> timeCost{};
  shared_ptr<string> externalType{};
  shared_ptr<string> externalId{};
  shared_ptr<bool> discreteCheck{};
  shared_ptr<bool> fixedCheck{};
  shared_ptr<string> trend{};
  shared_ptr<double> warningThreshold{};
  shared_ptr<double> criticalThreshold{};
  shared_ptr<double> expectValue{};
  shared_ptr<string> op{};
  shared_ptr<string> projectName{};
  shared_ptr<string> tableName{};
  shared_ptr<int> templateId{};
  shared_ptr<string> templateName{};
  shared_ptr<string> resultString{};
  shared_ptr<int> checkerId{};
  shared_ptr<int> checkerType{};
  shared_ptr<string> ruleName{};
  shared_ptr<bool> isPrediction{};
  shared_ptr<double> upperValue{};
  shared_ptr<double> lowerValue{};
  shared_ptr<string> checkerName{};
  shared_ptr<vector<ListQualityResultsByRuleResponseDataRuleChecksReferenceValue>> referenceValue{};
  shared_ptr<vector<ListQualityResultsByRuleResponseDataRuleChecksSampleValue>> sampleValue{};

  ListQualityResultsByRuleResponseDataRuleChecks() {}

  explicit ListQualityResultsByRuleResponseDataRuleChecks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!id) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("id is required.")));
    }
    if (!taskId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskId is required.")));
    }
    if (!entityId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("entityId is required.")));
    }
    if (!ruleId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleId is required.")));
    }
    if (!property) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("property is required.")));
    }
    if (!bizDate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("bizDate is required.")));
    }
    if (!dateType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dateType is required.")));
    }
    if (!actualExpression) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("actualExpression is required.")));
    }
    if (!matchExpression) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("matchExpression is required.")));
    }
    if (!blockType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("blockType is required.")));
    }
    if (!checkResult) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("checkResult is required.")));
    }
    if (!checkResultStatus) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("checkResultStatus is required.")));
    }
    if (!methodName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("methodName is required.")));
    }
    if (!comment) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("comment is required.")));
    }
    if (!whereCondition) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("whereCondition is required.")));
    }
    if (!beginTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("beginTime is required.")));
    }
    if (!endTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("endTime is required.")));
    }
    if (!timeCost) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("timeCost is required.")));
    }
    if (!externalType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("externalType is required.")));
    }
    if (!externalId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("externalId is required.")));
    }
    if (!discreteCheck) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("discreteCheck is required.")));
    }
    if (!fixedCheck) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("fixedCheck is required.")));
    }
    if (!trend) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("trend is required.")));
    }
    if (!warningThreshold) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("warningThreshold is required.")));
    }
    if (!criticalThreshold) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("criticalThreshold is required.")));
    }
    if (!expectValue) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("expectValue is required.")));
    }
    if (!op) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("op is required.")));
    }
    if (!projectName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectName is required.")));
    }
    if (!tableName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tableName is required.")));
    }
    if (!templateId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("templateId is required.")));
    }
    if (!templateName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("templateName is required.")));
    }
    if (!resultString) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("resultString is required.")));
    }
    if (!checkerId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("checkerId is required.")));
    }
    if (!checkerType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("checkerType is required.")));
    }
    if (!ruleName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleName is required.")));
    }
    if (!isPrediction) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("isPrediction is required.")));
    }
    if (!upperValue) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("upperValue is required.")));
    }
    if (!lowerValue) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("lowerValue is required.")));
    }
    if (!checkerName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("checkerName is required.")));
    }
    if (!referenceValue) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("referenceValue is required.")));
    }
    if (!sampleValue) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("sampleValue is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (entityId) {
      res["EntityId"] = boost::any(*entityId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (property) {
      res["Property"] = boost::any(*property);
    }
    if (bizDate) {
      res["BizDate"] = boost::any(*bizDate);
    }
    if (dateType) {
      res["DateType"] = boost::any(*dateType);
    }
    if (actualExpression) {
      res["ActualExpression"] = boost::any(*actualExpression);
    }
    if (matchExpression) {
      res["MatchExpression"] = boost::any(*matchExpression);
    }
    if (blockType) {
      res["BlockType"] = boost::any(*blockType);
    }
    if (checkResult) {
      res["CheckResult"] = boost::any(*checkResult);
    }
    if (checkResultStatus) {
      res["CheckResultStatus"] = boost::any(*checkResultStatus);
    }
    if (methodName) {
      res["MethodName"] = boost::any(*methodName);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (whereCondition) {
      res["WhereCondition"] = boost::any(*whereCondition);
    }
    if (beginTime) {
      res["BeginTime"] = boost::any(*beginTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (timeCost) {
      res["TimeCost"] = boost::any(*timeCost);
    }
    if (externalType) {
      res["ExternalType"] = boost::any(*externalType);
    }
    if (externalId) {
      res["ExternalId"] = boost::any(*externalId);
    }
    if (discreteCheck) {
      res["DiscreteCheck"] = boost::any(*discreteCheck);
    }
    if (fixedCheck) {
      res["FixedCheck"] = boost::any(*fixedCheck);
    }
    if (trend) {
      res["Trend"] = boost::any(*trend);
    }
    if (warningThreshold) {
      res["WarningThreshold"] = boost::any(*warningThreshold);
    }
    if (criticalThreshold) {
      res["CriticalThreshold"] = boost::any(*criticalThreshold);
    }
    if (expectValue) {
      res["ExpectValue"] = boost::any(*expectValue);
    }
    if (op) {
      res["Op"] = boost::any(*op);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (resultString) {
      res["ResultString"] = boost::any(*resultString);
    }
    if (checkerId) {
      res["CheckerId"] = boost::any(*checkerId);
    }
    if (checkerType) {
      res["CheckerType"] = boost::any(*checkerType);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (isPrediction) {
      res["IsPrediction"] = boost::any(*isPrediction);
    }
    if (upperValue) {
      res["UpperValue"] = boost::any(*upperValue);
    }
    if (lowerValue) {
      res["LowerValue"] = boost::any(*lowerValue);
    }
    if (checkerName) {
      res["CheckerName"] = boost::any(*checkerName);
    }
    if (referenceValue) {
      vector<boost::any> temp1;
      for(auto item1:*referenceValue){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ReferenceValue"] = boost::any(temp1);
    }
    if (sampleValue) {
      vector<boost::any> temp1;
      for(auto item1:*sampleValue){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SampleValue"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<int>(boost::any_cast<int>(m["Id"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("EntityId") != m.end() && !m["EntityId"].empty()) {
      entityId = make_shared<int>(boost::any_cast<int>(m["EntityId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<int>(boost::any_cast<int>(m["RuleId"]));
    }
    if (m.find("Property") != m.end() && !m["Property"].empty()) {
      property = make_shared<string>(boost::any_cast<string>(m["Property"]));
    }
    if (m.find("BizDate") != m.end() && !m["BizDate"].empty()) {
      bizDate = make_shared<long>(boost::any_cast<long>(m["BizDate"]));
    }
    if (m.find("DateType") != m.end() && !m["DateType"].empty()) {
      dateType = make_shared<string>(boost::any_cast<string>(m["DateType"]));
    }
    if (m.find("ActualExpression") != m.end() && !m["ActualExpression"].empty()) {
      actualExpression = make_shared<string>(boost::any_cast<string>(m["ActualExpression"]));
    }
    if (m.find("MatchExpression") != m.end() && !m["MatchExpression"].empty()) {
      matchExpression = make_shared<string>(boost::any_cast<string>(m["MatchExpression"]));
    }
    if (m.find("BlockType") != m.end() && !m["BlockType"].empty()) {
      blockType = make_shared<int>(boost::any_cast<int>(m["BlockType"]));
    }
    if (m.find("CheckResult") != m.end() && !m["CheckResult"].empty()) {
      checkResult = make_shared<int>(boost::any_cast<int>(m["CheckResult"]));
    }
    if (m.find("CheckResultStatus") != m.end() && !m["CheckResultStatus"].empty()) {
      checkResultStatus = make_shared<int>(boost::any_cast<int>(m["CheckResultStatus"]));
    }
    if (m.find("MethodName") != m.end() && !m["MethodName"].empty()) {
      methodName = make_shared<string>(boost::any_cast<string>(m["MethodName"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("WhereCondition") != m.end() && !m["WhereCondition"].empty()) {
      whereCondition = make_shared<string>(boost::any_cast<string>(m["WhereCondition"]));
    }
    if (m.find("BeginTime") != m.end() && !m["BeginTime"].empty()) {
      beginTime = make_shared<long>(boost::any_cast<long>(m["BeginTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("TimeCost") != m.end() && !m["TimeCost"].empty()) {
      timeCost = make_shared<string>(boost::any_cast<string>(m["TimeCost"]));
    }
    if (m.find("ExternalType") != m.end() && !m["ExternalType"].empty()) {
      externalType = make_shared<string>(boost::any_cast<string>(m["ExternalType"]));
    }
    if (m.find("ExternalId") != m.end() && !m["ExternalId"].empty()) {
      externalId = make_shared<string>(boost::any_cast<string>(m["ExternalId"]));
    }
    if (m.find("DiscreteCheck") != m.end() && !m["DiscreteCheck"].empty()) {
      discreteCheck = make_shared<bool>(boost::any_cast<bool>(m["DiscreteCheck"]));
    }
    if (m.find("FixedCheck") != m.end() && !m["FixedCheck"].empty()) {
      fixedCheck = make_shared<bool>(boost::any_cast<bool>(m["FixedCheck"]));
    }
    if (m.find("Trend") != m.end() && !m["Trend"].empty()) {
      trend = make_shared<string>(boost::any_cast<string>(m["Trend"]));
    }
    if (m.find("WarningThreshold") != m.end() && !m["WarningThreshold"].empty()) {
      warningThreshold = make_shared<double>(boost::any_cast<double>(m["WarningThreshold"]));
    }
    if (m.find("CriticalThreshold") != m.end() && !m["CriticalThreshold"].empty()) {
      criticalThreshold = make_shared<double>(boost::any_cast<double>(m["CriticalThreshold"]));
    }
    if (m.find("ExpectValue") != m.end() && !m["ExpectValue"].empty()) {
      expectValue = make_shared<double>(boost::any_cast<double>(m["ExpectValue"]));
    }
    if (m.find("Op") != m.end() && !m["Op"].empty()) {
      op = make_shared<string>(boost::any_cast<string>(m["Op"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<int>(boost::any_cast<int>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("ResultString") != m.end() && !m["ResultString"].empty()) {
      resultString = make_shared<string>(boost::any_cast<string>(m["ResultString"]));
    }
    if (m.find("CheckerId") != m.end() && !m["CheckerId"].empty()) {
      checkerId = make_shared<int>(boost::any_cast<int>(m["CheckerId"]));
    }
    if (m.find("CheckerType") != m.end() && !m["CheckerType"].empty()) {
      checkerType = make_shared<int>(boost::any_cast<int>(m["CheckerType"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("IsPrediction") != m.end() && !m["IsPrediction"].empty()) {
      isPrediction = make_shared<bool>(boost::any_cast<bool>(m["IsPrediction"]));
    }
    if (m.find("UpperValue") != m.end() && !m["UpperValue"].empty()) {
      upperValue = make_shared<double>(boost::any_cast<double>(m["UpperValue"]));
    }
    if (m.find("LowerValue") != m.end() && !m["LowerValue"].empty()) {
      lowerValue = make_shared<double>(boost::any_cast<double>(m["LowerValue"]));
    }
    if (m.find("CheckerName") != m.end() && !m["CheckerName"].empty()) {
      checkerName = make_shared<string>(boost::any_cast<string>(m["CheckerName"]));
    }
    if (m.find("ReferenceValue") != m.end() && !m["ReferenceValue"].empty()) {
      if (typeid(vector<boost::any>) == m["ReferenceValue"].type()) {
        vector<ListQualityResultsByRuleResponseDataRuleChecksReferenceValue> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ReferenceValue"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListQualityResultsByRuleResponseDataRuleChecksReferenceValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        referenceValue = make_shared<vector<ListQualityResultsByRuleResponseDataRuleChecksReferenceValue>>(expect1);
      }
    }
    if (m.find("SampleValue") != m.end() && !m["SampleValue"].empty()) {
      if (typeid(vector<boost::any>) == m["SampleValue"].type()) {
        vector<ListQualityResultsByRuleResponseDataRuleChecksSampleValue> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SampleValue"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListQualityResultsByRuleResponseDataRuleChecksSampleValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sampleValue = make_shared<vector<ListQualityResultsByRuleResponseDataRuleChecksSampleValue>>(expect1);
      }
    }
  }


  virtual ~ListQualityResultsByRuleResponseDataRuleChecks() = default;
};
class ListQualityResultsByRuleResponseData : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<vector<ListQualityResultsByRuleResponseDataRuleChecks>> ruleChecks{};

  ListQualityResultsByRuleResponseData() {}

  explicit ListQualityResultsByRuleResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!totalCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("totalCount is required.")));
    }
    if (!pageNumber) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNumber is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!ruleChecks) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleChecks is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (ruleChecks) {
      vector<boost::any> temp1;
      for(auto item1:*ruleChecks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuleChecks"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("RuleChecks") != m.end() && !m["RuleChecks"].empty()) {
      if (typeid(vector<boost::any>) == m["RuleChecks"].type()) {
        vector<ListQualityResultsByRuleResponseDataRuleChecks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuleChecks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListQualityResultsByRuleResponseDataRuleChecks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleChecks = make_shared<vector<ListQualityResultsByRuleResponseDataRuleChecks>>(expect1);
      }
    }
  }


  virtual ~ListQualityResultsByRuleResponseData() = default;
};
class ListQualityResultsByRuleResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<ListQualityResultsByRuleResponseData> data{};

  ListQualityResultsByRuleResponse() {}

  explicit ListQualityResultsByRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListQualityResultsByRuleResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListQualityResultsByRuleResponseData>(model1);
      }
    }
  }


  virtual ~ListQualityResultsByRuleResponse() = default;
};
class ListMetaDBRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> dataSourceType{};
  shared_ptr<int> pageNum{};
  shared_ptr<int> pageSize{};

  ListMetaDBRequest() {}

  explicit ListMetaDBRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!dataSourceType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dataSourceType is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (dataSourceType) {
      res["DataSourceType"] = boost::any(*dataSourceType);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("DataSourceType") != m.end() && !m["DataSourceType"].empty()) {
      dataSourceType = make_shared<string>(boost::any_cast<string>(m["DataSourceType"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<int>(boost::any_cast<int>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
  }


  virtual ~ListMetaDBRequest() = default;
};
class ListMetaDBResponseDatabaseInfoDbList : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> location{};
  shared_ptr<long> createTimeStamp{};
  shared_ptr<long> modifiedTimeStamp{};
  shared_ptr<string> UUID{};

  ListMetaDBResponseDatabaseInfoDbList() {}

  explicit ListMetaDBResponseDatabaseInfoDbList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!name) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("name is required.")));
    }
    if (!type) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("type is required.")));
    }
    if (!ownerId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ownerId is required.")));
    }
    if (!location) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("location is required.")));
    }
    if (!createTimeStamp) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("createTimeStamp is required.")));
    }
    if (!modifiedTimeStamp) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("modifiedTimeStamp is required.")));
    }
    if (!UUID) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("UUID is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (createTimeStamp) {
      res["CreateTimeStamp"] = boost::any(*createTimeStamp);
    }
    if (modifiedTimeStamp) {
      res["ModifiedTimeStamp"] = boost::any(*modifiedTimeStamp);
    }
    if (UUID) {
      res["UUID"] = boost::any(*UUID);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("CreateTimeStamp") != m.end() && !m["CreateTimeStamp"].empty()) {
      createTimeStamp = make_shared<long>(boost::any_cast<long>(m["CreateTimeStamp"]));
    }
    if (m.find("ModifiedTimeStamp") != m.end() && !m["ModifiedTimeStamp"].empty()) {
      modifiedTimeStamp = make_shared<long>(boost::any_cast<long>(m["ModifiedTimeStamp"]));
    }
    if (m.find("UUID") != m.end() && !m["UUID"].empty()) {
      UUID = make_shared<string>(boost::any_cast<string>(m["UUID"]));
    }
  }


  virtual ~ListMetaDBResponseDatabaseInfoDbList() = default;
};
class ListMetaDBResponseDatabaseInfo : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListMetaDBResponseDatabaseInfoDbList>> dbList{};

  ListMetaDBResponseDatabaseInfo() {}

  explicit ListMetaDBResponseDatabaseInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!totalCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("totalCount is required.")));
    }
    if (!dbList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dbList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (dbList) {
      vector<boost::any> temp1;
      for(auto item1:*dbList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DbList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("DbList") != m.end() && !m["DbList"].empty()) {
      if (typeid(vector<boost::any>) == m["DbList"].type()) {
        vector<ListMetaDBResponseDatabaseInfoDbList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DbList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMetaDBResponseDatabaseInfoDbList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dbList = make_shared<vector<ListMetaDBResponseDatabaseInfoDbList>>(expect1);
      }
    }
  }


  virtual ~ListMetaDBResponseDatabaseInfo() = default;
};
class ListMetaDBResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListMetaDBResponseDatabaseInfo> databaseInfo{};

  ListMetaDBResponse() {}

  explicit ListMetaDBResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!databaseInfo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("databaseInfo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (databaseInfo) {
      res["DatabaseInfo"] = databaseInfo ? boost::any(databaseInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DatabaseInfo") != m.end() && !m["DatabaseInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["DatabaseInfo"].type()) {
        ListMetaDBResponseDatabaseInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DatabaseInfo"]));
        databaseInfo = make_shared<ListMetaDBResponseDatabaseInfo>(model1);
      }
    }
  }


  virtual ~ListMetaDBResponse() = default;
};
class CreateTableRequestColumns : public Darabonba::Model {
public:
  shared_ptr<string> columnName{};
  shared_ptr<string> columnNameCn{};
  shared_ptr<string> columnType{};
  shared_ptr<int> seqNumber{};
  shared_ptr<int> length{};
  shared_ptr<bool> isPartitionCol{};
  shared_ptr<string> comment{};

  CreateTableRequestColumns() {}

  explicit CreateTableRequestColumns(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!columnName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("columnName is required.")));
    }
    if (!columnType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("columnType is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (columnNameCn) {
      res["ColumnNameCn"] = boost::any(*columnNameCn);
    }
    if (columnType) {
      res["ColumnType"] = boost::any(*columnType);
    }
    if (seqNumber) {
      res["SeqNumber"] = boost::any(*seqNumber);
    }
    if (length) {
      res["Length"] = boost::any(*length);
    }
    if (isPartitionCol) {
      res["IsPartitionCol"] = boost::any(*isPartitionCol);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("ColumnNameCn") != m.end() && !m["ColumnNameCn"].empty()) {
      columnNameCn = make_shared<string>(boost::any_cast<string>(m["ColumnNameCn"]));
    }
    if (m.find("ColumnType") != m.end() && !m["ColumnType"].empty()) {
      columnType = make_shared<string>(boost::any_cast<string>(m["ColumnType"]));
    }
    if (m.find("SeqNumber") != m.end() && !m["SeqNumber"].empty()) {
      seqNumber = make_shared<int>(boost::any_cast<int>(m["SeqNumber"]));
    }
    if (m.find("Length") != m.end() && !m["Length"].empty()) {
      length = make_shared<int>(boost::any_cast<int>(m["Length"]));
    }
    if (m.find("IsPartitionCol") != m.end() && !m["IsPartitionCol"].empty()) {
      isPartitionCol = make_shared<bool>(boost::any_cast<bool>(m["IsPartitionCol"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
  }


  virtual ~CreateTableRequestColumns() = default;
};
class CreateTableRequestThemes : public Darabonba::Model {
public:
  shared_ptr<long> themeId{};
  shared_ptr<int> themeLevel{};

  CreateTableRequestThemes() {}

  explicit CreateTableRequestThemes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (themeId) {
      res["ThemeId"] = boost::any(*themeId);
    }
    if (themeLevel) {
      res["ThemeLevel"] = boost::any(*themeLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ThemeId") != m.end() && !m["ThemeId"].empty()) {
      themeId = make_shared<long>(boost::any_cast<long>(m["ThemeId"]));
    }
    if (m.find("ThemeLevel") != m.end() && !m["ThemeLevel"].empty()) {
      themeLevel = make_shared<int>(boost::any_cast<int>(m["ThemeLevel"]));
    }
  }


  virtual ~CreateTableRequestThemes() = default;
};
class CreateTableRequest : public Darabonba::Model {
public:
  shared_ptr<vector<CreateTableRequestColumns>> columns{};
  shared_ptr<int> isView{};
  shared_ptr<int> visibility{};
  shared_ptr<int> lifeCycle{};
  shared_ptr<long> categoryId{};
  shared_ptr<long> logicalLevelId{};
  shared_ptr<long> physicsLevelId{};
  shared_ptr<string> externalTableType{};
  shared_ptr<string> location{};
  shared_ptr<long> projectId{};
  shared_ptr<string> tableName{};
  shared_ptr<string> endpoint{};
  shared_ptr<int> envType{};
  shared_ptr<vector<CreateTableRequestThemes>> themes{};
  shared_ptr<string> appGuid{};
  shared_ptr<string> comment{};
  shared_ptr<string> ownerId{};
  shared_ptr<int> hasPart{};
  shared_ptr<string> clientToken{};

  CreateTableRequest() {}

  explicit CreateTableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!columns) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("columns is required.")));
    }
    if (!tableName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tableName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columns) {
      vector<boost::any> temp1;
      for(auto item1:*columns){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Columns"] = boost::any(temp1);
    }
    if (isView) {
      res["IsView"] = boost::any(*isView);
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    if (lifeCycle) {
      res["LifeCycle"] = boost::any(*lifeCycle);
    }
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (logicalLevelId) {
      res["LogicalLevelId"] = boost::any(*logicalLevelId);
    }
    if (physicsLevelId) {
      res["PhysicsLevelId"] = boost::any(*physicsLevelId);
    }
    if (externalTableType) {
      res["ExternalTableType"] = boost::any(*externalTableType);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (themes) {
      vector<boost::any> temp1;
      for(auto item1:*themes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Themes"] = boost::any(temp1);
    }
    if (appGuid) {
      res["AppGuid"] = boost::any(*appGuid);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (hasPart) {
      res["HasPart"] = boost::any(*hasPart);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Columns") != m.end() && !m["Columns"].empty()) {
      if (typeid(vector<boost::any>) == m["Columns"].type()) {
        vector<CreateTableRequestColumns> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Columns"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateTableRequestColumns model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        columns = make_shared<vector<CreateTableRequestColumns>>(expect1);
      }
    }
    if (m.find("IsView") != m.end() && !m["IsView"].empty()) {
      isView = make_shared<int>(boost::any_cast<int>(m["IsView"]));
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<int>(boost::any_cast<int>(m["Visibility"]));
    }
    if (m.find("LifeCycle") != m.end() && !m["LifeCycle"].empty()) {
      lifeCycle = make_shared<int>(boost::any_cast<int>(m["LifeCycle"]));
    }
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<long>(boost::any_cast<long>(m["CategoryId"]));
    }
    if (m.find("LogicalLevelId") != m.end() && !m["LogicalLevelId"].empty()) {
      logicalLevelId = make_shared<long>(boost::any_cast<long>(m["LogicalLevelId"]));
    }
    if (m.find("PhysicsLevelId") != m.end() && !m["PhysicsLevelId"].empty()) {
      physicsLevelId = make_shared<long>(boost::any_cast<long>(m["PhysicsLevelId"]));
    }
    if (m.find("ExternalTableType") != m.end() && !m["ExternalTableType"].empty()) {
      externalTableType = make_shared<string>(boost::any_cast<string>(m["ExternalTableType"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<int>(boost::any_cast<int>(m["EnvType"]));
    }
    if (m.find("Themes") != m.end() && !m["Themes"].empty()) {
      if (typeid(vector<boost::any>) == m["Themes"].type()) {
        vector<CreateTableRequestThemes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Themes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateTableRequestThemes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        themes = make_shared<vector<CreateTableRequestThemes>>(expect1);
      }
    }
    if (m.find("AppGuid") != m.end() && !m["AppGuid"].empty()) {
      appGuid = make_shared<string>(boost::any_cast<string>(m["AppGuid"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("HasPart") != m.end() && !m["HasPart"].empty()) {
      hasPart = make_shared<int>(boost::any_cast<int>(m["HasPart"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
  }


  virtual ~CreateTableRequest() = default;
};
class CreateTableResponseTaskInfo : public Darabonba::Model {
public:
  shared_ptr<string> taskId{};
  shared_ptr<string> content{};
  shared_ptr<string> status{};
  shared_ptr<string> nextTaskId{};

  CreateTableResponseTaskInfo() {}

  explicit CreateTableResponseTaskInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!taskId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskId is required.")));
    }
    if (!content) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("content is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!nextTaskId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nextTaskId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (nextTaskId) {
      res["NextTaskId"] = boost::any(*nextTaskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("NextTaskId") != m.end() && !m["NextTaskId"].empty()) {
      nextTaskId = make_shared<string>(boost::any_cast<string>(m["NextTaskId"]));
    }
  }


  virtual ~CreateTableResponseTaskInfo() = default;
};
class CreateTableResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<CreateTableResponseTaskInfo> taskInfo{};

  CreateTableResponse() {}

  explicit CreateTableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!taskInfo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskInfo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskInfo) {
      res["TaskInfo"] = taskInfo ? boost::any(taskInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskInfo") != m.end() && !m["TaskInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["TaskInfo"].type()) {
        CreateTableResponseTaskInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TaskInfo"]));
        taskInfo = make_shared<CreateTableResponseTaskInfo>(model1);
      }
    }
  }


  virtual ~CreateTableResponse() = default;
};
class CreateTableThemeRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<int> level{};
  shared_ptr<string> name{};
  shared_ptr<long> parentId{};

  CreateTableThemeRequest() {}

  explicit CreateTableThemeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!level) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("level is required.")));
    }
    if (!name) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("name is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<int>(boost::any_cast<int>(m["Level"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
  }


  virtual ~CreateTableThemeRequest() = default;
};
class CreateTableThemeResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<bool> success{};
  shared_ptr<long> themeId{};

  CreateTableThemeResponse() {}

  explicit CreateTableThemeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!themeId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("themeId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (themeId) {
      res["ThemeId"] = boost::any(*themeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ThemeId") != m.end() && !m["ThemeId"].empty()) {
      themeId = make_shared<long>(boost::any_cast<long>(m["ThemeId"]));
    }
  }


  virtual ~CreateTableThemeResponse() = default;
};
class GetInstanceErrorRankRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};

  GetInstanceErrorRankRequest() {}

  explicit GetInstanceErrorRankRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~GetInstanceErrorRankRequest() = default;
};
class GetInstanceErrorRankResponseInstanceErrorRankErrorRank : public Darabonba::Model {
public:
  shared_ptr<long> nodeId{};
  shared_ptr<string> nodeName{};
  shared_ptr<string> owner{};
  shared_ptr<int> count{};
  shared_ptr<long> projectId{};
  shared_ptr<int> prgType{};

  GetInstanceErrorRankResponseInstanceErrorRankErrorRank() {}

  explicit GetInstanceErrorRankResponseInstanceErrorRankErrorRank(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!nodeId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeId is required.")));
    }
    if (!nodeName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeName is required.")));
    }
    if (!owner) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("owner is required.")));
    }
    if (!count) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("count is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!prgType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("prgType is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (prgType) {
      res["PrgType"] = boost::any(*prgType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<int>(boost::any_cast<int>(m["Count"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("PrgType") != m.end() && !m["PrgType"].empty()) {
      prgType = make_shared<int>(boost::any_cast<int>(m["PrgType"]));
    }
  }


  virtual ~GetInstanceErrorRankResponseInstanceErrorRankErrorRank() = default;
};
class GetInstanceErrorRankResponseInstanceErrorRank : public Darabonba::Model {
public:
  shared_ptr<long> updateTime{};
  shared_ptr<vector<GetInstanceErrorRankResponseInstanceErrorRankErrorRank>> errorRank{};

  GetInstanceErrorRankResponseInstanceErrorRank() {}

  explicit GetInstanceErrorRankResponseInstanceErrorRank(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!updateTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("updateTime is required.")));
    }
    if (!errorRank) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorRank is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (errorRank) {
      vector<boost::any> temp1;
      for(auto item1:*errorRank){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ErrorRank"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("ErrorRank") != m.end() && !m["ErrorRank"].empty()) {
      if (typeid(vector<boost::any>) == m["ErrorRank"].type()) {
        vector<GetInstanceErrorRankResponseInstanceErrorRankErrorRank> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ErrorRank"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetInstanceErrorRankResponseInstanceErrorRankErrorRank model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        errorRank = make_shared<vector<GetInstanceErrorRankResponseInstanceErrorRankErrorRank>>(expect1);
      }
    }
  }


  virtual ~GetInstanceErrorRankResponseInstanceErrorRank() = default;
};
class GetInstanceErrorRankResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetInstanceErrorRankResponseInstanceErrorRank> instanceErrorRank{};

  GetInstanceErrorRankResponse() {}

  explicit GetInstanceErrorRankResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!instanceErrorRank) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceErrorRank is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (instanceErrorRank) {
      res["InstanceErrorRank"] = instanceErrorRank ? boost::any(instanceErrorRank->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("InstanceErrorRank") != m.end() && !m["InstanceErrorRank"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceErrorRank"].type()) {
        GetInstanceErrorRankResponseInstanceErrorRank model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceErrorRank"]));
        instanceErrorRank = make_shared<GetInstanceErrorRankResponseInstanceErrorRank>(model1);
      }
    }
  }


  virtual ~GetInstanceErrorRankResponse() = default;
};
class GetDDLJobStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> taskId{};

  GetDDLJobStatusRequest() {}

  explicit GetDDLJobStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!taskId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~GetDDLJobStatusRequest() = default;
};
class GetDDLJobStatusResponseData : public Darabonba::Model {
public:
  shared_ptr<string> nextTaskId{};
  shared_ptr<string> content{};
  shared_ptr<string> status{};
  shared_ptr<string> taskId{};

  GetDDLJobStatusResponseData() {}

  explicit GetDDLJobStatusResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!nextTaskId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nextTaskId is required.")));
    }
    if (!content) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("content is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!taskId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextTaskId) {
      res["NextTaskId"] = boost::any(*nextTaskId);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextTaskId") != m.end() && !m["NextTaskId"].empty()) {
      nextTaskId = make_shared<string>(boost::any_cast<string>(m["NextTaskId"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~GetDDLJobStatusResponseData() = default;
};
class GetDDLJobStatusResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetDDLJobStatusResponseData> data{};

  GetDDLJobStatusResponse() {}

  explicit GetDDLJobStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetDDLJobStatusResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetDDLJobStatusResponseData>(model1);
      }
    }
  }


  virtual ~GetDDLJobStatusResponse() = default;
};
class GetInstanceConsumeTimeRankRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> bizdate{};

  GetInstanceConsumeTimeRankRequest() {}

  explicit GetInstanceConsumeTimeRankRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!bizdate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("bizdate is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (bizdate) {
      res["Bizdate"] = boost::any(*bizdate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Bizdate") != m.end() && !m["Bizdate"].empty()) {
      bizdate = make_shared<string>(boost::any_cast<string>(m["Bizdate"]));
    }
  }


  virtual ~GetInstanceConsumeTimeRankRequest() = default;
};
class GetInstanceConsumeTimeRankResponseInstanceConsumeTimeRankConsumeTimeRank : public Darabonba::Model {
public:
  shared_ptr<string> nodeName{};
  shared_ptr<long> nodeId{};
  shared_ptr<long> bizdate{};
  shared_ptr<string> owner{};
  shared_ptr<long> consumed{};
  shared_ptr<long> instanceId{};
  shared_ptr<int> prgType{};

  GetInstanceConsumeTimeRankResponseInstanceConsumeTimeRankConsumeTimeRank() {}

  explicit GetInstanceConsumeTimeRankResponseInstanceConsumeTimeRankConsumeTimeRank(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!nodeName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeName is required.")));
    }
    if (!nodeId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeId is required.")));
    }
    if (!bizdate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("bizdate is required.")));
    }
    if (!owner) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("owner is required.")));
    }
    if (!consumed) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("consumed is required.")));
    }
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
    if (!prgType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("prgType is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (bizdate) {
      res["Bizdate"] = boost::any(*bizdate);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (consumed) {
      res["Consumed"] = boost::any(*consumed);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (prgType) {
      res["PrgType"] = boost::any(*prgType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("Bizdate") != m.end() && !m["Bizdate"].empty()) {
      bizdate = make_shared<long>(boost::any_cast<long>(m["Bizdate"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("Consumed") != m.end() && !m["Consumed"].empty()) {
      consumed = make_shared<long>(boost::any_cast<long>(m["Consumed"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("PrgType") != m.end() && !m["PrgType"].empty()) {
      prgType = make_shared<int>(boost::any_cast<int>(m["PrgType"]));
    }
  }


  virtual ~GetInstanceConsumeTimeRankResponseInstanceConsumeTimeRankConsumeTimeRank() = default;
};
class GetInstanceConsumeTimeRankResponseInstanceConsumeTimeRank : public Darabonba::Model {
public:
  shared_ptr<long> updateTime{};
  shared_ptr<vector<GetInstanceConsumeTimeRankResponseInstanceConsumeTimeRankConsumeTimeRank>> consumeTimeRank{};

  GetInstanceConsumeTimeRankResponseInstanceConsumeTimeRank() {}

  explicit GetInstanceConsumeTimeRankResponseInstanceConsumeTimeRank(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!updateTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("updateTime is required.")));
    }
    if (!consumeTimeRank) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("consumeTimeRank is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (consumeTimeRank) {
      vector<boost::any> temp1;
      for(auto item1:*consumeTimeRank){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConsumeTimeRank"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("ConsumeTimeRank") != m.end() && !m["ConsumeTimeRank"].empty()) {
      if (typeid(vector<boost::any>) == m["ConsumeTimeRank"].type()) {
        vector<GetInstanceConsumeTimeRankResponseInstanceConsumeTimeRankConsumeTimeRank> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConsumeTimeRank"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetInstanceConsumeTimeRankResponseInstanceConsumeTimeRankConsumeTimeRank model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        consumeTimeRank = make_shared<vector<GetInstanceConsumeTimeRankResponseInstanceConsumeTimeRankConsumeTimeRank>>(expect1);
      }
    }
  }


  virtual ~GetInstanceConsumeTimeRankResponseInstanceConsumeTimeRank() = default;
};
class GetInstanceConsumeTimeRankResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetInstanceConsumeTimeRankResponseInstanceConsumeTimeRank> instanceConsumeTimeRank{};

  GetInstanceConsumeTimeRankResponse() {}

  explicit GetInstanceConsumeTimeRankResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!instanceConsumeTimeRank) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceConsumeTimeRank is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (instanceConsumeTimeRank) {
      res["InstanceConsumeTimeRank"] = instanceConsumeTimeRank ? boost::any(instanceConsumeTimeRank->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("InstanceConsumeTimeRank") != m.end() && !m["InstanceConsumeTimeRank"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceConsumeTimeRank"].type()) {
        GetInstanceConsumeTimeRankResponseInstanceConsumeTimeRank model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceConsumeTimeRank"]));
        instanceConsumeTimeRank = make_shared<GetInstanceConsumeTimeRankResponseInstanceConsumeTimeRank>(model1);
      }
    }
  }


  virtual ~GetInstanceConsumeTimeRankResponse() = default;
};
class CreateDataServiceApiAuthorityRequest : public Darabonba::Model {
public:
  shared_ptr<long> tenantId{};
  shared_ptr<long> projectId{};
  shared_ptr<long> apiId{};
  shared_ptr<long> authorizedProjectId{};
  shared_ptr<long> endTime{};

  CreateDataServiceApiAuthorityRequest() {}

  explicit CreateDataServiceApiAuthorityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!tenantId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tenantId is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!apiId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("apiId is required.")));
    }
    if (!authorizedProjectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("authorizedProjectId is required.")));
    }
    if (!endTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("endTime is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (authorizedProjectId) {
      res["AuthorizedProjectId"] = boost::any(*authorizedProjectId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<long>(boost::any_cast<long>(m["ApiId"]));
    }
    if (m.find("AuthorizedProjectId") != m.end() && !m["AuthorizedProjectId"].empty()) {
      authorizedProjectId = make_shared<long>(boost::any_cast<long>(m["AuthorizedProjectId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
  }


  virtual ~CreateDataServiceApiAuthorityRequest() = default;
};
class CreateDataServiceApiAuthorityResponse : public Darabonba::Model {
public:
  shared_ptr<bool> success{};
  shared_ptr<string> requestId{};

  CreateDataServiceApiAuthorityResponse() {}

  explicit CreateDataServiceApiAuthorityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDataServiceApiAuthorityResponse() = default;
};
class DeleteDataServiceApiAuthorityRequest : public Darabonba::Model {
public:
  shared_ptr<long> tenantId{};
  shared_ptr<long> projectId{};
  shared_ptr<long> apiId{};
  shared_ptr<long> authorizedProjectId{};

  DeleteDataServiceApiAuthorityRequest() {}

  explicit DeleteDataServiceApiAuthorityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!tenantId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tenantId is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!apiId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("apiId is required.")));
    }
    if (!authorizedProjectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("authorizedProjectId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (authorizedProjectId) {
      res["AuthorizedProjectId"] = boost::any(*authorizedProjectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<long>(boost::any_cast<long>(m["ApiId"]));
    }
    if (m.find("AuthorizedProjectId") != m.end() && !m["AuthorizedProjectId"].empty()) {
      authorizedProjectId = make_shared<long>(boost::any_cast<long>(m["AuthorizedProjectId"]));
    }
  }


  virtual ~DeleteDataServiceApiAuthorityRequest() = default;
};
class DeleteDataServiceApiAuthorityResponse : public Darabonba::Model {
public:
  shared_ptr<bool> success{};
  shared_ptr<string> requestId{};

  DeleteDataServiceApiAuthorityResponse() {}

  explicit DeleteDataServiceApiAuthorityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDataServiceApiAuthorityResponse() = default;
};
class CreateDataServiceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> tenantId{};
  shared_ptr<long> projectId{};
  shared_ptr<string> apiGatewayGroupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> description{};

  CreateDataServiceGroupRequest() {}

  explicit CreateDataServiceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!tenantId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tenantId is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!apiGatewayGroupId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("apiGatewayGroupId is required.")));
    }
    if (!groupName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (apiGatewayGroupId) {
      res["ApiGatewayGroupId"] = boost::any(*apiGatewayGroupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ApiGatewayGroupId") != m.end() && !m["ApiGatewayGroupId"].empty()) {
      apiGatewayGroupId = make_shared<string>(boost::any_cast<string>(m["ApiGatewayGroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~CreateDataServiceGroupRequest() = default;
};
class CreateDataServiceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> requestId{};

  CreateDataServiceGroupResponse() {}

  explicit CreateDataServiceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!groupId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupId is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDataServiceGroupResponse() = default;
};
class UpdateMetaTableRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> tableName{};
  shared_ptr<int> envType{};
  shared_ptr<string> tableGuid{};
  shared_ptr<string> newOwnerId{};
  shared_ptr<string> addedLabels{};
  shared_ptr<string> removedLabels{};
  shared_ptr<long> categoryId{};
  shared_ptr<int> visibility{};
  shared_ptr<string> caption{};

  UpdateMetaTableRequest() {}

  explicit UpdateMetaTableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (newOwnerId) {
      res["NewOwnerId"] = boost::any(*newOwnerId);
    }
    if (addedLabels) {
      res["AddedLabels"] = boost::any(*addedLabels);
    }
    if (removedLabels) {
      res["RemovedLabels"] = boost::any(*removedLabels);
    }
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    if (caption) {
      res["Caption"] = boost::any(*caption);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<int>(boost::any_cast<int>(m["EnvType"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("NewOwnerId") != m.end() && !m["NewOwnerId"].empty()) {
      newOwnerId = make_shared<string>(boost::any_cast<string>(m["NewOwnerId"]));
    }
    if (m.find("AddedLabels") != m.end() && !m["AddedLabels"].empty()) {
      addedLabels = make_shared<string>(boost::any_cast<string>(m["AddedLabels"]));
    }
    if (m.find("RemovedLabels") != m.end() && !m["RemovedLabels"].empty()) {
      removedLabels = make_shared<string>(boost::any_cast<string>(m["RemovedLabels"]));
    }
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<long>(boost::any_cast<long>(m["CategoryId"]));
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<int>(boost::any_cast<int>(m["Visibility"]));
    }
    if (m.find("Caption") != m.end() && !m["Caption"].empty()) {
      caption = make_shared<string>(boost::any_cast<string>(m["Caption"]));
    }
  }


  virtual ~UpdateMetaTableRequest() = default;
};
class UpdateMetaTableResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> updateResult{};

  UpdateMetaTableResponse() {}

  explicit UpdateMetaTableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!updateResult) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("updateResult is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (updateResult) {
      res["UpdateResult"] = boost::any(*updateResult);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UpdateResult") != m.end() && !m["UpdateResult"].empty()) {
      updateResult = make_shared<bool>(boost::any_cast<bool>(m["UpdateResult"]));
    }
  }


  virtual ~UpdateMetaTableResponse() = default;
};
class GetInstanceCountTrendRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> beginDate{};
  shared_ptr<string> endDate{};

  GetInstanceCountTrendRequest() {}

  explicit GetInstanceCountTrendRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!beginDate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("beginDate is required.")));
    }
    if (!endDate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("endDate is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (beginDate) {
      res["BeginDate"] = boost::any(*beginDate);
    }
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("BeginDate") != m.end() && !m["BeginDate"].empty()) {
      beginDate = make_shared<string>(boost::any_cast<string>(m["BeginDate"]));
    }
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
  }


  virtual ~GetInstanceCountTrendRequest() = default;
};
class GetInstanceCountTrendResponseInstanceCounts : public Darabonba::Model {
public:
  shared_ptr<long> date{};
  shared_ptr<int> count{};

  GetInstanceCountTrendResponseInstanceCounts() {}

  explicit GetInstanceCountTrendResponseInstanceCounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!date) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("date is required.")));
    }
    if (!count) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("count is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (date) {
      res["Date"] = boost::any(*date);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Date") != m.end() && !m["Date"].empty()) {
      date = make_shared<long>(boost::any_cast<long>(m["Date"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<int>(boost::any_cast<int>(m["Count"]));
    }
  }


  virtual ~GetInstanceCountTrendResponseInstanceCounts() = default;
};
class GetInstanceCountTrendResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetInstanceCountTrendResponseInstanceCounts>> instanceCounts{};

  GetInstanceCountTrendResponse() {}

  explicit GetInstanceCountTrendResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!instanceCounts) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceCounts is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (instanceCounts) {
      vector<boost::any> temp1;
      for(auto item1:*instanceCounts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceCounts"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("InstanceCounts") != m.end() && !m["InstanceCounts"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceCounts"].type()) {
        vector<GetInstanceCountTrendResponseInstanceCounts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceCounts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetInstanceCountTrendResponseInstanceCounts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceCounts = make_shared<vector<GetInstanceCountTrendResponseInstanceCounts>>(expect1);
      }
    }
  }


  virtual ~GetInstanceCountTrendResponse() = default;
};
class DeleteTableRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> tableName{};
  shared_ptr<int> envType{};
  shared_ptr<string> appGuid{};

  DeleteTableRequest() {}

  explicit DeleteTableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!tableName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tableName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (appGuid) {
      res["AppGuid"] = boost::any(*appGuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<int>(boost::any_cast<int>(m["EnvType"]));
    }
    if (m.find("AppGuid") != m.end() && !m["AppGuid"].empty()) {
      appGuid = make_shared<string>(boost::any_cast<string>(m["AppGuid"]));
    }
  }


  virtual ~DeleteTableRequest() = default;
};
class DeleteTableResponseTaskInfo : public Darabonba::Model {
public:
  shared_ptr<string> taskId{};
  shared_ptr<string> content{};
  shared_ptr<string> status{};
  shared_ptr<string> nextTaskId{};

  DeleteTableResponseTaskInfo() {}

  explicit DeleteTableResponseTaskInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!taskId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskId is required.")));
    }
    if (!content) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("content is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!nextTaskId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nextTaskId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (nextTaskId) {
      res["NextTaskId"] = boost::any(*nextTaskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("NextTaskId") != m.end() && !m["NextTaskId"].empty()) {
      nextTaskId = make_shared<string>(boost::any_cast<string>(m["NextTaskId"]));
    }
  }


  virtual ~DeleteTableResponseTaskInfo() = default;
};
class DeleteTableResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DeleteTableResponseTaskInfo> taskInfo{};

  DeleteTableResponse() {}

  explicit DeleteTableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!taskInfo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskInfo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskInfo) {
      res["TaskInfo"] = taskInfo ? boost::any(taskInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskInfo") != m.end() && !m["TaskInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["TaskInfo"].type()) {
        DeleteTableResponseTaskInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TaskInfo"]));
        taskInfo = make_shared<DeleteTableResponseTaskInfo>(model1);
      }
    }
  }


  virtual ~DeleteTableResponse() = default;
};
class ListTableThemeRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<long> parentId{};
  shared_ptr<int> pageNum{};
  shared_ptr<int> pageSize{};

  ListTableThemeRequest() {}

  explicit ListTableThemeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<int>(boost::any_cast<int>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
  }


  virtual ~ListTableThemeRequest() = default;
};
class ListTableThemeResponseDataThemeList : public Darabonba::Model {
public:
  shared_ptr<long> themeId{};
  shared_ptr<string> name{};
  shared_ptr<int> level{};
  shared_ptr<long> parentId{};
  shared_ptr<long> projectId{};
  shared_ptr<string> creator{};
  shared_ptr<long> createTimeStamp{};

  ListTableThemeResponseDataThemeList() {}

  explicit ListTableThemeResponseDataThemeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!themeId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("themeId is required.")));
    }
    if (!name) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("name is required.")));
    }
    if (!level) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("level is required.")));
    }
    if (!parentId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parentId is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!creator) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("creator is required.")));
    }
    if (!createTimeStamp) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("createTimeStamp is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (themeId) {
      res["ThemeId"] = boost::any(*themeId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (createTimeStamp) {
      res["CreateTimeStamp"] = boost::any(*createTimeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ThemeId") != m.end() && !m["ThemeId"].empty()) {
      themeId = make_shared<long>(boost::any_cast<long>(m["ThemeId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<int>(boost::any_cast<int>(m["Level"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("CreateTimeStamp") != m.end() && !m["CreateTimeStamp"].empty()) {
      createTimeStamp = make_shared<long>(boost::any_cast<long>(m["CreateTimeStamp"]));
    }
  }


  virtual ~ListTableThemeResponseDataThemeList() = default;
};
class ListTableThemeResponseData : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListTableThemeResponseDataThemeList>> themeList{};

  ListTableThemeResponseData() {}

  explicit ListTableThemeResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!totalCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("totalCount is required.")));
    }
    if (!themeList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("themeList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (themeList) {
      vector<boost::any> temp1;
      for(auto item1:*themeList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ThemeList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("ThemeList") != m.end() && !m["ThemeList"].empty()) {
      if (typeid(vector<boost::any>) == m["ThemeList"].type()) {
        vector<ListTableThemeResponseDataThemeList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ThemeList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTableThemeResponseDataThemeList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        themeList = make_shared<vector<ListTableThemeResponseDataThemeList>>(expect1);
      }
    }
  }


  virtual ~ListTableThemeResponseData() = default;
};
class ListTableThemeResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<bool> success{};
  shared_ptr<ListTableThemeResponseData> data{};

  ListTableThemeResponse() {}

  explicit ListTableThemeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListTableThemeResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListTableThemeResponseData>(model1);
      }
    }
  }


  virtual ~ListTableThemeResponse() = default;
};
class GetSuccessInstanceTrendRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};

  GetSuccessInstanceTrendRequest() {}

  explicit GetSuccessInstanceTrendRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~GetSuccessInstanceTrendRequest() = default;
};
class GetSuccessInstanceTrendResponseInstanceStatusTrendTodayTrend : public Darabonba::Model {
public:
  shared_ptr<int> count{};
  shared_ptr<string> timePoint{};

  GetSuccessInstanceTrendResponseInstanceStatusTrendTodayTrend() {}

  explicit GetSuccessInstanceTrendResponseInstanceStatusTrendTodayTrend(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!count) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("count is required.")));
    }
    if (!timePoint) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("timePoint is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (timePoint) {
      res["TimePoint"] = boost::any(*timePoint);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<int>(boost::any_cast<int>(m["Count"]));
    }
    if (m.find("TimePoint") != m.end() && !m["TimePoint"].empty()) {
      timePoint = make_shared<string>(boost::any_cast<string>(m["TimePoint"]));
    }
  }


  virtual ~GetSuccessInstanceTrendResponseInstanceStatusTrendTodayTrend() = default;
};
class GetSuccessInstanceTrendResponseInstanceStatusTrendYesterdayTrend : public Darabonba::Model {
public:
  shared_ptr<int> count{};
  shared_ptr<string> timePoint{};

  GetSuccessInstanceTrendResponseInstanceStatusTrendYesterdayTrend() {}

  explicit GetSuccessInstanceTrendResponseInstanceStatusTrendYesterdayTrend(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!count) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("count is required.")));
    }
    if (!timePoint) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("timePoint is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (timePoint) {
      res["TimePoint"] = boost::any(*timePoint);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<int>(boost::any_cast<int>(m["Count"]));
    }
    if (m.find("TimePoint") != m.end() && !m["TimePoint"].empty()) {
      timePoint = make_shared<string>(boost::any_cast<string>(m["TimePoint"]));
    }
  }


  virtual ~GetSuccessInstanceTrendResponseInstanceStatusTrendYesterdayTrend() = default;
};
class GetSuccessInstanceTrendResponseInstanceStatusTrendAvgTrend : public Darabonba::Model {
public:
  shared_ptr<int> count{};
  shared_ptr<string> timePoint{};

  GetSuccessInstanceTrendResponseInstanceStatusTrendAvgTrend() {}

  explicit GetSuccessInstanceTrendResponseInstanceStatusTrendAvgTrend(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!count) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("count is required.")));
    }
    if (!timePoint) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("timePoint is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (timePoint) {
      res["TimePoint"] = boost::any(*timePoint);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<int>(boost::any_cast<int>(m["Count"]));
    }
    if (m.find("TimePoint") != m.end() && !m["TimePoint"].empty()) {
      timePoint = make_shared<string>(boost::any_cast<string>(m["TimePoint"]));
    }
  }


  virtual ~GetSuccessInstanceTrendResponseInstanceStatusTrendAvgTrend() = default;
};
class GetSuccessInstanceTrendResponseInstanceStatusTrend : public Darabonba::Model {
public:
  shared_ptr<vector<GetSuccessInstanceTrendResponseInstanceStatusTrendTodayTrend>> todayTrend{};
  shared_ptr<vector<GetSuccessInstanceTrendResponseInstanceStatusTrendYesterdayTrend>> yesterdayTrend{};
  shared_ptr<vector<GetSuccessInstanceTrendResponseInstanceStatusTrendAvgTrend>> avgTrend{};

  GetSuccessInstanceTrendResponseInstanceStatusTrend() {}

  explicit GetSuccessInstanceTrendResponseInstanceStatusTrend(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!todayTrend) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("todayTrend is required.")));
    }
    if (!yesterdayTrend) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("yesterdayTrend is required.")));
    }
    if (!avgTrend) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("avgTrend is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (todayTrend) {
      vector<boost::any> temp1;
      for(auto item1:*todayTrend){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TodayTrend"] = boost::any(temp1);
    }
    if (yesterdayTrend) {
      vector<boost::any> temp1;
      for(auto item1:*yesterdayTrend){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["YesterdayTrend"] = boost::any(temp1);
    }
    if (avgTrend) {
      vector<boost::any> temp1;
      for(auto item1:*avgTrend){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AvgTrend"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TodayTrend") != m.end() && !m["TodayTrend"].empty()) {
      if (typeid(vector<boost::any>) == m["TodayTrend"].type()) {
        vector<GetSuccessInstanceTrendResponseInstanceStatusTrendTodayTrend> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TodayTrend"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetSuccessInstanceTrendResponseInstanceStatusTrendTodayTrend model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        todayTrend = make_shared<vector<GetSuccessInstanceTrendResponseInstanceStatusTrendTodayTrend>>(expect1);
      }
    }
    if (m.find("YesterdayTrend") != m.end() && !m["YesterdayTrend"].empty()) {
      if (typeid(vector<boost::any>) == m["YesterdayTrend"].type()) {
        vector<GetSuccessInstanceTrendResponseInstanceStatusTrendYesterdayTrend> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["YesterdayTrend"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetSuccessInstanceTrendResponseInstanceStatusTrendYesterdayTrend model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        yesterdayTrend = make_shared<vector<GetSuccessInstanceTrendResponseInstanceStatusTrendYesterdayTrend>>(expect1);
      }
    }
    if (m.find("AvgTrend") != m.end() && !m["AvgTrend"].empty()) {
      if (typeid(vector<boost::any>) == m["AvgTrend"].type()) {
        vector<GetSuccessInstanceTrendResponseInstanceStatusTrendAvgTrend> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AvgTrend"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetSuccessInstanceTrendResponseInstanceStatusTrendAvgTrend model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        avgTrend = make_shared<vector<GetSuccessInstanceTrendResponseInstanceStatusTrendAvgTrend>>(expect1);
      }
    }
  }


  virtual ~GetSuccessInstanceTrendResponseInstanceStatusTrend() = default;
};
class GetSuccessInstanceTrendResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetSuccessInstanceTrendResponseInstanceStatusTrend> instanceStatusTrend{};

  GetSuccessInstanceTrendResponse() {}

  explicit GetSuccessInstanceTrendResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!instanceStatusTrend) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceStatusTrend is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (instanceStatusTrend) {
      res["InstanceStatusTrend"] = instanceStatusTrend ? boost::any(instanceStatusTrend->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("InstanceStatusTrend") != m.end() && !m["InstanceStatusTrend"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceStatusTrend"].type()) {
        GetSuccessInstanceTrendResponseInstanceStatusTrend model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceStatusTrend"]));
        instanceStatusTrend = make_shared<GetSuccessInstanceTrendResponseInstanceStatusTrend>(model1);
      }
    }
  }


  virtual ~GetSuccessInstanceTrendResponse() = default;
};
class UpdateTableRequestColumns : public Darabonba::Model {
public:
  shared_ptr<string> columnName{};
  shared_ptr<string> columnNameCn{};
  shared_ptr<string> columnType{};
  shared_ptr<int> seqNumber{};
  shared_ptr<int> length{};
  shared_ptr<bool> isPartitionCol{};
  shared_ptr<string> comment{};

  UpdateTableRequestColumns() {}

  explicit UpdateTableRequestColumns(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!columnName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("columnName is required.")));
    }
    if (!columnType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("columnType is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (columnNameCn) {
      res["ColumnNameCn"] = boost::any(*columnNameCn);
    }
    if (columnType) {
      res["ColumnType"] = boost::any(*columnType);
    }
    if (seqNumber) {
      res["SeqNumber"] = boost::any(*seqNumber);
    }
    if (length) {
      res["Length"] = boost::any(*length);
    }
    if (isPartitionCol) {
      res["IsPartitionCol"] = boost::any(*isPartitionCol);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("ColumnNameCn") != m.end() && !m["ColumnNameCn"].empty()) {
      columnNameCn = make_shared<string>(boost::any_cast<string>(m["ColumnNameCn"]));
    }
    if (m.find("ColumnType") != m.end() && !m["ColumnType"].empty()) {
      columnType = make_shared<string>(boost::any_cast<string>(m["ColumnType"]));
    }
    if (m.find("SeqNumber") != m.end() && !m["SeqNumber"].empty()) {
      seqNumber = make_shared<int>(boost::any_cast<int>(m["SeqNumber"]));
    }
    if (m.find("Length") != m.end() && !m["Length"].empty()) {
      length = make_shared<int>(boost::any_cast<int>(m["Length"]));
    }
    if (m.find("IsPartitionCol") != m.end() && !m["IsPartitionCol"].empty()) {
      isPartitionCol = make_shared<bool>(boost::any_cast<bool>(m["IsPartitionCol"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
  }


  virtual ~UpdateTableRequestColumns() = default;
};
class UpdateTableRequestThemes : public Darabonba::Model {
public:
  shared_ptr<long> themeId{};
  shared_ptr<int> themeLevel{};

  UpdateTableRequestThemes() {}

  explicit UpdateTableRequestThemes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (themeId) {
      res["ThemeId"] = boost::any(*themeId);
    }
    if (themeLevel) {
      res["ThemeLevel"] = boost::any(*themeLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ThemeId") != m.end() && !m["ThemeId"].empty()) {
      themeId = make_shared<long>(boost::any_cast<long>(m["ThemeId"]));
    }
    if (m.find("ThemeLevel") != m.end() && !m["ThemeLevel"].empty()) {
      themeLevel = make_shared<int>(boost::any_cast<int>(m["ThemeLevel"]));
    }
  }


  virtual ~UpdateTableRequestThemes() = default;
};
class UpdateTableRequest : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateTableRequestColumns>> columns{};
  shared_ptr<int> isView{};
  shared_ptr<int> visibility{};
  shared_ptr<int> lifeCycle{};
  shared_ptr<long> categoryId{};
  shared_ptr<long> logicalLevelId{};
  shared_ptr<long> physicsLevelId{};
  shared_ptr<string> externalTableType{};
  shared_ptr<string> location{};
  shared_ptr<long> projectId{};
  shared_ptr<string> tableName{};
  shared_ptr<string> endpoint{};
  shared_ptr<int> envType{};
  shared_ptr<vector<UpdateTableRequestThemes>> themes{};
  shared_ptr<string> appGuid{};
  shared_ptr<bool> createIfNotExists{};
  shared_ptr<string> ownerId{};
  shared_ptr<int> hasPart{};
  shared_ptr<string> comment{};

  UpdateTableRequest() {}

  explicit UpdateTableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!tableName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tableName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columns) {
      vector<boost::any> temp1;
      for(auto item1:*columns){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Columns"] = boost::any(temp1);
    }
    if (isView) {
      res["IsView"] = boost::any(*isView);
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    if (lifeCycle) {
      res["LifeCycle"] = boost::any(*lifeCycle);
    }
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (logicalLevelId) {
      res["LogicalLevelId"] = boost::any(*logicalLevelId);
    }
    if (physicsLevelId) {
      res["PhysicsLevelId"] = boost::any(*physicsLevelId);
    }
    if (externalTableType) {
      res["ExternalTableType"] = boost::any(*externalTableType);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (themes) {
      vector<boost::any> temp1;
      for(auto item1:*themes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Themes"] = boost::any(temp1);
    }
    if (appGuid) {
      res["AppGuid"] = boost::any(*appGuid);
    }
    if (createIfNotExists) {
      res["CreateIfNotExists"] = boost::any(*createIfNotExists);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (hasPart) {
      res["HasPart"] = boost::any(*hasPart);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Columns") != m.end() && !m["Columns"].empty()) {
      if (typeid(vector<boost::any>) == m["Columns"].type()) {
        vector<UpdateTableRequestColumns> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Columns"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateTableRequestColumns model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        columns = make_shared<vector<UpdateTableRequestColumns>>(expect1);
      }
    }
    if (m.find("IsView") != m.end() && !m["IsView"].empty()) {
      isView = make_shared<int>(boost::any_cast<int>(m["IsView"]));
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<int>(boost::any_cast<int>(m["Visibility"]));
    }
    if (m.find("LifeCycle") != m.end() && !m["LifeCycle"].empty()) {
      lifeCycle = make_shared<int>(boost::any_cast<int>(m["LifeCycle"]));
    }
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<long>(boost::any_cast<long>(m["CategoryId"]));
    }
    if (m.find("LogicalLevelId") != m.end() && !m["LogicalLevelId"].empty()) {
      logicalLevelId = make_shared<long>(boost::any_cast<long>(m["LogicalLevelId"]));
    }
    if (m.find("PhysicsLevelId") != m.end() && !m["PhysicsLevelId"].empty()) {
      physicsLevelId = make_shared<long>(boost::any_cast<long>(m["PhysicsLevelId"]));
    }
    if (m.find("ExternalTableType") != m.end() && !m["ExternalTableType"].empty()) {
      externalTableType = make_shared<string>(boost::any_cast<string>(m["ExternalTableType"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<int>(boost::any_cast<int>(m["EnvType"]));
    }
    if (m.find("Themes") != m.end() && !m["Themes"].empty()) {
      if (typeid(vector<boost::any>) == m["Themes"].type()) {
        vector<UpdateTableRequestThemes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Themes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateTableRequestThemes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        themes = make_shared<vector<UpdateTableRequestThemes>>(expect1);
      }
    }
    if (m.find("AppGuid") != m.end() && !m["AppGuid"].empty()) {
      appGuid = make_shared<string>(boost::any_cast<string>(m["AppGuid"]));
    }
    if (m.find("CreateIfNotExists") != m.end() && !m["CreateIfNotExists"].empty()) {
      createIfNotExists = make_shared<bool>(boost::any_cast<bool>(m["CreateIfNotExists"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("HasPart") != m.end() && !m["HasPart"].empty()) {
      hasPart = make_shared<int>(boost::any_cast<int>(m["HasPart"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
  }


  virtual ~UpdateTableRequest() = default;
};
class UpdateTableResponseTaskInfo : public Darabonba::Model {
public:
  shared_ptr<string> taskId{};
  shared_ptr<string> content{};
  shared_ptr<string> status{};
  shared_ptr<string> nextTaskId{};

  UpdateTableResponseTaskInfo() {}

  explicit UpdateTableResponseTaskInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!taskId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskId is required.")));
    }
    if (!content) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("content is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!nextTaskId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nextTaskId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (nextTaskId) {
      res["NextTaskId"] = boost::any(*nextTaskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("NextTaskId") != m.end() && !m["NextTaskId"].empty()) {
      nextTaskId = make_shared<string>(boost::any_cast<string>(m["NextTaskId"]));
    }
  }


  virtual ~UpdateTableResponseTaskInfo() = default;
};
class UpdateTableResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<UpdateTableResponseTaskInfo> taskInfo{};

  UpdateTableResponse() {}

  explicit UpdateTableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!taskInfo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskInfo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskInfo) {
      res["TaskInfo"] = taskInfo ? boost::any(taskInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskInfo") != m.end() && !m["TaskInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["TaskInfo"].type()) {
        UpdateTableResponseTaskInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TaskInfo"]));
        taskInfo = make_shared<UpdateTableResponseTaskInfo>(model1);
      }
    }
  }


  virtual ~UpdateTableResponse() = default;
};
class GetDataServiceFolderRequest : public Darabonba::Model {
public:
  shared_ptr<long> tenantId{};
  shared_ptr<long> projectId{};
  shared_ptr<long> folderId{};

  GetDataServiceFolderRequest() {}

  explicit GetDataServiceFolderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!tenantId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tenantId is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!folderId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("folderId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (folderId) {
      res["FolderId"] = boost::any(*folderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("FolderId") != m.end() && !m["FolderId"].empty()) {
      folderId = make_shared<long>(boost::any_cast<long>(m["FolderId"]));
    }
  }


  virtual ~GetDataServiceFolderRequest() = default;
};
class GetDataServiceFolderResponseFolder : public Darabonba::Model {
public:
  shared_ptr<long> tenantId{};
  shared_ptr<long> projectId{};
  shared_ptr<long> folderId{};
  shared_ptr<string> folderName{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> groupId{};
  shared_ptr<long> parentId{};

  GetDataServiceFolderResponseFolder() {}

  explicit GetDataServiceFolderResponseFolder(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!tenantId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tenantId is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!folderId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("folderId is required.")));
    }
    if (!folderName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("folderName is required.")));
    }
    if (!createdTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("createdTime is required.")));
    }
    if (!modifiedTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("modifiedTime is required.")));
    }
    if (!groupId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupId is required.")));
    }
    if (!parentId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parentId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (folderId) {
      res["FolderId"] = boost::any(*folderId);
    }
    if (folderName) {
      res["FolderName"] = boost::any(*folderName);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("FolderId") != m.end() && !m["FolderId"].empty()) {
      folderId = make_shared<long>(boost::any_cast<long>(m["FolderId"]));
    }
    if (m.find("FolderName") != m.end() && !m["FolderName"].empty()) {
      folderName = make_shared<string>(boost::any_cast<string>(m["FolderName"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
  }


  virtual ~GetDataServiceFolderResponseFolder() = default;
};
class GetDataServiceFolderResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetDataServiceFolderResponseFolder> folder{};

  GetDataServiceFolderResponse() {}

  explicit GetDataServiceFolderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!folder) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("folder is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (folder) {
      res["Folder"] = folder ? boost::any(folder->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Folder") != m.end() && !m["Folder"].empty()) {
      if (typeid(map<string, boost::any>) == m["Folder"].type()) {
        GetDataServiceFolderResponseFolder model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Folder"]));
        folder = make_shared<GetDataServiceFolderResponseFolder>(model1);
      }
    }
  }


  virtual ~GetDataServiceFolderResponse() = default;
};
class ListTableLevelRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<int> levelType{};
  shared_ptr<int> pageNum{};
  shared_ptr<int> pageSize{};

  ListTableLevelRequest() {}

  explicit ListTableLevelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!levelType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("levelType is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (levelType) {
      res["LevelType"] = boost::any(*levelType);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("LevelType") != m.end() && !m["LevelType"].empty()) {
      levelType = make_shared<int>(boost::any_cast<int>(m["LevelType"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<int>(boost::any_cast<int>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
  }


  virtual ~ListTableLevelRequest() = default;
};
class ListTableLevelResponseTableLevelInfoLevelList : public Darabonba::Model {
public:
  shared_ptr<long> levelId{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<int> levelType{};
  shared_ptr<string> description{};

  ListTableLevelResponseTableLevelInfoLevelList() {}

  explicit ListTableLevelResponseTableLevelInfoLevelList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!levelId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("levelId is required.")));
    }
    if (!name) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("name is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!levelType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("levelType is required.")));
    }
    if (!description) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("description is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (levelId) {
      res["LevelId"] = boost::any(*levelId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (levelType) {
      res["LevelType"] = boost::any(*levelType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LevelId") != m.end() && !m["LevelId"].empty()) {
      levelId = make_shared<long>(boost::any_cast<long>(m["LevelId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("LevelType") != m.end() && !m["LevelType"].empty()) {
      levelType = make_shared<int>(boost::any_cast<int>(m["LevelType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~ListTableLevelResponseTableLevelInfoLevelList() = default;
};
class ListTableLevelResponseTableLevelInfo : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListTableLevelResponseTableLevelInfoLevelList>> levelList{};

  ListTableLevelResponseTableLevelInfo() {}

  explicit ListTableLevelResponseTableLevelInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!totalCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("totalCount is required.")));
    }
    if (!levelList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("levelList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (levelList) {
      vector<boost::any> temp1;
      for(auto item1:*levelList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LevelList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("LevelList") != m.end() && !m["LevelList"].empty()) {
      if (typeid(vector<boost::any>) == m["LevelList"].type()) {
        vector<ListTableLevelResponseTableLevelInfoLevelList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LevelList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTableLevelResponseTableLevelInfoLevelList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        levelList = make_shared<vector<ListTableLevelResponseTableLevelInfoLevelList>>(expect1);
      }
    }
  }


  virtual ~ListTableLevelResponseTableLevelInfo() = default;
};
class ListTableLevelResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<bool> success{};
  shared_ptr<ListTableLevelResponseTableLevelInfo> tableLevelInfo{};

  ListTableLevelResponse() {}

  explicit ListTableLevelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!tableLevelInfo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tableLevelInfo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (tableLevelInfo) {
      res["TableLevelInfo"] = tableLevelInfo ? boost::any(tableLevelInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TableLevelInfo") != m.end() && !m["TableLevelInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["TableLevelInfo"].type()) {
        ListTableLevelResponseTableLevelInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TableLevelInfo"]));
        tableLevelInfo = make_shared<ListTableLevelResponseTableLevelInfo>(model1);
      }
    }
  }


  virtual ~ListTableLevelResponse() = default;
};
class ListDataServiceGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<long> tenantId{};
  shared_ptr<string> groupNameKeyword{};

  ListDataServiceGroupsRequest() {}

  explicit ListDataServiceGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!tenantId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tenantId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (groupNameKeyword) {
      res["GroupNameKeyword"] = boost::any(*groupNameKeyword);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("GroupNameKeyword") != m.end() && !m["GroupNameKeyword"].empty()) {
      groupNameKeyword = make_shared<string>(boost::any_cast<string>(m["GroupNameKeyword"]));
    }
  }


  virtual ~ListDataServiceGroupsRequest() = default;
};
class ListDataServiceGroupsResponseGroupPagingResultGroups : public Darabonba::Model {
public:
  shared_ptr<long> tenantId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> apiGatewayGroupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> description{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> creatorId{};
  shared_ptr<long> projectId{};

  ListDataServiceGroupsResponseGroupPagingResultGroups() {}

  explicit ListDataServiceGroupsResponseGroupPagingResultGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!tenantId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tenantId is required.")));
    }
    if (!groupId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupId is required.")));
    }
    if (!apiGatewayGroupId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("apiGatewayGroupId is required.")));
    }
    if (!groupName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupName is required.")));
    }
    if (!description) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("description is required.")));
    }
    if (!createdTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("createdTime is required.")));
    }
    if (!modifiedTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("modifiedTime is required.")));
    }
    if (!creatorId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("creatorId is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (apiGatewayGroupId) {
      res["ApiGatewayGroupId"] = boost::any(*apiGatewayGroupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("ApiGatewayGroupId") != m.end() && !m["ApiGatewayGroupId"].empty()) {
      apiGatewayGroupId = make_shared<string>(boost::any_cast<string>(m["ApiGatewayGroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~ListDataServiceGroupsResponseGroupPagingResultGroups() = default;
};
class ListDataServiceGroupsResponseGroupPagingResult : public Darabonba::Model {
public:
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> totalCount{};
  shared_ptr<vector<ListDataServiceGroupsResponseGroupPagingResultGroups>> groups{};

  ListDataServiceGroupsResponseGroupPagingResult() {}

  explicit ListDataServiceGroupsResponseGroupPagingResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageNumber) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNumber is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!totalCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("totalCount is required.")));
    }
    if (!groups) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groups is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (groups) {
      vector<boost::any> temp1;
      for(auto item1:*groups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Groups"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<int>(boost::any_cast<int>(m["TotalCount"]));
    }
    if (m.find("Groups") != m.end() && !m["Groups"].empty()) {
      if (typeid(vector<boost::any>) == m["Groups"].type()) {
        vector<ListDataServiceGroupsResponseGroupPagingResultGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Groups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataServiceGroupsResponseGroupPagingResultGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groups = make_shared<vector<ListDataServiceGroupsResponseGroupPagingResultGroups>>(expect1);
      }
    }
  }


  virtual ~ListDataServiceGroupsResponseGroupPagingResult() = default;
};
class ListDataServiceGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListDataServiceGroupsResponseGroupPagingResult> groupPagingResult{};

  ListDataServiceGroupsResponse() {}

  explicit ListDataServiceGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!groupPagingResult) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupPagingResult is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (groupPagingResult) {
      res["GroupPagingResult"] = groupPagingResult ? boost::any(groupPagingResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("GroupPagingResult") != m.end() && !m["GroupPagingResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["GroupPagingResult"].type()) {
        ListDataServiceGroupsResponseGroupPagingResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GroupPagingResult"]));
        groupPagingResult = make_shared<ListDataServiceGroupsResponseGroupPagingResult>(model1);
      }
    }
  }


  virtual ~ListDataServiceGroupsResponse() = default;
};
class UpdateTableThemeRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> name{};
  shared_ptr<long> themeId{};

  UpdateTableThemeRequest() {}

  explicit UpdateTableThemeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!name) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("name is required.")));
    }
    if (!themeId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("themeId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (themeId) {
      res["ThemeId"] = boost::any(*themeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ThemeId") != m.end() && !m["ThemeId"].empty()) {
      themeId = make_shared<long>(boost::any_cast<long>(m["ThemeId"]));
    }
  }


  virtual ~UpdateTableThemeRequest() = default;
};
class UpdateTableThemeResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<bool> success{};
  shared_ptr<bool> updateResult{};

  UpdateTableThemeResponse() {}

  explicit UpdateTableThemeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!updateResult) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("updateResult is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (updateResult) {
      res["UpdateResult"] = boost::any(*updateResult);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("UpdateResult") != m.end() && !m["UpdateResult"].empty()) {
      updateResult = make_shared<bool>(boost::any_cast<bool>(m["UpdateResult"]));
    }
  }


  virtual ~UpdateTableThemeResponse() = default;
};
class CreateDataServiceFolderRequest : public Darabonba::Model {
public:
  shared_ptr<long> tenantId{};
  shared_ptr<long> projectId{};
  shared_ptr<string> folderName{};
  shared_ptr<long> parentId{};
  shared_ptr<string> groupId{};

  CreateDataServiceFolderRequest() {}

  explicit CreateDataServiceFolderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!tenantId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tenantId is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!folderName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("folderName is required.")));
    }
    if (!parentId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parentId is required.")));
    }
    if (!groupId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (folderName) {
      res["FolderName"] = boost::any(*folderName);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("FolderName") != m.end() && !m["FolderName"].empty()) {
      folderName = make_shared<string>(boost::any_cast<string>(m["FolderName"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~CreateDataServiceFolderRequest() = default;
};
class CreateDataServiceFolderResponse : public Darabonba::Model {
public:
  shared_ptr<long> folderId{};
  shared_ptr<string> requestId{};

  CreateDataServiceFolderResponse() {}

  explicit CreateDataServiceFolderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!folderId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("folderId is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (folderId) {
      res["FolderId"] = boost::any(*folderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FolderId") != m.end() && !m["FolderId"].empty()) {
      folderId = make_shared<long>(boost::any_cast<long>(m["FolderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDataServiceFolderResponse() = default;
};
class GetDataServiceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> tenantId{};
  shared_ptr<long> projectId{};
  shared_ptr<string> groupId{};

  GetDataServiceGroupRequest() {}

  explicit GetDataServiceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!tenantId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tenantId is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!groupId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~GetDataServiceGroupRequest() = default;
};
class GetDataServiceGroupResponseGroup : public Darabonba::Model {
public:
  shared_ptr<long> tenantId{};
  shared_ptr<long> projectId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> apiGatewayGroupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> description{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> creatorId{};

  GetDataServiceGroupResponseGroup() {}

  explicit GetDataServiceGroupResponseGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!tenantId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tenantId is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!groupId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupId is required.")));
    }
    if (!apiGatewayGroupId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("apiGatewayGroupId is required.")));
    }
    if (!groupName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupName is required.")));
    }
    if (!description) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("description is required.")));
    }
    if (!createdTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("createdTime is required.")));
    }
    if (!modifiedTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("modifiedTime is required.")));
    }
    if (!creatorId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("creatorId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (apiGatewayGroupId) {
      res["ApiGatewayGroupId"] = boost::any(*apiGatewayGroupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("ApiGatewayGroupId") != m.end() && !m["ApiGatewayGroupId"].empty()) {
      apiGatewayGroupId = make_shared<string>(boost::any_cast<string>(m["ApiGatewayGroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
  }


  virtual ~GetDataServiceGroupResponseGroup() = default;
};
class GetDataServiceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetDataServiceGroupResponseGroup> group{};

  GetDataServiceGroupResponse() {}

  explicit GetDataServiceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!group) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("group is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (group) {
      res["Group"] = group ? boost::any(group->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      if (typeid(map<string, boost::any>) == m["Group"].type()) {
        GetDataServiceGroupResponseGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Group"]));
        group = make_shared<GetDataServiceGroupResponseGroup>(model1);
      }
    }
  }


  virtual ~GetDataServiceGroupResponse() = default;
};
class CreateTableLevelRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<int> levelType{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};

  CreateTableLevelRequest() {}

  explicit CreateTableLevelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!levelType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("levelType is required.")));
    }
    if (!name) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("name is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (levelType) {
      res["LevelType"] = boost::any(*levelType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("LevelType") != m.end() && !m["LevelType"].empty()) {
      levelType = make_shared<int>(boost::any_cast<int>(m["LevelType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~CreateTableLevelRequest() = default;
};
class CreateTableLevelResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<bool> success{};
  shared_ptr<long> levelId{};

  CreateTableLevelResponse() {}

  explicit CreateTableLevelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!levelId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("levelId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (levelId) {
      res["LevelId"] = boost::any(*levelId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("LevelId") != m.end() && !m["LevelId"].empty()) {
      levelId = make_shared<long>(boost::any_cast<long>(m["LevelId"]));
    }
  }


  virtual ~CreateTableLevelResponse() = default;
};
class UpdateMetaTableIntroWikiRequest : public Darabonba::Model {
public:
  shared_ptr<string> tableGuid{};
  shared_ptr<string> content{};

  UpdateMetaTableIntroWikiRequest() {}

  explicit UpdateMetaTableIntroWikiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!tableGuid) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tableGuid is required.")));
    }
    if (!content) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("content is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
  }


  virtual ~UpdateMetaTableIntroWikiRequest() = default;
};
class UpdateMetaTableIntroWikiResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> updateResult{};

  UpdateMetaTableIntroWikiResponse() {}

  explicit UpdateMetaTableIntroWikiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!updateResult) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("updateResult is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (updateResult) {
      res["UpdateResult"] = boost::any(*updateResult);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UpdateResult") != m.end() && !m["UpdateResult"].empty()) {
      updateResult = make_shared<bool>(boost::any_cast<bool>(m["UpdateResult"]));
    }
  }


  virtual ~UpdateMetaTableIntroWikiResponse() = default;
};
class DeleteTableLevelRequest : public Darabonba::Model {
public:
  shared_ptr<long> levelId{};
  shared_ptr<long> projectId{};

  DeleteTableLevelRequest() {}

  explicit DeleteTableLevelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!levelId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("levelId is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (levelId) {
      res["LevelId"] = boost::any(*levelId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LevelId") != m.end() && !m["LevelId"].empty()) {
      levelId = make_shared<long>(boost::any_cast<long>(m["LevelId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~DeleteTableLevelRequest() = default;
};
class DeleteTableLevelResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> deleteResult{};

  DeleteTableLevelResponse() {}

  explicit DeleteTableLevelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!deleteResult) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deleteResult is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (deleteResult) {
      res["DeleteResult"] = boost::any(*deleteResult);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DeleteResult") != m.end() && !m["DeleteResult"].empty()) {
      deleteResult = make_shared<bool>(boost::any_cast<bool>(m["DeleteResult"]));
    }
  }


  virtual ~DeleteTableLevelResponse() = default;
};
class UpdateTableLevelRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<int> levelType{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};
  shared_ptr<long> levelId{};

  UpdateTableLevelRequest() {}

  explicit UpdateTableLevelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!levelId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("levelId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (levelType) {
      res["LevelType"] = boost::any(*levelType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (levelId) {
      res["LevelId"] = boost::any(*levelId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("LevelType") != m.end() && !m["LevelType"].empty()) {
      levelType = make_shared<int>(boost::any_cast<int>(m["LevelType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("LevelId") != m.end() && !m["LevelId"].empty()) {
      levelId = make_shared<long>(boost::any_cast<long>(m["LevelId"]));
    }
  }


  virtual ~UpdateTableLevelRequest() = default;
};
class UpdateTableLevelResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<bool> success{};
  shared_ptr<bool> updateResult{};

  UpdateTableLevelResponse() {}

  explicit UpdateTableLevelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!updateResult) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("updateResult is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (updateResult) {
      res["UpdateResult"] = boost::any(*updateResult);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("UpdateResult") != m.end() && !m["UpdateResult"].empty()) {
      updateResult = make_shared<bool>(boost::any_cast<bool>(m["UpdateResult"]));
    }
  }


  virtual ~UpdateTableLevelResponse() = default;
};
class DeleteTableThemeRequest : public Darabonba::Model {
public:
  shared_ptr<long> themeId{};
  shared_ptr<long> projectId{};

  DeleteTableThemeRequest() {}

  explicit DeleteTableThemeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!themeId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("themeId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (themeId) {
      res["ThemeId"] = boost::any(*themeId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ThemeId") != m.end() && !m["ThemeId"].empty()) {
      themeId = make_shared<long>(boost::any_cast<long>(m["ThemeId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~DeleteTableThemeRequest() = default;
};
class DeleteTableThemeResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<bool> success{};
  shared_ptr<bool> deleteResult{};

  DeleteTableThemeResponse() {}

  explicit DeleteTableThemeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!deleteResult) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deleteResult is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (deleteResult) {
      res["DeleteResult"] = boost::any(*deleteResult);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("DeleteResult") != m.end() && !m["DeleteResult"].empty()) {
      deleteResult = make_shared<bool>(boost::any_cast<bool>(m["DeleteResult"]));
    }
  }


  virtual ~DeleteTableThemeResponse() = default;
};
class ListProgramTypeCountRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> projectEnv{};

  ListProgramTypeCountRequest() {}

  explicit ListProgramTypeCountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!projectEnv) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectEnv is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
  }


  virtual ~ListProgramTypeCountRequest() = default;
};
class ListProgramTypeCountResponseProgramTypeAndCounts : public Darabonba::Model {
public:
  shared_ptr<string> programType{};
  shared_ptr<int> count{};

  ListProgramTypeCountResponseProgramTypeAndCounts() {}

  explicit ListProgramTypeCountResponseProgramTypeAndCounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!programType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("programType is required.")));
    }
    if (!count) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("count is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (programType) {
      res["ProgramType"] = boost::any(*programType);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProgramType") != m.end() && !m["ProgramType"].empty()) {
      programType = make_shared<string>(boost::any_cast<string>(m["ProgramType"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<int>(boost::any_cast<int>(m["Count"]));
    }
  }


  virtual ~ListProgramTypeCountResponseProgramTypeAndCounts() = default;
};
class ListProgramTypeCountResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListProgramTypeCountResponseProgramTypeAndCounts>> programTypeAndCounts{};

  ListProgramTypeCountResponse() {}

  explicit ListProgramTypeCountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!programTypeAndCounts) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("programTypeAndCounts is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (programTypeAndCounts) {
      vector<boost::any> temp1;
      for(auto item1:*programTypeAndCounts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProgramTypeAndCounts"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ProgramTypeAndCounts") != m.end() && !m["ProgramTypeAndCounts"].empty()) {
      if (typeid(vector<boost::any>) == m["ProgramTypeAndCounts"].type()) {
        vector<ListProgramTypeCountResponseProgramTypeAndCounts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProgramTypeAndCounts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProgramTypeCountResponseProgramTypeAndCounts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        programTypeAndCounts = make_shared<vector<ListProgramTypeCountResponseProgramTypeAndCounts>>(expect1);
      }
    }
  }


  virtual ~ListProgramTypeCountResponse() = default;
};
class UpdateTableModelInfoRequest : public Darabonba::Model {
public:
  shared_ptr<long> firstLevelThemeId{};
  shared_ptr<long> secondLevelThemeId{};
  shared_ptr<long> levelId{};
  shared_ptr<string> tableGuid{};
  shared_ptr<int> levelType{};

  UpdateTableModelInfoRequest() {}

  explicit UpdateTableModelInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!tableGuid) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tableGuid is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (firstLevelThemeId) {
      res["FirstLevelThemeId"] = boost::any(*firstLevelThemeId);
    }
    if (secondLevelThemeId) {
      res["SecondLevelThemeId"] = boost::any(*secondLevelThemeId);
    }
    if (levelId) {
      res["LevelId"] = boost::any(*levelId);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (levelType) {
      res["LevelType"] = boost::any(*levelType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FirstLevelThemeId") != m.end() && !m["FirstLevelThemeId"].empty()) {
      firstLevelThemeId = make_shared<long>(boost::any_cast<long>(m["FirstLevelThemeId"]));
    }
    if (m.find("SecondLevelThemeId") != m.end() && !m["SecondLevelThemeId"].empty()) {
      secondLevelThemeId = make_shared<long>(boost::any_cast<long>(m["SecondLevelThemeId"]));
    }
    if (m.find("LevelId") != m.end() && !m["LevelId"].empty()) {
      levelId = make_shared<long>(boost::any_cast<long>(m["LevelId"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("LevelType") != m.end() && !m["LevelType"].empty()) {
      levelType = make_shared<int>(boost::any_cast<int>(m["LevelType"]));
    }
  }


  virtual ~UpdateTableModelInfoRequest() = default;
};
class UpdateTableModelInfoResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> updateResult{};

  UpdateTableModelInfoResponse() {}

  explicit UpdateTableModelInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!updateResult) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("updateResult is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (updateResult) {
      res["UpdateResult"] = boost::any(*updateResult);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UpdateResult") != m.end() && !m["UpdateResult"].empty()) {
      updateResult = make_shared<bool>(boost::any_cast<bool>(m["UpdateResult"]));
    }
  }


  virtual ~UpdateTableModelInfoResponse() = default;
};
class ListProjectsRequest : public Darabonba::Model {
public:
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};

  ListProjectsRequest() {}

  explicit ListProjectsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
  }


  virtual ~ListProjectsRequest() = default;
};
class ListProjectsResponsePageResultProjectList : public Darabonba::Model {
public:
  shared_ptr<string> projectName{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<string> projectDescription{};
  shared_ptr<int> projectStatus{};
  shared_ptr<long> projectId{};
  shared_ptr<string> projectOwnerBaseId{};
  shared_ptr<string> projectStatusCode{};

  ListProjectsResponsePageResultProjectList() {}

  explicit ListProjectsResponsePageResultProjectList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectName is required.")));
    }
    if (!projectIdentifier) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectIdentifier is required.")));
    }
    if (!projectDescription) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectDescription is required.")));
    }
    if (!projectStatus) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectStatus is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!projectOwnerBaseId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectOwnerBaseId is required.")));
    }
    if (!projectStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectStatusCode is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (projectDescription) {
      res["ProjectDescription"] = boost::any(*projectDescription);
    }
    if (projectStatus) {
      res["ProjectStatus"] = boost::any(*projectStatus);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectOwnerBaseId) {
      res["ProjectOwnerBaseId"] = boost::any(*projectOwnerBaseId);
    }
    if (projectStatusCode) {
      res["ProjectStatusCode"] = boost::any(*projectStatusCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("ProjectDescription") != m.end() && !m["ProjectDescription"].empty()) {
      projectDescription = make_shared<string>(boost::any_cast<string>(m["ProjectDescription"]));
    }
    if (m.find("ProjectStatus") != m.end() && !m["ProjectStatus"].empty()) {
      projectStatus = make_shared<int>(boost::any_cast<int>(m["ProjectStatus"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectOwnerBaseId") != m.end() && !m["ProjectOwnerBaseId"].empty()) {
      projectOwnerBaseId = make_shared<string>(boost::any_cast<string>(m["ProjectOwnerBaseId"]));
    }
    if (m.find("ProjectStatusCode") != m.end() && !m["ProjectStatusCode"].empty()) {
      projectStatusCode = make_shared<string>(boost::any_cast<string>(m["ProjectStatusCode"]));
    }
  }


  virtual ~ListProjectsResponsePageResultProjectList() = default;
};
class ListProjectsResponsePageResult : public Darabonba::Model {
public:
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> totalCount{};
  shared_ptr<vector<ListProjectsResponsePageResultProjectList>> projectList{};

  ListProjectsResponsePageResult() {}

  explicit ListProjectsResponsePageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageNumber) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNumber is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!totalCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("totalCount is required.")));
    }
    if (!projectList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (projectList) {
      vector<boost::any> temp1;
      for(auto item1:*projectList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProjectList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<int>(boost::any_cast<int>(m["TotalCount"]));
    }
    if (m.find("ProjectList") != m.end() && !m["ProjectList"].empty()) {
      if (typeid(vector<boost::any>) == m["ProjectList"].type()) {
        vector<ListProjectsResponsePageResultProjectList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProjectList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProjectsResponsePageResultProjectList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        projectList = make_shared<vector<ListProjectsResponsePageResultProjectList>>(expect1);
      }
    }
  }


  virtual ~ListProjectsResponsePageResult() = default;
};
class ListProjectsResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListProjectsResponsePageResult> pageResult{};

  ListProjectsResponse() {}

  explicit ListProjectsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!pageResult) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageResult is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageResult) {
      res["PageResult"] = pageResult ? boost::any(pageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageResult") != m.end() && !m["PageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageResult"].type()) {
        ListProjectsResponsePageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageResult"]));
        pageResult = make_shared<ListProjectsResponsePageResult>(model1);
      }
    }
  }


  virtual ~ListProjectsResponse() = default;
};
class ListProjectMembersRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};

  ListProjectMembersRequest() {}

  explicit ListProjectMembersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
  }


  virtual ~ListProjectMembersRequest() = default;
};
class ListProjectMembersResponseDataProjectMemberListProjectRoleList : public Darabonba::Model {
public:
  shared_ptr<string> projectRoleCode{};
  shared_ptr<int> projectRoleId{};
  shared_ptr<string> projectRoleName{};
  shared_ptr<string> projectRoleType{};

  ListProjectMembersResponseDataProjectMemberListProjectRoleList() {}

  explicit ListProjectMembersResponseDataProjectMemberListProjectRoleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectRoleCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectRoleCode is required.")));
    }
    if (!projectRoleId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectRoleId is required.")));
    }
    if (!projectRoleName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectRoleName is required.")));
    }
    if (!projectRoleType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectRoleType is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectRoleCode) {
      res["ProjectRoleCode"] = boost::any(*projectRoleCode);
    }
    if (projectRoleId) {
      res["ProjectRoleId"] = boost::any(*projectRoleId);
    }
    if (projectRoleName) {
      res["ProjectRoleName"] = boost::any(*projectRoleName);
    }
    if (projectRoleType) {
      res["ProjectRoleType"] = boost::any(*projectRoleType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectRoleCode") != m.end() && !m["ProjectRoleCode"].empty()) {
      projectRoleCode = make_shared<string>(boost::any_cast<string>(m["ProjectRoleCode"]));
    }
    if (m.find("ProjectRoleId") != m.end() && !m["ProjectRoleId"].empty()) {
      projectRoleId = make_shared<int>(boost::any_cast<int>(m["ProjectRoleId"]));
    }
    if (m.find("ProjectRoleName") != m.end() && !m["ProjectRoleName"].empty()) {
      projectRoleName = make_shared<string>(boost::any_cast<string>(m["ProjectRoleName"]));
    }
    if (m.find("ProjectRoleType") != m.end() && !m["ProjectRoleType"].empty()) {
      projectRoleType = make_shared<string>(boost::any_cast<string>(m["ProjectRoleType"]));
    }
  }


  virtual ~ListProjectMembersResponseDataProjectMemberListProjectRoleList() = default;
};
class ListProjectMembersResponseDataProjectMemberList : public Darabonba::Model {
public:
  shared_ptr<string> nick{};
  shared_ptr<string> projectMemberId{};
  shared_ptr<string> projectMemberName{};
  shared_ptr<string> projectMemberType{};
  shared_ptr<string> status{};
  shared_ptr<vector<ListProjectMembersResponseDataProjectMemberListProjectRoleList>> projectRoleList{};

  ListProjectMembersResponseDataProjectMemberList() {}

  explicit ListProjectMembersResponseDataProjectMemberList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!nick) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nick is required.")));
    }
    if (!projectMemberId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectMemberId is required.")));
    }
    if (!projectMemberName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectMemberName is required.")));
    }
    if (!projectMemberType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectMemberType is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!projectRoleList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectRoleList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nick) {
      res["Nick"] = boost::any(*nick);
    }
    if (projectMemberId) {
      res["ProjectMemberId"] = boost::any(*projectMemberId);
    }
    if (projectMemberName) {
      res["ProjectMemberName"] = boost::any(*projectMemberName);
    }
    if (projectMemberType) {
      res["ProjectMemberType"] = boost::any(*projectMemberType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (projectRoleList) {
      vector<boost::any> temp1;
      for(auto item1:*projectRoleList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProjectRoleList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Nick") != m.end() && !m["Nick"].empty()) {
      nick = make_shared<string>(boost::any_cast<string>(m["Nick"]));
    }
    if (m.find("ProjectMemberId") != m.end() && !m["ProjectMemberId"].empty()) {
      projectMemberId = make_shared<string>(boost::any_cast<string>(m["ProjectMemberId"]));
    }
    if (m.find("ProjectMemberName") != m.end() && !m["ProjectMemberName"].empty()) {
      projectMemberName = make_shared<string>(boost::any_cast<string>(m["ProjectMemberName"]));
    }
    if (m.find("ProjectMemberType") != m.end() && !m["ProjectMemberType"].empty()) {
      projectMemberType = make_shared<string>(boost::any_cast<string>(m["ProjectMemberType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("ProjectRoleList") != m.end() && !m["ProjectRoleList"].empty()) {
      if (typeid(vector<boost::any>) == m["ProjectRoleList"].type()) {
        vector<ListProjectMembersResponseDataProjectMemberListProjectRoleList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProjectRoleList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProjectMembersResponseDataProjectMemberListProjectRoleList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        projectRoleList = make_shared<vector<ListProjectMembersResponseDataProjectMemberListProjectRoleList>>(expect1);
      }
    }
  }


  virtual ~ListProjectMembersResponseDataProjectMemberList() = default;
};
class ListProjectMembersResponseData : public Darabonba::Model {
public:
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> totalCount{};
  shared_ptr<vector<ListProjectMembersResponseDataProjectMemberList>> projectMemberList{};

  ListProjectMembersResponseData() {}

  explicit ListProjectMembersResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageNumber) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNumber is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!totalCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("totalCount is required.")));
    }
    if (!projectMemberList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectMemberList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (projectMemberList) {
      vector<boost::any> temp1;
      for(auto item1:*projectMemberList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProjectMemberList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<int>(boost::any_cast<int>(m["TotalCount"]));
    }
    if (m.find("ProjectMemberList") != m.end() && !m["ProjectMemberList"].empty()) {
      if (typeid(vector<boost::any>) == m["ProjectMemberList"].type()) {
        vector<ListProjectMembersResponseDataProjectMemberList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProjectMemberList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProjectMembersResponseDataProjectMemberList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        projectMemberList = make_shared<vector<ListProjectMembersResponseDataProjectMemberList>>(expect1);
      }
    }
  }


  virtual ~ListProjectMembersResponseData() = default;
};
class ListProjectMembersResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListProjectMembersResponseData> data{};

  ListProjectMembersResponse() {}

  explicit ListProjectMembersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListProjectMembersResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListProjectMembersResponseData>(model1);
      }
    }
  }


  virtual ~ListProjectMembersResponse() = default;
};
class CreateProjectMemberRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> userId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> roleCode{};

  CreateProjectMemberRequest() {}

  explicit CreateProjectMemberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!userId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("userId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (roleCode) {
      res["RoleCode"] = boost::any(*roleCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("RoleCode") != m.end() && !m["RoleCode"].empty()) {
      roleCode = make_shared<string>(boost::any_cast<string>(m["RoleCode"]));
    }
  }


  virtual ~CreateProjectMemberRequest() = default;
};
class CreateProjectMemberResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateProjectMemberResponse() {}

  explicit CreateProjectMemberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateProjectMemberResponse() = default;
};
class ListProjectRolesRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};

  ListProjectRolesRequest() {}

  explicit ListProjectRolesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~ListProjectRolesRequest() = default;
};
class ListProjectRolesResponseProjectRoleList : public Darabonba::Model {
public:
  shared_ptr<string> projectRoleCode{};
  shared_ptr<int> projectRoleId{};
  shared_ptr<string> projectRoleName{};
  shared_ptr<string> projectRoleType{};

  ListProjectRolesResponseProjectRoleList() {}

  explicit ListProjectRolesResponseProjectRoleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectRoleCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectRoleCode is required.")));
    }
    if (!projectRoleId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectRoleId is required.")));
    }
    if (!projectRoleName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectRoleName is required.")));
    }
    if (!projectRoleType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectRoleType is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectRoleCode) {
      res["ProjectRoleCode"] = boost::any(*projectRoleCode);
    }
    if (projectRoleId) {
      res["ProjectRoleId"] = boost::any(*projectRoleId);
    }
    if (projectRoleName) {
      res["ProjectRoleName"] = boost::any(*projectRoleName);
    }
    if (projectRoleType) {
      res["ProjectRoleType"] = boost::any(*projectRoleType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectRoleCode") != m.end() && !m["ProjectRoleCode"].empty()) {
      projectRoleCode = make_shared<string>(boost::any_cast<string>(m["ProjectRoleCode"]));
    }
    if (m.find("ProjectRoleId") != m.end() && !m["ProjectRoleId"].empty()) {
      projectRoleId = make_shared<int>(boost::any_cast<int>(m["ProjectRoleId"]));
    }
    if (m.find("ProjectRoleName") != m.end() && !m["ProjectRoleName"].empty()) {
      projectRoleName = make_shared<string>(boost::any_cast<string>(m["ProjectRoleName"]));
    }
    if (m.find("ProjectRoleType") != m.end() && !m["ProjectRoleType"].empty()) {
      projectRoleType = make_shared<string>(boost::any_cast<string>(m["ProjectRoleType"]));
    }
  }


  virtual ~ListProjectRolesResponseProjectRoleList() = default;
};
class ListProjectRolesResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListProjectRolesResponseProjectRoleList>> projectRoleList{};

  ListProjectRolesResponse() {}

  explicit ListProjectRolesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!projectRoleList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectRoleList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (projectRoleList) {
      vector<boost::any> temp1;
      for(auto item1:*projectRoleList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProjectRoleList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ProjectRoleList") != m.end() && !m["ProjectRoleList"].empty()) {
      if (typeid(vector<boost::any>) == m["ProjectRoleList"].type()) {
        vector<ListProjectRolesResponseProjectRoleList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProjectRoleList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProjectRolesResponseProjectRoleList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        projectRoleList = make_shared<vector<ListProjectRolesResponseProjectRoleList>>(expect1);
      }
    }
  }


  virtual ~ListProjectRolesResponse() = default;
};
class AddProjectMemberToRoleRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> userId{};
  shared_ptr<string> roleCode{};
  shared_ptr<string> clientToken{};

  AddProjectMemberToRoleRequest() {}

  explicit AddProjectMemberToRoleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!userId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("userId is required.")));
    }
    if (!roleCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("roleCode is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (roleCode) {
      res["RoleCode"] = boost::any(*roleCode);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("RoleCode") != m.end() && !m["RoleCode"].empty()) {
      roleCode = make_shared<string>(boost::any_cast<string>(m["RoleCode"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
  }


  virtual ~AddProjectMemberToRoleRequest() = default;
};
class AddProjectMemberToRoleResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddProjectMemberToRoleResponse() {}

  explicit AddProjectMemberToRoleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddProjectMemberToRoleResponse() = default;
};
class RemoveProjectMemberFromRoleRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> userId{};
  shared_ptr<string> roleCode{};

  RemoveProjectMemberFromRoleRequest() {}

  explicit RemoveProjectMemberFromRoleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!userId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("userId is required.")));
    }
    if (!roleCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("roleCode is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (roleCode) {
      res["RoleCode"] = boost::any(*roleCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("RoleCode") != m.end() && !m["RoleCode"].empty()) {
      roleCode = make_shared<string>(boost::any_cast<string>(m["RoleCode"]));
    }
  }


  virtual ~RemoveProjectMemberFromRoleRequest() = default;
};
class RemoveProjectMemberFromRoleResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RemoveProjectMemberFromRoleResponse() {}

  explicit RemoveProjectMemberFromRoleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveProjectMemberFromRoleResponse() = default;
};
class DeleteProjectMemberRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> userId{};

  DeleteProjectMemberRequest() {}

  explicit DeleteProjectMemberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!userId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("userId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~DeleteProjectMemberRequest() = default;
};
class DeleteProjectMemberResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteProjectMemberResponse() {}

  explicit DeleteProjectMemberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteProjectMemberResponse() = default;
};
class CreateDagComplementRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectEnv{};
  shared_ptr<string> startBizDate{};
  shared_ptr<string> name{};
  shared_ptr<long> rootNodeId{};
  shared_ptr<string> includeNodeIds{};
  shared_ptr<string> excludeNodeIds{};
  shared_ptr<string> bizBeginTime{};
  shared_ptr<string> bizEndTime{};
  shared_ptr<bool> parallelism{};
  shared_ptr<string> endBizDate{};
  shared_ptr<string> nodeParams{};

  CreateDagComplementRequest() {}

  explicit CreateDagComplementRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectEnv) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectEnv is required.")));
    }
    if (!startBizDate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("startBizDate is required.")));
    }
    if (!name) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("name is required.")));
    }
    if (!rootNodeId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("rootNodeId is required.")));
    }
    if (!includeNodeIds) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("includeNodeIds is required.")));
    }
    if (!parallelism) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parallelism is required.")));
    }
    if (!endBizDate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("endBizDate is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (startBizDate) {
      res["StartBizDate"] = boost::any(*startBizDate);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (rootNodeId) {
      res["RootNodeId"] = boost::any(*rootNodeId);
    }
    if (includeNodeIds) {
      res["IncludeNodeIds"] = boost::any(*includeNodeIds);
    }
    if (excludeNodeIds) {
      res["ExcludeNodeIds"] = boost::any(*excludeNodeIds);
    }
    if (bizBeginTime) {
      res["BizBeginTime"] = boost::any(*bizBeginTime);
    }
    if (bizEndTime) {
      res["BizEndTime"] = boost::any(*bizEndTime);
    }
    if (parallelism) {
      res["Parallelism"] = boost::any(*parallelism);
    }
    if (endBizDate) {
      res["EndBizDate"] = boost::any(*endBizDate);
    }
    if (nodeParams) {
      res["NodeParams"] = boost::any(*nodeParams);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("StartBizDate") != m.end() && !m["StartBizDate"].empty()) {
      startBizDate = make_shared<string>(boost::any_cast<string>(m["StartBizDate"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RootNodeId") != m.end() && !m["RootNodeId"].empty()) {
      rootNodeId = make_shared<long>(boost::any_cast<long>(m["RootNodeId"]));
    }
    if (m.find("IncludeNodeIds") != m.end() && !m["IncludeNodeIds"].empty()) {
      includeNodeIds = make_shared<string>(boost::any_cast<string>(m["IncludeNodeIds"]));
    }
    if (m.find("ExcludeNodeIds") != m.end() && !m["ExcludeNodeIds"].empty()) {
      excludeNodeIds = make_shared<string>(boost::any_cast<string>(m["ExcludeNodeIds"]));
    }
    if (m.find("BizBeginTime") != m.end() && !m["BizBeginTime"].empty()) {
      bizBeginTime = make_shared<string>(boost::any_cast<string>(m["BizBeginTime"]));
    }
    if (m.find("BizEndTime") != m.end() && !m["BizEndTime"].empty()) {
      bizEndTime = make_shared<string>(boost::any_cast<string>(m["BizEndTime"]));
    }
    if (m.find("Parallelism") != m.end() && !m["Parallelism"].empty()) {
      parallelism = make_shared<bool>(boost::any_cast<bool>(m["Parallelism"]));
    }
    if (m.find("EndBizDate") != m.end() && !m["EndBizDate"].empty()) {
      endBizDate = make_shared<string>(boost::any_cast<string>(m["EndBizDate"]));
    }
    if (m.find("NodeParams") != m.end() && !m["NodeParams"].empty()) {
      nodeParams = make_shared<string>(boost::any_cast<string>(m["NodeParams"]));
    }
  }


  virtual ~CreateDagComplementRequest() = default;
};
class CreateDagComplementResponse : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<vector<long>> data{};

  CreateDagComplementResponse() {}

  explicit CreateDagComplementResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Data"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      data = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~CreateDagComplementResponse() = default;
};
class CreateDagTestRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectEnv{};
  shared_ptr<string> bizdate{};
  shared_ptr<string> name{};
  shared_ptr<long> nodeId{};
  shared_ptr<string> nodeParams{};

  CreateDagTestRequest() {}

  explicit CreateDagTestRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectEnv) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectEnv is required.")));
    }
    if (!bizdate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("bizdate is required.")));
    }
    if (!name) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("name is required.")));
    }
    if (!nodeId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (bizdate) {
      res["Bizdate"] = boost::any(*bizdate);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeParams) {
      res["NodeParams"] = boost::any(*nodeParams);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("Bizdate") != m.end() && !m["Bizdate"].empty()) {
      bizdate = make_shared<string>(boost::any_cast<string>(m["Bizdate"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("NodeParams") != m.end() && !m["NodeParams"].empty()) {
      nodeParams = make_shared<string>(boost::any_cast<string>(m["NodeParams"]));
    }
  }


  virtual ~CreateDagTestRequest() = default;
};
class CreateDagTestResponse : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> data{};

  CreateDagTestResponse() {}

  explicit CreateDagTestResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
  }


  virtual ~CreateDagTestResponse() = default;
};
class ListCalcEnginesRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> name{};
  shared_ptr<string> calcEngineType{};
  shared_ptr<string> envType{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> pageNumber{};

  ListCalcEnginesRequest() {}

  explicit ListCalcEnginesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!calcEngineType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("calcEngineType is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (calcEngineType) {
      res["CalcEngineType"] = boost::any(*calcEngineType);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("CalcEngineType") != m.end() && !m["CalcEngineType"].empty()) {
      calcEngineType = make_shared<string>(boost::any_cast<string>(m["CalcEngineType"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
  }


  virtual ~ListCalcEnginesRequest() = default;
};
class ListCalcEnginesResponseDataCalcEngines : public Darabonba::Model {
public:
  shared_ptr<string> calcEngineType{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> dwRegion{};
  shared_ptr<bool> isDefault{};
  shared_ptr<int> bindingProjectId{};
  shared_ptr<string> envType{};
  shared_ptr<long> tenantId{};
  shared_ptr<string> name{};
  shared_ptr<string> bindingProjectName{};
  shared_ptr<string> region{};
  shared_ptr<int> engineId{};
  shared_ptr<map<string, boost::any>> engineInfo{};
  shared_ptr<string> taskAuthType{};

  ListCalcEnginesResponseDataCalcEngines() {}

  explicit ListCalcEnginesResponseDataCalcEngines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!calcEngineType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("calcEngineType is required.")));
    }
    if (!gmtCreate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtCreate is required.")));
    }
    if (!dwRegion) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dwRegion is required.")));
    }
    if (!isDefault) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("isDefault is required.")));
    }
    if (!bindingProjectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("bindingProjectId is required.")));
    }
    if (!envType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("envType is required.")));
    }
    if (!tenantId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tenantId is required.")));
    }
    if (!name) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("name is required.")));
    }
    if (!bindingProjectName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("bindingProjectName is required.")));
    }
    if (!region) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("region is required.")));
    }
    if (!engineId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("engineId is required.")));
    }
    if (!engineInfo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("engineInfo is required.")));
    }
    if (!taskAuthType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskAuthType is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (calcEngineType) {
      res["CalcEngineType"] = boost::any(*calcEngineType);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (dwRegion) {
      res["DwRegion"] = boost::any(*dwRegion);
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    if (bindingProjectId) {
      res["BindingProjectId"] = boost::any(*bindingProjectId);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (bindingProjectName) {
      res["BindingProjectName"] = boost::any(*bindingProjectName);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (engineId) {
      res["EngineId"] = boost::any(*engineId);
    }
    if (engineInfo) {
      res["EngineInfo"] = boost::any(*engineInfo);
    }
    if (taskAuthType) {
      res["TaskAuthType"] = boost::any(*taskAuthType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CalcEngineType") != m.end() && !m["CalcEngineType"].empty()) {
      calcEngineType = make_shared<string>(boost::any_cast<string>(m["CalcEngineType"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("DwRegion") != m.end() && !m["DwRegion"].empty()) {
      dwRegion = make_shared<string>(boost::any_cast<string>(m["DwRegion"]));
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<bool>(boost::any_cast<bool>(m["IsDefault"]));
    }
    if (m.find("BindingProjectId") != m.end() && !m["BindingProjectId"].empty()) {
      bindingProjectId = make_shared<int>(boost::any_cast<int>(m["BindingProjectId"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("BindingProjectName") != m.end() && !m["BindingProjectName"].empty()) {
      bindingProjectName = make_shared<string>(boost::any_cast<string>(m["BindingProjectName"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("EngineId") != m.end() && !m["EngineId"].empty()) {
      engineId = make_shared<int>(boost::any_cast<int>(m["EngineId"]));
    }
    if (m.find("EngineInfo") != m.end() && !m["EngineInfo"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["EngineInfo"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      engineInfo = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("TaskAuthType") != m.end() && !m["TaskAuthType"].empty()) {
      taskAuthType = make_shared<string>(boost::any_cast<string>(m["TaskAuthType"]));
    }
  }


  virtual ~ListCalcEnginesResponseDataCalcEngines() = default;
};
class ListCalcEnginesResponseData : public Darabonba::Model {
public:
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> totalCount{};
  shared_ptr<vector<ListCalcEnginesResponseDataCalcEngines>> calcEngines{};

  ListCalcEnginesResponseData() {}

  explicit ListCalcEnginesResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageNumber) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNumber is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!totalCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("totalCount is required.")));
    }
    if (!calcEngines) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("calcEngines is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (calcEngines) {
      vector<boost::any> temp1;
      for(auto item1:*calcEngines){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CalcEngines"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<int>(boost::any_cast<int>(m["TotalCount"]));
    }
    if (m.find("CalcEngines") != m.end() && !m["CalcEngines"].empty()) {
      if (typeid(vector<boost::any>) == m["CalcEngines"].type()) {
        vector<ListCalcEnginesResponseDataCalcEngines> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CalcEngines"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCalcEnginesResponseDataCalcEngines model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        calcEngines = make_shared<vector<ListCalcEnginesResponseDataCalcEngines>>(expect1);
      }
    }
  }


  virtual ~ListCalcEnginesResponseData() = default;
};
class ListCalcEnginesResponse : public Darabonba::Model {
public:
  shared_ptr<int> httpStatusCode{};
  shared_ptr<bool> success{};
  shared_ptr<string> requestId{};
  shared_ptr<ListCalcEnginesResponseData> data{};

  ListCalcEnginesResponse() {}

  explicit ListCalcEnginesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListCalcEnginesResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListCalcEnginesResponseData>(model1);
      }
    }
  }


  virtual ~ListCalcEnginesResponse() = default;
};
class ListConnectionsRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> name{};
  shared_ptr<string> connectionType{};
  shared_ptr<string> subType{};
  shared_ptr<string> status{};
  shared_ptr<int> envType{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> pageNumber{};

  ListConnectionsRequest() {}

  explicit ListConnectionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (connectionType) {
      res["ConnectionType"] = boost::any(*connectionType);
    }
    if (subType) {
      res["SubType"] = boost::any(*subType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ConnectionType") != m.end() && !m["ConnectionType"].empty()) {
      connectionType = make_shared<string>(boost::any_cast<string>(m["ConnectionType"]));
    }
    if (m.find("SubType") != m.end() && !m["SubType"].empty()) {
      subType = make_shared<string>(boost::any_cast<string>(m["SubType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<int>(boost::any_cast<int>(m["EnvType"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
  }


  virtual ~ListConnectionsRequest() = default;
};
class ListConnectionsResponseDataConnections : public Darabonba::Model {
public:
  shared_ptr<bool> shared{};
  shared_ptr<string> gmtModified{};
  shared_ptr<int> connectStatus{};
  shared_ptr<int> bindingCalcEngineId{};
  shared_ptr<string> description{};
  shared_ptr<string> connectionType{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<bool> defaultEngine{};
  shared_ptr<string> operator_{};
  shared_ptr<int> sequence{};
  shared_ptr<int> envType{};
  shared_ptr<long> tenantId{};
  shared_ptr<string> name{};
  shared_ptr<string> subType{};
  shared_ptr<int> id{};
  shared_ptr<int> projectId{};
  shared_ptr<int> status{};
  shared_ptr<string> content{};

  ListConnectionsResponseDataConnections() {}

  explicit ListConnectionsResponseDataConnections(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!shared) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("shared is required.")));
    }
    if (!gmtModified) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtModified is required.")));
    }
    if (!connectStatus) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("connectStatus is required.")));
    }
    if (!bindingCalcEngineId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("bindingCalcEngineId is required.")));
    }
    if (!description) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("description is required.")));
    }
    if (!connectionType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("connectionType is required.")));
    }
    if (!gmtCreate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtCreate is required.")));
    }
    if (!defaultEngine) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("defaultEngine is required.")));
    }
    if (!operator_) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("operator is required.")));
    }
    if (!sequence) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("sequence is required.")));
    }
    if (!envType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("envType is required.")));
    }
    if (!tenantId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tenantId is required.")));
    }
    if (!name) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("name is required.")));
    }
    if (!subType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("subType is required.")));
    }
    if (!id) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("id is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!content) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("content is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (shared) {
      res["Shared"] = boost::any(*shared);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (connectStatus) {
      res["ConnectStatus"] = boost::any(*connectStatus);
    }
    if (bindingCalcEngineId) {
      res["BindingCalcEngineId"] = boost::any(*bindingCalcEngineId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (connectionType) {
      res["ConnectionType"] = boost::any(*connectionType);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (defaultEngine) {
      res["DefaultEngine"] = boost::any(*defaultEngine);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (subType) {
      res["SubType"] = boost::any(*subType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Shared") != m.end() && !m["Shared"].empty()) {
      shared = make_shared<bool>(boost::any_cast<bool>(m["Shared"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("ConnectStatus") != m.end() && !m["ConnectStatus"].empty()) {
      connectStatus = make_shared<int>(boost::any_cast<int>(m["ConnectStatus"]));
    }
    if (m.find("BindingCalcEngineId") != m.end() && !m["BindingCalcEngineId"].empty()) {
      bindingCalcEngineId = make_shared<int>(boost::any_cast<int>(m["BindingCalcEngineId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ConnectionType") != m.end() && !m["ConnectionType"].empty()) {
      connectionType = make_shared<string>(boost::any_cast<string>(m["ConnectionType"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("DefaultEngine") != m.end() && !m["DefaultEngine"].empty()) {
      defaultEngine = make_shared<bool>(boost::any_cast<bool>(m["DefaultEngine"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<int>(boost::any_cast<int>(m["Sequence"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<int>(boost::any_cast<int>(m["EnvType"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SubType") != m.end() && !m["SubType"].empty()) {
      subType = make_shared<string>(boost::any_cast<string>(m["SubType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<int>(boost::any_cast<int>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<int>(boost::any_cast<int>(m["ProjectId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<int>(boost::any_cast<int>(m["Status"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
  }


  virtual ~ListConnectionsResponseDataConnections() = default;
};
class ListConnectionsResponseData : public Darabonba::Model {
public:
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> totalCount{};
  shared_ptr<vector<ListConnectionsResponseDataConnections>> connections{};

  ListConnectionsResponseData() {}

  explicit ListConnectionsResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageNumber) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNumber is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!totalCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("totalCount is required.")));
    }
    if (!connections) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("connections is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (connections) {
      vector<boost::any> temp1;
      for(auto item1:*connections){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Connections"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<int>(boost::any_cast<int>(m["TotalCount"]));
    }
    if (m.find("Connections") != m.end() && !m["Connections"].empty()) {
      if (typeid(vector<boost::any>) == m["Connections"].type()) {
        vector<ListConnectionsResponseDataConnections> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Connections"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListConnectionsResponseDataConnections model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        connections = make_shared<vector<ListConnectionsResponseDataConnections>>(expect1);
      }
    }
  }


  virtual ~ListConnectionsResponseData() = default;
};
class ListConnectionsResponse : public Darabonba::Model {
public:
  shared_ptr<int> httpStatusCode{};
  shared_ptr<bool> success{};
  shared_ptr<string> requestId{};
  shared_ptr<ListConnectionsResponseData> data{};

  ListConnectionsResponse() {}

  explicit ListConnectionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListConnectionsResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListConnectionsResponseData>(model1);
      }
    }
  }


  virtual ~ListConnectionsResponse() = default;
};
class UpdateConnectionRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<int> envType{};
  shared_ptr<string> content{};
  shared_ptr<string> status{};
  shared_ptr<long> connectionId{};

  UpdateConnectionRequest() {}

  explicit UpdateConnectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!connectionId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("connectionId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (connectionId) {
      res["ConnectionId"] = boost::any(*connectionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<int>(boost::any_cast<int>(m["EnvType"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("ConnectionId") != m.end() && !m["ConnectionId"].empty()) {
      connectionId = make_shared<long>(boost::any_cast<long>(m["ConnectionId"]));
    }
  }


  virtual ~UpdateConnectionRequest() = default;
};
class UpdateConnectionResponse : public Darabonba::Model {
public:
  shared_ptr<bool> success{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  UpdateConnectionResponse() {}

  explicit UpdateConnectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateConnectionResponse() = default;
};
class DeleteConnectionRequest : public Darabonba::Model {
public:
  shared_ptr<long> connectionId{};

  DeleteConnectionRequest() {}

  explicit DeleteConnectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!connectionId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("connectionId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connectionId) {
      res["ConnectionId"] = boost::any(*connectionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConnectionId") != m.end() && !m["ConnectionId"].empty()) {
      connectionId = make_shared<long>(boost::any_cast<long>(m["ConnectionId"]));
    }
  }


  virtual ~DeleteConnectionRequest() = default;
};
class DeleteConnectionResponse : public Darabonba::Model {
public:
  shared_ptr<bool> success{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  DeleteConnectionResponse() {}

  explicit DeleteConnectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteConnectionResponse() = default;
};
class GetProjectDetailRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};

  GetProjectDetailRequest() {}

  explicit GetProjectDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~GetProjectDetailRequest() = default;
};
class GetProjectDetailResponseData : public Darabonba::Model {
public:
  shared_ptr<string> gmtModified{};
  shared_ptr<string> defaultDiResourceGroupIdentifier{};
  shared_ptr<int> isAllowDownload{};
  shared_ptr<int> schedulerRetryInterval{};
  shared_ptr<string> residentArea{};
  shared_ptr<string> projectOwnerBaseId{};
  shared_ptr<int> projectMode{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<int> protectedMode{};
  shared_ptr<long> tenantId{};
  shared_ptr<string> projectDescription{};
  shared_ptr<int> schedulerMaxRetryTimes{};
  shared_ptr<string> projectName{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<int> projectId{};
  shared_ptr<int> status{};
  shared_ptr<int> developmentType{};
  shared_ptr<vector<string>> envTypes{};

  GetProjectDetailResponseData() {}

  explicit GetProjectDetailResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!gmtModified) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtModified is required.")));
    }
    if (!defaultDiResourceGroupIdentifier) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("defaultDiResourceGroupIdentifier is required.")));
    }
    if (!isAllowDownload) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("isAllowDownload is required.")));
    }
    if (!schedulerRetryInterval) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("schedulerRetryInterval is required.")));
    }
    if (!residentArea) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("residentArea is required.")));
    }
    if (!projectOwnerBaseId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectOwnerBaseId is required.")));
    }
    if (!projectMode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectMode is required.")));
    }
    if (!gmtCreate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtCreate is required.")));
    }
    if (!protectedMode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("protectedMode is required.")));
    }
    if (!tenantId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tenantId is required.")));
    }
    if (!projectDescription) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectDescription is required.")));
    }
    if (!schedulerMaxRetryTimes) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("schedulerMaxRetryTimes is required.")));
    }
    if (!projectName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectName is required.")));
    }
    if (!projectIdentifier) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectIdentifier is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!developmentType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("developmentType is required.")));
    }
    if (!envTypes) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("envTypes is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (defaultDiResourceGroupIdentifier) {
      res["DefaultDiResourceGroupIdentifier"] = boost::any(*defaultDiResourceGroupIdentifier);
    }
    if (isAllowDownload) {
      res["IsAllowDownload"] = boost::any(*isAllowDownload);
    }
    if (schedulerRetryInterval) {
      res["SchedulerRetryInterval"] = boost::any(*schedulerRetryInterval);
    }
    if (residentArea) {
      res["ResidentArea"] = boost::any(*residentArea);
    }
    if (projectOwnerBaseId) {
      res["ProjectOwnerBaseId"] = boost::any(*projectOwnerBaseId);
    }
    if (projectMode) {
      res["ProjectMode"] = boost::any(*projectMode);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (protectedMode) {
      res["ProtectedMode"] = boost::any(*protectedMode);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (projectDescription) {
      res["ProjectDescription"] = boost::any(*projectDescription);
    }
    if (schedulerMaxRetryTimes) {
      res["SchedulerMaxRetryTimes"] = boost::any(*schedulerMaxRetryTimes);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (developmentType) {
      res["DevelopmentType"] = boost::any(*developmentType);
    }
    if (envTypes) {
      res["EnvTypes"] = boost::any(*envTypes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("DefaultDiResourceGroupIdentifier") != m.end() && !m["DefaultDiResourceGroupIdentifier"].empty()) {
      defaultDiResourceGroupIdentifier = make_shared<string>(boost::any_cast<string>(m["DefaultDiResourceGroupIdentifier"]));
    }
    if (m.find("IsAllowDownload") != m.end() && !m["IsAllowDownload"].empty()) {
      isAllowDownload = make_shared<int>(boost::any_cast<int>(m["IsAllowDownload"]));
    }
    if (m.find("SchedulerRetryInterval") != m.end() && !m["SchedulerRetryInterval"].empty()) {
      schedulerRetryInterval = make_shared<int>(boost::any_cast<int>(m["SchedulerRetryInterval"]));
    }
    if (m.find("ResidentArea") != m.end() && !m["ResidentArea"].empty()) {
      residentArea = make_shared<string>(boost::any_cast<string>(m["ResidentArea"]));
    }
    if (m.find("ProjectOwnerBaseId") != m.end() && !m["ProjectOwnerBaseId"].empty()) {
      projectOwnerBaseId = make_shared<string>(boost::any_cast<string>(m["ProjectOwnerBaseId"]));
    }
    if (m.find("ProjectMode") != m.end() && !m["ProjectMode"].empty()) {
      projectMode = make_shared<int>(boost::any_cast<int>(m["ProjectMode"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("ProtectedMode") != m.end() && !m["ProtectedMode"].empty()) {
      protectedMode = make_shared<int>(boost::any_cast<int>(m["ProtectedMode"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("ProjectDescription") != m.end() && !m["ProjectDescription"].empty()) {
      projectDescription = make_shared<string>(boost::any_cast<string>(m["ProjectDescription"]));
    }
    if (m.find("SchedulerMaxRetryTimes") != m.end() && !m["SchedulerMaxRetryTimes"].empty()) {
      schedulerMaxRetryTimes = make_shared<int>(boost::any_cast<int>(m["SchedulerMaxRetryTimes"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<int>(boost::any_cast<int>(m["ProjectId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<int>(boost::any_cast<int>(m["Status"]));
    }
    if (m.find("DevelopmentType") != m.end() && !m["DevelopmentType"].empty()) {
      developmentType = make_shared<int>(boost::any_cast<int>(m["DevelopmentType"]));
    }
    if (m.find("EnvTypes") != m.end() && !m["EnvTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EnvTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EnvTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      envTypes = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetProjectDetailResponseData() = default;
};
class GetProjectDetailResponse : public Darabonba::Model {
public:
  shared_ptr<int> httpStatusCode{};
  shared_ptr<bool> success{};
  shared_ptr<string> requestId{};
  shared_ptr<GetProjectDetailResponseData> data{};

  GetProjectDetailResponse() {}

  explicit GetProjectDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetProjectDetailResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetProjectDetailResponseData>(model1);
      }
    }
  }


  virtual ~GetProjectDetailResponse() = default;
};
class ListResourceGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<int> resourceGroupType{};
  shared_ptr<string> keyword{};
  shared_ptr<string> bizExtKey{};

  ListResourceGroupsRequest() {}

  explicit ListResourceGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!resourceGroupType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("resourceGroupType is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceGroupType) {
      res["ResourceGroupType"] = boost::any(*resourceGroupType);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (bizExtKey) {
      res["BizExtKey"] = boost::any(*bizExtKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceGroupType") != m.end() && !m["ResourceGroupType"].empty()) {
      resourceGroupType = make_shared<int>(boost::any_cast<int>(m["ResourceGroupType"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("BizExtKey") != m.end() && !m["BizExtKey"].empty()) {
      bizExtKey = make_shared<string>(boost::any_cast<string>(m["BizExtKey"]));
    }
  }


  virtual ~ListResourceGroupsRequest() = default;
};
class ListResourceGroupsResponseData : public Darabonba::Model {
public:
  shared_ptr<string> identifier{};
  shared_ptr<string> cluster{};
  shared_ptr<string> bizExtKey{};
  shared_ptr<bool> enableKp{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> resourceGroupType{};
  shared_ptr<string> mode{};
  shared_ptr<int> sequence{};
  shared_ptr<bool> isDefault{};
  shared_ptr<string> createTime{};
  shared_ptr<string> name{};
  shared_ptr<long> tenantId{};
  shared_ptr<long> id{};
  shared_ptr<int> status{};
  shared_ptr<map<string, boost::any>> specs{};

  ListResourceGroupsResponseData() {}

  explicit ListResourceGroupsResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!identifier) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("identifier is required.")));
    }
    if (!cluster) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("cluster is required.")));
    }
    if (!bizExtKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("bizExtKey is required.")));
    }
    if (!enableKp) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("enableKp is required.")));
    }
    if (!updateTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("updateTime is required.")));
    }
    if (!resourceGroupType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("resourceGroupType is required.")));
    }
    if (!mode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("mode is required.")));
    }
    if (!sequence) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("sequence is required.")));
    }
    if (!isDefault) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("isDefault is required.")));
    }
    if (!createTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("createTime is required.")));
    }
    if (!name) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("name is required.")));
    }
    if (!tenantId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tenantId is required.")));
    }
    if (!id) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("id is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!specs) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("specs is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (cluster) {
      res["Cluster"] = boost::any(*cluster);
    }
    if (bizExtKey) {
      res["BizExtKey"] = boost::any(*bizExtKey);
    }
    if (enableKp) {
      res["EnableKp"] = boost::any(*enableKp);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (resourceGroupType) {
      res["ResourceGroupType"] = boost::any(*resourceGroupType);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (specs) {
      res["Specs"] = boost::any(*specs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("Cluster") != m.end() && !m["Cluster"].empty()) {
      cluster = make_shared<string>(boost::any_cast<string>(m["Cluster"]));
    }
    if (m.find("BizExtKey") != m.end() && !m["BizExtKey"].empty()) {
      bizExtKey = make_shared<string>(boost::any_cast<string>(m["BizExtKey"]));
    }
    if (m.find("EnableKp") != m.end() && !m["EnableKp"].empty()) {
      enableKp = make_shared<bool>(boost::any_cast<bool>(m["EnableKp"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("ResourceGroupType") != m.end() && !m["ResourceGroupType"].empty()) {
      resourceGroupType = make_shared<string>(boost::any_cast<string>(m["ResourceGroupType"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<int>(boost::any_cast<int>(m["Sequence"]));
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<bool>(boost::any_cast<bool>(m["IsDefault"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<int>(boost::any_cast<int>(m["Status"]));
    }
    if (m.find("Specs") != m.end() && !m["Specs"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Specs"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      specs = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~ListResourceGroupsResponseData() = default;
};
class ListResourceGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<int> httpStatusCode{};
  shared_ptr<bool> success{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListResourceGroupsResponseData>> data{};

  ListResourceGroupsResponse() {}

  explicit ListResourceGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListResourceGroupsResponseData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListResourceGroupsResponseData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListResourceGroupsResponseData>>(expect1);
      }
    }
  }


  virtual ~ListResourceGroupsResponse() = default;
};
class CreateConnectionRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};
  shared_ptr<string> connectionType{};
  shared_ptr<string> subType{};
  shared_ptr<int> envType{};
  shared_ptr<string> content{};

  CreateConnectionRequest() {}

  explicit CreateConnectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!name) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("name is required.")));
    }
    if (!connectionType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("connectionType is required.")));
    }
    if (!envType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("envType is required.")));
    }
    if (!content) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("content is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (connectionType) {
      res["ConnectionType"] = boost::any(*connectionType);
    }
    if (subType) {
      res["SubType"] = boost::any(*subType);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ConnectionType") != m.end() && !m["ConnectionType"].empty()) {
      connectionType = make_shared<string>(boost::any_cast<string>(m["ConnectionType"]));
    }
    if (m.find("SubType") != m.end() && !m["SubType"].empty()) {
      subType = make_shared<string>(boost::any_cast<string>(m["SubType"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<int>(boost::any_cast<int>(m["EnvType"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
  }


  virtual ~CreateConnectionRequest() = default;
};
class CreateConnectionResponse : public Darabonba::Model {
public:
  shared_ptr<bool> success{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<long> data{};
  shared_ptr<string> requestId{};

  CreateConnectionResponse() {}

  explicit CreateConnectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateConnectionResponse() = default;
};
class GetDataServiceApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<long> tenantId{};
  shared_ptr<long> projectId{};
  shared_ptr<long> applicationId{};

  GetDataServiceApplicationRequest() {}

  explicit GetDataServiceApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!tenantId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tenantId is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!applicationId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("applicationId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<long>(boost::any_cast<long>(m["ApplicationId"]));
    }
  }


  virtual ~GetDataServiceApplicationRequest() = default;
};
class GetDataServiceApplicationResponseData : public Darabonba::Model {
public:
  shared_ptr<string> applicationCode{};
  shared_ptr<long> applicationId{};
  shared_ptr<string> applicationKey{};
  shared_ptr<string> applicationName{};
  shared_ptr<string> applicationSecret{};
  shared_ptr<long> projectId{};

  GetDataServiceApplicationResponseData() {}

  explicit GetDataServiceApplicationResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!applicationCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("applicationCode is required.")));
    }
    if (!applicationId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("applicationId is required.")));
    }
    if (!applicationKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("applicationKey is required.")));
    }
    if (!applicationName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("applicationName is required.")));
    }
    if (!applicationSecret) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("applicationSecret is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationCode) {
      res["ApplicationCode"] = boost::any(*applicationCode);
    }
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (applicationKey) {
      res["ApplicationKey"] = boost::any(*applicationKey);
    }
    if (applicationName) {
      res["ApplicationName"] = boost::any(*applicationName);
    }
    if (applicationSecret) {
      res["ApplicationSecret"] = boost::any(*applicationSecret);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationCode") != m.end() && !m["ApplicationCode"].empty()) {
      applicationCode = make_shared<string>(boost::any_cast<string>(m["ApplicationCode"]));
    }
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<long>(boost::any_cast<long>(m["ApplicationId"]));
    }
    if (m.find("ApplicationKey") != m.end() && !m["ApplicationKey"].empty()) {
      applicationKey = make_shared<string>(boost::any_cast<string>(m["ApplicationKey"]));
    }
    if (m.find("ApplicationName") != m.end() && !m["ApplicationName"].empty()) {
      applicationName = make_shared<string>(boost::any_cast<string>(m["ApplicationName"]));
    }
    if (m.find("ApplicationSecret") != m.end() && !m["ApplicationSecret"].empty()) {
      applicationSecret = make_shared<string>(boost::any_cast<string>(m["ApplicationSecret"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~GetDataServiceApplicationResponseData() = default;
};
class GetDataServiceApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<GetDataServiceApplicationResponseData> data{};

  GetDataServiceApplicationResponse() {}

  explicit GetDataServiceApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetDataServiceApplicationResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetDataServiceApplicationResponseData>(model1);
      }
    }
  }


  virtual ~GetDataServiceApplicationResponse() = default;
};
class ListDataServiceApplicationsRequest : public Darabonba::Model {
public:
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<string> projectIdList{};
  shared_ptr<long> tenantId{};

  ListDataServiceApplicationsRequest() {}

  explicit ListDataServiceApplicationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectIdList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectIdList is required.")));
    }
    if (!tenantId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tenantId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectIdList) {
      res["ProjectIdList"] = boost::any(*projectIdList);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("ProjectIdList") != m.end() && !m["ProjectIdList"].empty()) {
      projectIdList = make_shared<string>(boost::any_cast<string>(m["ProjectIdList"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
  }


  virtual ~ListDataServiceApplicationsRequest() = default;
};
class ListDataServiceApplicationsResponseDataApplications : public Darabonba::Model {
public:
  shared_ptr<long> applicationId{};
  shared_ptr<string> applicationName{};
  shared_ptr<long> projectId{};

  ListDataServiceApplicationsResponseDataApplications() {}

  explicit ListDataServiceApplicationsResponseDataApplications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!applicationId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("applicationId is required.")));
    }
    if (!applicationName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("applicationName is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (applicationName) {
      res["ApplicationName"] = boost::any(*applicationName);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<long>(boost::any_cast<long>(m["ApplicationId"]));
    }
    if (m.find("ApplicationName") != m.end() && !m["ApplicationName"].empty()) {
      applicationName = make_shared<string>(boost::any_cast<string>(m["ApplicationName"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~ListDataServiceApplicationsResponseDataApplications() = default;
};
class ListDataServiceApplicationsResponseData : public Darabonba::Model {
public:
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> totalCount{};
  shared_ptr<vector<ListDataServiceApplicationsResponseDataApplications>> applications{};

  ListDataServiceApplicationsResponseData() {}

  explicit ListDataServiceApplicationsResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageNumber) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNumber is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!totalCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("totalCount is required.")));
    }
    if (!applications) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("applications is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (applications) {
      vector<boost::any> temp1;
      for(auto item1:*applications){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Applications"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<int>(boost::any_cast<int>(m["TotalCount"]));
    }
    if (m.find("Applications") != m.end() && !m["Applications"].empty()) {
      if (typeid(vector<boost::any>) == m["Applications"].type()) {
        vector<ListDataServiceApplicationsResponseDataApplications> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Applications"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataServiceApplicationsResponseDataApplications model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        applications = make_shared<vector<ListDataServiceApplicationsResponseDataApplications>>(expect1);
      }
    }
  }


  virtual ~ListDataServiceApplicationsResponseData() = default;
};
class ListDataServiceApplicationsResponse : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<ListDataServiceApplicationsResponseData> data{};

  ListDataServiceApplicationsResponse() {}

  explicit ListDataServiceApplicationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListDataServiceApplicationsResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListDataServiceApplicationsResponseData>(model1);
      }
    }
  }


  virtual ~ListDataServiceApplicationsResponse() = default;
};
class GetNodeOnBaselineRequest : public Darabonba::Model {
public:
  shared_ptr<long> baselineId{};

  GetNodeOnBaselineRequest() {}

  explicit GetNodeOnBaselineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!baselineId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("baselineId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
  }


  virtual ~GetNodeOnBaselineRequest() = default;
};
class GetNodeOnBaselineResponseData : public Darabonba::Model {
public:
  shared_ptr<long> nodeId{};
  shared_ptr<string> nodeName{};
  shared_ptr<string> owner{};
  shared_ptr<long> projectId{};

  GetNodeOnBaselineResponseData() {}

  explicit GetNodeOnBaselineResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!nodeId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeId is required.")));
    }
    if (!nodeName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeName is required.")));
    }
    if (!owner) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("owner is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~GetNodeOnBaselineResponseData() = default;
};
class GetNodeOnBaselineResponse : public Darabonba::Model {
public:
  shared_ptr<string> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetNodeOnBaselineResponseData>> data{};

  GetNodeOnBaselineResponse() {}

  explicit GetNodeOnBaselineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<GetNodeOnBaselineResponseData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetNodeOnBaselineResponseData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<GetNodeOnBaselineResponseData>>(expect1);
      }
    }
  }


  virtual ~GetNodeOnBaselineResponse() = default;
};
class ListBaselineConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<string> owner{};
  shared_ptr<long> projectId{};
  shared_ptr<string> priority{};
  shared_ptr<bool> useflag{};
  shared_ptr<string> baselineTypes{};
  shared_ptr<string> searchText{};

  ListBaselineConfigsRequest() {}

  explicit ListBaselineConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageNumber) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNumber is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (useflag) {
      res["Useflag"] = boost::any(*useflag);
    }
    if (baselineTypes) {
      res["BaselineTypes"] = boost::any(*baselineTypes);
    }
    if (searchText) {
      res["SearchText"] = boost::any(*searchText);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("Useflag") != m.end() && !m["Useflag"].empty()) {
      useflag = make_shared<bool>(boost::any_cast<bool>(m["Useflag"]));
    }
    if (m.find("BaselineTypes") != m.end() && !m["BaselineTypes"].empty()) {
      baselineTypes = make_shared<string>(boost::any_cast<string>(m["BaselineTypes"]));
    }
    if (m.find("SearchText") != m.end() && !m["SearchText"].empty()) {
      searchText = make_shared<string>(boost::any_cast<string>(m["SearchText"]));
    }
  }


  virtual ~ListBaselineConfigsRequest() = default;
};
class ListBaselineConfigsResponseDataBaselines : public Darabonba::Model {
public:
  shared_ptr<long> baselineId{};
  shared_ptr<int> priority{};
  shared_ptr<string> baselineName{};
  shared_ptr<string> owner{};
  shared_ptr<long> projectId{};
  shared_ptr<bool> useFlag{};
  shared_ptr<string> baselineType{};
  shared_ptr<int> expHour{};
  shared_ptr<int> expMinu{};
  shared_ptr<int> slaHour{};
  shared_ptr<int> slaMinu{};
  shared_ptr<string> hourExpDetail{};
  shared_ptr<string> hourSlaDetail{};
  shared_ptr<bool> isDefault{};

  ListBaselineConfigsResponseDataBaselines() {}

  explicit ListBaselineConfigsResponseDataBaselines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!baselineId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("baselineId is required.")));
    }
    if (!priority) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("priority is required.")));
    }
    if (!baselineName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("baselineName is required.")));
    }
    if (!owner) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("owner is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!useFlag) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("useFlag is required.")));
    }
    if (!baselineType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("baselineType is required.")));
    }
    if (!expHour) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("expHour is required.")));
    }
    if (!expMinu) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("expMinu is required.")));
    }
    if (!slaHour) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("slaHour is required.")));
    }
    if (!slaMinu) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("slaMinu is required.")));
    }
    if (!hourExpDetail) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("hourExpDetail is required.")));
    }
    if (!hourSlaDetail) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("hourSlaDetail is required.")));
    }
    if (!isDefault) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("isDefault is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (baselineName) {
      res["BaselineName"] = boost::any(*baselineName);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (useFlag) {
      res["UseFlag"] = boost::any(*useFlag);
    }
    if (baselineType) {
      res["BaselineType"] = boost::any(*baselineType);
    }
    if (expHour) {
      res["ExpHour"] = boost::any(*expHour);
    }
    if (expMinu) {
      res["ExpMinu"] = boost::any(*expMinu);
    }
    if (slaHour) {
      res["SlaHour"] = boost::any(*slaHour);
    }
    if (slaMinu) {
      res["SlaMinu"] = boost::any(*slaMinu);
    }
    if (hourExpDetail) {
      res["HourExpDetail"] = boost::any(*hourExpDetail);
    }
    if (hourSlaDetail) {
      res["HourSlaDetail"] = boost::any(*hourSlaDetail);
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<int>(boost::any_cast<int>(m["Priority"]));
    }
    if (m.find("BaselineName") != m.end() && !m["BaselineName"].empty()) {
      baselineName = make_shared<string>(boost::any_cast<string>(m["BaselineName"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("UseFlag") != m.end() && !m["UseFlag"].empty()) {
      useFlag = make_shared<bool>(boost::any_cast<bool>(m["UseFlag"]));
    }
    if (m.find("BaselineType") != m.end() && !m["BaselineType"].empty()) {
      baselineType = make_shared<string>(boost::any_cast<string>(m["BaselineType"]));
    }
    if (m.find("ExpHour") != m.end() && !m["ExpHour"].empty()) {
      expHour = make_shared<int>(boost::any_cast<int>(m["ExpHour"]));
    }
    if (m.find("ExpMinu") != m.end() && !m["ExpMinu"].empty()) {
      expMinu = make_shared<int>(boost::any_cast<int>(m["ExpMinu"]));
    }
    if (m.find("SlaHour") != m.end() && !m["SlaHour"].empty()) {
      slaHour = make_shared<int>(boost::any_cast<int>(m["SlaHour"]));
    }
    if (m.find("SlaMinu") != m.end() && !m["SlaMinu"].empty()) {
      slaMinu = make_shared<int>(boost::any_cast<int>(m["SlaMinu"]));
    }
    if (m.find("HourExpDetail") != m.end() && !m["HourExpDetail"].empty()) {
      hourExpDetail = make_shared<string>(boost::any_cast<string>(m["HourExpDetail"]));
    }
    if (m.find("HourSlaDetail") != m.end() && !m["HourSlaDetail"].empty()) {
      hourSlaDetail = make_shared<string>(boost::any_cast<string>(m["HourSlaDetail"]));
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<bool>(boost::any_cast<bool>(m["IsDefault"]));
    }
  }


  virtual ~ListBaselineConfigsResponseDataBaselines() = default;
};
class ListBaselineConfigsResponseData : public Darabonba::Model {
public:
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> totalCount{};
  shared_ptr<vector<ListBaselineConfigsResponseDataBaselines>> baselines{};

  ListBaselineConfigsResponseData() {}

  explicit ListBaselineConfigsResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageNumber) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNumber is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!totalCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("totalCount is required.")));
    }
    if (!baselines) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("baselines is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (baselines) {
      vector<boost::any> temp1;
      for(auto item1:*baselines){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Baselines"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<int>(boost::any_cast<int>(m["TotalCount"]));
    }
    if (m.find("Baselines") != m.end() && !m["Baselines"].empty()) {
      if (typeid(vector<boost::any>) == m["Baselines"].type()) {
        vector<ListBaselineConfigsResponseDataBaselines> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Baselines"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListBaselineConfigsResponseDataBaselines model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        baselines = make_shared<vector<ListBaselineConfigsResponseDataBaselines>>(expect1);
      }
    }
  }


  virtual ~ListBaselineConfigsResponseData() = default;
};
class ListBaselineConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<ListBaselineConfigsResponseData> data{};

  ListBaselineConfigsResponse() {}

  explicit ListBaselineConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListBaselineConfigsResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListBaselineConfigsResponseData>(model1);
      }
    }
  }


  virtual ~ListBaselineConfigsResponse() = default;
};
class GetMetaTableChangeLogRequest : public Darabonba::Model {
public:
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<string> tableGuid{};
  shared_ptr<string> changeType{};
  shared_ptr<string> objectType{};
  shared_ptr<string> startDate{};
  shared_ptr<string> endDate{};

  GetMetaTableChangeLogRequest() {}

  explicit GetMetaTableChangeLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!tableGuid) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tableGuid is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (changeType) {
      res["ChangeType"] = boost::any(*changeType);
    }
    if (objectType) {
      res["ObjectType"] = boost::any(*objectType);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("ChangeType") != m.end() && !m["ChangeType"].empty()) {
      changeType = make_shared<string>(boost::any_cast<string>(m["ChangeType"]));
    }
    if (m.find("ObjectType") != m.end() && !m["ObjectType"].empty()) {
      objectType = make_shared<string>(boost::any_cast<string>(m["ObjectType"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
  }


  virtual ~GetMetaTableChangeLogRequest() = default;
};
class GetMetaTableChangeLogResponseDataDataEntityList : public Darabonba::Model {
public:
  shared_ptr<string> objectType{};
  shared_ptr<long> modifiedTime{};
  shared_ptr<long> createTime{};
  shared_ptr<string> changeContent{};
  shared_ptr<string> operator_{};
  shared_ptr<string> changeType{};

  GetMetaTableChangeLogResponseDataDataEntityList() {}

  explicit GetMetaTableChangeLogResponseDataDataEntityList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!objectType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("objectType is required.")));
    }
    if (!modifiedTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("modifiedTime is required.")));
    }
    if (!createTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("createTime is required.")));
    }
    if (!changeContent) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("changeContent is required.")));
    }
    if (!operator_) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("operator is required.")));
    }
    if (!changeType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("changeType is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (objectType) {
      res["ObjectType"] = boost::any(*objectType);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (changeContent) {
      res["ChangeContent"] = boost::any(*changeContent);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (changeType) {
      res["ChangeType"] = boost::any(*changeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ObjectType") != m.end() && !m["ObjectType"].empty()) {
      objectType = make_shared<string>(boost::any_cast<string>(m["ObjectType"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<long>(boost::any_cast<long>(m["ModifiedTime"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("ChangeContent") != m.end() && !m["ChangeContent"].empty()) {
      changeContent = make_shared<string>(boost::any_cast<string>(m["ChangeContent"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("ChangeType") != m.end() && !m["ChangeType"].empty()) {
      changeType = make_shared<string>(boost::any_cast<string>(m["ChangeType"]));
    }
  }


  virtual ~GetMetaTableChangeLogResponseDataDataEntityList() = default;
};
class GetMetaTableChangeLogResponseData : public Darabonba::Model {
public:
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<GetMetaTableChangeLogResponseDataDataEntityList>> dataEntityList{};

  GetMetaTableChangeLogResponseData() {}

  explicit GetMetaTableChangeLogResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageNumber) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNumber is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!totalCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("totalCount is required.")));
    }
    if (!dataEntityList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dataEntityList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (dataEntityList) {
      vector<boost::any> temp1;
      for(auto item1:*dataEntityList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataEntityList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("DataEntityList") != m.end() && !m["DataEntityList"].empty()) {
      if (typeid(vector<boost::any>) == m["DataEntityList"].type()) {
        vector<GetMetaTableChangeLogResponseDataDataEntityList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataEntityList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMetaTableChangeLogResponseDataDataEntityList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataEntityList = make_shared<vector<GetMetaTableChangeLogResponseDataDataEntityList>>(expect1);
      }
    }
  }


  virtual ~GetMetaTableChangeLogResponseData() = default;
};
class GetMetaTableChangeLogResponse : public Darabonba::Model {
public:
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<GetMetaTableChangeLogResponseData> data{};

  GetMetaTableChangeLogResponse() {}

  explicit GetMetaTableChangeLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetMetaTableChangeLogResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetMetaTableChangeLogResponseData>(model1);
      }
    }
  }


  virtual ~GetMetaTableChangeLogResponse() = default;
};
class GetMetaTableOutputRequest : public Darabonba::Model {
public:
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<string> tableGuid{};
  shared_ptr<string> startDate{};
  shared_ptr<string> endDate{};

  GetMetaTableOutputRequest() {}

  explicit GetMetaTableOutputRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!tableGuid) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tableGuid is required.")));
    }
    if (!startDate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("startDate is required.")));
    }
    if (!endDate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("endDate is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
  }


  virtual ~GetMetaTableOutputRequest() = default;
};
class GetMetaTableOutputResponseDataDataEntityList : public Darabonba::Model {
public:
  shared_ptr<string> tableGuid{};
  shared_ptr<string> taskId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<string> waitTime{};
  shared_ptr<long> projectId{};
  shared_ptr<long> taskInstanceId{};

  GetMetaTableOutputResponseDataDataEntityList() {}

  explicit GetMetaTableOutputResponseDataDataEntityList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!tableGuid) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tableGuid is required.")));
    }
    if (!taskId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskId is required.")));
    }
    if (!startTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("startTime is required.")));
    }
    if (!endTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("endTime is required.")));
    }
    if (!waitTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("waitTime is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!taskInstanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskInstanceId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (waitTime) {
      res["WaitTime"] = boost::any(*waitTime);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (taskInstanceId) {
      res["TaskInstanceId"] = boost::any(*taskInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("WaitTime") != m.end() && !m["WaitTime"].empty()) {
      waitTime = make_shared<string>(boost::any_cast<string>(m["WaitTime"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TaskInstanceId") != m.end() && !m["TaskInstanceId"].empty()) {
      taskInstanceId = make_shared<long>(boost::any_cast<long>(m["TaskInstanceId"]));
    }
  }


  virtual ~GetMetaTableOutputResponseDataDataEntityList() = default;
};
class GetMetaTableOutputResponseData : public Darabonba::Model {
public:
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<GetMetaTableOutputResponseDataDataEntityList>> dataEntityList{};

  GetMetaTableOutputResponseData() {}

  explicit GetMetaTableOutputResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageNumber) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNumber is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!totalCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("totalCount is required.")));
    }
    if (!dataEntityList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dataEntityList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (dataEntityList) {
      vector<boost::any> temp1;
      for(auto item1:*dataEntityList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataEntityList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("DataEntityList") != m.end() && !m["DataEntityList"].empty()) {
      if (typeid(vector<boost::any>) == m["DataEntityList"].type()) {
        vector<GetMetaTableOutputResponseDataDataEntityList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataEntityList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMetaTableOutputResponseDataDataEntityList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataEntityList = make_shared<vector<GetMetaTableOutputResponseDataDataEntityList>>(expect1);
      }
    }
  }


  virtual ~GetMetaTableOutputResponseData() = default;
};
class GetMetaTableOutputResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<bool> success{};
  shared_ptr<GetMetaTableOutputResponseData> data{};

  GetMetaTableOutputResponse() {}

  explicit GetMetaTableOutputResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetMetaTableOutputResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetMetaTableOutputResponseData>(model1);
      }
    }
  }


  virtual ~GetMetaTableOutputResponse() = default;
};
class GetMetaTablePartitionRequest : public Darabonba::Model {
public:
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<string> tableGuid{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> databaseName{};
  shared_ptr<string> tableName{};
  shared_ptr<string> dataSourceType{};

  GetMetaTablePartitionRequest() {}

  explicit GetMetaTablePartitionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (dataSourceType) {
      res["DataSourceType"] = boost::any(*dataSourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("DataSourceType") != m.end() && !m["DataSourceType"].empty()) {
      dataSourceType = make_shared<string>(boost::any_cast<string>(m["DataSourceType"]));
    }
  }


  virtual ~GetMetaTablePartitionRequest() = default;
};
class GetMetaTablePartitionResponseDataDataEntityList : public Darabonba::Model {
public:
  shared_ptr<string> partitionGuid{};
  shared_ptr<string> partitionName{};
  shared_ptr<long> createTime{};
  shared_ptr<long> dataSize{};
  shared_ptr<long> recordCount{};
  shared_ptr<long> modifiedTime{};
  shared_ptr<string> tableGuid{};
  shared_ptr<string> comment{};
  shared_ptr<string> partitionType{};
  shared_ptr<string> partitionPath{};
  shared_ptr<string> partitionLocation{};

  GetMetaTablePartitionResponseDataDataEntityList() {}

  explicit GetMetaTablePartitionResponseDataDataEntityList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!partitionGuid) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("partitionGuid is required.")));
    }
    if (!partitionName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("partitionName is required.")));
    }
    if (!createTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("createTime is required.")));
    }
    if (!dataSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dataSize is required.")));
    }
    if (!recordCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("recordCount is required.")));
    }
    if (!modifiedTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("modifiedTime is required.")));
    }
    if (!tableGuid) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tableGuid is required.")));
    }
    if (!comment) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("comment is required.")));
    }
    if (!partitionType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("partitionType is required.")));
    }
    if (!partitionPath) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("partitionPath is required.")));
    }
    if (!partitionLocation) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("partitionLocation is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (partitionGuid) {
      res["PartitionGuid"] = boost::any(*partitionGuid);
    }
    if (partitionName) {
      res["PartitionName"] = boost::any(*partitionName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dataSize) {
      res["DataSize"] = boost::any(*dataSize);
    }
    if (recordCount) {
      res["RecordCount"] = boost::any(*recordCount);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (partitionType) {
      res["PartitionType"] = boost::any(*partitionType);
    }
    if (partitionPath) {
      res["PartitionPath"] = boost::any(*partitionPath);
    }
    if (partitionLocation) {
      res["PartitionLocation"] = boost::any(*partitionLocation);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PartitionGuid") != m.end() && !m["PartitionGuid"].empty()) {
      partitionGuid = make_shared<string>(boost::any_cast<string>(m["PartitionGuid"]));
    }
    if (m.find("PartitionName") != m.end() && !m["PartitionName"].empty()) {
      partitionName = make_shared<string>(boost::any_cast<string>(m["PartitionName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DataSize") != m.end() && !m["DataSize"].empty()) {
      dataSize = make_shared<long>(boost::any_cast<long>(m["DataSize"]));
    }
    if (m.find("RecordCount") != m.end() && !m["RecordCount"].empty()) {
      recordCount = make_shared<long>(boost::any_cast<long>(m["RecordCount"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<long>(boost::any_cast<long>(m["ModifiedTime"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("PartitionType") != m.end() && !m["PartitionType"].empty()) {
      partitionType = make_shared<string>(boost::any_cast<string>(m["PartitionType"]));
    }
    if (m.find("PartitionPath") != m.end() && !m["PartitionPath"].empty()) {
      partitionPath = make_shared<string>(boost::any_cast<string>(m["PartitionPath"]));
    }
    if (m.find("PartitionLocation") != m.end() && !m["PartitionLocation"].empty()) {
      partitionLocation = make_shared<string>(boost::any_cast<string>(m["PartitionLocation"]));
    }
  }


  virtual ~GetMetaTablePartitionResponseDataDataEntityList() = default;
};
class GetMetaTablePartitionResponseData : public Darabonba::Model {
public:
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<GetMetaTablePartitionResponseDataDataEntityList>> dataEntityList{};

  GetMetaTablePartitionResponseData() {}

  explicit GetMetaTablePartitionResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageNumber) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNumber is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!totalCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("totalCount is required.")));
    }
    if (!dataEntityList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dataEntityList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (dataEntityList) {
      vector<boost::any> temp1;
      for(auto item1:*dataEntityList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataEntityList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("DataEntityList") != m.end() && !m["DataEntityList"].empty()) {
      if (typeid(vector<boost::any>) == m["DataEntityList"].type()) {
        vector<GetMetaTablePartitionResponseDataDataEntityList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataEntityList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMetaTablePartitionResponseDataDataEntityList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataEntityList = make_shared<vector<GetMetaTablePartitionResponseDataDataEntityList>>(expect1);
      }
    }
  }


  virtual ~GetMetaTablePartitionResponseData() = default;
};
class GetMetaTablePartitionResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<bool> success{};
  shared_ptr<GetMetaTablePartitionResponseData> data{};

  GetMetaTablePartitionResponse() {}

  explicit GetMetaTablePartitionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetMetaTablePartitionResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetMetaTablePartitionResponseData>(model1);
      }
    }
  }


  virtual ~GetMetaTablePartitionResponse() = default;
};
class GetMetaTableFullInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> tableGuid{};
  shared_ptr<int> pageNum{};
  shared_ptr<int> pageSize{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> databaseName{};
  shared_ptr<string> tableName{};
  shared_ptr<string> dataSourceType{};

  GetMetaTableFullInfoRequest() {}

  explicit GetMetaTableFullInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (dataSourceType) {
      res["DataSourceType"] = boost::any(*dataSourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<int>(boost::any_cast<int>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("DataSourceType") != m.end() && !m["DataSourceType"].empty()) {
      dataSourceType = make_shared<string>(boost::any_cast<string>(m["DataSourceType"]));
    }
  }


  virtual ~GetMetaTableFullInfoRequest() = default;
};
class GetMetaTableFullInfoResponseDataColumnList : public Darabonba::Model {
public:
  shared_ptr<string> columnGuid{};
  shared_ptr<string> columnName{};
  shared_ptr<string> columnType{};
  shared_ptr<bool> isPrimaryKey{};
  shared_ptr<string> comment{};
  shared_ptr<bool> isPartitionColumn{};
  shared_ptr<bool> isForeignKey{};
  shared_ptr<string> caption{};
  shared_ptr<int> position{};

  GetMetaTableFullInfoResponseDataColumnList() {}

  explicit GetMetaTableFullInfoResponseDataColumnList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!columnGuid) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("columnGuid is required.")));
    }
    if (!columnName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("columnName is required.")));
    }
    if (!columnType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("columnType is required.")));
    }
    if (!isPrimaryKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("isPrimaryKey is required.")));
    }
    if (!comment) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("comment is required.")));
    }
    if (!isPartitionColumn) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("isPartitionColumn is required.")));
    }
    if (!isForeignKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("isForeignKey is required.")));
    }
    if (!caption) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("caption is required.")));
    }
    if (!position) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("position is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnGuid) {
      res["ColumnGuid"] = boost::any(*columnGuid);
    }
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (columnType) {
      res["ColumnType"] = boost::any(*columnType);
    }
    if (isPrimaryKey) {
      res["IsPrimaryKey"] = boost::any(*isPrimaryKey);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (isPartitionColumn) {
      res["IsPartitionColumn"] = boost::any(*isPartitionColumn);
    }
    if (isForeignKey) {
      res["IsForeignKey"] = boost::any(*isForeignKey);
    }
    if (caption) {
      res["Caption"] = boost::any(*caption);
    }
    if (position) {
      res["Position"] = boost::any(*position);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnGuid") != m.end() && !m["ColumnGuid"].empty()) {
      columnGuid = make_shared<string>(boost::any_cast<string>(m["ColumnGuid"]));
    }
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("ColumnType") != m.end() && !m["ColumnType"].empty()) {
      columnType = make_shared<string>(boost::any_cast<string>(m["ColumnType"]));
    }
    if (m.find("IsPrimaryKey") != m.end() && !m["IsPrimaryKey"].empty()) {
      isPrimaryKey = make_shared<bool>(boost::any_cast<bool>(m["IsPrimaryKey"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("IsPartitionColumn") != m.end() && !m["IsPartitionColumn"].empty()) {
      isPartitionColumn = make_shared<bool>(boost::any_cast<bool>(m["IsPartitionColumn"]));
    }
    if (m.find("IsForeignKey") != m.end() && !m["IsForeignKey"].empty()) {
      isForeignKey = make_shared<bool>(boost::any_cast<bool>(m["IsForeignKey"]));
    }
    if (m.find("Caption") != m.end() && !m["Caption"].empty()) {
      caption = make_shared<string>(boost::any_cast<string>(m["Caption"]));
    }
    if (m.find("Position") != m.end() && !m["Position"].empty()) {
      position = make_shared<int>(boost::any_cast<int>(m["Position"]));
    }
  }


  virtual ~GetMetaTableFullInfoResponseDataColumnList() = default;
};
class GetMetaTableFullInfoResponseData : public Darabonba::Model {
public:
  shared_ptr<string> tableName{};
  shared_ptr<string> tableGuid{};
  shared_ptr<string> ownerId{};
  shared_ptr<long> tenantId{};
  shared_ptr<long> projectId{};
  shared_ptr<long> createTime{};
  shared_ptr<long> lastModifyTime{};
  shared_ptr<int> lifeCycle{};
  shared_ptr<int> isVisible{};
  shared_ptr<string> projectName{};
  shared_ptr<long> dataSize{};
  shared_ptr<int> envType{};
  shared_ptr<string> comment{};
  shared_ptr<long> totalColumnCount{};
  shared_ptr<long> lastDdlTime{};
  shared_ptr<long> lastAccessTime{};
  shared_ptr<string> databaseName{};
  shared_ptr<string> partitionKeys{};
  shared_ptr<string> location{};
  shared_ptr<string> clusterId{};
  shared_ptr<vector<GetMetaTableFullInfoResponseDataColumnList>> columnList{};

  GetMetaTableFullInfoResponseData() {}

  explicit GetMetaTableFullInfoResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!tableName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tableName is required.")));
    }
    if (!tableGuid) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tableGuid is required.")));
    }
    if (!ownerId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ownerId is required.")));
    }
    if (!tenantId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tenantId is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!createTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("createTime is required.")));
    }
    if (!lastModifyTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("lastModifyTime is required.")));
    }
    if (!lifeCycle) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("lifeCycle is required.")));
    }
    if (!isVisible) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("isVisible is required.")));
    }
    if (!projectName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectName is required.")));
    }
    if (!dataSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dataSize is required.")));
    }
    if (!envType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("envType is required.")));
    }
    if (!comment) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("comment is required.")));
    }
    if (!totalColumnCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("totalColumnCount is required.")));
    }
    if (!lastDdlTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("lastDdlTime is required.")));
    }
    if (!lastAccessTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("lastAccessTime is required.")));
    }
    if (!databaseName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("databaseName is required.")));
    }
    if (!partitionKeys) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("partitionKeys is required.")));
    }
    if (!location) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("location is required.")));
    }
    if (!clusterId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("clusterId is required.")));
    }
    if (!columnList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("columnList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (lastModifyTime) {
      res["LastModifyTime"] = boost::any(*lastModifyTime);
    }
    if (lifeCycle) {
      res["LifeCycle"] = boost::any(*lifeCycle);
    }
    if (isVisible) {
      res["IsVisible"] = boost::any(*isVisible);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (dataSize) {
      res["DataSize"] = boost::any(*dataSize);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (totalColumnCount) {
      res["TotalColumnCount"] = boost::any(*totalColumnCount);
    }
    if (lastDdlTime) {
      res["LastDdlTime"] = boost::any(*lastDdlTime);
    }
    if (lastAccessTime) {
      res["LastAccessTime"] = boost::any(*lastAccessTime);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (partitionKeys) {
      res["PartitionKeys"] = boost::any(*partitionKeys);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (columnList) {
      vector<boost::any> temp1;
      for(auto item1:*columnList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ColumnList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("LastModifyTime") != m.end() && !m["LastModifyTime"].empty()) {
      lastModifyTime = make_shared<long>(boost::any_cast<long>(m["LastModifyTime"]));
    }
    if (m.find("LifeCycle") != m.end() && !m["LifeCycle"].empty()) {
      lifeCycle = make_shared<int>(boost::any_cast<int>(m["LifeCycle"]));
    }
    if (m.find("IsVisible") != m.end() && !m["IsVisible"].empty()) {
      isVisible = make_shared<int>(boost::any_cast<int>(m["IsVisible"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("DataSize") != m.end() && !m["DataSize"].empty()) {
      dataSize = make_shared<long>(boost::any_cast<long>(m["DataSize"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<int>(boost::any_cast<int>(m["EnvType"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("TotalColumnCount") != m.end() && !m["TotalColumnCount"].empty()) {
      totalColumnCount = make_shared<long>(boost::any_cast<long>(m["TotalColumnCount"]));
    }
    if (m.find("LastDdlTime") != m.end() && !m["LastDdlTime"].empty()) {
      lastDdlTime = make_shared<long>(boost::any_cast<long>(m["LastDdlTime"]));
    }
    if (m.find("LastAccessTime") != m.end() && !m["LastAccessTime"].empty()) {
      lastAccessTime = make_shared<long>(boost::any_cast<long>(m["LastAccessTime"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("PartitionKeys") != m.end() && !m["PartitionKeys"].empty()) {
      partitionKeys = make_shared<string>(boost::any_cast<string>(m["PartitionKeys"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ColumnList") != m.end() && !m["ColumnList"].empty()) {
      if (typeid(vector<boost::any>) == m["ColumnList"].type()) {
        vector<GetMetaTableFullInfoResponseDataColumnList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ColumnList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMetaTableFullInfoResponseDataColumnList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        columnList = make_shared<vector<GetMetaTableFullInfoResponseDataColumnList>>(expect1);
      }
    }
  }


  virtual ~GetMetaTableFullInfoResponseData() = default;
};
class GetMetaTableFullInfoResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<bool> success{};
  shared_ptr<GetMetaTableFullInfoResponseData> data{};

  GetMetaTableFullInfoResponse() {}

  explicit GetMetaTableFullInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetMetaTableFullInfoResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetMetaTableFullInfoResponseData>(model1);
      }
    }
  }


  virtual ~GetMetaTableFullInfoResponse() = default;
};
class GetFileVersionRequest : public Darabonba::Model {
public:
  shared_ptr<long> fileId{};
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<int> fileVersion{};

  GetFileVersionRequest() {}

  explicit GetFileVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!fileId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("fileId is required.")));
    }
    if (!fileVersion) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("fileVersion is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (fileVersion) {
      res["FileVersion"] = boost::any(*fileVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("FileVersion") != m.end() && !m["FileVersion"].empty()) {
      fileVersion = make_shared<int>(boost::any_cast<int>(m["FileVersion"]));
    }
  }


  virtual ~GetFileVersionRequest() = default;
};
class GetFileVersionResponseData : public Darabonba::Model {
public:
  shared_ptr<int> fileVersion{};
  shared_ptr<string> fileContent{};
  shared_ptr<string> filePropertyContent{};
  shared_ptr<string> nodeContent{};
  shared_ptr<string> comment{};
  shared_ptr<long> nodeId{};
  shared_ptr<bool> isCurrentProd{};
  shared_ptr<string> changeType{};
  shared_ptr<string> status{};
  shared_ptr<string> fileName{};
  shared_ptr<string> commitUser{};
  shared_ptr<long> commitTime{};
  shared_ptr<string> useType{};

  GetFileVersionResponseData() {}

  explicit GetFileVersionResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!fileVersion) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("fileVersion is required.")));
    }
    if (!fileContent) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("fileContent is required.")));
    }
    if (!filePropertyContent) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("filePropertyContent is required.")));
    }
    if (!nodeContent) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeContent is required.")));
    }
    if (!comment) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("comment is required.")));
    }
    if (!nodeId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeId is required.")));
    }
    if (!isCurrentProd) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("isCurrentProd is required.")));
    }
    if (!changeType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("changeType is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!fileName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("fileName is required.")));
    }
    if (!commitUser) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("commitUser is required.")));
    }
    if (!commitTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("commitTime is required.")));
    }
    if (!useType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("useType is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileVersion) {
      res["FileVersion"] = boost::any(*fileVersion);
    }
    if (fileContent) {
      res["FileContent"] = boost::any(*fileContent);
    }
    if (filePropertyContent) {
      res["FilePropertyContent"] = boost::any(*filePropertyContent);
    }
    if (nodeContent) {
      res["NodeContent"] = boost::any(*nodeContent);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (isCurrentProd) {
      res["IsCurrentProd"] = boost::any(*isCurrentProd);
    }
    if (changeType) {
      res["ChangeType"] = boost::any(*changeType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (commitUser) {
      res["CommitUser"] = boost::any(*commitUser);
    }
    if (commitTime) {
      res["CommitTime"] = boost::any(*commitTime);
    }
    if (useType) {
      res["UseType"] = boost::any(*useType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileVersion") != m.end() && !m["FileVersion"].empty()) {
      fileVersion = make_shared<int>(boost::any_cast<int>(m["FileVersion"]));
    }
    if (m.find("FileContent") != m.end() && !m["FileContent"].empty()) {
      fileContent = make_shared<string>(boost::any_cast<string>(m["FileContent"]));
    }
    if (m.find("FilePropertyContent") != m.end() && !m["FilePropertyContent"].empty()) {
      filePropertyContent = make_shared<string>(boost::any_cast<string>(m["FilePropertyContent"]));
    }
    if (m.find("NodeContent") != m.end() && !m["NodeContent"].empty()) {
      nodeContent = make_shared<string>(boost::any_cast<string>(m["NodeContent"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("IsCurrentProd") != m.end() && !m["IsCurrentProd"].empty()) {
      isCurrentProd = make_shared<bool>(boost::any_cast<bool>(m["IsCurrentProd"]));
    }
    if (m.find("ChangeType") != m.end() && !m["ChangeType"].empty()) {
      changeType = make_shared<string>(boost::any_cast<string>(m["ChangeType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("CommitUser") != m.end() && !m["CommitUser"].empty()) {
      commitUser = make_shared<string>(boost::any_cast<string>(m["CommitUser"]));
    }
    if (m.find("CommitTime") != m.end() && !m["CommitTime"].empty()) {
      commitTime = make_shared<long>(boost::any_cast<long>(m["CommitTime"]));
    }
    if (m.find("UseType") != m.end() && !m["UseType"].empty()) {
      useType = make_shared<string>(boost::any_cast<string>(m["UseType"]));
    }
  }


  virtual ~GetFileVersionResponseData() = default;
};
class GetFileVersionResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<GetFileVersionResponseData> data{};

  GetFileVersionResponse() {}

  explicit GetFileVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetFileVersionResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetFileVersionResponseData>(model1);
      }
    }
  }


  virtual ~GetFileVersionResponse() = default;
};
class GetMetaTableBasicInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> tableGuid{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> databaseName{};
  shared_ptr<string> tableName{};
  shared_ptr<string> dataSourceType{};
  shared_ptr<bool> extension{};

  GetMetaTableBasicInfoRequest() {}

  explicit GetMetaTableBasicInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (dataSourceType) {
      res["DataSourceType"] = boost::any(*dataSourceType);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("DataSourceType") != m.end() && !m["DataSourceType"].empty()) {
      dataSourceType = make_shared<string>(boost::any_cast<string>(m["DataSourceType"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<bool>(boost::any_cast<bool>(m["Extension"]));
    }
  }


  virtual ~GetMetaTableBasicInfoRequest() = default;
};
class GetMetaTableBasicInfoResponseData : public Darabonba::Model {
public:
  shared_ptr<string> tableName{};
  shared_ptr<string> tableGuid{};
  shared_ptr<string> ownerId{};
  shared_ptr<long> tenantId{};
  shared_ptr<long> projectId{};
  shared_ptr<long> createTime{};
  shared_ptr<long> lastModifyTime{};
  shared_ptr<int> lifeCycle{};
  shared_ptr<int> isVisible{};
  shared_ptr<long> lastDdlTime{};
  shared_ptr<long> lastAccessTime{};
  shared_ptr<int> envType{};
  shared_ptr<long> dataSize{};
  shared_ptr<string> comment{};
  shared_ptr<string> projectName{};
  shared_ptr<string> databaseName{};
  shared_ptr<string> partitionKeys{};
  shared_ptr<string> location{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> caption{};
  shared_ptr<bool> isPartitionTable{};
  shared_ptr<long> readCount{};
  shared_ptr<long> viewCount{};
  shared_ptr<long> favoriteCount{};
  shared_ptr<bool> isView{};
  shared_ptr<int> columnCount{};

  GetMetaTableBasicInfoResponseData() {}

  explicit GetMetaTableBasicInfoResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!tableName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tableName is required.")));
    }
    if (!tableGuid) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tableGuid is required.")));
    }
    if (!ownerId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ownerId is required.")));
    }
    if (!tenantId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tenantId is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!createTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("createTime is required.")));
    }
    if (!lastModifyTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("lastModifyTime is required.")));
    }
    if (!lifeCycle) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("lifeCycle is required.")));
    }
    if (!isVisible) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("isVisible is required.")));
    }
    if (!lastDdlTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("lastDdlTime is required.")));
    }
    if (!lastAccessTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("lastAccessTime is required.")));
    }
    if (!envType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("envType is required.")));
    }
    if (!dataSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dataSize is required.")));
    }
    if (!comment) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("comment is required.")));
    }
    if (!projectName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectName is required.")));
    }
    if (!databaseName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("databaseName is required.")));
    }
    if (!partitionKeys) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("partitionKeys is required.")));
    }
    if (!location) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("location is required.")));
    }
    if (!clusterId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("clusterId is required.")));
    }
    if (!caption) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("caption is required.")));
    }
    if (!isPartitionTable) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("isPartitionTable is required.")));
    }
    if (!readCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("readCount is required.")));
    }
    if (!viewCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("viewCount is required.")));
    }
    if (!favoriteCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("favoriteCount is required.")));
    }
    if (!isView) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("isView is required.")));
    }
    if (!columnCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("columnCount is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (lastModifyTime) {
      res["LastModifyTime"] = boost::any(*lastModifyTime);
    }
    if (lifeCycle) {
      res["LifeCycle"] = boost::any(*lifeCycle);
    }
    if (isVisible) {
      res["IsVisible"] = boost::any(*isVisible);
    }
    if (lastDdlTime) {
      res["LastDdlTime"] = boost::any(*lastDdlTime);
    }
    if (lastAccessTime) {
      res["LastAccessTime"] = boost::any(*lastAccessTime);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (dataSize) {
      res["DataSize"] = boost::any(*dataSize);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (partitionKeys) {
      res["PartitionKeys"] = boost::any(*partitionKeys);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (caption) {
      res["Caption"] = boost::any(*caption);
    }
    if (isPartitionTable) {
      res["IsPartitionTable"] = boost::any(*isPartitionTable);
    }
    if (readCount) {
      res["ReadCount"] = boost::any(*readCount);
    }
    if (viewCount) {
      res["ViewCount"] = boost::any(*viewCount);
    }
    if (favoriteCount) {
      res["FavoriteCount"] = boost::any(*favoriteCount);
    }
    if (isView) {
      res["IsView"] = boost::any(*isView);
    }
    if (columnCount) {
      res["ColumnCount"] = boost::any(*columnCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("LastModifyTime") != m.end() && !m["LastModifyTime"].empty()) {
      lastModifyTime = make_shared<long>(boost::any_cast<long>(m["LastModifyTime"]));
    }
    if (m.find("LifeCycle") != m.end() && !m["LifeCycle"].empty()) {
      lifeCycle = make_shared<int>(boost::any_cast<int>(m["LifeCycle"]));
    }
    if (m.find("IsVisible") != m.end() && !m["IsVisible"].empty()) {
      isVisible = make_shared<int>(boost::any_cast<int>(m["IsVisible"]));
    }
    if (m.find("LastDdlTime") != m.end() && !m["LastDdlTime"].empty()) {
      lastDdlTime = make_shared<long>(boost::any_cast<long>(m["LastDdlTime"]));
    }
    if (m.find("LastAccessTime") != m.end() && !m["LastAccessTime"].empty()) {
      lastAccessTime = make_shared<long>(boost::any_cast<long>(m["LastAccessTime"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<int>(boost::any_cast<int>(m["EnvType"]));
    }
    if (m.find("DataSize") != m.end() && !m["DataSize"].empty()) {
      dataSize = make_shared<long>(boost::any_cast<long>(m["DataSize"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("PartitionKeys") != m.end() && !m["PartitionKeys"].empty()) {
      partitionKeys = make_shared<string>(boost::any_cast<string>(m["PartitionKeys"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Caption") != m.end() && !m["Caption"].empty()) {
      caption = make_shared<string>(boost::any_cast<string>(m["Caption"]));
    }
    if (m.find("IsPartitionTable") != m.end() && !m["IsPartitionTable"].empty()) {
      isPartitionTable = make_shared<bool>(boost::any_cast<bool>(m["IsPartitionTable"]));
    }
    if (m.find("ReadCount") != m.end() && !m["ReadCount"].empty()) {
      readCount = make_shared<long>(boost::any_cast<long>(m["ReadCount"]));
    }
    if (m.find("ViewCount") != m.end() && !m["ViewCount"].empty()) {
      viewCount = make_shared<long>(boost::any_cast<long>(m["ViewCount"]));
    }
    if (m.find("FavoriteCount") != m.end() && !m["FavoriteCount"].empty()) {
      favoriteCount = make_shared<long>(boost::any_cast<long>(m["FavoriteCount"]));
    }
    if (m.find("IsView") != m.end() && !m["IsView"].empty()) {
      isView = make_shared<bool>(boost::any_cast<bool>(m["IsView"]));
    }
    if (m.find("ColumnCount") != m.end() && !m["ColumnCount"].empty()) {
      columnCount = make_shared<int>(boost::any_cast<int>(m["ColumnCount"]));
    }
  }


  virtual ~GetMetaTableBasicInfoResponseData() = default;
};
class GetMetaTableBasicInfoResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<bool> success{};
  shared_ptr<GetMetaTableBasicInfoResponseData> data{};

  GetMetaTableBasicInfoResponse() {}

  explicit GetMetaTableBasicInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetMetaTableBasicInfoResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetMetaTableBasicInfoResponseData>(model1);
      }
    }
  }


  virtual ~GetMetaTableBasicInfoResponse() = default;
};
class GetMetaTableColumnRequest : public Darabonba::Model {
public:
  shared_ptr<string> tableGuid{};
  shared_ptr<int> pageNum{};
  shared_ptr<int> pageSize{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> databaseName{};
  shared_ptr<string> tableName{};
  shared_ptr<string> dataSourceType{};

  GetMetaTableColumnRequest() {}

  explicit GetMetaTableColumnRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (dataSourceType) {
      res["DataSourceType"] = boost::any(*dataSourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<int>(boost::any_cast<int>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("DataSourceType") != m.end() && !m["DataSourceType"].empty()) {
      dataSourceType = make_shared<string>(boost::any_cast<string>(m["DataSourceType"]));
    }
  }


  virtual ~GetMetaTableColumnRequest() = default;
};
class GetMetaTableColumnResponseDataColumnList : public Darabonba::Model {
public:
  shared_ptr<string> columnName{};
  shared_ptr<string> columnGuid{};
  shared_ptr<string> comment{};
  shared_ptr<bool> isPrimaryKey{};
  shared_ptr<string> columnType{};
  shared_ptr<bool> isPartitionColumn{};
  shared_ptr<bool> isForeignKey{};
  shared_ptr<string> caption{};
  shared_ptr<int> position{};

  GetMetaTableColumnResponseDataColumnList() {}

  explicit GetMetaTableColumnResponseDataColumnList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!columnName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("columnName is required.")));
    }
    if (!columnGuid) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("columnGuid is required.")));
    }
    if (!comment) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("comment is required.")));
    }
    if (!isPrimaryKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("isPrimaryKey is required.")));
    }
    if (!columnType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("columnType is required.")));
    }
    if (!isPartitionColumn) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("isPartitionColumn is required.")));
    }
    if (!isForeignKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("isForeignKey is required.")));
    }
    if (!caption) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("caption is required.")));
    }
    if (!position) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("position is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (columnGuid) {
      res["ColumnGuid"] = boost::any(*columnGuid);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (isPrimaryKey) {
      res["IsPrimaryKey"] = boost::any(*isPrimaryKey);
    }
    if (columnType) {
      res["ColumnType"] = boost::any(*columnType);
    }
    if (isPartitionColumn) {
      res["IsPartitionColumn"] = boost::any(*isPartitionColumn);
    }
    if (isForeignKey) {
      res["IsForeignKey"] = boost::any(*isForeignKey);
    }
    if (caption) {
      res["Caption"] = boost::any(*caption);
    }
    if (position) {
      res["Position"] = boost::any(*position);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("ColumnGuid") != m.end() && !m["ColumnGuid"].empty()) {
      columnGuid = make_shared<string>(boost::any_cast<string>(m["ColumnGuid"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("IsPrimaryKey") != m.end() && !m["IsPrimaryKey"].empty()) {
      isPrimaryKey = make_shared<bool>(boost::any_cast<bool>(m["IsPrimaryKey"]));
    }
    if (m.find("ColumnType") != m.end() && !m["ColumnType"].empty()) {
      columnType = make_shared<string>(boost::any_cast<string>(m["ColumnType"]));
    }
    if (m.find("IsPartitionColumn") != m.end() && !m["IsPartitionColumn"].empty()) {
      isPartitionColumn = make_shared<bool>(boost::any_cast<bool>(m["IsPartitionColumn"]));
    }
    if (m.find("IsForeignKey") != m.end() && !m["IsForeignKey"].empty()) {
      isForeignKey = make_shared<bool>(boost::any_cast<bool>(m["IsForeignKey"]));
    }
    if (m.find("Caption") != m.end() && !m["Caption"].empty()) {
      caption = make_shared<string>(boost::any_cast<string>(m["Caption"]));
    }
    if (m.find("Position") != m.end() && !m["Position"].empty()) {
      position = make_shared<int>(boost::any_cast<int>(m["Position"]));
    }
  }


  virtual ~GetMetaTableColumnResponseDataColumnList() = default;
};
class GetMetaTableColumnResponseData : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<int> pageNum{};
  shared_ptr<int> pageSize{};
  shared_ptr<vector<GetMetaTableColumnResponseDataColumnList>> columnList{};

  GetMetaTableColumnResponseData() {}

  explicit GetMetaTableColumnResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!totalCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("totalCount is required.")));
    }
    if (!pageNum) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNum is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!columnList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("columnList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (columnList) {
      vector<boost::any> temp1;
      for(auto item1:*columnList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ColumnList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<int>(boost::any_cast<int>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("ColumnList") != m.end() && !m["ColumnList"].empty()) {
      if (typeid(vector<boost::any>) == m["ColumnList"].type()) {
        vector<GetMetaTableColumnResponseDataColumnList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ColumnList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMetaTableColumnResponseDataColumnList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        columnList = make_shared<vector<GetMetaTableColumnResponseDataColumnList>>(expect1);
      }
    }
  }


  virtual ~GetMetaTableColumnResponseData() = default;
};
class GetMetaTableColumnResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<bool> success{};
  shared_ptr<GetMetaTableColumnResponseData> data{};

  GetMetaTableColumnResponse() {}

  explicit GetMetaTableColumnResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetMetaTableColumnResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetMetaTableColumnResponseData>(model1);
      }
    }
  }


  virtual ~GetMetaTableColumnResponse() = default;
};
class GetMetaDBInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> appGuid{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> databaseName{};
  shared_ptr<string> dataSourceType{};

  GetMetaDBInfoRequest() {}

  explicit GetMetaDBInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appGuid) {
      res["AppGuid"] = boost::any(*appGuid);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (dataSourceType) {
      res["DataSourceType"] = boost::any(*dataSourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppGuid") != m.end() && !m["AppGuid"].empty()) {
      appGuid = make_shared<string>(boost::any_cast<string>(m["AppGuid"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("DataSourceType") != m.end() && !m["DataSourceType"].empty()) {
      dataSourceType = make_shared<string>(boost::any_cast<string>(m["DataSourceType"]));
    }
  }


  virtual ~GetMetaDBInfoRequest() = default;
};
class GetMetaDBInfoResponseData : public Darabonba::Model {
public:
  shared_ptr<string> appGuid{};
  shared_ptr<long> tenantId{};
  shared_ptr<string> endpoint{};
  shared_ptr<long> projectId{};
  shared_ptr<int> envType{};
  shared_ptr<string> projectName{};
  shared_ptr<string> projectNameCn{};
  shared_ptr<long> createTime{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> ownerName{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> comment{};
  shared_ptr<string> location{};
  shared_ptr<string> clusterBizId{};

  GetMetaDBInfoResponseData() {}

  explicit GetMetaDBInfoResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!appGuid) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("appGuid is required.")));
    }
    if (!tenantId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tenantId is required.")));
    }
    if (!endpoint) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("endpoint is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!envType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("envType is required.")));
    }
    if (!projectName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectName is required.")));
    }
    if (!projectNameCn) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectNameCn is required.")));
    }
    if (!createTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("createTime is required.")));
    }
    if (!modifyTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("modifyTime is required.")));
    }
    if (!ownerId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ownerId is required.")));
    }
    if (!ownerName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ownerName is required.")));
    }
    if (!name) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("name is required.")));
    }
    if (!type) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("type is required.")));
    }
    if (!comment) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("comment is required.")));
    }
    if (!location) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("location is required.")));
    }
    if (!clusterBizId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("clusterBizId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appGuid) {
      res["AppGuid"] = boost::any(*appGuid);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (projectNameCn) {
      res["ProjectNameCn"] = boost::any(*projectNameCn);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (ownerName) {
      res["OwnerName"] = boost::any(*ownerName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (clusterBizId) {
      res["ClusterBizId"] = boost::any(*clusterBizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppGuid") != m.end() && !m["AppGuid"].empty()) {
      appGuid = make_shared<string>(boost::any_cast<string>(m["AppGuid"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<int>(boost::any_cast<int>(m["EnvType"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("ProjectNameCn") != m.end() && !m["ProjectNameCn"].empty()) {
      projectNameCn = make_shared<string>(boost::any_cast<string>(m["ProjectNameCn"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("OwnerName") != m.end() && !m["OwnerName"].empty()) {
      ownerName = make_shared<string>(boost::any_cast<string>(m["OwnerName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("ClusterBizId") != m.end() && !m["ClusterBizId"].empty()) {
      clusterBizId = make_shared<string>(boost::any_cast<string>(m["ClusterBizId"]));
    }
  }


  virtual ~GetMetaDBInfoResponseData() = default;
};
class GetMetaDBInfoResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetMetaDBInfoResponseData> data{};

  GetMetaDBInfoResponse() {}

  explicit GetMetaDBInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetMetaDBInfoResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetMetaDBInfoResponseData>(model1);
      }
    }
  }


  virtual ~GetMetaDBInfoResponse() = default;
};
class GetMetaCategoryRequest : public Darabonba::Model {
public:
  shared_ptr<long> parentCategoryId{};
  shared_ptr<int> pageNum{};
  shared_ptr<int> pageSize{};

  GetMetaCategoryRequest() {}

  explicit GetMetaCategoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parentCategoryId) {
      res["ParentCategoryId"] = boost::any(*parentCategoryId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParentCategoryId") != m.end() && !m["ParentCategoryId"].empty()) {
      parentCategoryId = make_shared<long>(boost::any_cast<long>(m["ParentCategoryId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<int>(boost::any_cast<int>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
  }


  virtual ~GetMetaCategoryRequest() = default;
};
class GetMetaCategoryResponseDataDataEntityList : public Darabonba::Model {
public:
  shared_ptr<long> categoryId{};
  shared_ptr<string> name{};
  shared_ptr<long> createTime{};
  shared_ptr<long> modifiedTime{};
  shared_ptr<string> comment{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> lastOperatorId{};
  shared_ptr<long> parentCategoryId{};
  shared_ptr<int> depth{};

  GetMetaCategoryResponseDataDataEntityList() {}

  explicit GetMetaCategoryResponseDataDataEntityList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!categoryId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("categoryId is required.")));
    }
    if (!name) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("name is required.")));
    }
    if (!createTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("createTime is required.")));
    }
    if (!modifiedTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("modifiedTime is required.")));
    }
    if (!comment) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("comment is required.")));
    }
    if (!ownerId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ownerId is required.")));
    }
    if (!lastOperatorId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("lastOperatorId is required.")));
    }
    if (!parentCategoryId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parentCategoryId is required.")));
    }
    if (!depth) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("depth is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (lastOperatorId) {
      res["LastOperatorId"] = boost::any(*lastOperatorId);
    }
    if (parentCategoryId) {
      res["ParentCategoryId"] = boost::any(*parentCategoryId);
    }
    if (depth) {
      res["Depth"] = boost::any(*depth);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<long>(boost::any_cast<long>(m["CategoryId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<long>(boost::any_cast<long>(m["ModifiedTime"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("LastOperatorId") != m.end() && !m["LastOperatorId"].empty()) {
      lastOperatorId = make_shared<string>(boost::any_cast<string>(m["LastOperatorId"]));
    }
    if (m.find("ParentCategoryId") != m.end() && !m["ParentCategoryId"].empty()) {
      parentCategoryId = make_shared<long>(boost::any_cast<long>(m["ParentCategoryId"]));
    }
    if (m.find("Depth") != m.end() && !m["Depth"].empty()) {
      depth = make_shared<int>(boost::any_cast<int>(m["Depth"]));
    }
  }


  virtual ~GetMetaCategoryResponseDataDataEntityList() = default;
};
class GetMetaCategoryResponseData : public Darabonba::Model {
public:
  shared_ptr<int> pageNum{};
  shared_ptr<int> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<GetMetaCategoryResponseDataDataEntityList>> dataEntityList{};

  GetMetaCategoryResponseData() {}

  explicit GetMetaCategoryResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageNum) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNum is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!totalCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("totalCount is required.")));
    }
    if (!dataEntityList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dataEntityList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (dataEntityList) {
      vector<boost::any> temp1;
      for(auto item1:*dataEntityList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataEntityList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<int>(boost::any_cast<int>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("DataEntityList") != m.end() && !m["DataEntityList"].empty()) {
      if (typeid(vector<boost::any>) == m["DataEntityList"].type()) {
        vector<GetMetaCategoryResponseDataDataEntityList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataEntityList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMetaCategoryResponseDataDataEntityList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataEntityList = make_shared<vector<GetMetaCategoryResponseDataDataEntityList>>(expect1);
      }
    }
  }


  virtual ~GetMetaCategoryResponseData() = default;
};
class GetMetaCategoryResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<bool> success{};
  shared_ptr<GetMetaCategoryResponseData> data{};

  GetMetaCategoryResponse() {}

  explicit GetMetaCategoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetMetaCategoryResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetMetaCategoryResponseData>(model1);
      }
    }
  }


  virtual ~GetMetaCategoryResponse() = default;
};
class ListAlertMessagesRequest : public Darabonba::Model {
public:
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<string> beginTime{};
  shared_ptr<string> endTime{};
  shared_ptr<long> remindId{};
  shared_ptr<string> alertMethods{};
  shared_ptr<string> alertUser{};
  shared_ptr<string> alertRuleTypes{};

  ListAlertMessagesRequest() {}

  explicit ListAlertMessagesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageNumber) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNumber is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!beginTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("beginTime is required.")));
    }
    if (!endTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("endTime is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (beginTime) {
      res["BeginTime"] = boost::any(*beginTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (remindId) {
      res["RemindId"] = boost::any(*remindId);
    }
    if (alertMethods) {
      res["AlertMethods"] = boost::any(*alertMethods);
    }
    if (alertUser) {
      res["AlertUser"] = boost::any(*alertUser);
    }
    if (alertRuleTypes) {
      res["AlertRuleTypes"] = boost::any(*alertRuleTypes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("BeginTime") != m.end() && !m["BeginTime"].empty()) {
      beginTime = make_shared<string>(boost::any_cast<string>(m["BeginTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RemindId") != m.end() && !m["RemindId"].empty()) {
      remindId = make_shared<long>(boost::any_cast<long>(m["RemindId"]));
    }
    if (m.find("AlertMethods") != m.end() && !m["AlertMethods"].empty()) {
      alertMethods = make_shared<string>(boost::any_cast<string>(m["AlertMethods"]));
    }
    if (m.find("AlertUser") != m.end() && !m["AlertUser"].empty()) {
      alertUser = make_shared<string>(boost::any_cast<string>(m["AlertUser"]));
    }
    if (m.find("AlertRuleTypes") != m.end() && !m["AlertRuleTypes"].empty()) {
      alertRuleTypes = make_shared<string>(boost::any_cast<string>(m["AlertRuleTypes"]));
    }
  }


  virtual ~ListAlertMessagesRequest() = default;
};
class ListAlertMessagesResponseDataAlertMessagesInstances : public Darabonba::Model {
public:
  shared_ptr<long> nodeId{};
  shared_ptr<string> nodeName{};
  shared_ptr<long> projectId{};
  shared_ptr<string> status{};
  shared_ptr<long> instanceId{};

  ListAlertMessagesResponseDataAlertMessagesInstances() {}

  explicit ListAlertMessagesResponseDataAlertMessagesInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!nodeId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeId is required.")));
    }
    if (!nodeName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeName is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
  }


  virtual ~ListAlertMessagesResponseDataAlertMessagesInstances() = default;
};
class ListAlertMessagesResponseDataAlertMessagesTopics : public Darabonba::Model {
public:
  shared_ptr<long> nodeId{};
  shared_ptr<long> instanceId{};
  shared_ptr<long> topicId{};
  shared_ptr<string> topicName{};
  shared_ptr<string> topicOwner{};
  shared_ptr<string> topicStatus{};

  ListAlertMessagesResponseDataAlertMessagesTopics() {}

  explicit ListAlertMessagesResponseDataAlertMessagesTopics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!nodeId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeId is required.")));
    }
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
    if (!topicId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("topicId is required.")));
    }
    if (!topicName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("topicName is required.")));
    }
    if (!topicOwner) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("topicOwner is required.")));
    }
    if (!topicStatus) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("topicStatus is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (topicId) {
      res["TopicId"] = boost::any(*topicId);
    }
    if (topicName) {
      res["TopicName"] = boost::any(*topicName);
    }
    if (topicOwner) {
      res["TopicOwner"] = boost::any(*topicOwner);
    }
    if (topicStatus) {
      res["TopicStatus"] = boost::any(*topicStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("TopicId") != m.end() && !m["TopicId"].empty()) {
      topicId = make_shared<long>(boost::any_cast<long>(m["TopicId"]));
    }
    if (m.find("TopicName") != m.end() && !m["TopicName"].empty()) {
      topicName = make_shared<string>(boost::any_cast<string>(m["TopicName"]));
    }
    if (m.find("TopicOwner") != m.end() && !m["TopicOwner"].empty()) {
      topicOwner = make_shared<string>(boost::any_cast<string>(m["TopicOwner"]));
    }
    if (m.find("TopicStatus") != m.end() && !m["TopicStatus"].empty()) {
      topicStatus = make_shared<string>(boost::any_cast<string>(m["TopicStatus"]));
    }
  }


  virtual ~ListAlertMessagesResponseDataAlertMessagesTopics() = default;
};
class ListAlertMessagesResponseDataAlertMessagesNodes : public Darabonba::Model {
public:
  shared_ptr<long> nodeId{};
  shared_ptr<string> nodeName{};
  shared_ptr<string> owner{};
  shared_ptr<long> projectId{};

  ListAlertMessagesResponseDataAlertMessagesNodes() {}

  explicit ListAlertMessagesResponseDataAlertMessagesNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!nodeId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeId is required.")));
    }
    if (!nodeName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeName is required.")));
    }
    if (!owner) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("owner is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~ListAlertMessagesResponseDataAlertMessagesNodes() = default;
};
class ListAlertMessagesResponseDataAlertMessagesSlaAlert : public Darabonba::Model {
public:
  shared_ptr<long> baselineId{};
  shared_ptr<string> baselineName{};
  shared_ptr<string> baselineOwner{};
  shared_ptr<long> bizdate{};
  shared_ptr<int> inGroupId{};
  shared_ptr<long> projectId{};
  shared_ptr<string> status{};

  ListAlertMessagesResponseDataAlertMessagesSlaAlert() {}

  explicit ListAlertMessagesResponseDataAlertMessagesSlaAlert(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!baselineId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("baselineId is required.")));
    }
    if (!baselineName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("baselineName is required.")));
    }
    if (!baselineOwner) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("baselineOwner is required.")));
    }
    if (!bizdate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("bizdate is required.")));
    }
    if (!inGroupId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("inGroupId is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (baselineName) {
      res["BaselineName"] = boost::any(*baselineName);
    }
    if (baselineOwner) {
      res["BaselineOwner"] = boost::any(*baselineOwner);
    }
    if (bizdate) {
      res["Bizdate"] = boost::any(*bizdate);
    }
    if (inGroupId) {
      res["InGroupId"] = boost::any(*inGroupId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("BaselineName") != m.end() && !m["BaselineName"].empty()) {
      baselineName = make_shared<string>(boost::any_cast<string>(m["BaselineName"]));
    }
    if (m.find("BaselineOwner") != m.end() && !m["BaselineOwner"].empty()) {
      baselineOwner = make_shared<string>(boost::any_cast<string>(m["BaselineOwner"]));
    }
    if (m.find("Bizdate") != m.end() && !m["Bizdate"].empty()) {
      bizdate = make_shared<long>(boost::any_cast<long>(m["Bizdate"]));
    }
    if (m.find("InGroupId") != m.end() && !m["InGroupId"].empty()) {
      inGroupId = make_shared<int>(boost::any_cast<int>(m["InGroupId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListAlertMessagesResponseDataAlertMessagesSlaAlert() = default;
};
class ListAlertMessagesResponseDataAlertMessages : public Darabonba::Model {
public:
  shared_ptr<long> alertId{};
  shared_ptr<long> alertTime{};
  shared_ptr<string> source{};
  shared_ptr<long> remindId{};
  shared_ptr<string> remindName{};
  shared_ptr<string> alertUser{};
  shared_ptr<string> alertMethod{};
  shared_ptr<string> alertMessageStatus{};
  shared_ptr<string> content{};
  shared_ptr<vector<ListAlertMessagesResponseDataAlertMessagesInstances>> instances{};
  shared_ptr<vector<ListAlertMessagesResponseDataAlertMessagesTopics>> topics{};
  shared_ptr<vector<ListAlertMessagesResponseDataAlertMessagesNodes>> nodes{};
  shared_ptr<ListAlertMessagesResponseDataAlertMessagesSlaAlert> slaAlert{};

  ListAlertMessagesResponseDataAlertMessages() {}

  explicit ListAlertMessagesResponseDataAlertMessages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!alertId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("alertId is required.")));
    }
    if (!alertTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("alertTime is required.")));
    }
    if (!source) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("source is required.")));
    }
    if (!remindId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("remindId is required.")));
    }
    if (!remindName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("remindName is required.")));
    }
    if (!alertUser) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("alertUser is required.")));
    }
    if (!alertMethod) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("alertMethod is required.")));
    }
    if (!alertMessageStatus) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("alertMessageStatus is required.")));
    }
    if (!content) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("content is required.")));
    }
    if (!instances) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instances is required.")));
    }
    if (!topics) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("topics is required.")));
    }
    if (!nodes) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodes is required.")));
    }
    if (!slaAlert) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("slaAlert is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertId) {
      res["AlertId"] = boost::any(*alertId);
    }
    if (alertTime) {
      res["AlertTime"] = boost::any(*alertTime);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (remindId) {
      res["RemindId"] = boost::any(*remindId);
    }
    if (remindName) {
      res["RemindName"] = boost::any(*remindName);
    }
    if (alertUser) {
      res["AlertUser"] = boost::any(*alertUser);
    }
    if (alertMethod) {
      res["AlertMethod"] = boost::any(*alertMethod);
    }
    if (alertMessageStatus) {
      res["AlertMessageStatus"] = boost::any(*alertMessageStatus);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (instances) {
      vector<boost::any> temp1;
      for(auto item1:*instances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Instances"] = boost::any(temp1);
    }
    if (topics) {
      vector<boost::any> temp1;
      for(auto item1:*topics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Topics"] = boost::any(temp1);
    }
    if (nodes) {
      vector<boost::any> temp1;
      for(auto item1:*nodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Nodes"] = boost::any(temp1);
    }
    if (slaAlert) {
      res["SlaAlert"] = slaAlert ? boost::any(slaAlert->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertId") != m.end() && !m["AlertId"].empty()) {
      alertId = make_shared<long>(boost::any_cast<long>(m["AlertId"]));
    }
    if (m.find("AlertTime") != m.end() && !m["AlertTime"].empty()) {
      alertTime = make_shared<long>(boost::any_cast<long>(m["AlertTime"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("RemindId") != m.end() && !m["RemindId"].empty()) {
      remindId = make_shared<long>(boost::any_cast<long>(m["RemindId"]));
    }
    if (m.find("RemindName") != m.end() && !m["RemindName"].empty()) {
      remindName = make_shared<string>(boost::any_cast<string>(m["RemindName"]));
    }
    if (m.find("AlertUser") != m.end() && !m["AlertUser"].empty()) {
      alertUser = make_shared<string>(boost::any_cast<string>(m["AlertUser"]));
    }
    if (m.find("AlertMethod") != m.end() && !m["AlertMethod"].empty()) {
      alertMethod = make_shared<string>(boost::any_cast<string>(m["AlertMethod"]));
    }
    if (m.find("AlertMessageStatus") != m.end() && !m["AlertMessageStatus"].empty()) {
      alertMessageStatus = make_shared<string>(boost::any_cast<string>(m["AlertMessageStatus"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      if (typeid(vector<boost::any>) == m["Instances"].type()) {
        vector<ListAlertMessagesResponseDataAlertMessagesInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Instances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAlertMessagesResponseDataAlertMessagesInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instances = make_shared<vector<ListAlertMessagesResponseDataAlertMessagesInstances>>(expect1);
      }
    }
    if (m.find("Topics") != m.end() && !m["Topics"].empty()) {
      if (typeid(vector<boost::any>) == m["Topics"].type()) {
        vector<ListAlertMessagesResponseDataAlertMessagesTopics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Topics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAlertMessagesResponseDataAlertMessagesTopics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        topics = make_shared<vector<ListAlertMessagesResponseDataAlertMessagesTopics>>(expect1);
      }
    }
    if (m.find("Nodes") != m.end() && !m["Nodes"].empty()) {
      if (typeid(vector<boost::any>) == m["Nodes"].type()) {
        vector<ListAlertMessagesResponseDataAlertMessagesNodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Nodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAlertMessagesResponseDataAlertMessagesNodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodes = make_shared<vector<ListAlertMessagesResponseDataAlertMessagesNodes>>(expect1);
      }
    }
    if (m.find("SlaAlert") != m.end() && !m["SlaAlert"].empty()) {
      if (typeid(map<string, boost::any>) == m["SlaAlert"].type()) {
        ListAlertMessagesResponseDataAlertMessagesSlaAlert model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SlaAlert"]));
        slaAlert = make_shared<ListAlertMessagesResponseDataAlertMessagesSlaAlert>(model1);
      }
    }
  }


  virtual ~ListAlertMessagesResponseDataAlertMessages() = default;
};
class ListAlertMessagesResponseData : public Darabonba::Model {
public:
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> totalCount{};
  shared_ptr<vector<ListAlertMessagesResponseDataAlertMessages>> alertMessages{};

  ListAlertMessagesResponseData() {}

  explicit ListAlertMessagesResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageNumber) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNumber is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!totalCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("totalCount is required.")));
    }
    if (!alertMessages) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("alertMessages is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (alertMessages) {
      vector<boost::any> temp1;
      for(auto item1:*alertMessages){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlertMessages"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<string>(boost::any_cast<string>(m["TotalCount"]));
    }
    if (m.find("AlertMessages") != m.end() && !m["AlertMessages"].empty()) {
      if (typeid(vector<boost::any>) == m["AlertMessages"].type()) {
        vector<ListAlertMessagesResponseDataAlertMessages> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlertMessages"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAlertMessagesResponseDataAlertMessages model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alertMessages = make_shared<vector<ListAlertMessagesResponseDataAlertMessages>>(expect1);
      }
    }
  }


  virtual ~ListAlertMessagesResponseData() = default;
};
class ListAlertMessagesResponse : public Darabonba::Model {
public:
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<ListAlertMessagesResponseData> data{};

  ListAlertMessagesResponse() {}

  explicit ListAlertMessagesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListAlertMessagesResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListAlertMessagesResponseData>(model1);
      }
    }
  }


  virtual ~ListAlertMessagesResponse() = default;
};
class GetBaselineConfigRequest : public Darabonba::Model {
public:
  shared_ptr<long> baselineId{};

  GetBaselineConfigRequest() {}

  explicit GetBaselineConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!baselineId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("baselineId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
  }


  virtual ~GetBaselineConfigRequest() = default;
};
class GetBaselineConfigResponseData : public Darabonba::Model {
public:
  shared_ptr<long> baselineId{};
  shared_ptr<int> priority{};
  shared_ptr<string> baselineName{};
  shared_ptr<string> owner{};
  shared_ptr<long> projectId{};
  shared_ptr<bool> useFlag{};
  shared_ptr<string> baselineType{};
  shared_ptr<int> expHour{};
  shared_ptr<int> expMinu{};
  shared_ptr<int> slaHour{};
  shared_ptr<int> slaMinu{};
  shared_ptr<string> hourExpDetail{};
  shared_ptr<string> hourSlaDetail{};
  shared_ptr<bool> isDefault{};

  GetBaselineConfigResponseData() {}

  explicit GetBaselineConfigResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!baselineId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("baselineId is required.")));
    }
    if (!priority) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("priority is required.")));
    }
    if (!baselineName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("baselineName is required.")));
    }
    if (!owner) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("owner is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!useFlag) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("useFlag is required.")));
    }
    if (!baselineType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("baselineType is required.")));
    }
    if (!expHour) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("expHour is required.")));
    }
    if (!expMinu) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("expMinu is required.")));
    }
    if (!slaHour) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("slaHour is required.")));
    }
    if (!slaMinu) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("slaMinu is required.")));
    }
    if (!hourExpDetail) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("hourExpDetail is required.")));
    }
    if (!hourSlaDetail) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("hourSlaDetail is required.")));
    }
    if (!isDefault) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("isDefault is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (baselineName) {
      res["BaselineName"] = boost::any(*baselineName);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (useFlag) {
      res["UseFlag"] = boost::any(*useFlag);
    }
    if (baselineType) {
      res["BaselineType"] = boost::any(*baselineType);
    }
    if (expHour) {
      res["ExpHour"] = boost::any(*expHour);
    }
    if (expMinu) {
      res["ExpMinu"] = boost::any(*expMinu);
    }
    if (slaHour) {
      res["SlaHour"] = boost::any(*slaHour);
    }
    if (slaMinu) {
      res["SlaMinu"] = boost::any(*slaMinu);
    }
    if (hourExpDetail) {
      res["HourExpDetail"] = boost::any(*hourExpDetail);
    }
    if (hourSlaDetail) {
      res["HourSlaDetail"] = boost::any(*hourSlaDetail);
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<int>(boost::any_cast<int>(m["Priority"]));
    }
    if (m.find("BaselineName") != m.end() && !m["BaselineName"].empty()) {
      baselineName = make_shared<string>(boost::any_cast<string>(m["BaselineName"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("UseFlag") != m.end() && !m["UseFlag"].empty()) {
      useFlag = make_shared<bool>(boost::any_cast<bool>(m["UseFlag"]));
    }
    if (m.find("BaselineType") != m.end() && !m["BaselineType"].empty()) {
      baselineType = make_shared<string>(boost::any_cast<string>(m["BaselineType"]));
    }
    if (m.find("ExpHour") != m.end() && !m["ExpHour"].empty()) {
      expHour = make_shared<int>(boost::any_cast<int>(m["ExpHour"]));
    }
    if (m.find("ExpMinu") != m.end() && !m["ExpMinu"].empty()) {
      expMinu = make_shared<int>(boost::any_cast<int>(m["ExpMinu"]));
    }
    if (m.find("SlaHour") != m.end() && !m["SlaHour"].empty()) {
      slaHour = make_shared<int>(boost::any_cast<int>(m["SlaHour"]));
    }
    if (m.find("SlaMinu") != m.end() && !m["SlaMinu"].empty()) {
      slaMinu = make_shared<int>(boost::any_cast<int>(m["SlaMinu"]));
    }
    if (m.find("HourExpDetail") != m.end() && !m["HourExpDetail"].empty()) {
      hourExpDetail = make_shared<string>(boost::any_cast<string>(m["HourExpDetail"]));
    }
    if (m.find("HourSlaDetail") != m.end() && !m["HourSlaDetail"].empty()) {
      hourSlaDetail = make_shared<string>(boost::any_cast<string>(m["HourSlaDetail"]));
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<bool>(boost::any_cast<bool>(m["IsDefault"]));
    }
  }


  virtual ~GetBaselineConfigResponseData() = default;
};
class GetBaselineConfigResponse : public Darabonba::Model {
public:
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<GetBaselineConfigResponseData> data{};

  GetBaselineConfigResponse() {}

  explicit GetBaselineConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetBaselineConfigResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetBaselineConfigResponseData>(model1);
      }
    }
  }


  virtual ~GetBaselineConfigResponse() = default;
};
class SearchMetaTablesRequest : public Darabonba::Model {
public:
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<string> appGuid{};
  shared_ptr<string> keyword{};
  shared_ptr<int> entityType{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> dataSourceType{};

  SearchMetaTablesRequest() {}

  explicit SearchMetaTablesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!keyword) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("keyword is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (appGuid) {
      res["AppGuid"] = boost::any(*appGuid);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (entityType) {
      res["EntityType"] = boost::any(*entityType);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (dataSourceType) {
      res["DataSourceType"] = boost::any(*dataSourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("AppGuid") != m.end() && !m["AppGuid"].empty()) {
      appGuid = make_shared<string>(boost::any_cast<string>(m["AppGuid"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("EntityType") != m.end() && !m["EntityType"].empty()) {
      entityType = make_shared<int>(boost::any_cast<int>(m["EntityType"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DataSourceType") != m.end() && !m["DataSourceType"].empty()) {
      dataSourceType = make_shared<string>(boost::any_cast<string>(m["DataSourceType"]));
    }
  }


  virtual ~SearchMetaTablesRequest() = default;
};
class SearchMetaTablesResponseDataDataEntityList : public Darabonba::Model {
public:
  shared_ptr<string> tableName{};
  shared_ptr<string> tableGuid{};
  shared_ptr<string> ownerId{};
  shared_ptr<long> tenantId{};
  shared_ptr<int> envType{};
  shared_ptr<int> entityType{};
  shared_ptr<long> projectId{};
  shared_ptr<string> projectName{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> databaseName{};

  SearchMetaTablesResponseDataDataEntityList() {}

  explicit SearchMetaTablesResponseDataDataEntityList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!tableName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tableName is required.")));
    }
    if (!tableGuid) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tableGuid is required.")));
    }
    if (!ownerId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ownerId is required.")));
    }
    if (!tenantId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tenantId is required.")));
    }
    if (!envType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("envType is required.")));
    }
    if (!entityType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("entityType is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!projectName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectName is required.")));
    }
    if (!clusterId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("clusterId is required.")));
    }
    if (!databaseName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("databaseName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (entityType) {
      res["EntityType"] = boost::any(*entityType);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<int>(boost::any_cast<int>(m["EnvType"]));
    }
    if (m.find("EntityType") != m.end() && !m["EntityType"].empty()) {
      entityType = make_shared<int>(boost::any_cast<int>(m["EntityType"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
  }


  virtual ~SearchMetaTablesResponseDataDataEntityList() = default;
};
class SearchMetaTablesResponseData : public Darabonba::Model {
public:
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<SearchMetaTablesResponseDataDataEntityList>> dataEntityList{};

  SearchMetaTablesResponseData() {}

  explicit SearchMetaTablesResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageNumber) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNumber is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!totalCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("totalCount is required.")));
    }
    if (!dataEntityList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dataEntityList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (dataEntityList) {
      vector<boost::any> temp1;
      for(auto item1:*dataEntityList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataEntityList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("DataEntityList") != m.end() && !m["DataEntityList"].empty()) {
      if (typeid(vector<boost::any>) == m["DataEntityList"].type()) {
        vector<SearchMetaTablesResponseDataDataEntityList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataEntityList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchMetaTablesResponseDataDataEntityList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataEntityList = make_shared<vector<SearchMetaTablesResponseDataDataEntityList>>(expect1);
      }
    }
  }


  virtual ~SearchMetaTablesResponseData() = default;
};
class SearchMetaTablesResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<bool> success{};
  shared_ptr<SearchMetaTablesResponseData> data{};

  SearchMetaTablesResponse() {}

  explicit SearchMetaTablesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        SearchMetaTablesResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<SearchMetaTablesResponseData>(model1);
      }
    }
  }


  virtual ~SearchMetaTablesResponse() = default;
};
class GetMetaTableListByCategoryRequest : public Darabonba::Model {
public:
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<long> categoryId{};

  GetMetaTableListByCategoryRequest() {}

  explicit GetMetaTableListByCategoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!categoryId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("categoryId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<long>(boost::any_cast<long>(m["CategoryId"]));
    }
  }


  virtual ~GetMetaTableListByCategoryRequest() = default;
};
class GetMetaTableListByCategoryResponseData : public Darabonba::Model {
public:
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<string>> tableGuidList{};

  GetMetaTableListByCategoryResponseData() {}

  explicit GetMetaTableListByCategoryResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageNumber) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNumber is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!totalCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("totalCount is required.")));
    }
    if (!tableGuidList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tableGuidList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (tableGuidList) {
      res["TableGuidList"] = boost::any(*tableGuidList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("TableGuidList") != m.end() && !m["TableGuidList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TableGuidList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TableGuidList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tableGuidList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetMetaTableListByCategoryResponseData() = default;
};
class GetMetaTableListByCategoryResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<bool> success{};
  shared_ptr<GetMetaTableListByCategoryResponseData> data{};

  GetMetaTableListByCategoryResponse() {}

  explicit GetMetaTableListByCategoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetMetaTableListByCategoryResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetMetaTableListByCategoryResponseData>(model1);
      }
    }
  }


  virtual ~GetMetaTableListByCategoryResponse() = default;
};
class DeleteMetaCategoryRequest : public Darabonba::Model {
public:
  shared_ptr<long> categoryId{};

  DeleteMetaCategoryRequest() {}

  explicit DeleteMetaCategoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!categoryId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("categoryId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<long>(boost::any_cast<long>(m["CategoryId"]));
    }
  }


  virtual ~DeleteMetaCategoryRequest() = default;
};
class DeleteMetaCategoryResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<bool> success{};
  shared_ptr<bool> data{};

  DeleteMetaCategoryResponse() {}

  explicit DeleteMetaCategoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
  }


  virtual ~DeleteMetaCategoryResponse() = default;
};
class UpdateMetaCategoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> comment{};
  shared_ptr<long> categoryId{};

  UpdateMetaCategoryRequest() {}

  explicit UpdateMetaCategoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!categoryId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("categoryId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<long>(boost::any_cast<long>(m["CategoryId"]));
    }
  }


  virtual ~UpdateMetaCategoryRequest() = default;
};
class UpdateMetaCategoryResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<bool> success{};
  shared_ptr<bool> data{};

  UpdateMetaCategoryResponse() {}

  explicit UpdateMetaCategoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
  }


  virtual ~UpdateMetaCategoryResponse() = default;
};
class ListTopicsRequest : public Darabonba::Model {
public:
  shared_ptr<string> beginTime{};
  shared_ptr<string> endTime{};
  shared_ptr<string> topicTypes{};
  shared_ptr<string> topicStatuses{};
  shared_ptr<long> nodeId{};
  shared_ptr<long> instanceId{};
  shared_ptr<string> owner{};
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};

  ListTopicsRequest() {}

  explicit ListTopicsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!beginTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("beginTime is required.")));
    }
    if (!endTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("endTime is required.")));
    }
    if (!pageNumber) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNumber is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beginTime) {
      res["BeginTime"] = boost::any(*beginTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (topicTypes) {
      res["TopicTypes"] = boost::any(*topicTypes);
    }
    if (topicStatuses) {
      res["TopicStatuses"] = boost::any(*topicStatuses);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BeginTime") != m.end() && !m["BeginTime"].empty()) {
      beginTime = make_shared<string>(boost::any_cast<string>(m["BeginTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("TopicTypes") != m.end() && !m["TopicTypes"].empty()) {
      topicTypes = make_shared<string>(boost::any_cast<string>(m["TopicTypes"]));
    }
    if (m.find("TopicStatuses") != m.end() && !m["TopicStatuses"].empty()) {
      topicStatuses = make_shared<string>(boost::any_cast<string>(m["TopicStatuses"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
  }


  virtual ~ListTopicsRequest() = default;
};
class ListTopicsResponseDataTopics : public Darabonba::Model {
public:
  shared_ptr<long> topicId{};
  shared_ptr<string> topicName{};
  shared_ptr<string> topicStatus{};
  shared_ptr<string> topicType{};
  shared_ptr<long> addTime{};
  shared_ptr<long> happenTime{};
  shared_ptr<long> fixTime{};
  shared_ptr<long> instanceId{};
  shared_ptr<long> nodeId{};
  shared_ptr<string> nodeName{};
  shared_ptr<string> nodeOwner{};
  shared_ptr<long> projectId{};

  ListTopicsResponseDataTopics() {}

  explicit ListTopicsResponseDataTopics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!topicId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("topicId is required.")));
    }
    if (!topicName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("topicName is required.")));
    }
    if (!topicStatus) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("topicStatus is required.")));
    }
    if (!topicType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("topicType is required.")));
    }
    if (!addTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("addTime is required.")));
    }
    if (!happenTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("happenTime is required.")));
    }
    if (!fixTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("fixTime is required.")));
    }
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
    if (!nodeId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeId is required.")));
    }
    if (!nodeName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeName is required.")));
    }
    if (!nodeOwner) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeOwner is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (topicId) {
      res["TopicId"] = boost::any(*topicId);
    }
    if (topicName) {
      res["TopicName"] = boost::any(*topicName);
    }
    if (topicStatus) {
      res["TopicStatus"] = boost::any(*topicStatus);
    }
    if (topicType) {
      res["TopicType"] = boost::any(*topicType);
    }
    if (addTime) {
      res["AddTime"] = boost::any(*addTime);
    }
    if (happenTime) {
      res["HappenTime"] = boost::any(*happenTime);
    }
    if (fixTime) {
      res["FixTime"] = boost::any(*fixTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (nodeOwner) {
      res["NodeOwner"] = boost::any(*nodeOwner);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TopicId") != m.end() && !m["TopicId"].empty()) {
      topicId = make_shared<long>(boost::any_cast<long>(m["TopicId"]));
    }
    if (m.find("TopicName") != m.end() && !m["TopicName"].empty()) {
      topicName = make_shared<string>(boost::any_cast<string>(m["TopicName"]));
    }
    if (m.find("TopicStatus") != m.end() && !m["TopicStatus"].empty()) {
      topicStatus = make_shared<string>(boost::any_cast<string>(m["TopicStatus"]));
    }
    if (m.find("TopicType") != m.end() && !m["TopicType"].empty()) {
      topicType = make_shared<string>(boost::any_cast<string>(m["TopicType"]));
    }
    if (m.find("AddTime") != m.end() && !m["AddTime"].empty()) {
      addTime = make_shared<long>(boost::any_cast<long>(m["AddTime"]));
    }
    if (m.find("HappenTime") != m.end() && !m["HappenTime"].empty()) {
      happenTime = make_shared<long>(boost::any_cast<long>(m["HappenTime"]));
    }
    if (m.find("FixTime") != m.end() && !m["FixTime"].empty()) {
      fixTime = make_shared<long>(boost::any_cast<long>(m["FixTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("NodeOwner") != m.end() && !m["NodeOwner"].empty()) {
      nodeOwner = make_shared<string>(boost::any_cast<string>(m["NodeOwner"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~ListTopicsResponseDataTopics() = default;
};
class ListTopicsResponseData : public Darabonba::Model {
public:
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> totalCount{};
  shared_ptr<vector<ListTopicsResponseDataTopics>> topics{};

  ListTopicsResponseData() {}

  explicit ListTopicsResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageNumber) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNumber is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!totalCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("totalCount is required.")));
    }
    if (!topics) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("topics is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (topics) {
      vector<boost::any> temp1;
      for(auto item1:*topics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Topics"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<int>(boost::any_cast<int>(m["TotalCount"]));
    }
    if (m.find("Topics") != m.end() && !m["Topics"].empty()) {
      if (typeid(vector<boost::any>) == m["Topics"].type()) {
        vector<ListTopicsResponseDataTopics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Topics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTopicsResponseDataTopics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        topics = make_shared<vector<ListTopicsResponseDataTopics>>(expect1);
      }
    }
  }


  virtual ~ListTopicsResponseData() = default;
};
class ListTopicsResponse : public Darabonba::Model {
public:
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<ListTopicsResponseData> data{};

  ListTopicsResponse() {}

  explicit ListTopicsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListTopicsResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListTopicsResponseData>(model1);
      }
    }
  }


  virtual ~ListTopicsResponse() = default;
};
class ListFileVersionsRequest : public Darabonba::Model {
public:
  shared_ptr<long> fileId{};
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};

  ListFileVersionsRequest() {}

  explicit ListFileVersionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!fileId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("fileId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
  }


  virtual ~ListFileVersionsRequest() = default;
};
class ListFileVersionsResponseDataFileVersions : public Darabonba::Model {
public:
  shared_ptr<int> fileVersion{};
  shared_ptr<string> fileContent{};
  shared_ptr<long> commitTime{};
  shared_ptr<string> commitUser{};
  shared_ptr<string> fileName{};
  shared_ptr<string> status{};
  shared_ptr<string> changeType{};
  shared_ptr<bool> isCurrentProd{};
  shared_ptr<long> nodeId{};
  shared_ptr<string> comment{};
  shared_ptr<string> nodeContent{};
  shared_ptr<string> filePropertyContent{};
  shared_ptr<string> useType{};

  ListFileVersionsResponseDataFileVersions() {}

  explicit ListFileVersionsResponseDataFileVersions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!fileVersion) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("fileVersion is required.")));
    }
    if (!fileContent) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("fileContent is required.")));
    }
    if (!commitTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("commitTime is required.")));
    }
    if (!commitUser) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("commitUser is required.")));
    }
    if (!fileName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("fileName is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!changeType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("changeType is required.")));
    }
    if (!isCurrentProd) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("isCurrentProd is required.")));
    }
    if (!nodeId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeId is required.")));
    }
    if (!comment) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("comment is required.")));
    }
    if (!nodeContent) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeContent is required.")));
    }
    if (!filePropertyContent) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("filePropertyContent is required.")));
    }
    if (!useType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("useType is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileVersion) {
      res["FileVersion"] = boost::any(*fileVersion);
    }
    if (fileContent) {
      res["FileContent"] = boost::any(*fileContent);
    }
    if (commitTime) {
      res["CommitTime"] = boost::any(*commitTime);
    }
    if (commitUser) {
      res["CommitUser"] = boost::any(*commitUser);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (changeType) {
      res["ChangeType"] = boost::any(*changeType);
    }
    if (isCurrentProd) {
      res["IsCurrentProd"] = boost::any(*isCurrentProd);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (nodeContent) {
      res["NodeContent"] = boost::any(*nodeContent);
    }
    if (filePropertyContent) {
      res["FilePropertyContent"] = boost::any(*filePropertyContent);
    }
    if (useType) {
      res["UseType"] = boost::any(*useType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileVersion") != m.end() && !m["FileVersion"].empty()) {
      fileVersion = make_shared<int>(boost::any_cast<int>(m["FileVersion"]));
    }
    if (m.find("FileContent") != m.end() && !m["FileContent"].empty()) {
      fileContent = make_shared<string>(boost::any_cast<string>(m["FileContent"]));
    }
    if (m.find("CommitTime") != m.end() && !m["CommitTime"].empty()) {
      commitTime = make_shared<long>(boost::any_cast<long>(m["CommitTime"]));
    }
    if (m.find("CommitUser") != m.end() && !m["CommitUser"].empty()) {
      commitUser = make_shared<string>(boost::any_cast<string>(m["CommitUser"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("ChangeType") != m.end() && !m["ChangeType"].empty()) {
      changeType = make_shared<string>(boost::any_cast<string>(m["ChangeType"]));
    }
    if (m.find("IsCurrentProd") != m.end() && !m["IsCurrentProd"].empty()) {
      isCurrentProd = make_shared<bool>(boost::any_cast<bool>(m["IsCurrentProd"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("NodeContent") != m.end() && !m["NodeContent"].empty()) {
      nodeContent = make_shared<string>(boost::any_cast<string>(m["NodeContent"]));
    }
    if (m.find("FilePropertyContent") != m.end() && !m["FilePropertyContent"].empty()) {
      filePropertyContent = make_shared<string>(boost::any_cast<string>(m["FilePropertyContent"]));
    }
    if (m.find("UseType") != m.end() && !m["UseType"].empty()) {
      useType = make_shared<string>(boost::any_cast<string>(m["UseType"]));
    }
  }


  virtual ~ListFileVersionsResponseDataFileVersions() = default;
};
class ListFileVersionsResponseData : public Darabonba::Model {
public:
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> totalCount{};
  shared_ptr<vector<ListFileVersionsResponseDataFileVersions>> fileVersions{};

  ListFileVersionsResponseData() {}

  explicit ListFileVersionsResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageNumber) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNumber is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!totalCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("totalCount is required.")));
    }
    if (!fileVersions) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("fileVersions is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (fileVersions) {
      vector<boost::any> temp1;
      for(auto item1:*fileVersions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FileVersions"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<int>(boost::any_cast<int>(m["TotalCount"]));
    }
    if (m.find("FileVersions") != m.end() && !m["FileVersions"].empty()) {
      if (typeid(vector<boost::any>) == m["FileVersions"].type()) {
        vector<ListFileVersionsResponseDataFileVersions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FileVersions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFileVersionsResponseDataFileVersions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fileVersions = make_shared<vector<ListFileVersionsResponseDataFileVersions>>(expect1);
      }
    }
  }


  virtual ~ListFileVersionsResponseData() = default;
};
class ListFileVersionsResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<ListFileVersionsResponseData> data{};

  ListFileVersionsResponse() {}

  explicit ListFileVersionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListFileVersionsResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListFileVersionsResponseData>(model1);
      }
    }
  }


  virtual ~ListFileVersionsResponse() = default;
};
class CreateMetaCategoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> comment{};
  shared_ptr<long> parentId{};

  CreateMetaCategoryRequest() {}

  explicit CreateMetaCategoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!name) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("name is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
  }


  virtual ~CreateMetaCategoryRequest() = default;
};
class CreateMetaCategoryResponseData : public Darabonba::Model {
public:
  shared_ptr<long> categoryId{};

  CreateMetaCategoryResponseData() {}

  explicit CreateMetaCategoryResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!categoryId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("categoryId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<long>(boost::any_cast<long>(m["CategoryId"]));
    }
  }


  virtual ~CreateMetaCategoryResponseData() = default;
};
class CreateMetaCategoryResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<bool> success{};
  shared_ptr<CreateMetaCategoryResponseData> data{};

  CreateMetaCategoryResponse() {}

  explicit CreateMetaCategoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateMetaCategoryResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateMetaCategoryResponseData>(model1);
      }
    }
  }


  virtual ~CreateMetaCategoryResponse() = default;
};
class ListNodeIORequest : public Darabonba::Model {
public:
  shared_ptr<long> nodeId{};
  shared_ptr<string> projectEnv{};
  shared_ptr<string> ioType{};

  ListNodeIORequest() {}

  explicit ListNodeIORequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!nodeId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeId is required.")));
    }
    if (!projectEnv) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectEnv is required.")));
    }
    if (!ioType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ioType is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (ioType) {
      res["IoType"] = boost::any(*ioType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("IoType") != m.end() && !m["IoType"].empty()) {
      ioType = make_shared<string>(boost::any_cast<string>(m["IoType"]));
    }
  }


  virtual ~ListNodeIORequest() = default;
};
class ListNodeIOResponseData : public Darabonba::Model {
public:
  shared_ptr<string> tableName{};
  shared_ptr<string> data{};
  shared_ptr<long> nodeId{};

  ListNodeIOResponseData() {}

  explicit ListNodeIOResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!tableName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tableName is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
    if (!nodeId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
  }


  virtual ~ListNodeIOResponseData() = default;
};
class ListNodeIOResponse : public Darabonba::Model {
public:
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListNodeIOResponseData>> data{};

  ListNodeIOResponse() {}

  explicit ListNodeIOResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListNodeIOResponseData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNodeIOResponseData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListNodeIOResponseData>>(expect1);
      }
    }
  }


  virtual ~ListNodeIOResponse() = default;
};
class GetTopicInfluenceRequest : public Darabonba::Model {
public:
  shared_ptr<long> topicId{};

  GetTopicInfluenceRequest() {}

  explicit GetTopicInfluenceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!topicId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("topicId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (topicId) {
      res["TopicId"] = boost::any(*topicId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TopicId") != m.end() && !m["TopicId"].empty()) {
      topicId = make_shared<long>(boost::any_cast<long>(m["TopicId"]));
    }
  }


  virtual ~GetTopicInfluenceRequest() = default;
};
class GetTopicInfluenceResponseDataInfluences : public Darabonba::Model {
public:
  shared_ptr<long> baselineId{};
  shared_ptr<long> bizdate{};
  shared_ptr<int> inGroupId{};
  shared_ptr<string> baselineName{};
  shared_ptr<string> owner{};
  shared_ptr<string> status{};
  shared_ptr<long> projectId{};
  shared_ptr<int> priority{};
  shared_ptr<long> buffer{};

  GetTopicInfluenceResponseDataInfluences() {}

  explicit GetTopicInfluenceResponseDataInfluences(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!baselineId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("baselineId is required.")));
    }
    if (!bizdate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("bizdate is required.")));
    }
    if (!inGroupId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("inGroupId is required.")));
    }
    if (!baselineName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("baselineName is required.")));
    }
    if (!owner) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("owner is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!priority) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("priority is required.")));
    }
    if (!buffer) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("buffer is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (bizdate) {
      res["Bizdate"] = boost::any(*bizdate);
    }
    if (inGroupId) {
      res["InGroupId"] = boost::any(*inGroupId);
    }
    if (baselineName) {
      res["BaselineName"] = boost::any(*baselineName);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (buffer) {
      res["Buffer"] = boost::any(*buffer);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("Bizdate") != m.end() && !m["Bizdate"].empty()) {
      bizdate = make_shared<long>(boost::any_cast<long>(m["Bizdate"]));
    }
    if (m.find("InGroupId") != m.end() && !m["InGroupId"].empty()) {
      inGroupId = make_shared<int>(boost::any_cast<int>(m["InGroupId"]));
    }
    if (m.find("BaselineName") != m.end() && !m["BaselineName"].empty()) {
      baselineName = make_shared<string>(boost::any_cast<string>(m["BaselineName"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<int>(boost::any_cast<int>(m["Priority"]));
    }
    if (m.find("Buffer") != m.end() && !m["Buffer"].empty()) {
      buffer = make_shared<long>(boost::any_cast<long>(m["Buffer"]));
    }
  }


  virtual ~GetTopicInfluenceResponseDataInfluences() = default;
};
class GetTopicInfluenceResponseData : public Darabonba::Model {
public:
  shared_ptr<long> topicId{};
  shared_ptr<vector<GetTopicInfluenceResponseDataInfluences>> influences{};

  GetTopicInfluenceResponseData() {}

  explicit GetTopicInfluenceResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!topicId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("topicId is required.")));
    }
    if (!influences) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("influences is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (topicId) {
      res["TopicId"] = boost::any(*topicId);
    }
    if (influences) {
      vector<boost::any> temp1;
      for(auto item1:*influences){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Influences"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TopicId") != m.end() && !m["TopicId"].empty()) {
      topicId = make_shared<long>(boost::any_cast<long>(m["TopicId"]));
    }
    if (m.find("Influences") != m.end() && !m["Influences"].empty()) {
      if (typeid(vector<boost::any>) == m["Influences"].type()) {
        vector<GetTopicInfluenceResponseDataInfluences> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Influences"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTopicInfluenceResponseDataInfluences model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        influences = make_shared<vector<GetTopicInfluenceResponseDataInfluences>>(expect1);
      }
    }
  }


  virtual ~GetTopicInfluenceResponseData() = default;
};
class GetTopicInfluenceResponse : public Darabonba::Model {
public:
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<GetTopicInfluenceResponseData> data{};

  GetTopicInfluenceResponse() {}

  explicit GetTopicInfluenceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetTopicInfluenceResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetTopicInfluenceResponseData>(model1);
      }
    }
  }


  virtual ~GetTopicInfluenceResponse() = default;
};
class GetTopicRequest : public Darabonba::Model {
public:
  shared_ptr<long> topicId{};

  GetTopicRequest() {}

  explicit GetTopicRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!topicId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("topicId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (topicId) {
      res["TopicId"] = boost::any(*topicId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TopicId") != m.end() && !m["TopicId"].empty()) {
      topicId = make_shared<long>(boost::any_cast<long>(m["TopicId"]));
    }
  }


  virtual ~GetTopicRequest() = default;
};
class GetTopicResponseData : public Darabonba::Model {
public:
  shared_ptr<long> topicId{};
  shared_ptr<string> topicName{};
  shared_ptr<string> topicStatus{};
  shared_ptr<string> topicType{};
  shared_ptr<long> addTime{};
  shared_ptr<long> alertTime{};
  shared_ptr<string> assigner{};
  shared_ptr<long> baselineId{};
  shared_ptr<string> baselineName{};
  shared_ptr<int> baselineInGroupId{};
  shared_ptr<string> baselineStatus{};
  shared_ptr<long> baselineBuffer{};
  shared_ptr<long> buffer{};
  shared_ptr<long> dealTime{};
  shared_ptr<string> dealUser{};
  shared_ptr<long> fixTime{};
  shared_ptr<long> happenTime{};
  shared_ptr<long> instanceId{};
  shared_ptr<long> nextAlertTime{};
  shared_ptr<long> nodeId{};
  shared_ptr<string> nodeName{};
  shared_ptr<string> owner{};
  shared_ptr<long> projectId{};

  GetTopicResponseData() {}

  explicit GetTopicResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!topicId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("topicId is required.")));
    }
    if (!topicName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("topicName is required.")));
    }
    if (!topicStatus) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("topicStatus is required.")));
    }
    if (!topicType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("topicType is required.")));
    }
    if (!addTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("addTime is required.")));
    }
    if (!alertTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("alertTime is required.")));
    }
    if (!assigner) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("assigner is required.")));
    }
    if (!baselineId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("baselineId is required.")));
    }
    if (!baselineName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("baselineName is required.")));
    }
    if (!baselineInGroupId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("baselineInGroupId is required.")));
    }
    if (!baselineStatus) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("baselineStatus is required.")));
    }
    if (!baselineBuffer) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("baselineBuffer is required.")));
    }
    if (!buffer) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("buffer is required.")));
    }
    if (!dealTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dealTime is required.")));
    }
    if (!dealUser) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dealUser is required.")));
    }
    if (!fixTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("fixTime is required.")));
    }
    if (!happenTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("happenTime is required.")));
    }
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
    if (!nextAlertTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nextAlertTime is required.")));
    }
    if (!nodeId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeId is required.")));
    }
    if (!nodeName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeName is required.")));
    }
    if (!owner) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("owner is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (topicId) {
      res["TopicId"] = boost::any(*topicId);
    }
    if (topicName) {
      res["TopicName"] = boost::any(*topicName);
    }
    if (topicStatus) {
      res["TopicStatus"] = boost::any(*topicStatus);
    }
    if (topicType) {
      res["TopicType"] = boost::any(*topicType);
    }
    if (addTime) {
      res["AddTime"] = boost::any(*addTime);
    }
    if (alertTime) {
      res["AlertTime"] = boost::any(*alertTime);
    }
    if (assigner) {
      res["Assigner"] = boost::any(*assigner);
    }
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (baselineName) {
      res["BaselineName"] = boost::any(*baselineName);
    }
    if (baselineInGroupId) {
      res["BaselineInGroupId"] = boost::any(*baselineInGroupId);
    }
    if (baselineStatus) {
      res["BaselineStatus"] = boost::any(*baselineStatus);
    }
    if (baselineBuffer) {
      res["BaselineBuffer"] = boost::any(*baselineBuffer);
    }
    if (buffer) {
      res["Buffer"] = boost::any(*buffer);
    }
    if (dealTime) {
      res["DealTime"] = boost::any(*dealTime);
    }
    if (dealUser) {
      res["DealUser"] = boost::any(*dealUser);
    }
    if (fixTime) {
      res["FixTime"] = boost::any(*fixTime);
    }
    if (happenTime) {
      res["HappenTime"] = boost::any(*happenTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (nextAlertTime) {
      res["NextAlertTime"] = boost::any(*nextAlertTime);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TopicId") != m.end() && !m["TopicId"].empty()) {
      topicId = make_shared<long>(boost::any_cast<long>(m["TopicId"]));
    }
    if (m.find("TopicName") != m.end() && !m["TopicName"].empty()) {
      topicName = make_shared<string>(boost::any_cast<string>(m["TopicName"]));
    }
    if (m.find("TopicStatus") != m.end() && !m["TopicStatus"].empty()) {
      topicStatus = make_shared<string>(boost::any_cast<string>(m["TopicStatus"]));
    }
    if (m.find("TopicType") != m.end() && !m["TopicType"].empty()) {
      topicType = make_shared<string>(boost::any_cast<string>(m["TopicType"]));
    }
    if (m.find("AddTime") != m.end() && !m["AddTime"].empty()) {
      addTime = make_shared<long>(boost::any_cast<long>(m["AddTime"]));
    }
    if (m.find("AlertTime") != m.end() && !m["AlertTime"].empty()) {
      alertTime = make_shared<long>(boost::any_cast<long>(m["AlertTime"]));
    }
    if (m.find("Assigner") != m.end() && !m["Assigner"].empty()) {
      assigner = make_shared<string>(boost::any_cast<string>(m["Assigner"]));
    }
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("BaselineName") != m.end() && !m["BaselineName"].empty()) {
      baselineName = make_shared<string>(boost::any_cast<string>(m["BaselineName"]));
    }
    if (m.find("BaselineInGroupId") != m.end() && !m["BaselineInGroupId"].empty()) {
      baselineInGroupId = make_shared<int>(boost::any_cast<int>(m["BaselineInGroupId"]));
    }
    if (m.find("BaselineStatus") != m.end() && !m["BaselineStatus"].empty()) {
      baselineStatus = make_shared<string>(boost::any_cast<string>(m["BaselineStatus"]));
    }
    if (m.find("BaselineBuffer") != m.end() && !m["BaselineBuffer"].empty()) {
      baselineBuffer = make_shared<long>(boost::any_cast<long>(m["BaselineBuffer"]));
    }
    if (m.find("Buffer") != m.end() && !m["Buffer"].empty()) {
      buffer = make_shared<long>(boost::any_cast<long>(m["Buffer"]));
    }
    if (m.find("DealTime") != m.end() && !m["DealTime"].empty()) {
      dealTime = make_shared<long>(boost::any_cast<long>(m["DealTime"]));
    }
    if (m.find("DealUser") != m.end() && !m["DealUser"].empty()) {
      dealUser = make_shared<string>(boost::any_cast<string>(m["DealUser"]));
    }
    if (m.find("FixTime") != m.end() && !m["FixTime"].empty()) {
      fixTime = make_shared<long>(boost::any_cast<long>(m["FixTime"]));
    }
    if (m.find("HappenTime") != m.end() && !m["HappenTime"].empty()) {
      happenTime = make_shared<long>(boost::any_cast<long>(m["HappenTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("NextAlertTime") != m.end() && !m["NextAlertTime"].empty()) {
      nextAlertTime = make_shared<long>(boost::any_cast<long>(m["NextAlertTime"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~GetTopicResponseData() = default;
};
class GetTopicResponse : public Darabonba::Model {
public:
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<GetTopicResponseData> data{};

  GetTopicResponse() {}

  explicit GetTopicResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetTopicResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetTopicResponseData>(model1);
      }
    }
  }


  virtual ~GetTopicResponse() = default;
};
class DeleteFromMetaCategoryRequest : public Darabonba::Model {
public:
  shared_ptr<long> categoryId{};
  shared_ptr<string> tableGuid{};

  DeleteFromMetaCategoryRequest() {}

  explicit DeleteFromMetaCategoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!categoryId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("categoryId is required.")));
    }
    if (!tableGuid) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tableGuid is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<long>(boost::any_cast<long>(m["CategoryId"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
  }


  virtual ~DeleteFromMetaCategoryRequest() = default;
};
class DeleteFromMetaCategoryResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<bool> success{};
  shared_ptr<bool> data{};

  DeleteFromMetaCategoryResponse() {}

  explicit DeleteFromMetaCategoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
  }


  virtual ~DeleteFromMetaCategoryResponse() = default;
};
class GetNodeRequest : public Darabonba::Model {
public:
  shared_ptr<long> nodeId{};
  shared_ptr<string> projectEnv{};

  GetNodeRequest() {}

  explicit GetNodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!nodeId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeId is required.")));
    }
    if (!projectEnv) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectEnv is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
  }


  virtual ~GetNodeRequest() = default;
};
class GetNodeResponseData : public Darabonba::Model {
public:
  shared_ptr<long> nodeId{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> description{};
  shared_ptr<string> resGroupName{};
  shared_ptr<string> nodeName{};
  shared_ptr<string> cronExpress{};
  shared_ptr<string> repeatability{};
  shared_ptr<string> programType{};
  shared_ptr<long> projectId{};
  shared_ptr<string> schedulerType{};
  shared_ptr<string> paramValues{};
  shared_ptr<int> priority{};
  shared_ptr<long> baselineId{};
  shared_ptr<long> repeatInterval{};
  shared_ptr<string> connection{};
  shared_ptr<int> dqcType{};
  shared_ptr<string> dqcDescription{};
  shared_ptr<long> relatedFlowId{};
  shared_ptr<long> businessId{};

  GetNodeResponseData() {}

  explicit GetNodeResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!nodeId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeId is required.")));
    }
    if (!ownerId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ownerId is required.")));
    }
    if (!description) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("description is required.")));
    }
    if (!resGroupName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("resGroupName is required.")));
    }
    if (!nodeName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeName is required.")));
    }
    if (!cronExpress) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("cronExpress is required.")));
    }
    if (!repeatability) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("repeatability is required.")));
    }
    if (!programType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("programType is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!schedulerType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("schedulerType is required.")));
    }
    if (!paramValues) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("paramValues is required.")));
    }
    if (!priority) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("priority is required.")));
    }
    if (!baselineId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("baselineId is required.")));
    }
    if (!repeatInterval) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("repeatInterval is required.")));
    }
    if (!connection) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("connection is required.")));
    }
    if (!dqcType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dqcType is required.")));
    }
    if (!dqcDescription) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dqcDescription is required.")));
    }
    if (!relatedFlowId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("relatedFlowId is required.")));
    }
    if (!businessId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("businessId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (resGroupName) {
      res["ResGroupName"] = boost::any(*resGroupName);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (cronExpress) {
      res["CronExpress"] = boost::any(*cronExpress);
    }
    if (repeatability) {
      res["Repeatability"] = boost::any(*repeatability);
    }
    if (programType) {
      res["ProgramType"] = boost::any(*programType);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (schedulerType) {
      res["SchedulerType"] = boost::any(*schedulerType);
    }
    if (paramValues) {
      res["ParamValues"] = boost::any(*paramValues);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (repeatInterval) {
      res["RepeatInterval"] = boost::any(*repeatInterval);
    }
    if (connection) {
      res["Connection"] = boost::any(*connection);
    }
    if (dqcType) {
      res["DqcType"] = boost::any(*dqcType);
    }
    if (dqcDescription) {
      res["DqcDescription"] = boost::any(*dqcDescription);
    }
    if (relatedFlowId) {
      res["RelatedFlowId"] = boost::any(*relatedFlowId);
    }
    if (businessId) {
      res["BusinessId"] = boost::any(*businessId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ResGroupName") != m.end() && !m["ResGroupName"].empty()) {
      resGroupName = make_shared<string>(boost::any_cast<string>(m["ResGroupName"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("CronExpress") != m.end() && !m["CronExpress"].empty()) {
      cronExpress = make_shared<string>(boost::any_cast<string>(m["CronExpress"]));
    }
    if (m.find("Repeatability") != m.end() && !m["Repeatability"].empty()) {
      repeatability = make_shared<string>(boost::any_cast<string>(m["Repeatability"]));
    }
    if (m.find("ProgramType") != m.end() && !m["ProgramType"].empty()) {
      programType = make_shared<string>(boost::any_cast<string>(m["ProgramType"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SchedulerType") != m.end() && !m["SchedulerType"].empty()) {
      schedulerType = make_shared<string>(boost::any_cast<string>(m["SchedulerType"]));
    }
    if (m.find("ParamValues") != m.end() && !m["ParamValues"].empty()) {
      paramValues = make_shared<string>(boost::any_cast<string>(m["ParamValues"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<int>(boost::any_cast<int>(m["Priority"]));
    }
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("RepeatInterval") != m.end() && !m["RepeatInterval"].empty()) {
      repeatInterval = make_shared<long>(boost::any_cast<long>(m["RepeatInterval"]));
    }
    if (m.find("Connection") != m.end() && !m["Connection"].empty()) {
      connection = make_shared<string>(boost::any_cast<string>(m["Connection"]));
    }
    if (m.find("DqcType") != m.end() && !m["DqcType"].empty()) {
      dqcType = make_shared<int>(boost::any_cast<int>(m["DqcType"]));
    }
    if (m.find("DqcDescription") != m.end() && !m["DqcDescription"].empty()) {
      dqcDescription = make_shared<string>(boost::any_cast<string>(m["DqcDescription"]));
    }
    if (m.find("RelatedFlowId") != m.end() && !m["RelatedFlowId"].empty()) {
      relatedFlowId = make_shared<long>(boost::any_cast<long>(m["RelatedFlowId"]));
    }
    if (m.find("BusinessId") != m.end() && !m["BusinessId"].empty()) {
      businessId = make_shared<long>(boost::any_cast<long>(m["BusinessId"]));
    }
  }


  virtual ~GetNodeResponseData() = default;
};
class GetNodeResponse : public Darabonba::Model {
public:
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<GetNodeResponseData> data{};

  GetNodeResponse() {}

  explicit GetNodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetNodeResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetNodeResponseData>(model1);
      }
    }
  }


  virtual ~GetNodeResponse() = default;
};
class ListNodesRequest : public Darabonba::Model {
public:
  shared_ptr<string> owner{};
  shared_ptr<string> bizName{};
  shared_ptr<string> programType{};
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<string> projectEnv{};
  shared_ptr<string> nodeName{};

  ListNodesRequest() {}

  explicit ListNodesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!projectEnv) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectEnv is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (bizName) {
      res["BizName"] = boost::any(*bizName);
    }
    if (programType) {
      res["ProgramType"] = boost::any(*programType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("BizName") != m.end() && !m["BizName"].empty()) {
      bizName = make_shared<string>(boost::any_cast<string>(m["BizName"]));
    }
    if (m.find("ProgramType") != m.end() && !m["ProgramType"].empty()) {
      programType = make_shared<string>(boost::any_cast<string>(m["ProgramType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
  }


  virtual ~ListNodesRequest() = default;
};
class ListNodesResponseDataNodes : public Darabonba::Model {
public:
  shared_ptr<long> nodeId{};
  shared_ptr<string> nodeName{};
  shared_ptr<string> cronExpress{};
  shared_ptr<string> schedulerType{};
  shared_ptr<string> programType{};
  shared_ptr<string> ownerId{};
  shared_ptr<long> projectId{};
  shared_ptr<bool> repeatability{};
  shared_ptr<string> paramValues{};
  shared_ptr<string> description{};
  shared_ptr<string> resGroupName{};
  shared_ptr<int> priority{};
  shared_ptr<long> baselineId{};
  shared_ptr<long> repeatInterval{};
  shared_ptr<string> connection{};
  shared_ptr<int> dqcType{};
  shared_ptr<string> dqcDescription{};
  shared_ptr<long> relatedFlowId{};
  shared_ptr<long> businessId{};

  ListNodesResponseDataNodes() {}

  explicit ListNodesResponseDataNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!nodeId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeId is required.")));
    }
    if (!nodeName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeName is required.")));
    }
    if (!cronExpress) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("cronExpress is required.")));
    }
    if (!schedulerType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("schedulerType is required.")));
    }
    if (!programType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("programType is required.")));
    }
    if (!ownerId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ownerId is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!repeatability) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("repeatability is required.")));
    }
    if (!paramValues) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("paramValues is required.")));
    }
    if (!description) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("description is required.")));
    }
    if (!resGroupName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("resGroupName is required.")));
    }
    if (!priority) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("priority is required.")));
    }
    if (!baselineId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("baselineId is required.")));
    }
    if (!repeatInterval) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("repeatInterval is required.")));
    }
    if (!connection) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("connection is required.")));
    }
    if (!dqcType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dqcType is required.")));
    }
    if (!dqcDescription) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dqcDescription is required.")));
    }
    if (!relatedFlowId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("relatedFlowId is required.")));
    }
    if (!businessId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("businessId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (cronExpress) {
      res["CronExpress"] = boost::any(*cronExpress);
    }
    if (schedulerType) {
      res["SchedulerType"] = boost::any(*schedulerType);
    }
    if (programType) {
      res["ProgramType"] = boost::any(*programType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (repeatability) {
      res["Repeatability"] = boost::any(*repeatability);
    }
    if (paramValues) {
      res["ParamValues"] = boost::any(*paramValues);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (resGroupName) {
      res["ResGroupName"] = boost::any(*resGroupName);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (repeatInterval) {
      res["RepeatInterval"] = boost::any(*repeatInterval);
    }
    if (connection) {
      res["Connection"] = boost::any(*connection);
    }
    if (dqcType) {
      res["DqcType"] = boost::any(*dqcType);
    }
    if (dqcDescription) {
      res["DqcDescription"] = boost::any(*dqcDescription);
    }
    if (relatedFlowId) {
      res["RelatedFlowId"] = boost::any(*relatedFlowId);
    }
    if (businessId) {
      res["BusinessId"] = boost::any(*businessId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("CronExpress") != m.end() && !m["CronExpress"].empty()) {
      cronExpress = make_shared<string>(boost::any_cast<string>(m["CronExpress"]));
    }
    if (m.find("SchedulerType") != m.end() && !m["SchedulerType"].empty()) {
      schedulerType = make_shared<string>(boost::any_cast<string>(m["SchedulerType"]));
    }
    if (m.find("ProgramType") != m.end() && !m["ProgramType"].empty()) {
      programType = make_shared<string>(boost::any_cast<string>(m["ProgramType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Repeatability") != m.end() && !m["Repeatability"].empty()) {
      repeatability = make_shared<bool>(boost::any_cast<bool>(m["Repeatability"]));
    }
    if (m.find("ParamValues") != m.end() && !m["ParamValues"].empty()) {
      paramValues = make_shared<string>(boost::any_cast<string>(m["ParamValues"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ResGroupName") != m.end() && !m["ResGroupName"].empty()) {
      resGroupName = make_shared<string>(boost::any_cast<string>(m["ResGroupName"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<int>(boost::any_cast<int>(m["Priority"]));
    }
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("RepeatInterval") != m.end() && !m["RepeatInterval"].empty()) {
      repeatInterval = make_shared<long>(boost::any_cast<long>(m["RepeatInterval"]));
    }
    if (m.find("Connection") != m.end() && !m["Connection"].empty()) {
      connection = make_shared<string>(boost::any_cast<string>(m["Connection"]));
    }
    if (m.find("DqcType") != m.end() && !m["DqcType"].empty()) {
      dqcType = make_shared<int>(boost::any_cast<int>(m["DqcType"]));
    }
    if (m.find("DqcDescription") != m.end() && !m["DqcDescription"].empty()) {
      dqcDescription = make_shared<string>(boost::any_cast<string>(m["DqcDescription"]));
    }
    if (m.find("RelatedFlowId") != m.end() && !m["RelatedFlowId"].empty()) {
      relatedFlowId = make_shared<long>(boost::any_cast<long>(m["RelatedFlowId"]));
    }
    if (m.find("BusinessId") != m.end() && !m["BusinessId"].empty()) {
      businessId = make_shared<long>(boost::any_cast<long>(m["BusinessId"]));
    }
  }


  virtual ~ListNodesResponseDataNodes() = default;
};
class ListNodesResponseData : public Darabonba::Model {
public:
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> totalCount{};
  shared_ptr<vector<ListNodesResponseDataNodes>> nodes{};

  ListNodesResponseData() {}

  explicit ListNodesResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageNumber) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNumber is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!totalCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("totalCount is required.")));
    }
    if (!nodes) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodes is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (nodes) {
      vector<boost::any> temp1;
      for(auto item1:*nodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Nodes"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<int>(boost::any_cast<int>(m["TotalCount"]));
    }
    if (m.find("Nodes") != m.end() && !m["Nodes"].empty()) {
      if (typeid(vector<boost::any>) == m["Nodes"].type()) {
        vector<ListNodesResponseDataNodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Nodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNodesResponseDataNodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodes = make_shared<vector<ListNodesResponseDataNodes>>(expect1);
      }
    }
  }


  virtual ~ListNodesResponseData() = default;
};
class ListNodesResponse : public Darabonba::Model {
public:
  shared_ptr<bool> success{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<ListNodesResponseData> data{};

  ListNodesResponse() {}

  explicit ListNodesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListNodesResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListNodesResponseData>(model1);
      }
    }
  }


  virtual ~ListNodesResponse() = default;
};
class GetNodeCodeRequest : public Darabonba::Model {
public:
  shared_ptr<long> nodeId{};
  shared_ptr<string> projectEnv{};

  GetNodeCodeRequest() {}

  explicit GetNodeCodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!nodeId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeId is required.")));
    }
    if (!projectEnv) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectEnv is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
  }


  virtual ~GetNodeCodeRequest() = default;
};
class GetNodeCodeResponse : public Darabonba::Model {
public:
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> data{};

  GetNodeCodeResponse() {}

  explicit GetNodeCodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
  }


  virtual ~GetNodeCodeResponse() = default;
};
class EstablishRelationTableToBusinessRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<string> businessId{};
  shared_ptr<string> tableGuid{};
  shared_ptr<string> folderId{};

  EstablishRelationTableToBusinessRequest() {}

  explicit EstablishRelationTableToBusinessRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!businessId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("businessId is required.")));
    }
    if (!tableGuid) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tableGuid is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (businessId) {
      res["BusinessId"] = boost::any(*businessId);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (folderId) {
      res["FolderId"] = boost::any(*folderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("BusinessId") != m.end() && !m["BusinessId"].empty()) {
      businessId = make_shared<string>(boost::any_cast<string>(m["BusinessId"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("FolderId") != m.end() && !m["FolderId"].empty()) {
      folderId = make_shared<string>(boost::any_cast<string>(m["FolderId"]));
    }
  }


  virtual ~EstablishRelationTableToBusinessRequest() = default;
};
class EstablishRelationTableToBusinessResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};

  EstablishRelationTableToBusinessResponse() {}

  explicit EstablishRelationTableToBusinessResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
  }


  virtual ~EstablishRelationTableToBusinessResponse() = default;
};
class UpdateDataServiceApiRequest : public Darabonba::Model {
public:
  shared_ptr<long> tenantId{};
  shared_ptr<long> projectId{};
  shared_ptr<long> apiId{};
  shared_ptr<int> requestMethod{};
  shared_ptr<int> responseContentType{};
  shared_ptr<int> timeout{};
  shared_ptr<int> visibleRange{};
  shared_ptr<string> protocols{};
  shared_ptr<string> wizardDetails{};
  shared_ptr<string> scriptDetails{};
  shared_ptr<string> registrationDetails{};
  shared_ptr<string> apiPath{};
  shared_ptr<string> apiDescription{};

  UpdateDataServiceApiRequest() {}

  explicit UpdateDataServiceApiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!tenantId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tenantId is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!apiId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("apiId is required.")));
    }
    if (!requestMethod) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestMethod is required.")));
    }
    if (!responseContentType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("responseContentType is required.")));
    }
    if (!timeout) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("timeout is required.")));
    }
    if (!visibleRange) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("visibleRange is required.")));
    }
    if (!protocols) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("protocols is required.")));
    }
    if (!apiPath) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("apiPath is required.")));
    }
    if (!apiDescription) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("apiDescription is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (requestMethod) {
      res["RequestMethod"] = boost::any(*requestMethod);
    }
    if (responseContentType) {
      res["ResponseContentType"] = boost::any(*responseContentType);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (visibleRange) {
      res["VisibleRange"] = boost::any(*visibleRange);
    }
    if (protocols) {
      res["Protocols"] = boost::any(*protocols);
    }
    if (wizardDetails) {
      res["WizardDetails"] = boost::any(*wizardDetails);
    }
    if (scriptDetails) {
      res["ScriptDetails"] = boost::any(*scriptDetails);
    }
    if (registrationDetails) {
      res["RegistrationDetails"] = boost::any(*registrationDetails);
    }
    if (apiPath) {
      res["ApiPath"] = boost::any(*apiPath);
    }
    if (apiDescription) {
      res["ApiDescription"] = boost::any(*apiDescription);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<long>(boost::any_cast<long>(m["ApiId"]));
    }
    if (m.find("RequestMethod") != m.end() && !m["RequestMethod"].empty()) {
      requestMethod = make_shared<int>(boost::any_cast<int>(m["RequestMethod"]));
    }
    if (m.find("ResponseContentType") != m.end() && !m["ResponseContentType"].empty()) {
      responseContentType = make_shared<int>(boost::any_cast<int>(m["ResponseContentType"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<int>(boost::any_cast<int>(m["Timeout"]));
    }
    if (m.find("VisibleRange") != m.end() && !m["VisibleRange"].empty()) {
      visibleRange = make_shared<int>(boost::any_cast<int>(m["VisibleRange"]));
    }
    if (m.find("Protocols") != m.end() && !m["Protocols"].empty()) {
      protocols = make_shared<string>(boost::any_cast<string>(m["Protocols"]));
    }
    if (m.find("WizardDetails") != m.end() && !m["WizardDetails"].empty()) {
      wizardDetails = make_shared<string>(boost::any_cast<string>(m["WizardDetails"]));
    }
    if (m.find("ScriptDetails") != m.end() && !m["ScriptDetails"].empty()) {
      scriptDetails = make_shared<string>(boost::any_cast<string>(m["ScriptDetails"]));
    }
    if (m.find("RegistrationDetails") != m.end() && !m["RegistrationDetails"].empty()) {
      registrationDetails = make_shared<string>(boost::any_cast<string>(m["RegistrationDetails"]));
    }
    if (m.find("ApiPath") != m.end() && !m["ApiPath"].empty()) {
      apiPath = make_shared<string>(boost::any_cast<string>(m["ApiPath"]));
    }
    if (m.find("ApiDescription") != m.end() && !m["ApiDescription"].empty()) {
      apiDescription = make_shared<string>(boost::any_cast<string>(m["ApiDescription"]));
    }
  }


  virtual ~UpdateDataServiceApiRequest() = default;
};
class UpdateDataServiceApiResponse : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<bool> success{};
  shared_ptr<string> requestId{};

  UpdateDataServiceApiResponse() {}

  explicit UpdateDataServiceApiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateDataServiceApiResponse() = default;
};
class UpdateUdfFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> fileFolderPath{};
  shared_ptr<long> projectId{};
  shared_ptr<string> functionType{};
  shared_ptr<string> className{};
  shared_ptr<string> resources{};
  shared_ptr<string> udfDescription{};
  shared_ptr<string> cmdDescription{};
  shared_ptr<string> parameterDescription{};
  shared_ptr<string> returnValue{};
  shared_ptr<string> example{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<string> fileId{};

  UpdateUdfFileRequest() {}

  explicit UpdateUdfFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!functionType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("functionType is required.")));
    }
    if (!className) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("className is required.")));
    }
    if (!resources) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("resources is required.")));
    }
    if (!fileId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("fileId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileFolderPath) {
      res["FileFolderPath"] = boost::any(*fileFolderPath);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (functionType) {
      res["FunctionType"] = boost::any(*functionType);
    }
    if (className) {
      res["ClassName"] = boost::any(*className);
    }
    if (resources) {
      res["Resources"] = boost::any(*resources);
    }
    if (udfDescription) {
      res["UdfDescription"] = boost::any(*udfDescription);
    }
    if (cmdDescription) {
      res["CmdDescription"] = boost::any(*cmdDescription);
    }
    if (parameterDescription) {
      res["ParameterDescription"] = boost::any(*parameterDescription);
    }
    if (returnValue) {
      res["ReturnValue"] = boost::any(*returnValue);
    }
    if (example) {
      res["Example"] = boost::any(*example);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileFolderPath") != m.end() && !m["FileFolderPath"].empty()) {
      fileFolderPath = make_shared<string>(boost::any_cast<string>(m["FileFolderPath"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("FunctionType") != m.end() && !m["FunctionType"].empty()) {
      functionType = make_shared<string>(boost::any_cast<string>(m["FunctionType"]));
    }
    if (m.find("ClassName") != m.end() && !m["ClassName"].empty()) {
      className = make_shared<string>(boost::any_cast<string>(m["ClassName"]));
    }
    if (m.find("Resources") != m.end() && !m["Resources"].empty()) {
      resources = make_shared<string>(boost::any_cast<string>(m["Resources"]));
    }
    if (m.find("UdfDescription") != m.end() && !m["UdfDescription"].empty()) {
      udfDescription = make_shared<string>(boost::any_cast<string>(m["UdfDescription"]));
    }
    if (m.find("CmdDescription") != m.end() && !m["CmdDescription"].empty()) {
      cmdDescription = make_shared<string>(boost::any_cast<string>(m["CmdDescription"]));
    }
    if (m.find("ParameterDescription") != m.end() && !m["ParameterDescription"].empty()) {
      parameterDescription = make_shared<string>(boost::any_cast<string>(m["ParameterDescription"]));
    }
    if (m.find("ReturnValue") != m.end() && !m["ReturnValue"].empty()) {
      returnValue = make_shared<string>(boost::any_cast<string>(m["ReturnValue"]));
    }
    if (m.find("Example") != m.end() && !m["Example"].empty()) {
      example = make_shared<string>(boost::any_cast<string>(m["Example"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
  }


  virtual ~UpdateUdfFileRequest() = default;
};
class UpdateUdfFileResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};

  UpdateUdfFileResponse() {}

  explicit UpdateUdfFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
  }


  virtual ~UpdateUdfFileResponse() = default;
};
class CreateUdfFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> fileFolderPath{};
  shared_ptr<long> projectId{};
  shared_ptr<string> fileName{};
  shared_ptr<string> functionType{};
  shared_ptr<string> className{};
  shared_ptr<string> resources{};
  shared_ptr<string> udfDescription{};
  shared_ptr<string> cmdDescription{};
  shared_ptr<string> parameterDescription{};
  shared_ptr<string> returnValue{};
  shared_ptr<string> example{};
  shared_ptr<string> projectIdentifier{};

  CreateUdfFileRequest() {}

  explicit CreateUdfFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!fileName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("fileName is required.")));
    }
    if (!functionType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("functionType is required.")));
    }
    if (!className) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("className is required.")));
    }
    if (!resources) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("resources is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileFolderPath) {
      res["FileFolderPath"] = boost::any(*fileFolderPath);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (functionType) {
      res["FunctionType"] = boost::any(*functionType);
    }
    if (className) {
      res["ClassName"] = boost::any(*className);
    }
    if (resources) {
      res["Resources"] = boost::any(*resources);
    }
    if (udfDescription) {
      res["UdfDescription"] = boost::any(*udfDescription);
    }
    if (cmdDescription) {
      res["CmdDescription"] = boost::any(*cmdDescription);
    }
    if (parameterDescription) {
      res["ParameterDescription"] = boost::any(*parameterDescription);
    }
    if (returnValue) {
      res["ReturnValue"] = boost::any(*returnValue);
    }
    if (example) {
      res["Example"] = boost::any(*example);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileFolderPath") != m.end() && !m["FileFolderPath"].empty()) {
      fileFolderPath = make_shared<string>(boost::any_cast<string>(m["FileFolderPath"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FunctionType") != m.end() && !m["FunctionType"].empty()) {
      functionType = make_shared<string>(boost::any_cast<string>(m["FunctionType"]));
    }
    if (m.find("ClassName") != m.end() && !m["ClassName"].empty()) {
      className = make_shared<string>(boost::any_cast<string>(m["ClassName"]));
    }
    if (m.find("Resources") != m.end() && !m["Resources"].empty()) {
      resources = make_shared<string>(boost::any_cast<string>(m["Resources"]));
    }
    if (m.find("UdfDescription") != m.end() && !m["UdfDescription"].empty()) {
      udfDescription = make_shared<string>(boost::any_cast<string>(m["UdfDescription"]));
    }
    if (m.find("CmdDescription") != m.end() && !m["CmdDescription"].empty()) {
      cmdDescription = make_shared<string>(boost::any_cast<string>(m["CmdDescription"]));
    }
    if (m.find("ParameterDescription") != m.end() && !m["ParameterDescription"].empty()) {
      parameterDescription = make_shared<string>(boost::any_cast<string>(m["ParameterDescription"]));
    }
    if (m.find("ReturnValue") != m.end() && !m["ReturnValue"].empty()) {
      returnValue = make_shared<string>(boost::any_cast<string>(m["ReturnValue"]));
    }
    if (m.find("Example") != m.end() && !m["Example"].empty()) {
      example = make_shared<string>(boost::any_cast<string>(m["Example"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
  }


  virtual ~CreateUdfFileRequest() = default;
};
class CreateUdfFileResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> data{};
  shared_ptr<int> httpStatusCode{};

  CreateUdfFileResponse() {}

  explicit CreateUdfFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
  }


  virtual ~CreateUdfFileResponse() = default;
};
class ListFilesRequest : public Darabonba::Model {
public:
  shared_ptr<string> fileFolderPath{};
  shared_ptr<long> projectId{};
  shared_ptr<string> keyword{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<string> useType{};
  shared_ptr<string> fileTypes{};
  shared_ptr<string> owner{};
  shared_ptr<long> nodeId{};

  ListFilesRequest() {}

  explicit ListFilesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileFolderPath) {
      res["FileFolderPath"] = boost::any(*fileFolderPath);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (useType) {
      res["UseType"] = boost::any(*useType);
    }
    if (fileTypes) {
      res["FileTypes"] = boost::any(*fileTypes);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileFolderPath") != m.end() && !m["FileFolderPath"].empty()) {
      fileFolderPath = make_shared<string>(boost::any_cast<string>(m["FileFolderPath"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("UseType") != m.end() && !m["UseType"].empty()) {
      useType = make_shared<string>(boost::any_cast<string>(m["UseType"]));
    }
    if (m.find("FileTypes") != m.end() && !m["FileTypes"].empty()) {
      fileTypes = make_shared<string>(boost::any_cast<string>(m["FileTypes"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
  }


  virtual ~ListFilesRequest() = default;
};
class ListFilesResponseDataFiles : public Darabonba::Model {
public:
  shared_ptr<string> connectionName{};
  shared_ptr<long> parentId{};
  shared_ptr<bool> isMaxCompute{};
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<long> bizId{};
  shared_ptr<string> fileFolderId{};
  shared_ptr<string> fileName{};
  shared_ptr<int> fileType{};
  shared_ptr<string> useType{};
  shared_ptr<string> fileDescription{};
  shared_ptr<string> content{};
  shared_ptr<long> nodeId{};
  shared_ptr<int> currentVersion{};
  shared_ptr<string> owner{};
  shared_ptr<string> lastEditUser{};
  shared_ptr<long> lastEditTime{};
  shared_ptr<int> commitStatus{};
  shared_ptr<long> fileId{};
  shared_ptr<long> businessId{};
  shared_ptr<bool> autoParsing{};

  ListFilesResponseDataFiles() {}

  explicit ListFilesResponseDataFiles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!connectionName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("connectionName is required.")));
    }
    if (!parentId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parentId is required.")));
    }
    if (!isMaxCompute) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("isMaxCompute is required.")));
    }
    if (!createTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("createTime is required.")));
    }
    if (!createUser) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("createUser is required.")));
    }
    if (!bizId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("bizId is required.")));
    }
    if (!fileFolderId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("fileFolderId is required.")));
    }
    if (!fileName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("fileName is required.")));
    }
    if (!fileType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("fileType is required.")));
    }
    if (!useType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("useType is required.")));
    }
    if (!fileDescription) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("fileDescription is required.")));
    }
    if (!content) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("content is required.")));
    }
    if (!nodeId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeId is required.")));
    }
    if (!currentVersion) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("currentVersion is required.")));
    }
    if (!owner) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("owner is required.")));
    }
    if (!lastEditUser) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("lastEditUser is required.")));
    }
    if (!lastEditTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("lastEditTime is required.")));
    }
    if (!commitStatus) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("commitStatus is required.")));
    }
    if (!fileId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("fileId is required.")));
    }
    if (!businessId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("businessId is required.")));
    }
    if (!autoParsing) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("autoParsing is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connectionName) {
      res["ConnectionName"] = boost::any(*connectionName);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (isMaxCompute) {
      res["IsMaxCompute"] = boost::any(*isMaxCompute);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (fileFolderId) {
      res["FileFolderId"] = boost::any(*fileFolderId);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (useType) {
      res["UseType"] = boost::any(*useType);
    }
    if (fileDescription) {
      res["FileDescription"] = boost::any(*fileDescription);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (currentVersion) {
      res["CurrentVersion"] = boost::any(*currentVersion);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (lastEditUser) {
      res["LastEditUser"] = boost::any(*lastEditUser);
    }
    if (lastEditTime) {
      res["LastEditTime"] = boost::any(*lastEditTime);
    }
    if (commitStatus) {
      res["CommitStatus"] = boost::any(*commitStatus);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (businessId) {
      res["BusinessId"] = boost::any(*businessId);
    }
    if (autoParsing) {
      res["AutoParsing"] = boost::any(*autoParsing);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConnectionName") != m.end() && !m["ConnectionName"].empty()) {
      connectionName = make_shared<string>(boost::any_cast<string>(m["ConnectionName"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
    if (m.find("IsMaxCompute") != m.end() && !m["IsMaxCompute"].empty()) {
      isMaxCompute = make_shared<bool>(boost::any_cast<bool>(m["IsMaxCompute"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<long>(boost::any_cast<long>(m["BizId"]));
    }
    if (m.find("FileFolderId") != m.end() && !m["FileFolderId"].empty()) {
      fileFolderId = make_shared<string>(boost::any_cast<string>(m["FileFolderId"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<int>(boost::any_cast<int>(m["FileType"]));
    }
    if (m.find("UseType") != m.end() && !m["UseType"].empty()) {
      useType = make_shared<string>(boost::any_cast<string>(m["UseType"]));
    }
    if (m.find("FileDescription") != m.end() && !m["FileDescription"].empty()) {
      fileDescription = make_shared<string>(boost::any_cast<string>(m["FileDescription"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("CurrentVersion") != m.end() && !m["CurrentVersion"].empty()) {
      currentVersion = make_shared<int>(boost::any_cast<int>(m["CurrentVersion"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("LastEditUser") != m.end() && !m["LastEditUser"].empty()) {
      lastEditUser = make_shared<string>(boost::any_cast<string>(m["LastEditUser"]));
    }
    if (m.find("LastEditTime") != m.end() && !m["LastEditTime"].empty()) {
      lastEditTime = make_shared<long>(boost::any_cast<long>(m["LastEditTime"]));
    }
    if (m.find("CommitStatus") != m.end() && !m["CommitStatus"].empty()) {
      commitStatus = make_shared<int>(boost::any_cast<int>(m["CommitStatus"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
    if (m.find("BusinessId") != m.end() && !m["BusinessId"].empty()) {
      businessId = make_shared<long>(boost::any_cast<long>(m["BusinessId"]));
    }
    if (m.find("AutoParsing") != m.end() && !m["AutoParsing"].empty()) {
      autoParsing = make_shared<bool>(boost::any_cast<bool>(m["AutoParsing"]));
    }
  }


  virtual ~ListFilesResponseDataFiles() = default;
};
class ListFilesResponseData : public Darabonba::Model {
public:
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> totalCount{};
  shared_ptr<vector<ListFilesResponseDataFiles>> files{};

  ListFilesResponseData() {}

  explicit ListFilesResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageNumber) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNumber is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!totalCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("totalCount is required.")));
    }
    if (!files) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("files is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (files) {
      vector<boost::any> temp1;
      for(auto item1:*files){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Files"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<int>(boost::any_cast<int>(m["TotalCount"]));
    }
    if (m.find("Files") != m.end() && !m["Files"].empty()) {
      if (typeid(vector<boost::any>) == m["Files"].type()) {
        vector<ListFilesResponseDataFiles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Files"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFilesResponseDataFiles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        files = make_shared<vector<ListFilesResponseDataFiles>>(expect1);
      }
    }
  }


  virtual ~ListFilesResponseData() = default;
};
class ListFilesResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<ListFilesResponseData> data{};

  ListFilesResponse() {}

  explicit ListFilesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListFilesResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListFilesResponseData>(model1);
      }
    }
  }


  virtual ~ListFilesResponse() = default;
};
class ListDataServiceAuthorizedApisRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<long> tenantId{};
  shared_ptr<string> apiNameKeyword{};

  ListDataServiceAuthorizedApisRequest() {}

  explicit ListDataServiceAuthorizedApisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!tenantId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tenantId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (apiNameKeyword) {
      res["ApiNameKeyword"] = boost::any(*apiNameKeyword);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("ApiNameKeyword") != m.end() && !m["ApiNameKeyword"].empty()) {
      apiNameKeyword = make_shared<string>(boost::any_cast<string>(m["ApiNameKeyword"]));
    }
  }


  virtual ~ListDataServiceAuthorizedApisRequest() = default;
};
class ListDataServiceAuthorizedApisResponseDataApiAuthorizedList : public Darabonba::Model {
public:
  shared_ptr<long> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> apiPath{};
  shared_ptr<int> apiStatus{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> grantCreatedTime{};
  shared_ptr<string> grantEndTime{};
  shared_ptr<string> grantOperatorId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<long> projectId{};
  shared_ptr<long> tenantId{};

  ListDataServiceAuthorizedApisResponseDataApiAuthorizedList() {}

  explicit ListDataServiceAuthorizedApisResponseDataApiAuthorizedList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!apiId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("apiId is required.")));
    }
    if (!apiName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("apiName is required.")));
    }
    if (!apiPath) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("apiPath is required.")));
    }
    if (!apiStatus) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("apiStatus is required.")));
    }
    if (!createdTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("createdTime is required.")));
    }
    if (!creatorId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("creatorId is required.")));
    }
    if (!grantCreatedTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("grantCreatedTime is required.")));
    }
    if (!grantEndTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("grantEndTime is required.")));
    }
    if (!grantOperatorId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("grantOperatorId is required.")));
    }
    if (!groupId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupId is required.")));
    }
    if (!modifiedTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("modifiedTime is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!tenantId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tenantId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (apiPath) {
      res["ApiPath"] = boost::any(*apiPath);
    }
    if (apiStatus) {
      res["ApiStatus"] = boost::any(*apiStatus);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (grantCreatedTime) {
      res["GrantCreatedTime"] = boost::any(*grantCreatedTime);
    }
    if (grantEndTime) {
      res["GrantEndTime"] = boost::any(*grantEndTime);
    }
    if (grantOperatorId) {
      res["GrantOperatorId"] = boost::any(*grantOperatorId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<long>(boost::any_cast<long>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("ApiPath") != m.end() && !m["ApiPath"].empty()) {
      apiPath = make_shared<string>(boost::any_cast<string>(m["ApiPath"]));
    }
    if (m.find("ApiStatus") != m.end() && !m["ApiStatus"].empty()) {
      apiStatus = make_shared<int>(boost::any_cast<int>(m["ApiStatus"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("GrantCreatedTime") != m.end() && !m["GrantCreatedTime"].empty()) {
      grantCreatedTime = make_shared<string>(boost::any_cast<string>(m["GrantCreatedTime"]));
    }
    if (m.find("GrantEndTime") != m.end() && !m["GrantEndTime"].empty()) {
      grantEndTime = make_shared<string>(boost::any_cast<string>(m["GrantEndTime"]));
    }
    if (m.find("GrantOperatorId") != m.end() && !m["GrantOperatorId"].empty()) {
      grantOperatorId = make_shared<string>(boost::any_cast<string>(m["GrantOperatorId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
  }


  virtual ~ListDataServiceAuthorizedApisResponseDataApiAuthorizedList() = default;
};
class ListDataServiceAuthorizedApisResponseData : public Darabonba::Model {
public:
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> totalCount{};
  shared_ptr<vector<ListDataServiceAuthorizedApisResponseDataApiAuthorizedList>> apiAuthorizedList{};

  ListDataServiceAuthorizedApisResponseData() {}

  explicit ListDataServiceAuthorizedApisResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageNumber) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNumber is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!totalCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("totalCount is required.")));
    }
    if (!apiAuthorizedList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("apiAuthorizedList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (apiAuthorizedList) {
      vector<boost::any> temp1;
      for(auto item1:*apiAuthorizedList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiAuthorizedList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<int>(boost::any_cast<int>(m["TotalCount"]));
    }
    if (m.find("ApiAuthorizedList") != m.end() && !m["ApiAuthorizedList"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiAuthorizedList"].type()) {
        vector<ListDataServiceAuthorizedApisResponseDataApiAuthorizedList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiAuthorizedList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataServiceAuthorizedApisResponseDataApiAuthorizedList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiAuthorizedList = make_shared<vector<ListDataServiceAuthorizedApisResponseDataApiAuthorizedList>>(expect1);
      }
    }
  }


  virtual ~ListDataServiceAuthorizedApisResponseData() = default;
};
class ListDataServiceAuthorizedApisResponse : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<ListDataServiceAuthorizedApisResponseData> data{};

  ListDataServiceAuthorizedApisResponse() {}

  explicit ListDataServiceAuthorizedApisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListDataServiceAuthorizedApisResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListDataServiceAuthorizedApisResponseData>(model1);
      }
    }
  }


  virtual ~ListDataServiceAuthorizedApisResponse() = default;
};
class UpdateFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> fileFolderPath{};
  shared_ptr<long> projectId{};
  shared_ptr<string> fileName{};
  shared_ptr<string> fileDescription{};
  shared_ptr<string> content{};
  shared_ptr<int> autoRerunTimes{};
  shared_ptr<int> autoRerunIntervalMillis{};
  shared_ptr<string> rerunMode{};
  shared_ptr<bool> stop{};
  shared_ptr<string> paraValue{};
  shared_ptr<long> startEffectDate{};
  shared_ptr<long> endEffectDate{};
  shared_ptr<string> cronExpress{};
  shared_ptr<string> cycleType{};
  shared_ptr<string> dependentType{};
  shared_ptr<string> dependentNodeIdList{};
  shared_ptr<string> inputList{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<long> fileId{};
  shared_ptr<string> outputList{};
  shared_ptr<string> resourceGroupIdentifier{};
  shared_ptr<string> connectionName{};
  shared_ptr<string> owner{};
  shared_ptr<bool> autoParsing{};
  shared_ptr<string> schedulerType{};

  UpdateFileRequest() {}

  explicit UpdateFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!fileId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("fileId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileFolderPath) {
      res["FileFolderPath"] = boost::any(*fileFolderPath);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileDescription) {
      res["FileDescription"] = boost::any(*fileDescription);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (autoRerunTimes) {
      res["AutoRerunTimes"] = boost::any(*autoRerunTimes);
    }
    if (autoRerunIntervalMillis) {
      res["AutoRerunIntervalMillis"] = boost::any(*autoRerunIntervalMillis);
    }
    if (rerunMode) {
      res["RerunMode"] = boost::any(*rerunMode);
    }
    if (stop) {
      res["Stop"] = boost::any(*stop);
    }
    if (paraValue) {
      res["ParaValue"] = boost::any(*paraValue);
    }
    if (startEffectDate) {
      res["StartEffectDate"] = boost::any(*startEffectDate);
    }
    if (endEffectDate) {
      res["EndEffectDate"] = boost::any(*endEffectDate);
    }
    if (cronExpress) {
      res["CronExpress"] = boost::any(*cronExpress);
    }
    if (cycleType) {
      res["CycleType"] = boost::any(*cycleType);
    }
    if (dependentType) {
      res["DependentType"] = boost::any(*dependentType);
    }
    if (dependentNodeIdList) {
      res["DependentNodeIdList"] = boost::any(*dependentNodeIdList);
    }
    if (inputList) {
      res["InputList"] = boost::any(*inputList);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (outputList) {
      res["OutputList"] = boost::any(*outputList);
    }
    if (resourceGroupIdentifier) {
      res["ResourceGroupIdentifier"] = boost::any(*resourceGroupIdentifier);
    }
    if (connectionName) {
      res["ConnectionName"] = boost::any(*connectionName);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (autoParsing) {
      res["AutoParsing"] = boost::any(*autoParsing);
    }
    if (schedulerType) {
      res["SchedulerType"] = boost::any(*schedulerType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileFolderPath") != m.end() && !m["FileFolderPath"].empty()) {
      fileFolderPath = make_shared<string>(boost::any_cast<string>(m["FileFolderPath"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileDescription") != m.end() && !m["FileDescription"].empty()) {
      fileDescription = make_shared<string>(boost::any_cast<string>(m["FileDescription"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("AutoRerunTimes") != m.end() && !m["AutoRerunTimes"].empty()) {
      autoRerunTimes = make_shared<int>(boost::any_cast<int>(m["AutoRerunTimes"]));
    }
    if (m.find("AutoRerunIntervalMillis") != m.end() && !m["AutoRerunIntervalMillis"].empty()) {
      autoRerunIntervalMillis = make_shared<int>(boost::any_cast<int>(m["AutoRerunIntervalMillis"]));
    }
    if (m.find("RerunMode") != m.end() && !m["RerunMode"].empty()) {
      rerunMode = make_shared<string>(boost::any_cast<string>(m["RerunMode"]));
    }
    if (m.find("Stop") != m.end() && !m["Stop"].empty()) {
      stop = make_shared<bool>(boost::any_cast<bool>(m["Stop"]));
    }
    if (m.find("ParaValue") != m.end() && !m["ParaValue"].empty()) {
      paraValue = make_shared<string>(boost::any_cast<string>(m["ParaValue"]));
    }
    if (m.find("StartEffectDate") != m.end() && !m["StartEffectDate"].empty()) {
      startEffectDate = make_shared<long>(boost::any_cast<long>(m["StartEffectDate"]));
    }
    if (m.find("EndEffectDate") != m.end() && !m["EndEffectDate"].empty()) {
      endEffectDate = make_shared<long>(boost::any_cast<long>(m["EndEffectDate"]));
    }
    if (m.find("CronExpress") != m.end() && !m["CronExpress"].empty()) {
      cronExpress = make_shared<string>(boost::any_cast<string>(m["CronExpress"]));
    }
    if (m.find("CycleType") != m.end() && !m["CycleType"].empty()) {
      cycleType = make_shared<string>(boost::any_cast<string>(m["CycleType"]));
    }
    if (m.find("DependentType") != m.end() && !m["DependentType"].empty()) {
      dependentType = make_shared<string>(boost::any_cast<string>(m["DependentType"]));
    }
    if (m.find("DependentNodeIdList") != m.end() && !m["DependentNodeIdList"].empty()) {
      dependentNodeIdList = make_shared<string>(boost::any_cast<string>(m["DependentNodeIdList"]));
    }
    if (m.find("InputList") != m.end() && !m["InputList"].empty()) {
      inputList = make_shared<string>(boost::any_cast<string>(m["InputList"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
    if (m.find("OutputList") != m.end() && !m["OutputList"].empty()) {
      outputList = make_shared<string>(boost::any_cast<string>(m["OutputList"]));
    }
    if (m.find("ResourceGroupIdentifier") != m.end() && !m["ResourceGroupIdentifier"].empty()) {
      resourceGroupIdentifier = make_shared<string>(boost::any_cast<string>(m["ResourceGroupIdentifier"]));
    }
    if (m.find("ConnectionName") != m.end() && !m["ConnectionName"].empty()) {
      connectionName = make_shared<string>(boost::any_cast<string>(m["ConnectionName"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("AutoParsing") != m.end() && !m["AutoParsing"].empty()) {
      autoParsing = make_shared<bool>(boost::any_cast<bool>(m["AutoParsing"]));
    }
    if (m.find("SchedulerType") != m.end() && !m["SchedulerType"].empty()) {
      schedulerType = make_shared<string>(boost::any_cast<string>(m["SchedulerType"]));
    }
  }


  virtual ~UpdateFileRequest() = default;
};
class UpdateFileResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};

  UpdateFileResponse() {}

  explicit UpdateFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
  }


  virtual ~UpdateFileResponse() = default;
};
class DeleteFolderRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<string> folderId{};

  DeleteFolderRequest() {}

  explicit DeleteFolderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!folderId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("folderId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (folderId) {
      res["FolderId"] = boost::any(*folderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("FolderId") != m.end() && !m["FolderId"].empty()) {
      folderId = make_shared<string>(boost::any_cast<string>(m["FolderId"]));
    }
  }


  virtual ~DeleteFolderRequest() = default;
};
class DeleteFolderResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};

  DeleteFolderResponse() {}

  explicit DeleteFolderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
  }


  virtual ~DeleteFolderResponse() = default;
};
class ListFoldersRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<string> parentFolderPath{};
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};

  ListFoldersRequest() {}

  explicit ListFoldersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!parentFolderPath) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parentFolderPath is required.")));
    }
    if (!pageNumber) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNumber is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (parentFolderPath) {
      res["ParentFolderPath"] = boost::any(*parentFolderPath);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("ParentFolderPath") != m.end() && !m["ParentFolderPath"].empty()) {
      parentFolderPath = make_shared<string>(boost::any_cast<string>(m["ParentFolderPath"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
  }


  virtual ~ListFoldersRequest() = default;
};
class ListFoldersResponseDataFolders : public Darabonba::Model {
public:
  shared_ptr<string> folderId{};
  shared_ptr<string> folderPath{};

  ListFoldersResponseDataFolders() {}

  explicit ListFoldersResponseDataFolders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!folderId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("folderId is required.")));
    }
    if (!folderPath) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("folderPath is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (folderId) {
      res["FolderId"] = boost::any(*folderId);
    }
    if (folderPath) {
      res["FolderPath"] = boost::any(*folderPath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FolderId") != m.end() && !m["FolderId"].empty()) {
      folderId = make_shared<string>(boost::any_cast<string>(m["FolderId"]));
    }
    if (m.find("FolderPath") != m.end() && !m["FolderPath"].empty()) {
      folderPath = make_shared<string>(boost::any_cast<string>(m["FolderPath"]));
    }
  }


  virtual ~ListFoldersResponseDataFolders() = default;
};
class ListFoldersResponseData : public Darabonba::Model {
public:
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> totalCount{};
  shared_ptr<vector<ListFoldersResponseDataFolders>> folders{};

  ListFoldersResponseData() {}

  explicit ListFoldersResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageNumber) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNumber is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!totalCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("totalCount is required.")));
    }
    if (!folders) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("folders is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (folders) {
      vector<boost::any> temp1;
      for(auto item1:*folders){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Folders"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<int>(boost::any_cast<int>(m["TotalCount"]));
    }
    if (m.find("Folders") != m.end() && !m["Folders"].empty()) {
      if (typeid(vector<boost::any>) == m["Folders"].type()) {
        vector<ListFoldersResponseDataFolders> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Folders"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFoldersResponseDataFolders model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        folders = make_shared<vector<ListFoldersResponseDataFolders>>(expect1);
      }
    }
  }


  virtual ~ListFoldersResponseData() = default;
};
class ListFoldersResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<ListFoldersResponseData> data{};

  ListFoldersResponse() {}

  explicit ListFoldersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListFoldersResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListFoldersResponseData>(model1);
      }
    }
  }


  virtual ~ListFoldersResponse() = default;
};
class CheckMetaPartitionRequest : public Darabonba::Model {
public:
  shared_ptr<string> tableGuid{};
  shared_ptr<string> partition{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> databaseName{};
  shared_ptr<string> tableName{};
  shared_ptr<string> dataSourceType{};

  CheckMetaPartitionRequest() {}

  explicit CheckMetaPartitionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!partition) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("partition is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (partition) {
      res["Partition"] = boost::any(*partition);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (dataSourceType) {
      res["DataSourceType"] = boost::any(*dataSourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("Partition") != m.end() && !m["Partition"].empty()) {
      partition = make_shared<string>(boost::any_cast<string>(m["Partition"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("DataSourceType") != m.end() && !m["DataSourceType"].empty()) {
      dataSourceType = make_shared<string>(boost::any_cast<string>(m["DataSourceType"]));
    }
  }


  virtual ~CheckMetaPartitionRequest() = default;
};
class CheckMetaPartitionResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<bool> success{};
  shared_ptr<bool> data{};

  CheckMetaPartitionResponse() {}

  explicit CheckMetaPartitionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
  }


  virtual ~CheckMetaPartitionResponse() = default;
};
class UpdateFolderRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<string> folderId{};
  shared_ptr<string> folderName{};

  UpdateFolderRequest() {}

  explicit UpdateFolderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!folderId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("folderId is required.")));
    }
    if (!folderName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("folderName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (folderId) {
      res["FolderId"] = boost::any(*folderId);
    }
    if (folderName) {
      res["FolderName"] = boost::any(*folderName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("FolderId") != m.end() && !m["FolderId"].empty()) {
      folderId = make_shared<string>(boost::any_cast<string>(m["FolderId"]));
    }
    if (m.find("FolderName") != m.end() && !m["FolderName"].empty()) {
      folderName = make_shared<string>(boost::any_cast<string>(m["FolderName"]));
    }
  }


  virtual ~UpdateFolderRequest() = default;
};
class UpdateFolderResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};

  UpdateFolderResponse() {}

  explicit UpdateFolderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
  }


  virtual ~UpdateFolderResponse() = default;
};
class DeleteRemindRequest : public Darabonba::Model {
public:
  shared_ptr<long> remindId{};

  DeleteRemindRequest() {}

  explicit DeleteRemindRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!remindId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("remindId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (remindId) {
      res["RemindId"] = boost::any(*remindId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RemindId") != m.end() && !m["RemindId"].empty()) {
      remindId = make_shared<long>(boost::any_cast<long>(m["RemindId"]));
    }
  }


  virtual ~DeleteRemindRequest() = default;
};
class DeleteRemindResponse : public Darabonba::Model {
public:
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> data{};

  DeleteRemindResponse() {}

  explicit DeleteRemindResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
  }


  virtual ~DeleteRemindResponse() = default;
};
class AddToMetaCategoryRequest : public Darabonba::Model {
public:
  shared_ptr<long> categoryId{};
  shared_ptr<string> tableGuid{};

  AddToMetaCategoryRequest() {}

  explicit AddToMetaCategoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!categoryId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("categoryId is required.")));
    }
    if (!tableGuid) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tableGuid is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<long>(boost::any_cast<long>(m["CategoryId"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
  }


  virtual ~AddToMetaCategoryRequest() = default;
};
class AddToMetaCategoryResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<bool> success{};
  shared_ptr<bool> data{};

  AddToMetaCategoryResponse() {}

  explicit AddToMetaCategoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
  }


  virtual ~AddToMetaCategoryResponse() = default;
};
class ListInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectEnv{};
  shared_ptr<long> nodeId{};
  shared_ptr<string> nodeName{};
  shared_ptr<string> owner{};
  shared_ptr<long> projectId{};
  shared_ptr<string> bizName{};
  shared_ptr<string> programType{};
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<long> dagId{};
  shared_ptr<string> bizdate{};
  shared_ptr<string> beginBizdate{};
  shared_ptr<string> endBizdate{};

  ListInstancesRequest() {}

  explicit ListInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectEnv) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectEnv is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (bizName) {
      res["BizName"] = boost::any(*bizName);
    }
    if (programType) {
      res["ProgramType"] = boost::any(*programType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (bizdate) {
      res["Bizdate"] = boost::any(*bizdate);
    }
    if (beginBizdate) {
      res["BeginBizdate"] = boost::any(*beginBizdate);
    }
    if (endBizdate) {
      res["EndBizdate"] = boost::any(*endBizdate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("BizName") != m.end() && !m["BizName"].empty()) {
      bizName = make_shared<string>(boost::any_cast<string>(m["BizName"]));
    }
    if (m.find("ProgramType") != m.end() && !m["ProgramType"].empty()) {
      programType = make_shared<string>(boost::any_cast<string>(m["ProgramType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("Bizdate") != m.end() && !m["Bizdate"].empty()) {
      bizdate = make_shared<string>(boost::any_cast<string>(m["Bizdate"]));
    }
    if (m.find("BeginBizdate") != m.end() && !m["BeginBizdate"].empty()) {
      beginBizdate = make_shared<string>(boost::any_cast<string>(m["BeginBizdate"]));
    }
    if (m.find("EndBizdate") != m.end() && !m["EndBizdate"].empty()) {
      endBizdate = make_shared<string>(boost::any_cast<string>(m["EndBizdate"]));
    }
  }


  virtual ~ListInstancesRequest() = default;
};
class ListInstancesResponseDataInstances : public Darabonba::Model {
public:
  shared_ptr<long> nodeId{};
  shared_ptr<long> instanceId{};
  shared_ptr<long> dagId{};
  shared_ptr<string> dagType{};
  shared_ptr<string> status{};
  shared_ptr<long> bizdate{};
  shared_ptr<long> cycTime{};
  shared_ptr<long> createTime{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> nodeName{};
  shared_ptr<long> beginWaitTimeTime{};
  shared_ptr<long> beginWaitResTime{};
  shared_ptr<long> beginRunningTime{};
  shared_ptr<string> paramValues{};
  shared_ptr<long> finishTime{};
  shared_ptr<int> priority{};
  shared_ptr<long> baselineId{};
  shared_ptr<bool> repeatability{};
  shared_ptr<long> repeatInterval{};
  shared_ptr<string> connection{};
  shared_ptr<int> dqcType{};
  shared_ptr<string> dqcDescription{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> relatedFlowId{};
  shared_ptr<string> taskType{};
  shared_ptr<int> taskRerunTime{};
  shared_ptr<long> businessId{};

  ListInstancesResponseDataInstances() {}

  explicit ListInstancesResponseDataInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!nodeId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeId is required.")));
    }
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
    if (!dagId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dagId is required.")));
    }
    if (!dagType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dagType is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!bizdate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("bizdate is required.")));
    }
    if (!cycTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("cycTime is required.")));
    }
    if (!createTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("createTime is required.")));
    }
    if (!modifyTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("modifyTime is required.")));
    }
    if (!nodeName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeName is required.")));
    }
    if (!beginWaitTimeTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("beginWaitTimeTime is required.")));
    }
    if (!beginWaitResTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("beginWaitResTime is required.")));
    }
    if (!beginRunningTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("beginRunningTime is required.")));
    }
    if (!paramValues) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("paramValues is required.")));
    }
    if (!finishTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("finishTime is required.")));
    }
    if (!priority) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("priority is required.")));
    }
    if (!baselineId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("baselineId is required.")));
    }
    if (!repeatability) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("repeatability is required.")));
    }
    if (!repeatInterval) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("repeatInterval is required.")));
    }
    if (!connection) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("connection is required.")));
    }
    if (!dqcType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dqcType is required.")));
    }
    if (!dqcDescription) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dqcDescription is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!relatedFlowId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("relatedFlowId is required.")));
    }
    if (!taskType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskType is required.")));
    }
    if (!taskRerunTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskRerunTime is required.")));
    }
    if (!businessId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("businessId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (dagType) {
      res["DagType"] = boost::any(*dagType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (bizdate) {
      res["Bizdate"] = boost::any(*bizdate);
    }
    if (cycTime) {
      res["CycTime"] = boost::any(*cycTime);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (beginWaitTimeTime) {
      res["BeginWaitTimeTime"] = boost::any(*beginWaitTimeTime);
    }
    if (beginWaitResTime) {
      res["BeginWaitResTime"] = boost::any(*beginWaitResTime);
    }
    if (beginRunningTime) {
      res["BeginRunningTime"] = boost::any(*beginRunningTime);
    }
    if (paramValues) {
      res["ParamValues"] = boost::any(*paramValues);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (repeatability) {
      res["Repeatability"] = boost::any(*repeatability);
    }
    if (repeatInterval) {
      res["RepeatInterval"] = boost::any(*repeatInterval);
    }
    if (connection) {
      res["Connection"] = boost::any(*connection);
    }
    if (dqcType) {
      res["DqcType"] = boost::any(*dqcType);
    }
    if (dqcDescription) {
      res["DqcDescription"] = boost::any(*dqcDescription);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (relatedFlowId) {
      res["RelatedFlowId"] = boost::any(*relatedFlowId);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (taskRerunTime) {
      res["TaskRerunTime"] = boost::any(*taskRerunTime);
    }
    if (businessId) {
      res["BusinessId"] = boost::any(*businessId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("DagType") != m.end() && !m["DagType"].empty()) {
      dagType = make_shared<string>(boost::any_cast<string>(m["DagType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Bizdate") != m.end() && !m["Bizdate"].empty()) {
      bizdate = make_shared<long>(boost::any_cast<long>(m["Bizdate"]));
    }
    if (m.find("CycTime") != m.end() && !m["CycTime"].empty()) {
      cycTime = make_shared<long>(boost::any_cast<long>(m["CycTime"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("BeginWaitTimeTime") != m.end() && !m["BeginWaitTimeTime"].empty()) {
      beginWaitTimeTime = make_shared<long>(boost::any_cast<long>(m["BeginWaitTimeTime"]));
    }
    if (m.find("BeginWaitResTime") != m.end() && !m["BeginWaitResTime"].empty()) {
      beginWaitResTime = make_shared<long>(boost::any_cast<long>(m["BeginWaitResTime"]));
    }
    if (m.find("BeginRunningTime") != m.end() && !m["BeginRunningTime"].empty()) {
      beginRunningTime = make_shared<long>(boost::any_cast<long>(m["BeginRunningTime"]));
    }
    if (m.find("ParamValues") != m.end() && !m["ParamValues"].empty()) {
      paramValues = make_shared<string>(boost::any_cast<string>(m["ParamValues"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<long>(boost::any_cast<long>(m["FinishTime"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<int>(boost::any_cast<int>(m["Priority"]));
    }
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("Repeatability") != m.end() && !m["Repeatability"].empty()) {
      repeatability = make_shared<bool>(boost::any_cast<bool>(m["Repeatability"]));
    }
    if (m.find("RepeatInterval") != m.end() && !m["RepeatInterval"].empty()) {
      repeatInterval = make_shared<long>(boost::any_cast<long>(m["RepeatInterval"]));
    }
    if (m.find("Connection") != m.end() && !m["Connection"].empty()) {
      connection = make_shared<string>(boost::any_cast<string>(m["Connection"]));
    }
    if (m.find("DqcType") != m.end() && !m["DqcType"].empty()) {
      dqcType = make_shared<int>(boost::any_cast<int>(m["DqcType"]));
    }
    if (m.find("DqcDescription") != m.end() && !m["DqcDescription"].empty()) {
      dqcDescription = make_shared<string>(boost::any_cast<string>(m["DqcDescription"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RelatedFlowId") != m.end() && !m["RelatedFlowId"].empty()) {
      relatedFlowId = make_shared<long>(boost::any_cast<long>(m["RelatedFlowId"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("TaskRerunTime") != m.end() && !m["TaskRerunTime"].empty()) {
      taskRerunTime = make_shared<int>(boost::any_cast<int>(m["TaskRerunTime"]));
    }
    if (m.find("BusinessId") != m.end() && !m["BusinessId"].empty()) {
      businessId = make_shared<long>(boost::any_cast<long>(m["BusinessId"]));
    }
  }


  virtual ~ListInstancesResponseDataInstances() = default;
};
class ListInstancesResponseData : public Darabonba::Model {
public:
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> totalCount{};
  shared_ptr<vector<ListInstancesResponseDataInstances>> instances{};

  ListInstancesResponseData() {}

  explicit ListInstancesResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageNumber) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNumber is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!totalCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("totalCount is required.")));
    }
    if (!instances) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instances is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (instances) {
      vector<boost::any> temp1;
      for(auto item1:*instances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Instances"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<int>(boost::any_cast<int>(m["TotalCount"]));
    }
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      if (typeid(vector<boost::any>) == m["Instances"].type()) {
        vector<ListInstancesResponseDataInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Instances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInstancesResponseDataInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instances = make_shared<vector<ListInstancesResponseDataInstances>>(expect1);
      }
    }
  }


  virtual ~ListInstancesResponseData() = default;
};
class ListInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<bool> success{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<ListInstancesResponseData> data{};

  ListInstancesResponse() {}

  explicit ListInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListInstancesResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListInstancesResponseData>(model1);
      }
    }
  }


  virtual ~ListInstancesResponse() = default;
};
class SetSuccessInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> instanceId{};
  shared_ptr<string> projectEnv{};

  SetSuccessInstanceRequest() {}

  explicit SetSuccessInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
    if (!projectEnv) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectEnv is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
  }


  virtual ~SetSuccessInstanceRequest() = default;
};
class SetSuccessInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<bool> data{};

  SetSuccessInstanceResponse() {}

  explicit SetSuccessInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
  }


  virtual ~SetSuccessInstanceResponse() = default;
};
class CreateFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> fileFolderPath{};
  shared_ptr<long> projectId{};
  shared_ptr<string> fileName{};
  shared_ptr<string> fileDescription{};
  shared_ptr<int> fileType{};
  shared_ptr<string> owner{};
  shared_ptr<string> content{};
  shared_ptr<int> autoRerunTimes{};
  shared_ptr<int> autoRerunIntervalMillis{};
  shared_ptr<string> rerunMode{};
  shared_ptr<bool> stop{};
  shared_ptr<string> paraValue{};
  shared_ptr<long> startEffectDate{};
  shared_ptr<long> endEffectDate{};
  shared_ptr<string> cronExpress{};
  shared_ptr<string> cycleType{};
  shared_ptr<string> dependentType{};
  shared_ptr<string> dependentNodeIdList{};
  shared_ptr<string> inputList{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<string> resourceGroupIdentifier{};
  shared_ptr<long> resourceGroupId{};
  shared_ptr<string> connectionName{};
  shared_ptr<bool> autoParsing{};
  shared_ptr<string> schedulerType{};

  CreateFileRequest() {}

  explicit CreateFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!fileName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("fileName is required.")));
    }
    if (!fileType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("fileType is required.")));
    }
    if (!inputList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("inputList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileFolderPath) {
      res["FileFolderPath"] = boost::any(*fileFolderPath);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileDescription) {
      res["FileDescription"] = boost::any(*fileDescription);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (autoRerunTimes) {
      res["AutoRerunTimes"] = boost::any(*autoRerunTimes);
    }
    if (autoRerunIntervalMillis) {
      res["AutoRerunIntervalMillis"] = boost::any(*autoRerunIntervalMillis);
    }
    if (rerunMode) {
      res["RerunMode"] = boost::any(*rerunMode);
    }
    if (stop) {
      res["Stop"] = boost::any(*stop);
    }
    if (paraValue) {
      res["ParaValue"] = boost::any(*paraValue);
    }
    if (startEffectDate) {
      res["StartEffectDate"] = boost::any(*startEffectDate);
    }
    if (endEffectDate) {
      res["EndEffectDate"] = boost::any(*endEffectDate);
    }
    if (cronExpress) {
      res["CronExpress"] = boost::any(*cronExpress);
    }
    if (cycleType) {
      res["CycleType"] = boost::any(*cycleType);
    }
    if (dependentType) {
      res["DependentType"] = boost::any(*dependentType);
    }
    if (dependentNodeIdList) {
      res["DependentNodeIdList"] = boost::any(*dependentNodeIdList);
    }
    if (inputList) {
      res["InputList"] = boost::any(*inputList);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (resourceGroupIdentifier) {
      res["ResourceGroupIdentifier"] = boost::any(*resourceGroupIdentifier);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (connectionName) {
      res["ConnectionName"] = boost::any(*connectionName);
    }
    if (autoParsing) {
      res["AutoParsing"] = boost::any(*autoParsing);
    }
    if (schedulerType) {
      res["SchedulerType"] = boost::any(*schedulerType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileFolderPath") != m.end() && !m["FileFolderPath"].empty()) {
      fileFolderPath = make_shared<string>(boost::any_cast<string>(m["FileFolderPath"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileDescription") != m.end() && !m["FileDescription"].empty()) {
      fileDescription = make_shared<string>(boost::any_cast<string>(m["FileDescription"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<int>(boost::any_cast<int>(m["FileType"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("AutoRerunTimes") != m.end() && !m["AutoRerunTimes"].empty()) {
      autoRerunTimes = make_shared<int>(boost::any_cast<int>(m["AutoRerunTimes"]));
    }
    if (m.find("AutoRerunIntervalMillis") != m.end() && !m["AutoRerunIntervalMillis"].empty()) {
      autoRerunIntervalMillis = make_shared<int>(boost::any_cast<int>(m["AutoRerunIntervalMillis"]));
    }
    if (m.find("RerunMode") != m.end() && !m["RerunMode"].empty()) {
      rerunMode = make_shared<string>(boost::any_cast<string>(m["RerunMode"]));
    }
    if (m.find("Stop") != m.end() && !m["Stop"].empty()) {
      stop = make_shared<bool>(boost::any_cast<bool>(m["Stop"]));
    }
    if (m.find("ParaValue") != m.end() && !m["ParaValue"].empty()) {
      paraValue = make_shared<string>(boost::any_cast<string>(m["ParaValue"]));
    }
    if (m.find("StartEffectDate") != m.end() && !m["StartEffectDate"].empty()) {
      startEffectDate = make_shared<long>(boost::any_cast<long>(m["StartEffectDate"]));
    }
    if (m.find("EndEffectDate") != m.end() && !m["EndEffectDate"].empty()) {
      endEffectDate = make_shared<long>(boost::any_cast<long>(m["EndEffectDate"]));
    }
    if (m.find("CronExpress") != m.end() && !m["CronExpress"].empty()) {
      cronExpress = make_shared<string>(boost::any_cast<string>(m["CronExpress"]));
    }
    if (m.find("CycleType") != m.end() && !m["CycleType"].empty()) {
      cycleType = make_shared<string>(boost::any_cast<string>(m["CycleType"]));
    }
    if (m.find("DependentType") != m.end() && !m["DependentType"].empty()) {
      dependentType = make_shared<string>(boost::any_cast<string>(m["DependentType"]));
    }
    if (m.find("DependentNodeIdList") != m.end() && !m["DependentNodeIdList"].empty()) {
      dependentNodeIdList = make_shared<string>(boost::any_cast<string>(m["DependentNodeIdList"]));
    }
    if (m.find("InputList") != m.end() && !m["InputList"].empty()) {
      inputList = make_shared<string>(boost::any_cast<string>(m["InputList"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("ResourceGroupIdentifier") != m.end() && !m["ResourceGroupIdentifier"].empty()) {
      resourceGroupIdentifier = make_shared<string>(boost::any_cast<string>(m["ResourceGroupIdentifier"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<long>(boost::any_cast<long>(m["ResourceGroupId"]));
    }
    if (m.find("ConnectionName") != m.end() && !m["ConnectionName"].empty()) {
      connectionName = make_shared<string>(boost::any_cast<string>(m["ConnectionName"]));
    }
    if (m.find("AutoParsing") != m.end() && !m["AutoParsing"].empty()) {
      autoParsing = make_shared<bool>(boost::any_cast<bool>(m["AutoParsing"]));
    }
    if (m.find("SchedulerType") != m.end() && !m["SchedulerType"].empty()) {
      schedulerType = make_shared<string>(boost::any_cast<string>(m["SchedulerType"]));
    }
  }


  virtual ~CreateFileRequest() = default;
};
class CreateFileResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> data{};
  shared_ptr<int> httpStatusCode{};

  CreateFileResponse() {}

  explicit CreateFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
  }


  virtual ~CreateFileResponse() = default;
};
class StopInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> instanceId{};
  shared_ptr<string> projectEnv{};

  StopInstanceRequest() {}

  explicit StopInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
    if (!projectEnv) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectEnv is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
  }


  virtual ~StopInstanceRequest() = default;
};
class StopInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<bool> data{};

  StopInstanceResponse() {}

  explicit StopInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
  }


  virtual ~StopInstanceResponse() = default;
};
class ResumeInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> instanceId{};
  shared_ptr<string> projectEnv{};

  ResumeInstanceRequest() {}

  explicit ResumeInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
    if (!projectEnv) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectEnv is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
  }


  virtual ~ResumeInstanceRequest() = default;
};
class ResumeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<bool> data{};

  ResumeInstanceResponse() {}

  explicit ResumeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
  }


  virtual ~ResumeInstanceResponse() = default;
};
class SuspendInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> instanceId{};
  shared_ptr<string> projectEnv{};

  SuspendInstanceRequest() {}

  explicit SuspendInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
    if (!projectEnv) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectEnv is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
  }


  virtual ~SuspendInstanceRequest() = default;
};
class SuspendInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<bool> data{};

  SuspendInstanceResponse() {}

  explicit SuspendInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
  }


  virtual ~SuspendInstanceResponse() = default;
};
class RestartInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> instanceId{};
  shared_ptr<string> projectEnv{};

  RestartInstanceRequest() {}

  explicit RestartInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
    if (!projectEnv) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectEnv is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
  }


  virtual ~RestartInstanceRequest() = default;
};
class RestartInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<bool> data{};

  RestartInstanceResponse() {}

  explicit RestartInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
  }


  virtual ~RestartInstanceResponse() = default;
};
class ListDataServiceApiAuthoritiesRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<long> tenantId{};
  shared_ptr<string> apiNameKeyword{};

  ListDataServiceApiAuthoritiesRequest() {}

  explicit ListDataServiceApiAuthoritiesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!tenantId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tenantId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (apiNameKeyword) {
      res["ApiNameKeyword"] = boost::any(*apiNameKeyword);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("ApiNameKeyword") != m.end() && !m["ApiNameKeyword"].empty()) {
      apiNameKeyword = make_shared<string>(boost::any_cast<string>(m["ApiNameKeyword"]));
    }
  }


  virtual ~ListDataServiceApiAuthoritiesRequest() = default;
};
class ListDataServiceApiAuthoritiesResponseDataApiAuthorizationListAuthorizationRecords : public Darabonba::Model {
public:
  shared_ptr<string> createdTime{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> endTime{};
  shared_ptr<long> projectId{};

  ListDataServiceApiAuthoritiesResponseDataApiAuthorizationListAuthorizationRecords() {}

  explicit ListDataServiceApiAuthoritiesResponseDataApiAuthorizationListAuthorizationRecords(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!createdTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("createdTime is required.")));
    }
    if (!creatorId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("creatorId is required.")));
    }
    if (!endTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("endTime is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~ListDataServiceApiAuthoritiesResponseDataApiAuthorizationListAuthorizationRecords() = default;
};
class ListDataServiceApiAuthoritiesResponseDataApiAuthorizationList : public Darabonba::Model {
public:
  shared_ptr<long> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> apiPath{};
  shared_ptr<int> apiStatus{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<long> projectId{};
  shared_ptr<long> tenantId{};
  shared_ptr<vector<ListDataServiceApiAuthoritiesResponseDataApiAuthorizationListAuthorizationRecords>> authorizationRecords{};

  ListDataServiceApiAuthoritiesResponseDataApiAuthorizationList() {}

  explicit ListDataServiceApiAuthoritiesResponseDataApiAuthorizationList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!apiId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("apiId is required.")));
    }
    if (!apiName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("apiName is required.")));
    }
    if (!apiPath) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("apiPath is required.")));
    }
    if (!apiStatus) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("apiStatus is required.")));
    }
    if (!createdTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("createdTime is required.")));
    }
    if (!creatorId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("creatorId is required.")));
    }
    if (!groupId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupId is required.")));
    }
    if (!modifiedTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("modifiedTime is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!tenantId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tenantId is required.")));
    }
    if (!authorizationRecords) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("authorizationRecords is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (apiPath) {
      res["ApiPath"] = boost::any(*apiPath);
    }
    if (apiStatus) {
      res["ApiStatus"] = boost::any(*apiStatus);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (authorizationRecords) {
      vector<boost::any> temp1;
      for(auto item1:*authorizationRecords){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AuthorizationRecords"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<long>(boost::any_cast<long>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("ApiPath") != m.end() && !m["ApiPath"].empty()) {
      apiPath = make_shared<string>(boost::any_cast<string>(m["ApiPath"]));
    }
    if (m.find("ApiStatus") != m.end() && !m["ApiStatus"].empty()) {
      apiStatus = make_shared<int>(boost::any_cast<int>(m["ApiStatus"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("AuthorizationRecords") != m.end() && !m["AuthorizationRecords"].empty()) {
      if (typeid(vector<boost::any>) == m["AuthorizationRecords"].type()) {
        vector<ListDataServiceApiAuthoritiesResponseDataApiAuthorizationListAuthorizationRecords> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AuthorizationRecords"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataServiceApiAuthoritiesResponseDataApiAuthorizationListAuthorizationRecords model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        authorizationRecords = make_shared<vector<ListDataServiceApiAuthoritiesResponseDataApiAuthorizationListAuthorizationRecords>>(expect1);
      }
    }
  }


  virtual ~ListDataServiceApiAuthoritiesResponseDataApiAuthorizationList() = default;
};
class ListDataServiceApiAuthoritiesResponseData : public Darabonba::Model {
public:
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> totalCount{};
  shared_ptr<vector<ListDataServiceApiAuthoritiesResponseDataApiAuthorizationList>> apiAuthorizationList{};

  ListDataServiceApiAuthoritiesResponseData() {}

  explicit ListDataServiceApiAuthoritiesResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageNumber) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNumber is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!totalCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("totalCount is required.")));
    }
    if (!apiAuthorizationList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("apiAuthorizationList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (apiAuthorizationList) {
      vector<boost::any> temp1;
      for(auto item1:*apiAuthorizationList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiAuthorizationList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<int>(boost::any_cast<int>(m["TotalCount"]));
    }
    if (m.find("ApiAuthorizationList") != m.end() && !m["ApiAuthorizationList"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiAuthorizationList"].type()) {
        vector<ListDataServiceApiAuthoritiesResponseDataApiAuthorizationList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiAuthorizationList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataServiceApiAuthoritiesResponseDataApiAuthorizationList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiAuthorizationList = make_shared<vector<ListDataServiceApiAuthoritiesResponseDataApiAuthorizationList>>(expect1);
      }
    }
  }


  virtual ~ListDataServiceApiAuthoritiesResponseData() = default;
};
class ListDataServiceApiAuthoritiesResponse : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<ListDataServiceApiAuthoritiesResponseData> data{};

  ListDataServiceApiAuthoritiesResponse() {}

  explicit ListDataServiceApiAuthoritiesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListDataServiceApiAuthoritiesResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListDataServiceApiAuthoritiesResponseData>(model1);
      }
    }
  }


  virtual ~ListDataServiceApiAuthoritiesResponse() = default;
};
class ListDataServicePublishedApisRequest : public Darabonba::Model {
public:
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<long> tenantId{};
  shared_ptr<string> apiNameKeyword{};
  shared_ptr<string> apiPathKeyword{};
  shared_ptr<string> creatorId{};

  ListDataServicePublishedApisRequest() {}

  explicit ListDataServicePublishedApisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!tenantId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tenantId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (apiNameKeyword) {
      res["ApiNameKeyword"] = boost::any(*apiNameKeyword);
    }
    if (apiPathKeyword) {
      res["ApiPathKeyword"] = boost::any(*apiPathKeyword);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("ApiNameKeyword") != m.end() && !m["ApiNameKeyword"].empty()) {
      apiNameKeyword = make_shared<string>(boost::any_cast<string>(m["ApiNameKeyword"]));
    }
    if (m.find("ApiPathKeyword") != m.end() && !m["ApiPathKeyword"].empty()) {
      apiPathKeyword = make_shared<string>(boost::any_cast<string>(m["ApiPathKeyword"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
  }


  virtual ~ListDataServicePublishedApisRequest() = default;
};
class ListDataServicePublishedApisResponseDataApisRegistrationDetailsRegistrationErrorCodes : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorSolution{};

  ListDataServicePublishedApisResponseDataApisRegistrationDetailsRegistrationErrorCodes() {}

  explicit ListDataServicePublishedApisResponseDataApisRegistrationDetailsRegistrationErrorCodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!errorSolution) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorSolution is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorSolution) {
      res["ErrorSolution"] = boost::any(*errorSolution);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorSolution") != m.end() && !m["ErrorSolution"].empty()) {
      errorSolution = make_shared<string>(boost::any_cast<string>(m["ErrorSolution"]));
    }
  }


  virtual ~ListDataServicePublishedApisResponseDataApisRegistrationDetailsRegistrationErrorCodes() = default;
};
class ListDataServicePublishedApisResponseDataApisRegistrationDetailsRegistrationRequestParameters : public Darabonba::Model {
public:
  shared_ptr<string> defaultValue{};
  shared_ptr<string> exampleValue{};
  shared_ptr<bool> isRequiredParameter{};
  shared_ptr<int> parameterDataType{};
  shared_ptr<string> parameterDescription{};
  shared_ptr<string> parameterName{};
  shared_ptr<int> parameterOperator{};
  shared_ptr<int> parameterPosition{};

  ListDataServicePublishedApisResponseDataApisRegistrationDetailsRegistrationRequestParameters() {}

  explicit ListDataServicePublishedApisResponseDataApisRegistrationDetailsRegistrationRequestParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!defaultValue) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("defaultValue is required.")));
    }
    if (!exampleValue) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("exampleValue is required.")));
    }
    if (!isRequiredParameter) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("isRequiredParameter is required.")));
    }
    if (!parameterDataType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterDataType is required.")));
    }
    if (!parameterDescription) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterDescription is required.")));
    }
    if (!parameterName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterName is required.")));
    }
    if (!parameterOperator) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterOperator is required.")));
    }
    if (!parameterPosition) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterPosition is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (exampleValue) {
      res["ExampleValue"] = boost::any(*exampleValue);
    }
    if (isRequiredParameter) {
      res["IsRequiredParameter"] = boost::any(*isRequiredParameter);
    }
    if (parameterDataType) {
      res["ParameterDataType"] = boost::any(*parameterDataType);
    }
    if (parameterDescription) {
      res["ParameterDescription"] = boost::any(*parameterDescription);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (parameterOperator) {
      res["ParameterOperator"] = boost::any(*parameterOperator);
    }
    if (parameterPosition) {
      res["ParameterPosition"] = boost::any(*parameterPosition);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("ExampleValue") != m.end() && !m["ExampleValue"].empty()) {
      exampleValue = make_shared<string>(boost::any_cast<string>(m["ExampleValue"]));
    }
    if (m.find("IsRequiredParameter") != m.end() && !m["IsRequiredParameter"].empty()) {
      isRequiredParameter = make_shared<bool>(boost::any_cast<bool>(m["IsRequiredParameter"]));
    }
    if (m.find("ParameterDataType") != m.end() && !m["ParameterDataType"].empty()) {
      parameterDataType = make_shared<int>(boost::any_cast<int>(m["ParameterDataType"]));
    }
    if (m.find("ParameterDescription") != m.end() && !m["ParameterDescription"].empty()) {
      parameterDescription = make_shared<string>(boost::any_cast<string>(m["ParameterDescription"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ParameterOperator") != m.end() && !m["ParameterOperator"].empty()) {
      parameterOperator = make_shared<int>(boost::any_cast<int>(m["ParameterOperator"]));
    }
    if (m.find("ParameterPosition") != m.end() && !m["ParameterPosition"].empty()) {
      parameterPosition = make_shared<int>(boost::any_cast<int>(m["ParameterPosition"]));
    }
  }


  virtual ~ListDataServicePublishedApisResponseDataApisRegistrationDetailsRegistrationRequestParameters() = default;
};
class ListDataServicePublishedApisResponseDataApisRegistrationDetails : public Darabonba::Model {
public:
  shared_ptr<string> failedResultSample{};
  shared_ptr<int> serviceContentType{};
  shared_ptr<string> serviceHost{};
  shared_ptr<string> servicePath{};
  shared_ptr<string> serviceRequestBodyDescription{};
  shared_ptr<string> successfulResultSample{};
  shared_ptr<vector<ListDataServicePublishedApisResponseDataApisRegistrationDetailsRegistrationErrorCodes>> registrationErrorCodes{};
  shared_ptr<vector<ListDataServicePublishedApisResponseDataApisRegistrationDetailsRegistrationRequestParameters>> registrationRequestParameters{};

  ListDataServicePublishedApisResponseDataApisRegistrationDetails() {}

  explicit ListDataServicePublishedApisResponseDataApisRegistrationDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!failedResultSample) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("failedResultSample is required.")));
    }
    if (!serviceContentType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("serviceContentType is required.")));
    }
    if (!serviceHost) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("serviceHost is required.")));
    }
    if (!servicePath) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("servicePath is required.")));
    }
    if (!serviceRequestBodyDescription) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("serviceRequestBodyDescription is required.")));
    }
    if (!successfulResultSample) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("successfulResultSample is required.")));
    }
    if (!registrationErrorCodes) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("registrationErrorCodes is required.")));
    }
    if (!registrationRequestParameters) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("registrationRequestParameters is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failedResultSample) {
      res["FailedResultSample"] = boost::any(*failedResultSample);
    }
    if (serviceContentType) {
      res["ServiceContentType"] = boost::any(*serviceContentType);
    }
    if (serviceHost) {
      res["ServiceHost"] = boost::any(*serviceHost);
    }
    if (servicePath) {
      res["ServicePath"] = boost::any(*servicePath);
    }
    if (serviceRequestBodyDescription) {
      res["ServiceRequestBodyDescription"] = boost::any(*serviceRequestBodyDescription);
    }
    if (successfulResultSample) {
      res["SuccessfulResultSample"] = boost::any(*successfulResultSample);
    }
    if (registrationErrorCodes) {
      vector<boost::any> temp1;
      for(auto item1:*registrationErrorCodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RegistrationErrorCodes"] = boost::any(temp1);
    }
    if (registrationRequestParameters) {
      vector<boost::any> temp1;
      for(auto item1:*registrationRequestParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RegistrationRequestParameters"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailedResultSample") != m.end() && !m["FailedResultSample"].empty()) {
      failedResultSample = make_shared<string>(boost::any_cast<string>(m["FailedResultSample"]));
    }
    if (m.find("ServiceContentType") != m.end() && !m["ServiceContentType"].empty()) {
      serviceContentType = make_shared<int>(boost::any_cast<int>(m["ServiceContentType"]));
    }
    if (m.find("ServiceHost") != m.end() && !m["ServiceHost"].empty()) {
      serviceHost = make_shared<string>(boost::any_cast<string>(m["ServiceHost"]));
    }
    if (m.find("ServicePath") != m.end() && !m["ServicePath"].empty()) {
      servicePath = make_shared<string>(boost::any_cast<string>(m["ServicePath"]));
    }
    if (m.find("ServiceRequestBodyDescription") != m.end() && !m["ServiceRequestBodyDescription"].empty()) {
      serviceRequestBodyDescription = make_shared<string>(boost::any_cast<string>(m["ServiceRequestBodyDescription"]));
    }
    if (m.find("SuccessfulResultSample") != m.end() && !m["SuccessfulResultSample"].empty()) {
      successfulResultSample = make_shared<string>(boost::any_cast<string>(m["SuccessfulResultSample"]));
    }
    if (m.find("RegistrationErrorCodes") != m.end() && !m["RegistrationErrorCodes"].empty()) {
      if (typeid(vector<boost::any>) == m["RegistrationErrorCodes"].type()) {
        vector<ListDataServicePublishedApisResponseDataApisRegistrationDetailsRegistrationErrorCodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RegistrationErrorCodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataServicePublishedApisResponseDataApisRegistrationDetailsRegistrationErrorCodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        registrationErrorCodes = make_shared<vector<ListDataServicePublishedApisResponseDataApisRegistrationDetailsRegistrationErrorCodes>>(expect1);
      }
    }
    if (m.find("RegistrationRequestParameters") != m.end() && !m["RegistrationRequestParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["RegistrationRequestParameters"].type()) {
        vector<ListDataServicePublishedApisResponseDataApisRegistrationDetailsRegistrationRequestParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RegistrationRequestParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataServicePublishedApisResponseDataApisRegistrationDetailsRegistrationRequestParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        registrationRequestParameters = make_shared<vector<ListDataServicePublishedApisResponseDataApisRegistrationDetailsRegistrationRequestParameters>>(expect1);
      }
    }
  }


  virtual ~ListDataServicePublishedApisResponseDataApisRegistrationDetails() = default;
};
class ListDataServicePublishedApisResponseDataApisScriptDetailsScriptErrorCodes : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorSolution{};

  ListDataServicePublishedApisResponseDataApisScriptDetailsScriptErrorCodes() {}

  explicit ListDataServicePublishedApisResponseDataApisScriptDetailsScriptErrorCodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!errorSolution) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorSolution is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorSolution) {
      res["ErrorSolution"] = boost::any(*errorSolution);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorSolution") != m.end() && !m["ErrorSolution"].empty()) {
      errorSolution = make_shared<string>(boost::any_cast<string>(m["ErrorSolution"]));
    }
  }


  virtual ~ListDataServicePublishedApisResponseDataApisScriptDetailsScriptErrorCodes() = default;
};
class ListDataServicePublishedApisResponseDataApisScriptDetailsScriptRequestParameters : public Darabonba::Model {
public:
  shared_ptr<string> defaultValue{};
  shared_ptr<string> exampleValue{};
  shared_ptr<bool> isRequiredParameter{};
  shared_ptr<int> parameterDataType{};
  shared_ptr<string> parameterDescription{};
  shared_ptr<string> parameterName{};
  shared_ptr<int> parameterOperator{};
  shared_ptr<int> parameterPosition{};

  ListDataServicePublishedApisResponseDataApisScriptDetailsScriptRequestParameters() {}

  explicit ListDataServicePublishedApisResponseDataApisScriptDetailsScriptRequestParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!defaultValue) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("defaultValue is required.")));
    }
    if (!exampleValue) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("exampleValue is required.")));
    }
    if (!isRequiredParameter) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("isRequiredParameter is required.")));
    }
    if (!parameterDataType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterDataType is required.")));
    }
    if (!parameterDescription) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterDescription is required.")));
    }
    if (!parameterName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterName is required.")));
    }
    if (!parameterOperator) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterOperator is required.")));
    }
    if (!parameterPosition) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterPosition is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (exampleValue) {
      res["ExampleValue"] = boost::any(*exampleValue);
    }
    if (isRequiredParameter) {
      res["IsRequiredParameter"] = boost::any(*isRequiredParameter);
    }
    if (parameterDataType) {
      res["ParameterDataType"] = boost::any(*parameterDataType);
    }
    if (parameterDescription) {
      res["ParameterDescription"] = boost::any(*parameterDescription);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (parameterOperator) {
      res["ParameterOperator"] = boost::any(*parameterOperator);
    }
    if (parameterPosition) {
      res["ParameterPosition"] = boost::any(*parameterPosition);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("ExampleValue") != m.end() && !m["ExampleValue"].empty()) {
      exampleValue = make_shared<string>(boost::any_cast<string>(m["ExampleValue"]));
    }
    if (m.find("IsRequiredParameter") != m.end() && !m["IsRequiredParameter"].empty()) {
      isRequiredParameter = make_shared<bool>(boost::any_cast<bool>(m["IsRequiredParameter"]));
    }
    if (m.find("ParameterDataType") != m.end() && !m["ParameterDataType"].empty()) {
      parameterDataType = make_shared<int>(boost::any_cast<int>(m["ParameterDataType"]));
    }
    if (m.find("ParameterDescription") != m.end() && !m["ParameterDescription"].empty()) {
      parameterDescription = make_shared<string>(boost::any_cast<string>(m["ParameterDescription"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ParameterOperator") != m.end() && !m["ParameterOperator"].empty()) {
      parameterOperator = make_shared<int>(boost::any_cast<int>(m["ParameterOperator"]));
    }
    if (m.find("ParameterPosition") != m.end() && !m["ParameterPosition"].empty()) {
      parameterPosition = make_shared<int>(boost::any_cast<int>(m["ParameterPosition"]));
    }
  }


  virtual ~ListDataServicePublishedApisResponseDataApisScriptDetailsScriptRequestParameters() = default;
};
class ListDataServicePublishedApisResponseDataApisScriptDetailsScriptResponseParameters : public Darabonba::Model {
public:
  shared_ptr<string> exampleValue{};
  shared_ptr<int> parameterDataType{};
  shared_ptr<string> parameterDescription{};
  shared_ptr<string> parameterName{};

  ListDataServicePublishedApisResponseDataApisScriptDetailsScriptResponseParameters() {}

  explicit ListDataServicePublishedApisResponseDataApisScriptDetailsScriptResponseParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!exampleValue) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("exampleValue is required.")));
    }
    if (!parameterDataType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterDataType is required.")));
    }
    if (!parameterDescription) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterDescription is required.")));
    }
    if (!parameterName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (exampleValue) {
      res["ExampleValue"] = boost::any(*exampleValue);
    }
    if (parameterDataType) {
      res["ParameterDataType"] = boost::any(*parameterDataType);
    }
    if (parameterDescription) {
      res["ParameterDescription"] = boost::any(*parameterDescription);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExampleValue") != m.end() && !m["ExampleValue"].empty()) {
      exampleValue = make_shared<string>(boost::any_cast<string>(m["ExampleValue"]));
    }
    if (m.find("ParameterDataType") != m.end() && !m["ParameterDataType"].empty()) {
      parameterDataType = make_shared<int>(boost::any_cast<int>(m["ParameterDataType"]));
    }
    if (m.find("ParameterDescription") != m.end() && !m["ParameterDescription"].empty()) {
      parameterDescription = make_shared<string>(boost::any_cast<string>(m["ParameterDescription"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
  }


  virtual ~ListDataServicePublishedApisResponseDataApisScriptDetailsScriptResponseParameters() = default;
};
class ListDataServicePublishedApisResponseDataApisScriptDetailsScriptConnection : public Darabonba::Model {
public:
  shared_ptr<long> connectionId{};
  shared_ptr<string> tableName{};

  ListDataServicePublishedApisResponseDataApisScriptDetailsScriptConnection() {}

  explicit ListDataServicePublishedApisResponseDataApisScriptDetailsScriptConnection(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!connectionId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("connectionId is required.")));
    }
    if (!tableName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tableName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connectionId) {
      res["ConnectionId"] = boost::any(*connectionId);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConnectionId") != m.end() && !m["ConnectionId"].empty()) {
      connectionId = make_shared<long>(boost::any_cast<long>(m["ConnectionId"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
  }


  virtual ~ListDataServicePublishedApisResponseDataApisScriptDetailsScriptConnection() = default;
};
class ListDataServicePublishedApisResponseDataApisScriptDetails : public Darabonba::Model {
public:
  shared_ptr<string> failedResultSample{};
  shared_ptr<bool> isPagedResponse{};
  shared_ptr<string> script{};
  shared_ptr<string> successfulResultSample{};
  shared_ptr<vector<ListDataServicePublishedApisResponseDataApisScriptDetailsScriptErrorCodes>> scriptErrorCodes{};
  shared_ptr<vector<ListDataServicePublishedApisResponseDataApisScriptDetailsScriptRequestParameters>> scriptRequestParameters{};
  shared_ptr<vector<ListDataServicePublishedApisResponseDataApisScriptDetailsScriptResponseParameters>> scriptResponseParameters{};
  shared_ptr<ListDataServicePublishedApisResponseDataApisScriptDetailsScriptConnection> scriptConnection{};

  ListDataServicePublishedApisResponseDataApisScriptDetails() {}

  explicit ListDataServicePublishedApisResponseDataApisScriptDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!failedResultSample) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("failedResultSample is required.")));
    }
    if (!isPagedResponse) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("isPagedResponse is required.")));
    }
    if (!script) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("script is required.")));
    }
    if (!successfulResultSample) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("successfulResultSample is required.")));
    }
    if (!scriptErrorCodes) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("scriptErrorCodes is required.")));
    }
    if (!scriptRequestParameters) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("scriptRequestParameters is required.")));
    }
    if (!scriptResponseParameters) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("scriptResponseParameters is required.")));
    }
    if (!scriptConnection) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("scriptConnection is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failedResultSample) {
      res["FailedResultSample"] = boost::any(*failedResultSample);
    }
    if (isPagedResponse) {
      res["IsPagedResponse"] = boost::any(*isPagedResponse);
    }
    if (script) {
      res["Script"] = boost::any(*script);
    }
    if (successfulResultSample) {
      res["SuccessfulResultSample"] = boost::any(*successfulResultSample);
    }
    if (scriptErrorCodes) {
      vector<boost::any> temp1;
      for(auto item1:*scriptErrorCodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScriptErrorCodes"] = boost::any(temp1);
    }
    if (scriptRequestParameters) {
      vector<boost::any> temp1;
      for(auto item1:*scriptRequestParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScriptRequestParameters"] = boost::any(temp1);
    }
    if (scriptResponseParameters) {
      vector<boost::any> temp1;
      for(auto item1:*scriptResponseParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScriptResponseParameters"] = boost::any(temp1);
    }
    if (scriptConnection) {
      res["ScriptConnection"] = scriptConnection ? boost::any(scriptConnection->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailedResultSample") != m.end() && !m["FailedResultSample"].empty()) {
      failedResultSample = make_shared<string>(boost::any_cast<string>(m["FailedResultSample"]));
    }
    if (m.find("IsPagedResponse") != m.end() && !m["IsPagedResponse"].empty()) {
      isPagedResponse = make_shared<bool>(boost::any_cast<bool>(m["IsPagedResponse"]));
    }
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      script = make_shared<string>(boost::any_cast<string>(m["Script"]));
    }
    if (m.find("SuccessfulResultSample") != m.end() && !m["SuccessfulResultSample"].empty()) {
      successfulResultSample = make_shared<string>(boost::any_cast<string>(m["SuccessfulResultSample"]));
    }
    if (m.find("ScriptErrorCodes") != m.end() && !m["ScriptErrorCodes"].empty()) {
      if (typeid(vector<boost::any>) == m["ScriptErrorCodes"].type()) {
        vector<ListDataServicePublishedApisResponseDataApisScriptDetailsScriptErrorCodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScriptErrorCodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataServicePublishedApisResponseDataApisScriptDetailsScriptErrorCodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scriptErrorCodes = make_shared<vector<ListDataServicePublishedApisResponseDataApisScriptDetailsScriptErrorCodes>>(expect1);
      }
    }
    if (m.find("ScriptRequestParameters") != m.end() && !m["ScriptRequestParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["ScriptRequestParameters"].type()) {
        vector<ListDataServicePublishedApisResponseDataApisScriptDetailsScriptRequestParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScriptRequestParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataServicePublishedApisResponseDataApisScriptDetailsScriptRequestParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scriptRequestParameters = make_shared<vector<ListDataServicePublishedApisResponseDataApisScriptDetailsScriptRequestParameters>>(expect1);
      }
    }
    if (m.find("ScriptResponseParameters") != m.end() && !m["ScriptResponseParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["ScriptResponseParameters"].type()) {
        vector<ListDataServicePublishedApisResponseDataApisScriptDetailsScriptResponseParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScriptResponseParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataServicePublishedApisResponseDataApisScriptDetailsScriptResponseParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scriptResponseParameters = make_shared<vector<ListDataServicePublishedApisResponseDataApisScriptDetailsScriptResponseParameters>>(expect1);
      }
    }
    if (m.find("ScriptConnection") != m.end() && !m["ScriptConnection"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScriptConnection"].type()) {
        ListDataServicePublishedApisResponseDataApisScriptDetailsScriptConnection model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScriptConnection"]));
        scriptConnection = make_shared<ListDataServicePublishedApisResponseDataApisScriptDetailsScriptConnection>(model1);
      }
    }
  }


  virtual ~ListDataServicePublishedApisResponseDataApisScriptDetails() = default;
};
class ListDataServicePublishedApisResponseDataApisWizardDetailsWizardErrorCodes : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorSolution{};

  ListDataServicePublishedApisResponseDataApisWizardDetailsWizardErrorCodes() {}

  explicit ListDataServicePublishedApisResponseDataApisWizardDetailsWizardErrorCodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!errorSolution) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorSolution is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorSolution) {
      res["ErrorSolution"] = boost::any(*errorSolution);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorSolution") != m.end() && !m["ErrorSolution"].empty()) {
      errorSolution = make_shared<string>(boost::any_cast<string>(m["ErrorSolution"]));
    }
  }


  virtual ~ListDataServicePublishedApisResponseDataApisWizardDetailsWizardErrorCodes() = default;
};
class ListDataServicePublishedApisResponseDataApisWizardDetailsWizardRequestParameters : public Darabonba::Model {
public:
  shared_ptr<string> defaultValue{};
  shared_ptr<string> exampleValue{};
  shared_ptr<bool> isRequiredParameter{};
  shared_ptr<int> parameterDataType{};
  shared_ptr<string> parameterDescription{};
  shared_ptr<string> parameterName{};
  shared_ptr<int> parameterOperator{};
  shared_ptr<int> parameterPosition{};

  ListDataServicePublishedApisResponseDataApisWizardDetailsWizardRequestParameters() {}

  explicit ListDataServicePublishedApisResponseDataApisWizardDetailsWizardRequestParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!defaultValue) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("defaultValue is required.")));
    }
    if (!exampleValue) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("exampleValue is required.")));
    }
    if (!isRequiredParameter) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("isRequiredParameter is required.")));
    }
    if (!parameterDataType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterDataType is required.")));
    }
    if (!parameterDescription) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterDescription is required.")));
    }
    if (!parameterName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterName is required.")));
    }
    if (!parameterOperator) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterOperator is required.")));
    }
    if (!parameterPosition) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterPosition is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (exampleValue) {
      res["ExampleValue"] = boost::any(*exampleValue);
    }
    if (isRequiredParameter) {
      res["IsRequiredParameter"] = boost::any(*isRequiredParameter);
    }
    if (parameterDataType) {
      res["ParameterDataType"] = boost::any(*parameterDataType);
    }
    if (parameterDescription) {
      res["ParameterDescription"] = boost::any(*parameterDescription);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (parameterOperator) {
      res["ParameterOperator"] = boost::any(*parameterOperator);
    }
    if (parameterPosition) {
      res["ParameterPosition"] = boost::any(*parameterPosition);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("ExampleValue") != m.end() && !m["ExampleValue"].empty()) {
      exampleValue = make_shared<string>(boost::any_cast<string>(m["ExampleValue"]));
    }
    if (m.find("IsRequiredParameter") != m.end() && !m["IsRequiredParameter"].empty()) {
      isRequiredParameter = make_shared<bool>(boost::any_cast<bool>(m["IsRequiredParameter"]));
    }
    if (m.find("ParameterDataType") != m.end() && !m["ParameterDataType"].empty()) {
      parameterDataType = make_shared<int>(boost::any_cast<int>(m["ParameterDataType"]));
    }
    if (m.find("ParameterDescription") != m.end() && !m["ParameterDescription"].empty()) {
      parameterDescription = make_shared<string>(boost::any_cast<string>(m["ParameterDescription"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ParameterOperator") != m.end() && !m["ParameterOperator"].empty()) {
      parameterOperator = make_shared<int>(boost::any_cast<int>(m["ParameterOperator"]));
    }
    if (m.find("ParameterPosition") != m.end() && !m["ParameterPosition"].empty()) {
      parameterPosition = make_shared<int>(boost::any_cast<int>(m["ParameterPosition"]));
    }
  }


  virtual ~ListDataServicePublishedApisResponseDataApisWizardDetailsWizardRequestParameters() = default;
};
class ListDataServicePublishedApisResponseDataApisWizardDetailsWizardResponseParameters : public Darabonba::Model {
public:
  shared_ptr<string> exampleValue{};
  shared_ptr<int> parameterDataType{};
  shared_ptr<string> parameterDescription{};
  shared_ptr<string> parameterName{};

  ListDataServicePublishedApisResponseDataApisWizardDetailsWizardResponseParameters() {}

  explicit ListDataServicePublishedApisResponseDataApisWizardDetailsWizardResponseParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!exampleValue) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("exampleValue is required.")));
    }
    if (!parameterDataType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterDataType is required.")));
    }
    if (!parameterDescription) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterDescription is required.")));
    }
    if (!parameterName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (exampleValue) {
      res["ExampleValue"] = boost::any(*exampleValue);
    }
    if (parameterDataType) {
      res["ParameterDataType"] = boost::any(*parameterDataType);
    }
    if (parameterDescription) {
      res["ParameterDescription"] = boost::any(*parameterDescription);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExampleValue") != m.end() && !m["ExampleValue"].empty()) {
      exampleValue = make_shared<string>(boost::any_cast<string>(m["ExampleValue"]));
    }
    if (m.find("ParameterDataType") != m.end() && !m["ParameterDataType"].empty()) {
      parameterDataType = make_shared<int>(boost::any_cast<int>(m["ParameterDataType"]));
    }
    if (m.find("ParameterDescription") != m.end() && !m["ParameterDescription"].empty()) {
      parameterDescription = make_shared<string>(boost::any_cast<string>(m["ParameterDescription"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
  }


  virtual ~ListDataServicePublishedApisResponseDataApisWizardDetailsWizardResponseParameters() = default;
};
class ListDataServicePublishedApisResponseDataApisWizardDetailsWizardConnection : public Darabonba::Model {
public:
  shared_ptr<long> connectionId{};
  shared_ptr<string> tableName{};

  ListDataServicePublishedApisResponseDataApisWizardDetailsWizardConnection() {}

  explicit ListDataServicePublishedApisResponseDataApisWizardDetailsWizardConnection(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!connectionId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("connectionId is required.")));
    }
    if (!tableName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tableName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connectionId) {
      res["ConnectionId"] = boost::any(*connectionId);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConnectionId") != m.end() && !m["ConnectionId"].empty()) {
      connectionId = make_shared<long>(boost::any_cast<long>(m["ConnectionId"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
  }


  virtual ~ListDataServicePublishedApisResponseDataApisWizardDetailsWizardConnection() = default;
};
class ListDataServicePublishedApisResponseDataApisWizardDetails : public Darabonba::Model {
public:
  shared_ptr<string> failedResultSample{};
  shared_ptr<bool> isPagedResponse{};
  shared_ptr<string> successfulResultSample{};
  shared_ptr<vector<ListDataServicePublishedApisResponseDataApisWizardDetailsWizardErrorCodes>> wizardErrorCodes{};
  shared_ptr<vector<ListDataServicePublishedApisResponseDataApisWizardDetailsWizardRequestParameters>> wizardRequestParameters{};
  shared_ptr<vector<ListDataServicePublishedApisResponseDataApisWizardDetailsWizardResponseParameters>> wizardResponseParameters{};
  shared_ptr<ListDataServicePublishedApisResponseDataApisWizardDetailsWizardConnection> wizardConnection{};

  ListDataServicePublishedApisResponseDataApisWizardDetails() {}

  explicit ListDataServicePublishedApisResponseDataApisWizardDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!failedResultSample) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("failedResultSample is required.")));
    }
    if (!isPagedResponse) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("isPagedResponse is required.")));
    }
    if (!successfulResultSample) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("successfulResultSample is required.")));
    }
    if (!wizardErrorCodes) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("wizardErrorCodes is required.")));
    }
    if (!wizardRequestParameters) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("wizardRequestParameters is required.")));
    }
    if (!wizardResponseParameters) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("wizardResponseParameters is required.")));
    }
    if (!wizardConnection) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("wizardConnection is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failedResultSample) {
      res["FailedResultSample"] = boost::any(*failedResultSample);
    }
    if (isPagedResponse) {
      res["IsPagedResponse"] = boost::any(*isPagedResponse);
    }
    if (successfulResultSample) {
      res["SuccessfulResultSample"] = boost::any(*successfulResultSample);
    }
    if (wizardErrorCodes) {
      vector<boost::any> temp1;
      for(auto item1:*wizardErrorCodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WizardErrorCodes"] = boost::any(temp1);
    }
    if (wizardRequestParameters) {
      vector<boost::any> temp1;
      for(auto item1:*wizardRequestParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WizardRequestParameters"] = boost::any(temp1);
    }
    if (wizardResponseParameters) {
      vector<boost::any> temp1;
      for(auto item1:*wizardResponseParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WizardResponseParameters"] = boost::any(temp1);
    }
    if (wizardConnection) {
      res["WizardConnection"] = wizardConnection ? boost::any(wizardConnection->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailedResultSample") != m.end() && !m["FailedResultSample"].empty()) {
      failedResultSample = make_shared<string>(boost::any_cast<string>(m["FailedResultSample"]));
    }
    if (m.find("IsPagedResponse") != m.end() && !m["IsPagedResponse"].empty()) {
      isPagedResponse = make_shared<bool>(boost::any_cast<bool>(m["IsPagedResponse"]));
    }
    if (m.find("SuccessfulResultSample") != m.end() && !m["SuccessfulResultSample"].empty()) {
      successfulResultSample = make_shared<string>(boost::any_cast<string>(m["SuccessfulResultSample"]));
    }
    if (m.find("WizardErrorCodes") != m.end() && !m["WizardErrorCodes"].empty()) {
      if (typeid(vector<boost::any>) == m["WizardErrorCodes"].type()) {
        vector<ListDataServicePublishedApisResponseDataApisWizardDetailsWizardErrorCodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WizardErrorCodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataServicePublishedApisResponseDataApisWizardDetailsWizardErrorCodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        wizardErrorCodes = make_shared<vector<ListDataServicePublishedApisResponseDataApisWizardDetailsWizardErrorCodes>>(expect1);
      }
    }
    if (m.find("WizardRequestParameters") != m.end() && !m["WizardRequestParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["WizardRequestParameters"].type()) {
        vector<ListDataServicePublishedApisResponseDataApisWizardDetailsWizardRequestParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WizardRequestParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataServicePublishedApisResponseDataApisWizardDetailsWizardRequestParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        wizardRequestParameters = make_shared<vector<ListDataServicePublishedApisResponseDataApisWizardDetailsWizardRequestParameters>>(expect1);
      }
    }
    if (m.find("WizardResponseParameters") != m.end() && !m["WizardResponseParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["WizardResponseParameters"].type()) {
        vector<ListDataServicePublishedApisResponseDataApisWizardDetailsWizardResponseParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WizardResponseParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataServicePublishedApisResponseDataApisWizardDetailsWizardResponseParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        wizardResponseParameters = make_shared<vector<ListDataServicePublishedApisResponseDataApisWizardDetailsWizardResponseParameters>>(expect1);
      }
    }
    if (m.find("WizardConnection") != m.end() && !m["WizardConnection"].empty()) {
      if (typeid(map<string, boost::any>) == m["WizardConnection"].type()) {
        ListDataServicePublishedApisResponseDataApisWizardDetailsWizardConnection model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WizardConnection"]));
        wizardConnection = make_shared<ListDataServicePublishedApisResponseDataApisWizardDetailsWizardConnection>(model1);
      }
    }
  }


  virtual ~ListDataServicePublishedApisResponseDataApisWizardDetails() = default;
};
class ListDataServicePublishedApisResponseDataApis : public Darabonba::Model {
public:
  shared_ptr<long> apiId{};
  shared_ptr<int> apiMode{};
  shared_ptr<string> apiName{};
  shared_ptr<string> apiPath{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> operatorId{};
  shared_ptr<long> projectId{};
  shared_ptr<int> requestMethod{};
  shared_ptr<int> responseContentType{};
  shared_ptr<int> status{};
  shared_ptr<long> tenantId{};
  shared_ptr<int> timeout{};
  shared_ptr<int> visibleRange{};
  shared_ptr<ListDataServicePublishedApisResponseDataApisRegistrationDetails> registrationDetails{};
  shared_ptr<ListDataServicePublishedApisResponseDataApisScriptDetails> scriptDetails{};
  shared_ptr<ListDataServicePublishedApisResponseDataApisWizardDetails> wizardDetails{};
  shared_ptr<vector<int>> protocols{};

  ListDataServicePublishedApisResponseDataApis() {}

  explicit ListDataServicePublishedApisResponseDataApis(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!apiId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("apiId is required.")));
    }
    if (!apiMode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("apiMode is required.")));
    }
    if (!apiName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("apiName is required.")));
    }
    if (!apiPath) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("apiPath is required.")));
    }
    if (!createdTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("createdTime is required.")));
    }
    if (!creatorId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("creatorId is required.")));
    }
    if (!description) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("description is required.")));
    }
    if (!groupId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupId is required.")));
    }
    if (!modifiedTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("modifiedTime is required.")));
    }
    if (!operatorId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("operatorId is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!requestMethod) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestMethod is required.")));
    }
    if (!responseContentType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("responseContentType is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!tenantId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tenantId is required.")));
    }
    if (!timeout) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("timeout is required.")));
    }
    if (!visibleRange) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("visibleRange is required.")));
    }
    if (!registrationDetails) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("registrationDetails is required.")));
    }
    if (!scriptDetails) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("scriptDetails is required.")));
    }
    if (!wizardDetails) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("wizardDetails is required.")));
    }
    if (!protocols) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("protocols is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiMode) {
      res["ApiMode"] = boost::any(*apiMode);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (apiPath) {
      res["ApiPath"] = boost::any(*apiPath);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (operatorId) {
      res["OperatorId"] = boost::any(*operatorId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (requestMethod) {
      res["RequestMethod"] = boost::any(*requestMethod);
    }
    if (responseContentType) {
      res["ResponseContentType"] = boost::any(*responseContentType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (visibleRange) {
      res["VisibleRange"] = boost::any(*visibleRange);
    }
    if (registrationDetails) {
      res["RegistrationDetails"] = registrationDetails ? boost::any(registrationDetails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scriptDetails) {
      res["ScriptDetails"] = scriptDetails ? boost::any(scriptDetails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (wizardDetails) {
      res["WizardDetails"] = wizardDetails ? boost::any(wizardDetails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (protocols) {
      res["Protocols"] = boost::any(*protocols);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<long>(boost::any_cast<long>(m["ApiId"]));
    }
    if (m.find("ApiMode") != m.end() && !m["ApiMode"].empty()) {
      apiMode = make_shared<int>(boost::any_cast<int>(m["ApiMode"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("ApiPath") != m.end() && !m["ApiPath"].empty()) {
      apiPath = make_shared<string>(boost::any_cast<string>(m["ApiPath"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("OperatorId") != m.end() && !m["OperatorId"].empty()) {
      operatorId = make_shared<string>(boost::any_cast<string>(m["OperatorId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RequestMethod") != m.end() && !m["RequestMethod"].empty()) {
      requestMethod = make_shared<int>(boost::any_cast<int>(m["RequestMethod"]));
    }
    if (m.find("ResponseContentType") != m.end() && !m["ResponseContentType"].empty()) {
      responseContentType = make_shared<int>(boost::any_cast<int>(m["ResponseContentType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<int>(boost::any_cast<int>(m["Status"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<int>(boost::any_cast<int>(m["Timeout"]));
    }
    if (m.find("VisibleRange") != m.end() && !m["VisibleRange"].empty()) {
      visibleRange = make_shared<int>(boost::any_cast<int>(m["VisibleRange"]));
    }
    if (m.find("RegistrationDetails") != m.end() && !m["RegistrationDetails"].empty()) {
      if (typeid(map<string, boost::any>) == m["RegistrationDetails"].type()) {
        ListDataServicePublishedApisResponseDataApisRegistrationDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RegistrationDetails"]));
        registrationDetails = make_shared<ListDataServicePublishedApisResponseDataApisRegistrationDetails>(model1);
      }
    }
    if (m.find("ScriptDetails") != m.end() && !m["ScriptDetails"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScriptDetails"].type()) {
        ListDataServicePublishedApisResponseDataApisScriptDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScriptDetails"]));
        scriptDetails = make_shared<ListDataServicePublishedApisResponseDataApisScriptDetails>(model1);
      }
    }
    if (m.find("WizardDetails") != m.end() && !m["WizardDetails"].empty()) {
      if (typeid(map<string, boost::any>) == m["WizardDetails"].type()) {
        ListDataServicePublishedApisResponseDataApisWizardDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WizardDetails"]));
        wizardDetails = make_shared<ListDataServicePublishedApisResponseDataApisWizardDetails>(model1);
      }
    }
    if (m.find("Protocols") != m.end() && !m["Protocols"].empty()) {
      vector<int> toVec1;
      if (typeid(vector<boost::any>) == m["Protocols"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Protocols"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<int>(item));
        }
      }
      protocols = make_shared<vector<int>>(toVec1);
    }
  }


  virtual ~ListDataServicePublishedApisResponseDataApis() = default;
};
class ListDataServicePublishedApisResponseData : public Darabonba::Model {
public:
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> totalCount{};
  shared_ptr<vector<ListDataServicePublishedApisResponseDataApis>> apis{};

  ListDataServicePublishedApisResponseData() {}

  explicit ListDataServicePublishedApisResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageNumber) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNumber is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!totalCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("totalCount is required.")));
    }
    if (!apis) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("apis is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (apis) {
      vector<boost::any> temp1;
      for(auto item1:*apis){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Apis"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<int>(boost::any_cast<int>(m["TotalCount"]));
    }
    if (m.find("Apis") != m.end() && !m["Apis"].empty()) {
      if (typeid(vector<boost::any>) == m["Apis"].type()) {
        vector<ListDataServicePublishedApisResponseDataApis> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Apis"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataServicePublishedApisResponseDataApis model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apis = make_shared<vector<ListDataServicePublishedApisResponseDataApis>>(expect1);
      }
    }
  }


  virtual ~ListDataServicePublishedApisResponseData() = default;
};
class ListDataServicePublishedApisResponse : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<ListDataServicePublishedApisResponseData> data{};

  ListDataServicePublishedApisResponse() {}

  explicit ListDataServicePublishedApisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListDataServicePublishedApisResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListDataServicePublishedApisResponseData>(model1);
      }
    }
  }


  virtual ~ListDataServicePublishedApisResponse() = default;
};
class GetInstanceLogRequest : public Darabonba::Model {
public:
  shared_ptr<long> instanceId{};
  shared_ptr<string> projectEnv{};

  GetInstanceLogRequest() {}

  explicit GetInstanceLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
    if (!projectEnv) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectEnv is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
  }


  virtual ~GetInstanceLogRequest() = default;
};
class GetInstanceLogResponse : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> data{};

  GetInstanceLogResponse() {}

  explicit GetInstanceLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
  }


  virtual ~GetInstanceLogResponse() = default;
};
class CreateFolderRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<string> folderPath{};

  CreateFolderRequest() {}

  explicit CreateFolderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!folderPath) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("folderPath is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (folderPath) {
      res["FolderPath"] = boost::any(*folderPath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("FolderPath") != m.end() && !m["FolderPath"].empty()) {
      folderPath = make_shared<string>(boost::any_cast<string>(m["FolderPath"]));
    }
  }


  virtual ~CreateFolderRequest() = default;
};
class CreateFolderResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> data{};
  shared_ptr<int> httpStatusCode{};

  CreateFolderResponse() {}

  explicit CreateFolderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
  }


  virtual ~CreateFolderResponse() = default;
};
class GetBusinessRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<long> businessId{};

  GetBusinessRequest() {}

  explicit GetBusinessRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!businessId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("businessId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (businessId) {
      res["BusinessId"] = boost::any(*businessId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("BusinessId") != m.end() && !m["BusinessId"].empty()) {
      businessId = make_shared<long>(boost::any_cast<long>(m["BusinessId"]));
    }
  }


  virtual ~GetBusinessRequest() = default;
};
class GetBusinessResponseData : public Darabonba::Model {
public:
  shared_ptr<long> businessId{};
  shared_ptr<string> businessName{};
  shared_ptr<string> projectId{};
  shared_ptr<string> owner{};
  shared_ptr<string> description{};
  shared_ptr<string> useType{};

  GetBusinessResponseData() {}

  explicit GetBusinessResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!businessId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("businessId is required.")));
    }
    if (!businessName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("businessName is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!owner) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("owner is required.")));
    }
    if (!description) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("description is required.")));
    }
    if (!useType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("useType is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessId) {
      res["BusinessId"] = boost::any(*businessId);
    }
    if (businessName) {
      res["BusinessName"] = boost::any(*businessName);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (useType) {
      res["UseType"] = boost::any(*useType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessId") != m.end() && !m["BusinessId"].empty()) {
      businessId = make_shared<long>(boost::any_cast<long>(m["BusinessId"]));
    }
    if (m.find("BusinessName") != m.end() && !m["BusinessName"].empty()) {
      businessName = make_shared<string>(boost::any_cast<string>(m["BusinessName"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("UseType") != m.end() && !m["UseType"].empty()) {
      useType = make_shared<string>(boost::any_cast<string>(m["UseType"]));
    }
  }


  virtual ~GetBusinessResponseData() = default;
};
class GetBusinessResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<GetBusinessResponseData> data{};

  GetBusinessResponse() {}

  explicit GetBusinessResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetBusinessResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetBusinessResponseData>(model1);
      }
    }
  }


  virtual ~GetBusinessResponse() = default;
};
class GetInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> instanceId{};
  shared_ptr<string> projectEnv{};

  GetInstanceRequest() {}

  explicit GetInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
    if (!projectEnv) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectEnv is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
  }


  virtual ~GetInstanceRequest() = default;
};
class GetInstanceResponseData : public Darabonba::Model {
public:
  shared_ptr<long> nodeId{};
  shared_ptr<long> instanceId{};
  shared_ptr<long> dagId{};
  shared_ptr<string> dagType{};
  shared_ptr<string> status{};
  shared_ptr<long> bizdate{};
  shared_ptr<string> paramValues{};
  shared_ptr<long> cycTime{};
  shared_ptr<long> finishTime{};
  shared_ptr<long> beginWaitTimeTime{};
  shared_ptr<long> beginWaitResTime{};
  shared_ptr<long> beginRunningTime{};
  shared_ptr<long> createTime{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> nodeName{};
  shared_ptr<int> priority{};
  shared_ptr<long> baselineId{};
  shared_ptr<bool> repeatability{};
  shared_ptr<long> repeatInterval{};
  shared_ptr<string> connection{};
  shared_ptr<int> dqcType{};
  shared_ptr<string> dqcDescription{};
  shared_ptr<long> relatedFlowId{};
  shared_ptr<string> taskType{};
  shared_ptr<int> taskRerunTime{};
  shared_ptr<long> businessId{};

  GetInstanceResponseData() {}

  explicit GetInstanceResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!nodeId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeId is required.")));
    }
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
    if (!dagId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dagId is required.")));
    }
    if (!dagType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dagType is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!bizdate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("bizdate is required.")));
    }
    if (!paramValues) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("paramValues is required.")));
    }
    if (!cycTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("cycTime is required.")));
    }
    if (!finishTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("finishTime is required.")));
    }
    if (!beginWaitTimeTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("beginWaitTimeTime is required.")));
    }
    if (!beginWaitResTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("beginWaitResTime is required.")));
    }
    if (!beginRunningTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("beginRunningTime is required.")));
    }
    if (!createTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("createTime is required.")));
    }
    if (!modifyTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("modifyTime is required.")));
    }
    if (!nodeName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeName is required.")));
    }
    if (!priority) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("priority is required.")));
    }
    if (!baselineId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("baselineId is required.")));
    }
    if (!repeatability) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("repeatability is required.")));
    }
    if (!repeatInterval) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("repeatInterval is required.")));
    }
    if (!connection) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("connection is required.")));
    }
    if (!dqcType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dqcType is required.")));
    }
    if (!dqcDescription) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dqcDescription is required.")));
    }
    if (!relatedFlowId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("relatedFlowId is required.")));
    }
    if (!taskType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskType is required.")));
    }
    if (!taskRerunTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskRerunTime is required.")));
    }
    if (!businessId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("businessId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (dagType) {
      res["DagType"] = boost::any(*dagType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (bizdate) {
      res["Bizdate"] = boost::any(*bizdate);
    }
    if (paramValues) {
      res["ParamValues"] = boost::any(*paramValues);
    }
    if (cycTime) {
      res["CycTime"] = boost::any(*cycTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (beginWaitTimeTime) {
      res["BeginWaitTimeTime"] = boost::any(*beginWaitTimeTime);
    }
    if (beginWaitResTime) {
      res["BeginWaitResTime"] = boost::any(*beginWaitResTime);
    }
    if (beginRunningTime) {
      res["BeginRunningTime"] = boost::any(*beginRunningTime);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (repeatability) {
      res["Repeatability"] = boost::any(*repeatability);
    }
    if (repeatInterval) {
      res["RepeatInterval"] = boost::any(*repeatInterval);
    }
    if (connection) {
      res["Connection"] = boost::any(*connection);
    }
    if (dqcType) {
      res["DqcType"] = boost::any(*dqcType);
    }
    if (dqcDescription) {
      res["DqcDescription"] = boost::any(*dqcDescription);
    }
    if (relatedFlowId) {
      res["RelatedFlowId"] = boost::any(*relatedFlowId);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (taskRerunTime) {
      res["TaskRerunTime"] = boost::any(*taskRerunTime);
    }
    if (businessId) {
      res["BusinessId"] = boost::any(*businessId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("DagType") != m.end() && !m["DagType"].empty()) {
      dagType = make_shared<string>(boost::any_cast<string>(m["DagType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Bizdate") != m.end() && !m["Bizdate"].empty()) {
      bizdate = make_shared<long>(boost::any_cast<long>(m["Bizdate"]));
    }
    if (m.find("ParamValues") != m.end() && !m["ParamValues"].empty()) {
      paramValues = make_shared<string>(boost::any_cast<string>(m["ParamValues"]));
    }
    if (m.find("CycTime") != m.end() && !m["CycTime"].empty()) {
      cycTime = make_shared<long>(boost::any_cast<long>(m["CycTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<long>(boost::any_cast<long>(m["FinishTime"]));
    }
    if (m.find("BeginWaitTimeTime") != m.end() && !m["BeginWaitTimeTime"].empty()) {
      beginWaitTimeTime = make_shared<long>(boost::any_cast<long>(m["BeginWaitTimeTime"]));
    }
    if (m.find("BeginWaitResTime") != m.end() && !m["BeginWaitResTime"].empty()) {
      beginWaitResTime = make_shared<long>(boost::any_cast<long>(m["BeginWaitResTime"]));
    }
    if (m.find("BeginRunningTime") != m.end() && !m["BeginRunningTime"].empty()) {
      beginRunningTime = make_shared<long>(boost::any_cast<long>(m["BeginRunningTime"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<int>(boost::any_cast<int>(m["Priority"]));
    }
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("Repeatability") != m.end() && !m["Repeatability"].empty()) {
      repeatability = make_shared<bool>(boost::any_cast<bool>(m["Repeatability"]));
    }
    if (m.find("RepeatInterval") != m.end() && !m["RepeatInterval"].empty()) {
      repeatInterval = make_shared<long>(boost::any_cast<long>(m["RepeatInterval"]));
    }
    if (m.find("Connection") != m.end() && !m["Connection"].empty()) {
      connection = make_shared<string>(boost::any_cast<string>(m["Connection"]));
    }
    if (m.find("DqcType") != m.end() && !m["DqcType"].empty()) {
      dqcType = make_shared<int>(boost::any_cast<int>(m["DqcType"]));
    }
    if (m.find("DqcDescription") != m.end() && !m["DqcDescription"].empty()) {
      dqcDescription = make_shared<string>(boost::any_cast<string>(m["DqcDescription"]));
    }
    if (m.find("RelatedFlowId") != m.end() && !m["RelatedFlowId"].empty()) {
      relatedFlowId = make_shared<long>(boost::any_cast<long>(m["RelatedFlowId"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("TaskRerunTime") != m.end() && !m["TaskRerunTime"].empty()) {
      taskRerunTime = make_shared<int>(boost::any_cast<int>(m["TaskRerunTime"]));
    }
    if (m.find("BusinessId") != m.end() && !m["BusinessId"].empty()) {
      businessId = make_shared<long>(boost::any_cast<long>(m["BusinessId"]));
    }
  }


  virtual ~GetInstanceResponseData() = default;
};
class GetInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<GetInstanceResponseData> data{};

  GetInstanceResponse() {}

  explicit GetInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetInstanceResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetInstanceResponseData>(model1);
      }
    }
  }


  virtual ~GetInstanceResponse() = default;
};
class GetFileRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<long> fileId{};
  shared_ptr<long> nodeId{};

  GetFileRequest() {}

  explicit GetFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
  }


  virtual ~GetFileRequest() = default;
};
class GetFileResponseDataFile : public Darabonba::Model {
public:
  shared_ptr<string> connectionName{};
  shared_ptr<long> parentId{};
  shared_ptr<bool> isMaxCompute{};
  shared_ptr<long> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<long> bizId{};
  shared_ptr<string> fileFolderId{};
  shared_ptr<string> fileName{};
  shared_ptr<int> fileType{};
  shared_ptr<string> useType{};
  shared_ptr<string> fileDescription{};
  shared_ptr<string> content{};
  shared_ptr<long> nodeId{};
  shared_ptr<int> currentVersion{};
  shared_ptr<string> owner{};
  shared_ptr<string> lastEditUser{};
  shared_ptr<long> lastEditTime{};
  shared_ptr<int> commitStatus{};
  shared_ptr<string> deletedStatus{};
  shared_ptr<long> businessId{};
  shared_ptr<bool> autoParsing{};

  GetFileResponseDataFile() {}

  explicit GetFileResponseDataFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!connectionName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("connectionName is required.")));
    }
    if (!parentId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parentId is required.")));
    }
    if (!isMaxCompute) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("isMaxCompute is required.")));
    }
    if (!createTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("createTime is required.")));
    }
    if (!createUser) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("createUser is required.")));
    }
    if (!bizId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("bizId is required.")));
    }
    if (!fileFolderId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("fileFolderId is required.")));
    }
    if (!fileName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("fileName is required.")));
    }
    if (!fileType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("fileType is required.")));
    }
    if (!useType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("useType is required.")));
    }
    if (!fileDescription) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("fileDescription is required.")));
    }
    if (!content) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("content is required.")));
    }
    if (!nodeId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeId is required.")));
    }
    if (!currentVersion) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("currentVersion is required.")));
    }
    if (!owner) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("owner is required.")));
    }
    if (!lastEditUser) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("lastEditUser is required.")));
    }
    if (!lastEditTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("lastEditTime is required.")));
    }
    if (!commitStatus) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("commitStatus is required.")));
    }
    if (!deletedStatus) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deletedStatus is required.")));
    }
    if (!businessId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("businessId is required.")));
    }
    if (!autoParsing) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("autoParsing is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connectionName) {
      res["ConnectionName"] = boost::any(*connectionName);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (isMaxCompute) {
      res["IsMaxCompute"] = boost::any(*isMaxCompute);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (fileFolderId) {
      res["FileFolderId"] = boost::any(*fileFolderId);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (useType) {
      res["UseType"] = boost::any(*useType);
    }
    if (fileDescription) {
      res["FileDescription"] = boost::any(*fileDescription);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (currentVersion) {
      res["CurrentVersion"] = boost::any(*currentVersion);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (lastEditUser) {
      res["LastEditUser"] = boost::any(*lastEditUser);
    }
    if (lastEditTime) {
      res["LastEditTime"] = boost::any(*lastEditTime);
    }
    if (commitStatus) {
      res["CommitStatus"] = boost::any(*commitStatus);
    }
    if (deletedStatus) {
      res["DeletedStatus"] = boost::any(*deletedStatus);
    }
    if (businessId) {
      res["BusinessId"] = boost::any(*businessId);
    }
    if (autoParsing) {
      res["AutoParsing"] = boost::any(*autoParsing);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConnectionName") != m.end() && !m["ConnectionName"].empty()) {
      connectionName = make_shared<string>(boost::any_cast<string>(m["ConnectionName"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
    if (m.find("IsMaxCompute") != m.end() && !m["IsMaxCompute"].empty()) {
      isMaxCompute = make_shared<bool>(boost::any_cast<bool>(m["IsMaxCompute"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<long>(boost::any_cast<long>(m["BizId"]));
    }
    if (m.find("FileFolderId") != m.end() && !m["FileFolderId"].empty()) {
      fileFolderId = make_shared<string>(boost::any_cast<string>(m["FileFolderId"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<int>(boost::any_cast<int>(m["FileType"]));
    }
    if (m.find("UseType") != m.end() && !m["UseType"].empty()) {
      useType = make_shared<string>(boost::any_cast<string>(m["UseType"]));
    }
    if (m.find("FileDescription") != m.end() && !m["FileDescription"].empty()) {
      fileDescription = make_shared<string>(boost::any_cast<string>(m["FileDescription"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("CurrentVersion") != m.end() && !m["CurrentVersion"].empty()) {
      currentVersion = make_shared<int>(boost::any_cast<int>(m["CurrentVersion"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("LastEditUser") != m.end() && !m["LastEditUser"].empty()) {
      lastEditUser = make_shared<string>(boost::any_cast<string>(m["LastEditUser"]));
    }
    if (m.find("LastEditTime") != m.end() && !m["LastEditTime"].empty()) {
      lastEditTime = make_shared<long>(boost::any_cast<long>(m["LastEditTime"]));
    }
    if (m.find("CommitStatus") != m.end() && !m["CommitStatus"].empty()) {
      commitStatus = make_shared<int>(boost::any_cast<int>(m["CommitStatus"]));
    }
    if (m.find("DeletedStatus") != m.end() && !m["DeletedStatus"].empty()) {
      deletedStatus = make_shared<string>(boost::any_cast<string>(m["DeletedStatus"]));
    }
    if (m.find("BusinessId") != m.end() && !m["BusinessId"].empty()) {
      businessId = make_shared<long>(boost::any_cast<long>(m["BusinessId"]));
    }
    if (m.find("AutoParsing") != m.end() && !m["AutoParsing"].empty()) {
      autoParsing = make_shared<bool>(boost::any_cast<bool>(m["AutoParsing"]));
    }
  }


  virtual ~GetFileResponseDataFile() = default;
};
class GetFileResponseDataNodeConfigurationInputList : public Darabonba::Model {
public:
  shared_ptr<string> input{};
  shared_ptr<string> parseType{};

  GetFileResponseDataNodeConfigurationInputList() {}

  explicit GetFileResponseDataNodeConfigurationInputList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!input) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("input is required.")));
    }
    if (!parseType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parseType is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (parseType) {
      res["ParseType"] = boost::any(*parseType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("ParseType") != m.end() && !m["ParseType"].empty()) {
      parseType = make_shared<string>(boost::any_cast<string>(m["ParseType"]));
    }
  }


  virtual ~GetFileResponseDataNodeConfigurationInputList() = default;
};
class GetFileResponseDataNodeConfigurationOutputList : public Darabonba::Model {
public:
  shared_ptr<string> output{};
  shared_ptr<string> refTableName{};

  GetFileResponseDataNodeConfigurationOutputList() {}

  explicit GetFileResponseDataNodeConfigurationOutputList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!output) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("output is required.")));
    }
    if (!refTableName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("refTableName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = boost::any(*output);
    }
    if (refTableName) {
      res["RefTableName"] = boost::any(*refTableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      output = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
    if (m.find("RefTableName") != m.end() && !m["RefTableName"].empty()) {
      refTableName = make_shared<string>(boost::any_cast<string>(m["RefTableName"]));
    }
  }


  virtual ~GetFileResponseDataNodeConfigurationOutputList() = default;
};
class GetFileResponseDataNodeConfiguration : public Darabonba::Model {
public:
  shared_ptr<int> autoRerunTimes{};
  shared_ptr<int> autoRerunIntervalMillis{};
  shared_ptr<string> rerunMode{};
  shared_ptr<bool> stop{};
  shared_ptr<string> paraValue{};
  shared_ptr<long> startEffectDate{};
  shared_ptr<long> endEffectDate{};
  shared_ptr<string> cronExpress{};
  shared_ptr<string> cycleType{};
  shared_ptr<string> dependentType{};
  shared_ptr<string> dependentNodeIdList{};
  shared_ptr<long> resourceGroupId{};
  shared_ptr<string> schedulerType{};
  shared_ptr<vector<GetFileResponseDataNodeConfigurationInputList>> inputList{};
  shared_ptr<vector<GetFileResponseDataNodeConfigurationOutputList>> outputList{};

  GetFileResponseDataNodeConfiguration() {}

  explicit GetFileResponseDataNodeConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!autoRerunTimes) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("autoRerunTimes is required.")));
    }
    if (!autoRerunIntervalMillis) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("autoRerunIntervalMillis is required.")));
    }
    if (!rerunMode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("rerunMode is required.")));
    }
    if (!stop) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("stop is required.")));
    }
    if (!paraValue) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("paraValue is required.")));
    }
    if (!startEffectDate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("startEffectDate is required.")));
    }
    if (!endEffectDate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("endEffectDate is required.")));
    }
    if (!cronExpress) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("cronExpress is required.")));
    }
    if (!cycleType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("cycleType is required.")));
    }
    if (!dependentType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dependentType is required.")));
    }
    if (!dependentNodeIdList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dependentNodeIdList is required.")));
    }
    if (!resourceGroupId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("resourceGroupId is required.")));
    }
    if (!schedulerType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("schedulerType is required.")));
    }
    if (!inputList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("inputList is required.")));
    }
    if (!outputList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("outputList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRerunTimes) {
      res["AutoRerunTimes"] = boost::any(*autoRerunTimes);
    }
    if (autoRerunIntervalMillis) {
      res["AutoRerunIntervalMillis"] = boost::any(*autoRerunIntervalMillis);
    }
    if (rerunMode) {
      res["RerunMode"] = boost::any(*rerunMode);
    }
    if (stop) {
      res["Stop"] = boost::any(*stop);
    }
    if (paraValue) {
      res["ParaValue"] = boost::any(*paraValue);
    }
    if (startEffectDate) {
      res["StartEffectDate"] = boost::any(*startEffectDate);
    }
    if (endEffectDate) {
      res["EndEffectDate"] = boost::any(*endEffectDate);
    }
    if (cronExpress) {
      res["CronExpress"] = boost::any(*cronExpress);
    }
    if (cycleType) {
      res["CycleType"] = boost::any(*cycleType);
    }
    if (dependentType) {
      res["DependentType"] = boost::any(*dependentType);
    }
    if (dependentNodeIdList) {
      res["DependentNodeIdList"] = boost::any(*dependentNodeIdList);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (schedulerType) {
      res["SchedulerType"] = boost::any(*schedulerType);
    }
    if (inputList) {
      vector<boost::any> temp1;
      for(auto item1:*inputList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InputList"] = boost::any(temp1);
    }
    if (outputList) {
      vector<boost::any> temp1;
      for(auto item1:*outputList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OutputList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRerunTimes") != m.end() && !m["AutoRerunTimes"].empty()) {
      autoRerunTimes = make_shared<int>(boost::any_cast<int>(m["AutoRerunTimes"]));
    }
    if (m.find("AutoRerunIntervalMillis") != m.end() && !m["AutoRerunIntervalMillis"].empty()) {
      autoRerunIntervalMillis = make_shared<int>(boost::any_cast<int>(m["AutoRerunIntervalMillis"]));
    }
    if (m.find("RerunMode") != m.end() && !m["RerunMode"].empty()) {
      rerunMode = make_shared<string>(boost::any_cast<string>(m["RerunMode"]));
    }
    if (m.find("Stop") != m.end() && !m["Stop"].empty()) {
      stop = make_shared<bool>(boost::any_cast<bool>(m["Stop"]));
    }
    if (m.find("ParaValue") != m.end() && !m["ParaValue"].empty()) {
      paraValue = make_shared<string>(boost::any_cast<string>(m["ParaValue"]));
    }
    if (m.find("StartEffectDate") != m.end() && !m["StartEffectDate"].empty()) {
      startEffectDate = make_shared<long>(boost::any_cast<long>(m["StartEffectDate"]));
    }
    if (m.find("EndEffectDate") != m.end() && !m["EndEffectDate"].empty()) {
      endEffectDate = make_shared<long>(boost::any_cast<long>(m["EndEffectDate"]));
    }
    if (m.find("CronExpress") != m.end() && !m["CronExpress"].empty()) {
      cronExpress = make_shared<string>(boost::any_cast<string>(m["CronExpress"]));
    }
    if (m.find("CycleType") != m.end() && !m["CycleType"].empty()) {
      cycleType = make_shared<string>(boost::any_cast<string>(m["CycleType"]));
    }
    if (m.find("DependentType") != m.end() && !m["DependentType"].empty()) {
      dependentType = make_shared<string>(boost::any_cast<string>(m["DependentType"]));
    }
    if (m.find("DependentNodeIdList") != m.end() && !m["DependentNodeIdList"].empty()) {
      dependentNodeIdList = make_shared<string>(boost::any_cast<string>(m["DependentNodeIdList"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<long>(boost::any_cast<long>(m["ResourceGroupId"]));
    }
    if (m.find("SchedulerType") != m.end() && !m["SchedulerType"].empty()) {
      schedulerType = make_shared<string>(boost::any_cast<string>(m["SchedulerType"]));
    }
    if (m.find("InputList") != m.end() && !m["InputList"].empty()) {
      if (typeid(vector<boost::any>) == m["InputList"].type()) {
        vector<GetFileResponseDataNodeConfigurationInputList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InputList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetFileResponseDataNodeConfigurationInputList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inputList = make_shared<vector<GetFileResponseDataNodeConfigurationInputList>>(expect1);
      }
    }
    if (m.find("OutputList") != m.end() && !m["OutputList"].empty()) {
      if (typeid(vector<boost::any>) == m["OutputList"].type()) {
        vector<GetFileResponseDataNodeConfigurationOutputList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OutputList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetFileResponseDataNodeConfigurationOutputList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outputList = make_shared<vector<GetFileResponseDataNodeConfigurationOutputList>>(expect1);
      }
    }
  }


  virtual ~GetFileResponseDataNodeConfiguration() = default;
};
class GetFileResponseData : public Darabonba::Model {
public:
  shared_ptr<GetFileResponseDataFile> file{};
  shared_ptr<GetFileResponseDataNodeConfiguration> nodeConfiguration{};

  GetFileResponseData() {}

  explicit GetFileResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!file) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("file is required.")));
    }
    if (!nodeConfiguration) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeConfiguration is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nodeConfiguration) {
      res["NodeConfiguration"] = nodeConfiguration ? boost::any(nodeConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        GetFileResponseDataFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<GetFileResponseDataFile>(model1);
      }
    }
    if (m.find("NodeConfiguration") != m.end() && !m["NodeConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["NodeConfiguration"].type()) {
        GetFileResponseDataNodeConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NodeConfiguration"]));
        nodeConfiguration = make_shared<GetFileResponseDataNodeConfiguration>(model1);
      }
    }
  }


  virtual ~GetFileResponseData() = default;
};
class GetFileResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<GetFileResponseData> data{};

  GetFileResponse() {}

  explicit GetFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetFileResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetFileResponseData>(model1);
      }
    }
  }


  virtual ~GetFileResponse() = default;
};
class ListBusinessRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<string> keyword{};

  ListBusinessRequest() {}

  explicit ListBusinessRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageNumber) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNumber is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
  }


  virtual ~ListBusinessRequest() = default;
};
class ListBusinessResponseDataBusiness : public Darabonba::Model {
public:
  shared_ptr<long> businessId{};
  shared_ptr<string> businessName{};
  shared_ptr<long> projectId{};
  shared_ptr<string> owner{};
  shared_ptr<string> description{};
  shared_ptr<string> useType{};

  ListBusinessResponseDataBusiness() {}

  explicit ListBusinessResponseDataBusiness(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!businessId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("businessId is required.")));
    }
    if (!businessName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("businessName is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!owner) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("owner is required.")));
    }
    if (!description) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("description is required.")));
    }
    if (!useType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("useType is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessId) {
      res["BusinessId"] = boost::any(*businessId);
    }
    if (businessName) {
      res["BusinessName"] = boost::any(*businessName);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (useType) {
      res["UseType"] = boost::any(*useType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessId") != m.end() && !m["BusinessId"].empty()) {
      businessId = make_shared<long>(boost::any_cast<long>(m["BusinessId"]));
    }
    if (m.find("BusinessName") != m.end() && !m["BusinessName"].empty()) {
      businessName = make_shared<string>(boost::any_cast<string>(m["BusinessName"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("UseType") != m.end() && !m["UseType"].empty()) {
      useType = make_shared<string>(boost::any_cast<string>(m["UseType"]));
    }
  }


  virtual ~ListBusinessResponseDataBusiness() = default;
};
class ListBusinessResponseData : public Darabonba::Model {
public:
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> totalCount{};
  shared_ptr<vector<ListBusinessResponseDataBusiness>> business{};

  ListBusinessResponseData() {}

  explicit ListBusinessResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageNumber) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNumber is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!totalCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("totalCount is required.")));
    }
    if (!business) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("business is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (business) {
      vector<boost::any> temp1;
      for(auto item1:*business){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Business"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<int>(boost::any_cast<int>(m["TotalCount"]));
    }
    if (m.find("Business") != m.end() && !m["Business"].empty()) {
      if (typeid(vector<boost::any>) == m["Business"].type()) {
        vector<ListBusinessResponseDataBusiness> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Business"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListBusinessResponseDataBusiness model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        business = make_shared<vector<ListBusinessResponseDataBusiness>>(expect1);
      }
    }
  }


  virtual ~ListBusinessResponseData() = default;
};
class ListBusinessResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<ListBusinessResponseData> data{};

  ListBusinessResponse() {}

  explicit ListBusinessResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListBusinessResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListBusinessResponseData>(model1);
      }
    }
  }


  virtual ~ListBusinessResponse() = default;
};
class GetMetaDBTableListRequest : public Darabonba::Model {
public:
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<string> appGuid{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> databaseName{};
  shared_ptr<string> dataSourceType{};

  GetMetaDBTableListRequest() {}

  explicit GetMetaDBTableListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (appGuid) {
      res["AppGuid"] = boost::any(*appGuid);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (dataSourceType) {
      res["DataSourceType"] = boost::any(*dataSourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("AppGuid") != m.end() && !m["AppGuid"].empty()) {
      appGuid = make_shared<string>(boost::any_cast<string>(m["AppGuid"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("DataSourceType") != m.end() && !m["DataSourceType"].empty()) {
      dataSourceType = make_shared<string>(boost::any_cast<string>(m["DataSourceType"]));
    }
  }


  virtual ~GetMetaDBTableListRequest() = default;
};
class GetMetaDBTableListResponseDataTableEntityList : public Darabonba::Model {
public:
  shared_ptr<string> tableName{};
  shared_ptr<string> tableGuid{};
  shared_ptr<string> databaseName{};

  GetMetaDBTableListResponseDataTableEntityList() {}

  explicit GetMetaDBTableListResponseDataTableEntityList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!tableName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tableName is required.")));
    }
    if (!tableGuid) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tableGuid is required.")));
    }
    if (!databaseName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("databaseName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
  }


  virtual ~GetMetaDBTableListResponseDataTableEntityList() = default;
};
class GetMetaDBTableListResponseData : public Darabonba::Model {
public:
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<GetMetaDBTableListResponseDataTableEntityList>> tableEntityList{};

  GetMetaDBTableListResponseData() {}

  explicit GetMetaDBTableListResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageNumber) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNumber is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!totalCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("totalCount is required.")));
    }
    if (!tableEntityList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tableEntityList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (tableEntityList) {
      vector<boost::any> temp1;
      for(auto item1:*tableEntityList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TableEntityList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("TableEntityList") != m.end() && !m["TableEntityList"].empty()) {
      if (typeid(vector<boost::any>) == m["TableEntityList"].type()) {
        vector<GetMetaDBTableListResponseDataTableEntityList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TableEntityList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMetaDBTableListResponseDataTableEntityList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tableEntityList = make_shared<vector<GetMetaDBTableListResponseDataTableEntityList>>(expect1);
      }
    }
  }


  virtual ~GetMetaDBTableListResponseData() = default;
};
class GetMetaDBTableListResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetMetaDBTableListResponseData> data{};

  GetMetaDBTableListResponse() {}

  explicit GetMetaDBTableListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetMetaDBTableListResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetMetaDBTableListResponseData>(model1);
      }
    }
  }


  virtual ~GetMetaDBTableListResponse() = default;
};
class CheckMetaTableRequest : public Darabonba::Model {
public:
  shared_ptr<string> tableGuid{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> databaseName{};
  shared_ptr<string> tableName{};
  shared_ptr<string> dataSourceType{};

  CheckMetaTableRequest() {}

  explicit CheckMetaTableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (dataSourceType) {
      res["DataSourceType"] = boost::any(*dataSourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("DataSourceType") != m.end() && !m["DataSourceType"].empty()) {
      dataSourceType = make_shared<string>(boost::any_cast<string>(m["DataSourceType"]));
    }
  }


  virtual ~CheckMetaTableRequest() = default;
};
class CheckMetaTableResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> data{};

  CheckMetaTableResponse() {}

  explicit CheckMetaTableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
  }


  virtual ~CheckMetaTableResponse() = default;
};
class GetFolderRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<string> folderId{};
  shared_ptr<string> folderPath{};

  GetFolderRequest() {}

  explicit GetFolderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (folderId) {
      res["FolderId"] = boost::any(*folderId);
    }
    if (folderPath) {
      res["FolderPath"] = boost::any(*folderPath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("FolderId") != m.end() && !m["FolderId"].empty()) {
      folderId = make_shared<string>(boost::any_cast<string>(m["FolderId"]));
    }
    if (m.find("FolderPath") != m.end() && !m["FolderPath"].empty()) {
      folderPath = make_shared<string>(boost::any_cast<string>(m["FolderPath"]));
    }
  }


  virtual ~GetFolderRequest() = default;
};
class GetFolderResponseData : public Darabonba::Model {
public:
  shared_ptr<string> folderId{};
  shared_ptr<string> folderPath{};

  GetFolderResponseData() {}

  explicit GetFolderResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!folderId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("folderId is required.")));
    }
    if (!folderPath) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("folderPath is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (folderId) {
      res["FolderId"] = boost::any(*folderId);
    }
    if (folderPath) {
      res["FolderPath"] = boost::any(*folderPath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FolderId") != m.end() && !m["FolderId"].empty()) {
      folderId = make_shared<string>(boost::any_cast<string>(m["FolderId"]));
    }
    if (m.find("FolderPath") != m.end() && !m["FolderPath"].empty()) {
      folderPath = make_shared<string>(boost::any_cast<string>(m["FolderPath"]));
    }
  }


  virtual ~GetFolderResponseData() = default;
};
class GetFolderResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<GetFolderResponseData> data{};

  GetFolderResponse() {}

  explicit GetFolderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetFolderResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetFolderResponseData>(model1);
      }
    }
  }


  virtual ~GetFolderResponse() = default;
};
class DeployFileRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<long> fileId{};
  shared_ptr<string> comment{};
  shared_ptr<long> nodeId{};

  DeployFileRequest() {}

  explicit DeployFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
  }


  virtual ~DeployFileRequest() = default;
};
class DeployFileResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> data{};
  shared_ptr<int> httpStatusCode{};

  DeployFileResponse() {}

  explicit DeployFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
  }


  virtual ~DeployFileResponse() = default;
};
class DeleteBusinessRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<long> businessId{};

  DeleteBusinessRequest() {}

  explicit DeleteBusinessRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!businessId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("businessId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (businessId) {
      res["BusinessId"] = boost::any(*businessId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("BusinessId") != m.end() && !m["BusinessId"].empty()) {
      businessId = make_shared<long>(boost::any_cast<long>(m["BusinessId"]));
    }
  }


  virtual ~DeleteBusinessRequest() = default;
};
class DeleteBusinessResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};

  DeleteBusinessResponse() {}

  explicit DeleteBusinessResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
  }


  virtual ~DeleteBusinessResponse() = default;
};
class DeleteFileRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<long> fileId{};

  DeleteFileRequest() {}

  explicit DeleteFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!fileId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("fileId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
  }


  virtual ~DeleteFileRequest() = default;
};
class DeleteFileResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<long> deploymentId{};

  DeleteFileResponse() {}

  explicit DeleteFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!deploymentId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deploymentId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (deploymentId) {
      res["DeploymentId"] = boost::any(*deploymentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("DeploymentId") != m.end() && !m["DeploymentId"].empty()) {
      deploymentId = make_shared<long>(boost::any_cast<long>(m["DeploymentId"]));
    }
  }


  virtual ~DeleteFileResponse() = default;
};
class ListQualityRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectName{};
  shared_ptr<long> entityId{};
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};

  ListQualityRulesRequest() {}

  explicit ListQualityRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectName is required.")));
    }
    if (!entityId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("entityId is required.")));
    }
    if (!pageNumber) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNumber is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (entityId) {
      res["EntityId"] = boost::any(*entityId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("EntityId") != m.end() && !m["EntityId"].empty()) {
      entityId = make_shared<long>(boost::any_cast<long>(m["EntityId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
  }


  virtual ~ListQualityRulesRequest() = default;
};
class ListQualityRulesResponseDataRules : public Darabonba::Model {
public:
  shared_ptr<string> projectName{};
  shared_ptr<string> tableName{};
  shared_ptr<int> id{};
  shared_ptr<int> entityId{};
  shared_ptr<string> property{};
  shared_ptr<int> methodId{};
  shared_ptr<string> methodName{};
  shared_ptr<string> onDuty{};
  shared_ptr<int> ruleType{};
  shared_ptr<int> blockType{};
  shared_ptr<int> templateId{};
  shared_ptr<string> templateName{};
  shared_ptr<int> ruleCheckerRelationId{};
  shared_ptr<int> checkerId{};
  shared_ptr<bool> fixCheck{};
  shared_ptr<string> trend{};
  shared_ptr<string> warningThreshold{};
  shared_ptr<string> criticalThreshold{};
  shared_ptr<string> historyWarningThreshold{};
  shared_ptr<string> historyCriticalThreshold{};
  shared_ptr<string> propertyKey{};
  shared_ptr<string> matchExpression{};
  shared_ptr<string> comment{};
  shared_ptr<string> expectValue{};
  shared_ptr<string> onDutyAccountName{};

  ListQualityRulesResponseDataRules() {}

  explicit ListQualityRulesResponseDataRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectName is required.")));
    }
    if (!tableName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tableName is required.")));
    }
    if (!id) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("id is required.")));
    }
    if (!entityId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("entityId is required.")));
    }
    if (!property) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("property is required.")));
    }
    if (!methodId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("methodId is required.")));
    }
    if (!methodName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("methodName is required.")));
    }
    if (!onDuty) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("onDuty is required.")));
    }
    if (!ruleType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleType is required.")));
    }
    if (!blockType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("blockType is required.")));
    }
    if (!templateId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("templateId is required.")));
    }
    if (!templateName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("templateName is required.")));
    }
    if (!ruleCheckerRelationId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleCheckerRelationId is required.")));
    }
    if (!checkerId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("checkerId is required.")));
    }
    if (!fixCheck) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("fixCheck is required.")));
    }
    if (!trend) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("trend is required.")));
    }
    if (!warningThreshold) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("warningThreshold is required.")));
    }
    if (!criticalThreshold) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("criticalThreshold is required.")));
    }
    if (!historyWarningThreshold) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("historyWarningThreshold is required.")));
    }
    if (!historyCriticalThreshold) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("historyCriticalThreshold is required.")));
    }
    if (!propertyKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("propertyKey is required.")));
    }
    if (!matchExpression) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("matchExpression is required.")));
    }
    if (!comment) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("comment is required.")));
    }
    if (!expectValue) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("expectValue is required.")));
    }
    if (!onDutyAccountName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("onDutyAccountName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (entityId) {
      res["EntityId"] = boost::any(*entityId);
    }
    if (property) {
      res["Property"] = boost::any(*property);
    }
    if (methodId) {
      res["MethodId"] = boost::any(*methodId);
    }
    if (methodName) {
      res["MethodName"] = boost::any(*methodName);
    }
    if (onDuty) {
      res["OnDuty"] = boost::any(*onDuty);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    if (blockType) {
      res["BlockType"] = boost::any(*blockType);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (ruleCheckerRelationId) {
      res["RuleCheckerRelationId"] = boost::any(*ruleCheckerRelationId);
    }
    if (checkerId) {
      res["CheckerId"] = boost::any(*checkerId);
    }
    if (fixCheck) {
      res["FixCheck"] = boost::any(*fixCheck);
    }
    if (trend) {
      res["Trend"] = boost::any(*trend);
    }
    if (warningThreshold) {
      res["WarningThreshold"] = boost::any(*warningThreshold);
    }
    if (criticalThreshold) {
      res["CriticalThreshold"] = boost::any(*criticalThreshold);
    }
    if (historyWarningThreshold) {
      res["HistoryWarningThreshold"] = boost::any(*historyWarningThreshold);
    }
    if (historyCriticalThreshold) {
      res["HistoryCriticalThreshold"] = boost::any(*historyCriticalThreshold);
    }
    if (propertyKey) {
      res["PropertyKey"] = boost::any(*propertyKey);
    }
    if (matchExpression) {
      res["MatchExpression"] = boost::any(*matchExpression);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (expectValue) {
      res["ExpectValue"] = boost::any(*expectValue);
    }
    if (onDutyAccountName) {
      res["OnDutyAccountName"] = boost::any(*onDutyAccountName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<int>(boost::any_cast<int>(m["Id"]));
    }
    if (m.find("EntityId") != m.end() && !m["EntityId"].empty()) {
      entityId = make_shared<int>(boost::any_cast<int>(m["EntityId"]));
    }
    if (m.find("Property") != m.end() && !m["Property"].empty()) {
      property = make_shared<string>(boost::any_cast<string>(m["Property"]));
    }
    if (m.find("MethodId") != m.end() && !m["MethodId"].empty()) {
      methodId = make_shared<int>(boost::any_cast<int>(m["MethodId"]));
    }
    if (m.find("MethodName") != m.end() && !m["MethodName"].empty()) {
      methodName = make_shared<string>(boost::any_cast<string>(m["MethodName"]));
    }
    if (m.find("OnDuty") != m.end() && !m["OnDuty"].empty()) {
      onDuty = make_shared<string>(boost::any_cast<string>(m["OnDuty"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<int>(boost::any_cast<int>(m["RuleType"]));
    }
    if (m.find("BlockType") != m.end() && !m["BlockType"].empty()) {
      blockType = make_shared<int>(boost::any_cast<int>(m["BlockType"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<int>(boost::any_cast<int>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("RuleCheckerRelationId") != m.end() && !m["RuleCheckerRelationId"].empty()) {
      ruleCheckerRelationId = make_shared<int>(boost::any_cast<int>(m["RuleCheckerRelationId"]));
    }
    if (m.find("CheckerId") != m.end() && !m["CheckerId"].empty()) {
      checkerId = make_shared<int>(boost::any_cast<int>(m["CheckerId"]));
    }
    if (m.find("FixCheck") != m.end() && !m["FixCheck"].empty()) {
      fixCheck = make_shared<bool>(boost::any_cast<bool>(m["FixCheck"]));
    }
    if (m.find("Trend") != m.end() && !m["Trend"].empty()) {
      trend = make_shared<string>(boost::any_cast<string>(m["Trend"]));
    }
    if (m.find("WarningThreshold") != m.end() && !m["WarningThreshold"].empty()) {
      warningThreshold = make_shared<string>(boost::any_cast<string>(m["WarningThreshold"]));
    }
    if (m.find("CriticalThreshold") != m.end() && !m["CriticalThreshold"].empty()) {
      criticalThreshold = make_shared<string>(boost::any_cast<string>(m["CriticalThreshold"]));
    }
    if (m.find("HistoryWarningThreshold") != m.end() && !m["HistoryWarningThreshold"].empty()) {
      historyWarningThreshold = make_shared<string>(boost::any_cast<string>(m["HistoryWarningThreshold"]));
    }
    if (m.find("HistoryCriticalThreshold") != m.end() && !m["HistoryCriticalThreshold"].empty()) {
      historyCriticalThreshold = make_shared<string>(boost::any_cast<string>(m["HistoryCriticalThreshold"]));
    }
    if (m.find("PropertyKey") != m.end() && !m["PropertyKey"].empty()) {
      propertyKey = make_shared<string>(boost::any_cast<string>(m["PropertyKey"]));
    }
    if (m.find("MatchExpression") != m.end() && !m["MatchExpression"].empty()) {
      matchExpression = make_shared<string>(boost::any_cast<string>(m["MatchExpression"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("ExpectValue") != m.end() && !m["ExpectValue"].empty()) {
      expectValue = make_shared<string>(boost::any_cast<string>(m["ExpectValue"]));
    }
    if (m.find("OnDutyAccountName") != m.end() && !m["OnDutyAccountName"].empty()) {
      onDutyAccountName = make_shared<string>(boost::any_cast<string>(m["OnDutyAccountName"]));
    }
  }


  virtual ~ListQualityRulesResponseDataRules() = default;
};
class ListQualityRulesResponseData : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<vector<ListQualityRulesResponseDataRules>> rules{};

  ListQualityRulesResponseData() {}

  explicit ListQualityRulesResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!totalCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("totalCount is required.")));
    }
    if (!pageNumber) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNumber is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!rules) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("rules is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (rules) {
      vector<boost::any> temp1;
      for(auto item1:*rules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rules"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      if (typeid(vector<boost::any>) == m["Rules"].type()) {
        vector<ListQualityRulesResponseDataRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListQualityRulesResponseDataRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rules = make_shared<vector<ListQualityRulesResponseDataRules>>(expect1);
      }
    }
  }


  virtual ~ListQualityRulesResponseData() = default;
};
class ListQualityRulesResponse : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<ListQualityRulesResponseData> data{};

  ListQualityRulesResponse() {}

  explicit ListQualityRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListQualityRulesResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListQualityRulesResponseData>(model1);
      }
    }
  }


  virtual ~ListQualityRulesResponse() = default;
};
class CreateRemindRequest : public Darabonba::Model {
public:
  shared_ptr<string> remindName{};
  shared_ptr<string> dndEnd{};
  shared_ptr<string> remindUnit{};
  shared_ptr<string> nodeIds{};
  shared_ptr<string> baselineIds{};
  shared_ptr<long> projectId{};
  shared_ptr<string> bizProcessIds{};
  shared_ptr<string> remindType{};
  shared_ptr<int> maxAlertTimes{};
  shared_ptr<int> alertInterval{};
  shared_ptr<string> detail{};
  shared_ptr<string> alertUnit{};
  shared_ptr<string> alertMethods{};
  shared_ptr<string> alertTargets{};
  shared_ptr<string> robotUrls{};

  CreateRemindRequest() {}

  explicit CreateRemindRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!remindName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("remindName is required.")));
    }
    if (!remindUnit) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("remindUnit is required.")));
    }
    if (!remindType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("remindType is required.")));
    }
    if (!alertUnit) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("alertUnit is required.")));
    }
    if (!alertMethods) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("alertMethods is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (remindName) {
      res["RemindName"] = boost::any(*remindName);
    }
    if (dndEnd) {
      res["DndEnd"] = boost::any(*dndEnd);
    }
    if (remindUnit) {
      res["RemindUnit"] = boost::any(*remindUnit);
    }
    if (nodeIds) {
      res["NodeIds"] = boost::any(*nodeIds);
    }
    if (baselineIds) {
      res["BaselineIds"] = boost::any(*baselineIds);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (bizProcessIds) {
      res["BizProcessIds"] = boost::any(*bizProcessIds);
    }
    if (remindType) {
      res["RemindType"] = boost::any(*remindType);
    }
    if (maxAlertTimes) {
      res["MaxAlertTimes"] = boost::any(*maxAlertTimes);
    }
    if (alertInterval) {
      res["AlertInterval"] = boost::any(*alertInterval);
    }
    if (detail) {
      res["Detail"] = boost::any(*detail);
    }
    if (alertUnit) {
      res["AlertUnit"] = boost::any(*alertUnit);
    }
    if (alertMethods) {
      res["AlertMethods"] = boost::any(*alertMethods);
    }
    if (alertTargets) {
      res["AlertTargets"] = boost::any(*alertTargets);
    }
    if (robotUrls) {
      res["RobotUrls"] = boost::any(*robotUrls);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RemindName") != m.end() && !m["RemindName"].empty()) {
      remindName = make_shared<string>(boost::any_cast<string>(m["RemindName"]));
    }
    if (m.find("DndEnd") != m.end() && !m["DndEnd"].empty()) {
      dndEnd = make_shared<string>(boost::any_cast<string>(m["DndEnd"]));
    }
    if (m.find("RemindUnit") != m.end() && !m["RemindUnit"].empty()) {
      remindUnit = make_shared<string>(boost::any_cast<string>(m["RemindUnit"]));
    }
    if (m.find("NodeIds") != m.end() && !m["NodeIds"].empty()) {
      nodeIds = make_shared<string>(boost::any_cast<string>(m["NodeIds"]));
    }
    if (m.find("BaselineIds") != m.end() && !m["BaselineIds"].empty()) {
      baselineIds = make_shared<string>(boost::any_cast<string>(m["BaselineIds"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("BizProcessIds") != m.end() && !m["BizProcessIds"].empty()) {
      bizProcessIds = make_shared<string>(boost::any_cast<string>(m["BizProcessIds"]));
    }
    if (m.find("RemindType") != m.end() && !m["RemindType"].empty()) {
      remindType = make_shared<string>(boost::any_cast<string>(m["RemindType"]));
    }
    if (m.find("MaxAlertTimes") != m.end() && !m["MaxAlertTimes"].empty()) {
      maxAlertTimes = make_shared<int>(boost::any_cast<int>(m["MaxAlertTimes"]));
    }
    if (m.find("AlertInterval") != m.end() && !m["AlertInterval"].empty()) {
      alertInterval = make_shared<int>(boost::any_cast<int>(m["AlertInterval"]));
    }
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      detail = make_shared<string>(boost::any_cast<string>(m["Detail"]));
    }
    if (m.find("AlertUnit") != m.end() && !m["AlertUnit"].empty()) {
      alertUnit = make_shared<string>(boost::any_cast<string>(m["AlertUnit"]));
    }
    if (m.find("AlertMethods") != m.end() && !m["AlertMethods"].empty()) {
      alertMethods = make_shared<string>(boost::any_cast<string>(m["AlertMethods"]));
    }
    if (m.find("AlertTargets") != m.end() && !m["AlertTargets"].empty()) {
      alertTargets = make_shared<string>(boost::any_cast<string>(m["AlertTargets"]));
    }
    if (m.find("RobotUrls") != m.end() && !m["RobotUrls"].empty()) {
      robotUrls = make_shared<string>(boost::any_cast<string>(m["RobotUrls"]));
    }
  }


  virtual ~CreateRemindRequest() = default;
};
class CreateRemindResponse : public Darabonba::Model {
public:
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<long> data{};

  CreateRemindResponse() {}

  explicit CreateRemindResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
  }


  virtual ~CreateRemindResponse() = default;
};
class GetQualityRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> ruleId{};
  shared_ptr<string> projectName{};

  GetQualityRuleRequest() {}

  explicit GetQualityRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!ruleId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleId is required.")));
    }
    if (!projectName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
  }


  virtual ~GetQualityRuleRequest() = default;
};
class GetQualityRuleResponseData : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> entityId{};
  shared_ptr<string> property{};
  shared_ptr<int> methodId{};
  shared_ptr<string> methodName{};
  shared_ptr<string> whereCondition{};
  shared_ptr<string> onDuty{};
  shared_ptr<int> ruleType{};
  shared_ptr<int> blockType{};
  shared_ptr<int> templateId{};
  shared_ptr<string> templateName{};
  shared_ptr<string> comment{};
  shared_ptr<string> ruleName{};
  shared_ptr<int> predictType{};
  shared_ptr<string> warningThreshold{};
  shared_ptr<string> criticalThreshold{};
  shared_ptr<string> operator_{};
  shared_ptr<string> expectValue{};
  shared_ptr<string> trend{};
  shared_ptr<string> checkerName{};
  shared_ptr<int> checker{};
  shared_ptr<bool> fixCheck{};
  shared_ptr<string> onDutyAccountName{};

  GetQualityRuleResponseData() {}

  explicit GetQualityRuleResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!id) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("id is required.")));
    }
    if (!entityId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("entityId is required.")));
    }
    if (!property) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("property is required.")));
    }
    if (!methodId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("methodId is required.")));
    }
    if (!methodName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("methodName is required.")));
    }
    if (!whereCondition) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("whereCondition is required.")));
    }
    if (!onDuty) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("onDuty is required.")));
    }
    if (!ruleType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleType is required.")));
    }
    if (!blockType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("blockType is required.")));
    }
    if (!templateId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("templateId is required.")));
    }
    if (!templateName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("templateName is required.")));
    }
    if (!comment) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("comment is required.")));
    }
    if (!ruleName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleName is required.")));
    }
    if (!predictType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("predictType is required.")));
    }
    if (!warningThreshold) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("warningThreshold is required.")));
    }
    if (!criticalThreshold) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("criticalThreshold is required.")));
    }
    if (!operator_) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("operator is required.")));
    }
    if (!expectValue) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("expectValue is required.")));
    }
    if (!trend) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("trend is required.")));
    }
    if (!checkerName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("checkerName is required.")));
    }
    if (!checker) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("checker is required.")));
    }
    if (!fixCheck) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("fixCheck is required.")));
    }
    if (!onDutyAccountName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("onDutyAccountName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (entityId) {
      res["EntityId"] = boost::any(*entityId);
    }
    if (property) {
      res["Property"] = boost::any(*property);
    }
    if (methodId) {
      res["MethodId"] = boost::any(*methodId);
    }
    if (methodName) {
      res["MethodName"] = boost::any(*methodName);
    }
    if (whereCondition) {
      res["WhereCondition"] = boost::any(*whereCondition);
    }
    if (onDuty) {
      res["OnDuty"] = boost::any(*onDuty);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    if (blockType) {
      res["BlockType"] = boost::any(*blockType);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (predictType) {
      res["PredictType"] = boost::any(*predictType);
    }
    if (warningThreshold) {
      res["WarningThreshold"] = boost::any(*warningThreshold);
    }
    if (criticalThreshold) {
      res["CriticalThreshold"] = boost::any(*criticalThreshold);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (expectValue) {
      res["ExpectValue"] = boost::any(*expectValue);
    }
    if (trend) {
      res["Trend"] = boost::any(*trend);
    }
    if (checkerName) {
      res["CheckerName"] = boost::any(*checkerName);
    }
    if (checker) {
      res["Checker"] = boost::any(*checker);
    }
    if (fixCheck) {
      res["FixCheck"] = boost::any(*fixCheck);
    }
    if (onDutyAccountName) {
      res["OnDutyAccountName"] = boost::any(*onDutyAccountName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("EntityId") != m.end() && !m["EntityId"].empty()) {
      entityId = make_shared<long>(boost::any_cast<long>(m["EntityId"]));
    }
    if (m.find("Property") != m.end() && !m["Property"].empty()) {
      property = make_shared<string>(boost::any_cast<string>(m["Property"]));
    }
    if (m.find("MethodId") != m.end() && !m["MethodId"].empty()) {
      methodId = make_shared<int>(boost::any_cast<int>(m["MethodId"]));
    }
    if (m.find("MethodName") != m.end() && !m["MethodName"].empty()) {
      methodName = make_shared<string>(boost::any_cast<string>(m["MethodName"]));
    }
    if (m.find("WhereCondition") != m.end() && !m["WhereCondition"].empty()) {
      whereCondition = make_shared<string>(boost::any_cast<string>(m["WhereCondition"]));
    }
    if (m.find("OnDuty") != m.end() && !m["OnDuty"].empty()) {
      onDuty = make_shared<string>(boost::any_cast<string>(m["OnDuty"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<int>(boost::any_cast<int>(m["RuleType"]));
    }
    if (m.find("BlockType") != m.end() && !m["BlockType"].empty()) {
      blockType = make_shared<int>(boost::any_cast<int>(m["BlockType"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<int>(boost::any_cast<int>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("PredictType") != m.end() && !m["PredictType"].empty()) {
      predictType = make_shared<int>(boost::any_cast<int>(m["PredictType"]));
    }
    if (m.find("WarningThreshold") != m.end() && !m["WarningThreshold"].empty()) {
      warningThreshold = make_shared<string>(boost::any_cast<string>(m["WarningThreshold"]));
    }
    if (m.find("CriticalThreshold") != m.end() && !m["CriticalThreshold"].empty()) {
      criticalThreshold = make_shared<string>(boost::any_cast<string>(m["CriticalThreshold"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("ExpectValue") != m.end() && !m["ExpectValue"].empty()) {
      expectValue = make_shared<string>(boost::any_cast<string>(m["ExpectValue"]));
    }
    if (m.find("Trend") != m.end() && !m["Trend"].empty()) {
      trend = make_shared<string>(boost::any_cast<string>(m["Trend"]));
    }
    if (m.find("CheckerName") != m.end() && !m["CheckerName"].empty()) {
      checkerName = make_shared<string>(boost::any_cast<string>(m["CheckerName"]));
    }
    if (m.find("Checker") != m.end() && !m["Checker"].empty()) {
      checker = make_shared<int>(boost::any_cast<int>(m["Checker"]));
    }
    if (m.find("FixCheck") != m.end() && !m["FixCheck"].empty()) {
      fixCheck = make_shared<bool>(boost::any_cast<bool>(m["FixCheck"]));
    }
    if (m.find("OnDutyAccountName") != m.end() && !m["OnDutyAccountName"].empty()) {
      onDutyAccountName = make_shared<string>(boost::any_cast<string>(m["OnDutyAccountName"]));
    }
  }


  virtual ~GetQualityRuleResponseData() = default;
};
class GetQualityRuleResponse : public Darabonba::Model {
public:
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<GetQualityRuleResponseData> data{};

  GetQualityRuleResponse() {}

  explicit GetQualityRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetQualityRuleResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetQualityRuleResponseData>(model1);
      }
    }
  }


  virtual ~GetQualityRuleResponse() = default;
};
class GetDeploymentRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<long> deploymentId{};

  GetDeploymentRequest() {}

  explicit GetDeploymentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!deploymentId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deploymentId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (deploymentId) {
      res["DeploymentId"] = boost::any(*deploymentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("DeploymentId") != m.end() && !m["DeploymentId"].empty()) {
      deploymentId = make_shared<long>(boost::any_cast<long>(m["DeploymentId"]));
    }
  }


  virtual ~GetDeploymentRequest() = default;
};
class GetDeploymentResponseDataDeployment : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> handlerId{};
  shared_ptr<long> createTime{};
  shared_ptr<long> executeTime{};
  shared_ptr<int> status{};
  shared_ptr<int> fromEnvironment{};
  shared_ptr<int> toEnvironment{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> checkingStatus{};

  GetDeploymentResponseDataDeployment() {}

  explicit GetDeploymentResponseDataDeployment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!name) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("name is required.")));
    }
    if (!creatorId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("creatorId is required.")));
    }
    if (!handlerId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("handlerId is required.")));
    }
    if (!createTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("createTime is required.")));
    }
    if (!executeTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("executeTime is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!fromEnvironment) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("fromEnvironment is required.")));
    }
    if (!toEnvironment) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("toEnvironment is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!checkingStatus) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("checkingStatus is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (handlerId) {
      res["HandlerId"] = boost::any(*handlerId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (executeTime) {
      res["ExecuteTime"] = boost::any(*executeTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (fromEnvironment) {
      res["FromEnvironment"] = boost::any(*fromEnvironment);
    }
    if (toEnvironment) {
      res["ToEnvironment"] = boost::any(*toEnvironment);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (checkingStatus) {
      res["CheckingStatus"] = boost::any(*checkingStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("HandlerId") != m.end() && !m["HandlerId"].empty()) {
      handlerId = make_shared<string>(boost::any_cast<string>(m["HandlerId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("ExecuteTime") != m.end() && !m["ExecuteTime"].empty()) {
      executeTime = make_shared<long>(boost::any_cast<long>(m["ExecuteTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<int>(boost::any_cast<int>(m["Status"]));
    }
    if (m.find("FromEnvironment") != m.end() && !m["FromEnvironment"].empty()) {
      fromEnvironment = make_shared<int>(boost::any_cast<int>(m["FromEnvironment"]));
    }
    if (m.find("ToEnvironment") != m.end() && !m["ToEnvironment"].empty()) {
      toEnvironment = make_shared<int>(boost::any_cast<int>(m["ToEnvironment"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("CheckingStatus") != m.end() && !m["CheckingStatus"].empty()) {
      checkingStatus = make_shared<int>(boost::any_cast<int>(m["CheckingStatus"]));
    }
  }


  virtual ~GetDeploymentResponseDataDeployment() = default;
};
class GetDeploymentResponseData : public Darabonba::Model {
public:
  shared_ptr<GetDeploymentResponseDataDeployment> deployment{};

  GetDeploymentResponseData() {}

  explicit GetDeploymentResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!deployment) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deployment is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deployment) {
      res["Deployment"] = deployment ? boost::any(deployment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Deployment") != m.end() && !m["Deployment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Deployment"].type()) {
        GetDeploymentResponseDataDeployment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Deployment"]));
        deployment = make_shared<GetDeploymentResponseDataDeployment>(model1);
      }
    }
  }


  virtual ~GetDeploymentResponseData() = default;
};
class GetDeploymentResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<GetDeploymentResponseData> data{};

  GetDeploymentResponse() {}

  explicit GetDeploymentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetDeploymentResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetDeploymentResponseData>(model1);
      }
    }
  }


  virtual ~GetDeploymentResponse() = default;
};
class UpdateRemindRequest : public Darabonba::Model {
public:
  shared_ptr<long> remindId{};
  shared_ptr<string> remindName{};
  shared_ptr<string> dndEnd{};
  shared_ptr<string> remindUnit{};
  shared_ptr<string> nodeIds{};
  shared_ptr<string> baselineIds{};
  shared_ptr<long> projectId{};
  shared_ptr<string> bizProcessIds{};
  shared_ptr<string> remindType{};
  shared_ptr<int> maxAlertTimes{};
  shared_ptr<int> alertInterval{};
  shared_ptr<string> detail{};
  shared_ptr<string> alertUnit{};
  shared_ptr<string> alertMethods{};
  shared_ptr<string> alertTargets{};
  shared_ptr<bool> useFlag{};
  shared_ptr<string> robotUrls{};

  UpdateRemindRequest() {}

  explicit UpdateRemindRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!remindId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("remindId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (remindId) {
      res["RemindId"] = boost::any(*remindId);
    }
    if (remindName) {
      res["RemindName"] = boost::any(*remindName);
    }
    if (dndEnd) {
      res["DndEnd"] = boost::any(*dndEnd);
    }
    if (remindUnit) {
      res["RemindUnit"] = boost::any(*remindUnit);
    }
    if (nodeIds) {
      res["NodeIds"] = boost::any(*nodeIds);
    }
    if (baselineIds) {
      res["BaselineIds"] = boost::any(*baselineIds);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (bizProcessIds) {
      res["BizProcessIds"] = boost::any(*bizProcessIds);
    }
    if (remindType) {
      res["RemindType"] = boost::any(*remindType);
    }
    if (maxAlertTimes) {
      res["MaxAlertTimes"] = boost::any(*maxAlertTimes);
    }
    if (alertInterval) {
      res["AlertInterval"] = boost::any(*alertInterval);
    }
    if (detail) {
      res["Detail"] = boost::any(*detail);
    }
    if (alertUnit) {
      res["AlertUnit"] = boost::any(*alertUnit);
    }
    if (alertMethods) {
      res["AlertMethods"] = boost::any(*alertMethods);
    }
    if (alertTargets) {
      res["AlertTargets"] = boost::any(*alertTargets);
    }
    if (useFlag) {
      res["UseFlag"] = boost::any(*useFlag);
    }
    if (robotUrls) {
      res["RobotUrls"] = boost::any(*robotUrls);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RemindId") != m.end() && !m["RemindId"].empty()) {
      remindId = make_shared<long>(boost::any_cast<long>(m["RemindId"]));
    }
    if (m.find("RemindName") != m.end() && !m["RemindName"].empty()) {
      remindName = make_shared<string>(boost::any_cast<string>(m["RemindName"]));
    }
    if (m.find("DndEnd") != m.end() && !m["DndEnd"].empty()) {
      dndEnd = make_shared<string>(boost::any_cast<string>(m["DndEnd"]));
    }
    if (m.find("RemindUnit") != m.end() && !m["RemindUnit"].empty()) {
      remindUnit = make_shared<string>(boost::any_cast<string>(m["RemindUnit"]));
    }
    if (m.find("NodeIds") != m.end() && !m["NodeIds"].empty()) {
      nodeIds = make_shared<string>(boost::any_cast<string>(m["NodeIds"]));
    }
    if (m.find("BaselineIds") != m.end() && !m["BaselineIds"].empty()) {
      baselineIds = make_shared<string>(boost::any_cast<string>(m["BaselineIds"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("BizProcessIds") != m.end() && !m["BizProcessIds"].empty()) {
      bizProcessIds = make_shared<string>(boost::any_cast<string>(m["BizProcessIds"]));
    }
    if (m.find("RemindType") != m.end() && !m["RemindType"].empty()) {
      remindType = make_shared<string>(boost::any_cast<string>(m["RemindType"]));
    }
    if (m.find("MaxAlertTimes") != m.end() && !m["MaxAlertTimes"].empty()) {
      maxAlertTimes = make_shared<int>(boost::any_cast<int>(m["MaxAlertTimes"]));
    }
    if (m.find("AlertInterval") != m.end() && !m["AlertInterval"].empty()) {
      alertInterval = make_shared<int>(boost::any_cast<int>(m["AlertInterval"]));
    }
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      detail = make_shared<string>(boost::any_cast<string>(m["Detail"]));
    }
    if (m.find("AlertUnit") != m.end() && !m["AlertUnit"].empty()) {
      alertUnit = make_shared<string>(boost::any_cast<string>(m["AlertUnit"]));
    }
    if (m.find("AlertMethods") != m.end() && !m["AlertMethods"].empty()) {
      alertMethods = make_shared<string>(boost::any_cast<string>(m["AlertMethods"]));
    }
    if (m.find("AlertTargets") != m.end() && !m["AlertTargets"].empty()) {
      alertTargets = make_shared<string>(boost::any_cast<string>(m["AlertTargets"]));
    }
    if (m.find("UseFlag") != m.end() && !m["UseFlag"].empty()) {
      useFlag = make_shared<bool>(boost::any_cast<bool>(m["UseFlag"]));
    }
    if (m.find("RobotUrls") != m.end() && !m["RobotUrls"].empty()) {
      robotUrls = make_shared<string>(boost::any_cast<string>(m["RobotUrls"]));
    }
  }


  virtual ~UpdateRemindRequest() = default;
};
class UpdateRemindResponse : public Darabonba::Model {
public:
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> data{};

  UpdateRemindResponse() {}

  explicit UpdateRemindResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
  }


  virtual ~UpdateRemindResponse() = default;
};
class GetMetaColumnLineageRequest : public Darabonba::Model {
public:
  shared_ptr<string> columnGuid{};
  shared_ptr<string> direction{};
  shared_ptr<int> pageNum{};
  shared_ptr<int> pageSize{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> databaseName{};
  shared_ptr<string> tableName{};
  shared_ptr<string> columnName{};
  shared_ptr<string> dataSourceType{};

  GetMetaColumnLineageRequest() {}

  explicit GetMetaColumnLineageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!direction) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("direction is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnGuid) {
      res["ColumnGuid"] = boost::any(*columnGuid);
    }
    if (direction) {
      res["Direction"] = boost::any(*direction);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (dataSourceType) {
      res["DataSourceType"] = boost::any(*dataSourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnGuid") != m.end() && !m["ColumnGuid"].empty()) {
      columnGuid = make_shared<string>(boost::any_cast<string>(m["ColumnGuid"]));
    }
    if (m.find("Direction") != m.end() && !m["Direction"].empty()) {
      direction = make_shared<string>(boost::any_cast<string>(m["Direction"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<int>(boost::any_cast<int>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("DataSourceType") != m.end() && !m["DataSourceType"].empty()) {
      dataSourceType = make_shared<string>(boost::any_cast<string>(m["DataSourceType"]));
    }
  }


  virtual ~GetMetaColumnLineageRequest() = default;
};
class GetMetaColumnLineageResponseDataDataEntityList : public Darabonba::Model {
public:
  shared_ptr<string> columnName{};
  shared_ptr<string> columnGuid{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> databaseName{};
  shared_ptr<string> tableName{};

  GetMetaColumnLineageResponseDataDataEntityList() {}

  explicit GetMetaColumnLineageResponseDataDataEntityList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!columnName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("columnName is required.")));
    }
    if (!columnGuid) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("columnGuid is required.")));
    }
    if (!clusterId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("clusterId is required.")));
    }
    if (!databaseName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("databaseName is required.")));
    }
    if (!tableName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tableName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (columnGuid) {
      res["ColumnGuid"] = boost::any(*columnGuid);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("ColumnGuid") != m.end() && !m["ColumnGuid"].empty()) {
      columnGuid = make_shared<string>(boost::any_cast<string>(m["ColumnGuid"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
  }


  virtual ~GetMetaColumnLineageResponseDataDataEntityList() = default;
};
class GetMetaColumnLineageResponseData : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<int> pageNum{};
  shared_ptr<int> pageSize{};
  shared_ptr<vector<GetMetaColumnLineageResponseDataDataEntityList>> dataEntityList{};

  GetMetaColumnLineageResponseData() {}

  explicit GetMetaColumnLineageResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!totalCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("totalCount is required.")));
    }
    if (!pageNum) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNum is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!dataEntityList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dataEntityList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (dataEntityList) {
      vector<boost::any> temp1;
      for(auto item1:*dataEntityList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataEntityList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<int>(boost::any_cast<int>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("DataEntityList") != m.end() && !m["DataEntityList"].empty()) {
      if (typeid(vector<boost::any>) == m["DataEntityList"].type()) {
        vector<GetMetaColumnLineageResponseDataDataEntityList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataEntityList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMetaColumnLineageResponseDataDataEntityList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataEntityList = make_shared<vector<GetMetaColumnLineageResponseDataDataEntityList>>(expect1);
      }
    }
  }


  virtual ~GetMetaColumnLineageResponseData() = default;
};
class GetMetaColumnLineageResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<bool> success{};
  shared_ptr<GetMetaColumnLineageResponseData> data{};

  GetMetaColumnLineageResponse() {}

  explicit GetMetaColumnLineageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetMetaColumnLineageResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetMetaColumnLineageResponseData>(model1);
      }
    }
  }


  virtual ~GetMetaColumnLineageResponse() = default;
};
class UpdateBusinessRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<string> businessName{};
  shared_ptr<string> description{};
  shared_ptr<string> owner{};
  shared_ptr<long> businessId{};

  UpdateBusinessRequest() {}

  explicit UpdateBusinessRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!businessId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("businessId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (businessName) {
      res["BusinessName"] = boost::any(*businessName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (businessId) {
      res["BusinessId"] = boost::any(*businessId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("BusinessName") != m.end() && !m["BusinessName"].empty()) {
      businessName = make_shared<string>(boost::any_cast<string>(m["BusinessName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("BusinessId") != m.end() && !m["BusinessId"].empty()) {
      businessId = make_shared<long>(boost::any_cast<long>(m["BusinessId"]));
    }
  }


  virtual ~UpdateBusinessRequest() = default;
};
class UpdateBusinessResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};

  UpdateBusinessResponse() {}

  explicit UpdateBusinessResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
  }


  virtual ~UpdateBusinessResponse() = default;
};
class UpdateQualityRuleRequest : public Darabonba::Model {
public:
  shared_ptr<int> blockType{};
  shared_ptr<long> entityId{};
  shared_ptr<string> comment{};
  shared_ptr<int> checker{};
  shared_ptr<string> expectValue{};
  shared_ptr<long> id{};
  shared_ptr<string> trend{};
  shared_ptr<string> methodName{};
  shared_ptr<string> operator_{};
  shared_ptr<string> projectName{};
  shared_ptr<string> property{};
  shared_ptr<string> propertyType{};
  shared_ptr<int> ruleType{};
  shared_ptr<string> whereCondition{};
  shared_ptr<string> criticalThreshold{};
  shared_ptr<string> warningThreshold{};
  shared_ptr<int> templateId{};
  shared_ptr<string> ruleName{};
  shared_ptr<int> predictType{};

  UpdateQualityRuleRequest() {}

  explicit UpdateQualityRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!id) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("id is required.")));
    }
    if (!projectName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockType) {
      res["BlockType"] = boost::any(*blockType);
    }
    if (entityId) {
      res["EntityId"] = boost::any(*entityId);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (checker) {
      res["Checker"] = boost::any(*checker);
    }
    if (expectValue) {
      res["ExpectValue"] = boost::any(*expectValue);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (trend) {
      res["Trend"] = boost::any(*trend);
    }
    if (methodName) {
      res["MethodName"] = boost::any(*methodName);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (property) {
      res["Property"] = boost::any(*property);
    }
    if (propertyType) {
      res["PropertyType"] = boost::any(*propertyType);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    if (whereCondition) {
      res["WhereCondition"] = boost::any(*whereCondition);
    }
    if (criticalThreshold) {
      res["CriticalThreshold"] = boost::any(*criticalThreshold);
    }
    if (warningThreshold) {
      res["WarningThreshold"] = boost::any(*warningThreshold);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (predictType) {
      res["PredictType"] = boost::any(*predictType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockType") != m.end() && !m["BlockType"].empty()) {
      blockType = make_shared<int>(boost::any_cast<int>(m["BlockType"]));
    }
    if (m.find("EntityId") != m.end() && !m["EntityId"].empty()) {
      entityId = make_shared<long>(boost::any_cast<long>(m["EntityId"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Checker") != m.end() && !m["Checker"].empty()) {
      checker = make_shared<int>(boost::any_cast<int>(m["Checker"]));
    }
    if (m.find("ExpectValue") != m.end() && !m["ExpectValue"].empty()) {
      expectValue = make_shared<string>(boost::any_cast<string>(m["ExpectValue"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Trend") != m.end() && !m["Trend"].empty()) {
      trend = make_shared<string>(boost::any_cast<string>(m["Trend"]));
    }
    if (m.find("MethodName") != m.end() && !m["MethodName"].empty()) {
      methodName = make_shared<string>(boost::any_cast<string>(m["MethodName"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Property") != m.end() && !m["Property"].empty()) {
      property = make_shared<string>(boost::any_cast<string>(m["Property"]));
    }
    if (m.find("PropertyType") != m.end() && !m["PropertyType"].empty()) {
      propertyType = make_shared<string>(boost::any_cast<string>(m["PropertyType"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<int>(boost::any_cast<int>(m["RuleType"]));
    }
    if (m.find("WhereCondition") != m.end() && !m["WhereCondition"].empty()) {
      whereCondition = make_shared<string>(boost::any_cast<string>(m["WhereCondition"]));
    }
    if (m.find("CriticalThreshold") != m.end() && !m["CriticalThreshold"].empty()) {
      criticalThreshold = make_shared<string>(boost::any_cast<string>(m["CriticalThreshold"]));
    }
    if (m.find("WarningThreshold") != m.end() && !m["WarningThreshold"].empty()) {
      warningThreshold = make_shared<string>(boost::any_cast<string>(m["WarningThreshold"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<int>(boost::any_cast<int>(m["TemplateId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("PredictType") != m.end() && !m["PredictType"].empty()) {
      predictType = make_shared<int>(boost::any_cast<int>(m["PredictType"]));
    }
  }


  virtual ~UpdateQualityRuleRequest() = default;
};
class UpdateQualityRuleResponse : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<bool> data{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};

  UpdateQualityRuleResponse() {}

  explicit UpdateQualityRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateQualityRuleResponse() = default;
};
class DeleteQualityRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectName{};
  shared_ptr<long> ruleId{};

  DeleteQualityRuleRequest() {}

  explicit DeleteQualityRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectName is required.")));
    }
    if (!ruleId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
  }


  virtual ~DeleteQualityRuleRequest() = default;
};
class DeleteQualityRuleResponse : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<bool> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> success{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};

  DeleteQualityRuleResponse() {}

  explicit DeleteQualityRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteQualityRuleResponse() = default;
};
class SubmitFileRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<long> fileId{};
  shared_ptr<string> comment{};

  SubmitFileRequest() {}

  explicit SubmitFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!fileId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("fileId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
  }


  virtual ~SubmitFileRequest() = default;
};
class SubmitFileResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> data{};
  shared_ptr<int> httpStatusCode{};

  SubmitFileResponse() {}

  explicit SubmitFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
  }


  virtual ~SubmitFileResponse() = default;
};
class GetDataServiceApiRequest : public Darabonba::Model {
public:
  shared_ptr<long> tenantId{};
  shared_ptr<long> projectId{};
  shared_ptr<long> apiId{};

  GetDataServiceApiRequest() {}

  explicit GetDataServiceApiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!tenantId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tenantId is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!apiId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("apiId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<long>(boost::any_cast<long>(m["ApiId"]));
    }
  }


  virtual ~GetDataServiceApiRequest() = default;
};
class GetDataServiceApiResponseDataRegistrationDetailsRegistrationErrorCodes : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorSolution{};

  GetDataServiceApiResponseDataRegistrationDetailsRegistrationErrorCodes() {}

  explicit GetDataServiceApiResponseDataRegistrationDetailsRegistrationErrorCodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!errorSolution) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorSolution is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorSolution) {
      res["ErrorSolution"] = boost::any(*errorSolution);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorSolution") != m.end() && !m["ErrorSolution"].empty()) {
      errorSolution = make_shared<string>(boost::any_cast<string>(m["ErrorSolution"]));
    }
  }


  virtual ~GetDataServiceApiResponseDataRegistrationDetailsRegistrationErrorCodes() = default;
};
class GetDataServiceApiResponseDataRegistrationDetailsRegistrationRequestParameters : public Darabonba::Model {
public:
  shared_ptr<string> columnName{};
  shared_ptr<string> defaultValue{};
  shared_ptr<string> exampleValue{};
  shared_ptr<bool> isRequiredParameter{};
  shared_ptr<int> parameterDataType{};
  shared_ptr<string> parameterDescription{};
  shared_ptr<string> parameterName{};
  shared_ptr<int> parameterOperator{};
  shared_ptr<int> parameterPosition{};

  GetDataServiceApiResponseDataRegistrationDetailsRegistrationRequestParameters() {}

  explicit GetDataServiceApiResponseDataRegistrationDetailsRegistrationRequestParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!columnName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("columnName is required.")));
    }
    if (!defaultValue) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("defaultValue is required.")));
    }
    if (!exampleValue) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("exampleValue is required.")));
    }
    if (!isRequiredParameter) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("isRequiredParameter is required.")));
    }
    if (!parameterDataType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterDataType is required.")));
    }
    if (!parameterDescription) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterDescription is required.")));
    }
    if (!parameterName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterName is required.")));
    }
    if (!parameterOperator) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterOperator is required.")));
    }
    if (!parameterPosition) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterPosition is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (exampleValue) {
      res["ExampleValue"] = boost::any(*exampleValue);
    }
    if (isRequiredParameter) {
      res["IsRequiredParameter"] = boost::any(*isRequiredParameter);
    }
    if (parameterDataType) {
      res["ParameterDataType"] = boost::any(*parameterDataType);
    }
    if (parameterDescription) {
      res["ParameterDescription"] = boost::any(*parameterDescription);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (parameterOperator) {
      res["ParameterOperator"] = boost::any(*parameterOperator);
    }
    if (parameterPosition) {
      res["ParameterPosition"] = boost::any(*parameterPosition);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("ExampleValue") != m.end() && !m["ExampleValue"].empty()) {
      exampleValue = make_shared<string>(boost::any_cast<string>(m["ExampleValue"]));
    }
    if (m.find("IsRequiredParameter") != m.end() && !m["IsRequiredParameter"].empty()) {
      isRequiredParameter = make_shared<bool>(boost::any_cast<bool>(m["IsRequiredParameter"]));
    }
    if (m.find("ParameterDataType") != m.end() && !m["ParameterDataType"].empty()) {
      parameterDataType = make_shared<int>(boost::any_cast<int>(m["ParameterDataType"]));
    }
    if (m.find("ParameterDescription") != m.end() && !m["ParameterDescription"].empty()) {
      parameterDescription = make_shared<string>(boost::any_cast<string>(m["ParameterDescription"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ParameterOperator") != m.end() && !m["ParameterOperator"].empty()) {
      parameterOperator = make_shared<int>(boost::any_cast<int>(m["ParameterOperator"]));
    }
    if (m.find("ParameterPosition") != m.end() && !m["ParameterPosition"].empty()) {
      parameterPosition = make_shared<int>(boost::any_cast<int>(m["ParameterPosition"]));
    }
  }


  virtual ~GetDataServiceApiResponseDataRegistrationDetailsRegistrationRequestParameters() = default;
};
class GetDataServiceApiResponseDataRegistrationDetails : public Darabonba::Model {
public:
  shared_ptr<string> failedResultSample{};
  shared_ptr<int> serviceContentType{};
  shared_ptr<string> serviceHost{};
  shared_ptr<string> servicePath{};
  shared_ptr<string> serviceRequestBodyDescription{};
  shared_ptr<string> successfulResultSample{};
  shared_ptr<vector<GetDataServiceApiResponseDataRegistrationDetailsRegistrationErrorCodes>> registrationErrorCodes{};
  shared_ptr<vector<GetDataServiceApiResponseDataRegistrationDetailsRegistrationRequestParameters>> registrationRequestParameters{};

  GetDataServiceApiResponseDataRegistrationDetails() {}

  explicit GetDataServiceApiResponseDataRegistrationDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!failedResultSample) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("failedResultSample is required.")));
    }
    if (!serviceContentType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("serviceContentType is required.")));
    }
    if (!serviceHost) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("serviceHost is required.")));
    }
    if (!servicePath) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("servicePath is required.")));
    }
    if (!serviceRequestBodyDescription) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("serviceRequestBodyDescription is required.")));
    }
    if (!successfulResultSample) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("successfulResultSample is required.")));
    }
    if (!registrationErrorCodes) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("registrationErrorCodes is required.")));
    }
    if (!registrationRequestParameters) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("registrationRequestParameters is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failedResultSample) {
      res["FailedResultSample"] = boost::any(*failedResultSample);
    }
    if (serviceContentType) {
      res["ServiceContentType"] = boost::any(*serviceContentType);
    }
    if (serviceHost) {
      res["ServiceHost"] = boost::any(*serviceHost);
    }
    if (servicePath) {
      res["ServicePath"] = boost::any(*servicePath);
    }
    if (serviceRequestBodyDescription) {
      res["ServiceRequestBodyDescription"] = boost::any(*serviceRequestBodyDescription);
    }
    if (successfulResultSample) {
      res["SuccessfulResultSample"] = boost::any(*successfulResultSample);
    }
    if (registrationErrorCodes) {
      vector<boost::any> temp1;
      for(auto item1:*registrationErrorCodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RegistrationErrorCodes"] = boost::any(temp1);
    }
    if (registrationRequestParameters) {
      vector<boost::any> temp1;
      for(auto item1:*registrationRequestParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RegistrationRequestParameters"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailedResultSample") != m.end() && !m["FailedResultSample"].empty()) {
      failedResultSample = make_shared<string>(boost::any_cast<string>(m["FailedResultSample"]));
    }
    if (m.find("ServiceContentType") != m.end() && !m["ServiceContentType"].empty()) {
      serviceContentType = make_shared<int>(boost::any_cast<int>(m["ServiceContentType"]));
    }
    if (m.find("ServiceHost") != m.end() && !m["ServiceHost"].empty()) {
      serviceHost = make_shared<string>(boost::any_cast<string>(m["ServiceHost"]));
    }
    if (m.find("ServicePath") != m.end() && !m["ServicePath"].empty()) {
      servicePath = make_shared<string>(boost::any_cast<string>(m["ServicePath"]));
    }
    if (m.find("ServiceRequestBodyDescription") != m.end() && !m["ServiceRequestBodyDescription"].empty()) {
      serviceRequestBodyDescription = make_shared<string>(boost::any_cast<string>(m["ServiceRequestBodyDescription"]));
    }
    if (m.find("SuccessfulResultSample") != m.end() && !m["SuccessfulResultSample"].empty()) {
      successfulResultSample = make_shared<string>(boost::any_cast<string>(m["SuccessfulResultSample"]));
    }
    if (m.find("RegistrationErrorCodes") != m.end() && !m["RegistrationErrorCodes"].empty()) {
      if (typeid(vector<boost::any>) == m["RegistrationErrorCodes"].type()) {
        vector<GetDataServiceApiResponseDataRegistrationDetailsRegistrationErrorCodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RegistrationErrorCodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataServiceApiResponseDataRegistrationDetailsRegistrationErrorCodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        registrationErrorCodes = make_shared<vector<GetDataServiceApiResponseDataRegistrationDetailsRegistrationErrorCodes>>(expect1);
      }
    }
    if (m.find("RegistrationRequestParameters") != m.end() && !m["RegistrationRequestParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["RegistrationRequestParameters"].type()) {
        vector<GetDataServiceApiResponseDataRegistrationDetailsRegistrationRequestParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RegistrationRequestParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataServiceApiResponseDataRegistrationDetailsRegistrationRequestParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        registrationRequestParameters = make_shared<vector<GetDataServiceApiResponseDataRegistrationDetailsRegistrationRequestParameters>>(expect1);
      }
    }
  }


  virtual ~GetDataServiceApiResponseDataRegistrationDetails() = default;
};
class GetDataServiceApiResponseDataScriptDetailsScriptRequestParameters : public Darabonba::Model {
public:
  shared_ptr<string> columnName{};
  shared_ptr<string> defaultValue{};
  shared_ptr<string> exampleValue{};
  shared_ptr<bool> isRequiredParameter{};
  shared_ptr<int> parameterDataType{};
  shared_ptr<string> parameterDescription{};
  shared_ptr<string> parameterName{};
  shared_ptr<int> parameterOperator{};
  shared_ptr<int> parameterPosition{};

  GetDataServiceApiResponseDataScriptDetailsScriptRequestParameters() {}

  explicit GetDataServiceApiResponseDataScriptDetailsScriptRequestParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!columnName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("columnName is required.")));
    }
    if (!defaultValue) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("defaultValue is required.")));
    }
    if (!exampleValue) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("exampleValue is required.")));
    }
    if (!isRequiredParameter) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("isRequiredParameter is required.")));
    }
    if (!parameterDataType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterDataType is required.")));
    }
    if (!parameterDescription) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterDescription is required.")));
    }
    if (!parameterName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterName is required.")));
    }
    if (!parameterOperator) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterOperator is required.")));
    }
    if (!parameterPosition) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterPosition is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (exampleValue) {
      res["ExampleValue"] = boost::any(*exampleValue);
    }
    if (isRequiredParameter) {
      res["IsRequiredParameter"] = boost::any(*isRequiredParameter);
    }
    if (parameterDataType) {
      res["ParameterDataType"] = boost::any(*parameterDataType);
    }
    if (parameterDescription) {
      res["ParameterDescription"] = boost::any(*parameterDescription);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (parameterOperator) {
      res["ParameterOperator"] = boost::any(*parameterOperator);
    }
    if (parameterPosition) {
      res["ParameterPosition"] = boost::any(*parameterPosition);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("ExampleValue") != m.end() && !m["ExampleValue"].empty()) {
      exampleValue = make_shared<string>(boost::any_cast<string>(m["ExampleValue"]));
    }
    if (m.find("IsRequiredParameter") != m.end() && !m["IsRequiredParameter"].empty()) {
      isRequiredParameter = make_shared<bool>(boost::any_cast<bool>(m["IsRequiredParameter"]));
    }
    if (m.find("ParameterDataType") != m.end() && !m["ParameterDataType"].empty()) {
      parameterDataType = make_shared<int>(boost::any_cast<int>(m["ParameterDataType"]));
    }
    if (m.find("ParameterDescription") != m.end() && !m["ParameterDescription"].empty()) {
      parameterDescription = make_shared<string>(boost::any_cast<string>(m["ParameterDescription"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ParameterOperator") != m.end() && !m["ParameterOperator"].empty()) {
      parameterOperator = make_shared<int>(boost::any_cast<int>(m["ParameterOperator"]));
    }
    if (m.find("ParameterPosition") != m.end() && !m["ParameterPosition"].empty()) {
      parameterPosition = make_shared<int>(boost::any_cast<int>(m["ParameterPosition"]));
    }
  }


  virtual ~GetDataServiceApiResponseDataScriptDetailsScriptRequestParameters() = default;
};
class GetDataServiceApiResponseDataScriptDetailsScriptResponseParameters : public Darabonba::Model {
public:
  shared_ptr<string> columnName{};
  shared_ptr<string> exampleValue{};
  shared_ptr<int> parameterDataType{};
  shared_ptr<string> parameterDescription{};
  shared_ptr<string> parameterName{};

  GetDataServiceApiResponseDataScriptDetailsScriptResponseParameters() {}

  explicit GetDataServiceApiResponseDataScriptDetailsScriptResponseParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!columnName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("columnName is required.")));
    }
    if (!exampleValue) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("exampleValue is required.")));
    }
    if (!parameterDataType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterDataType is required.")));
    }
    if (!parameterDescription) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterDescription is required.")));
    }
    if (!parameterName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (exampleValue) {
      res["ExampleValue"] = boost::any(*exampleValue);
    }
    if (parameterDataType) {
      res["ParameterDataType"] = boost::any(*parameterDataType);
    }
    if (parameterDescription) {
      res["ParameterDescription"] = boost::any(*parameterDescription);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("ExampleValue") != m.end() && !m["ExampleValue"].empty()) {
      exampleValue = make_shared<string>(boost::any_cast<string>(m["ExampleValue"]));
    }
    if (m.find("ParameterDataType") != m.end() && !m["ParameterDataType"].empty()) {
      parameterDataType = make_shared<int>(boost::any_cast<int>(m["ParameterDataType"]));
    }
    if (m.find("ParameterDescription") != m.end() && !m["ParameterDescription"].empty()) {
      parameterDescription = make_shared<string>(boost::any_cast<string>(m["ParameterDescription"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
  }


  virtual ~GetDataServiceApiResponseDataScriptDetailsScriptResponseParameters() = default;
};
class GetDataServiceApiResponseDataScriptDetailsScriptConnection : public Darabonba::Model {
public:
  shared_ptr<long> connectionId{};
  shared_ptr<string> tableName{};

  GetDataServiceApiResponseDataScriptDetailsScriptConnection() {}

  explicit GetDataServiceApiResponseDataScriptDetailsScriptConnection(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!connectionId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("connectionId is required.")));
    }
    if (!tableName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tableName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connectionId) {
      res["ConnectionId"] = boost::any(*connectionId);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConnectionId") != m.end() && !m["ConnectionId"].empty()) {
      connectionId = make_shared<long>(boost::any_cast<long>(m["ConnectionId"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
  }


  virtual ~GetDataServiceApiResponseDataScriptDetailsScriptConnection() = default;
};
class GetDataServiceApiResponseDataScriptDetails : public Darabonba::Model {
public:
  shared_ptr<bool> isPagedResponse{};
  shared_ptr<string> script{};
  shared_ptr<vector<GetDataServiceApiResponseDataScriptDetailsScriptRequestParameters>> scriptRequestParameters{};
  shared_ptr<vector<GetDataServiceApiResponseDataScriptDetailsScriptResponseParameters>> scriptResponseParameters{};
  shared_ptr<GetDataServiceApiResponseDataScriptDetailsScriptConnection> scriptConnection{};

  GetDataServiceApiResponseDataScriptDetails() {}

  explicit GetDataServiceApiResponseDataScriptDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!isPagedResponse) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("isPagedResponse is required.")));
    }
    if (!script) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("script is required.")));
    }
    if (!scriptRequestParameters) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("scriptRequestParameters is required.")));
    }
    if (!scriptResponseParameters) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("scriptResponseParameters is required.")));
    }
    if (!scriptConnection) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("scriptConnection is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isPagedResponse) {
      res["IsPagedResponse"] = boost::any(*isPagedResponse);
    }
    if (script) {
      res["Script"] = boost::any(*script);
    }
    if (scriptRequestParameters) {
      vector<boost::any> temp1;
      for(auto item1:*scriptRequestParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScriptRequestParameters"] = boost::any(temp1);
    }
    if (scriptResponseParameters) {
      vector<boost::any> temp1;
      for(auto item1:*scriptResponseParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScriptResponseParameters"] = boost::any(temp1);
    }
    if (scriptConnection) {
      res["ScriptConnection"] = scriptConnection ? boost::any(scriptConnection->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsPagedResponse") != m.end() && !m["IsPagedResponse"].empty()) {
      isPagedResponse = make_shared<bool>(boost::any_cast<bool>(m["IsPagedResponse"]));
    }
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      script = make_shared<string>(boost::any_cast<string>(m["Script"]));
    }
    if (m.find("ScriptRequestParameters") != m.end() && !m["ScriptRequestParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["ScriptRequestParameters"].type()) {
        vector<GetDataServiceApiResponseDataScriptDetailsScriptRequestParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScriptRequestParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataServiceApiResponseDataScriptDetailsScriptRequestParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scriptRequestParameters = make_shared<vector<GetDataServiceApiResponseDataScriptDetailsScriptRequestParameters>>(expect1);
      }
    }
    if (m.find("ScriptResponseParameters") != m.end() && !m["ScriptResponseParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["ScriptResponseParameters"].type()) {
        vector<GetDataServiceApiResponseDataScriptDetailsScriptResponseParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScriptResponseParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataServiceApiResponseDataScriptDetailsScriptResponseParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scriptResponseParameters = make_shared<vector<GetDataServiceApiResponseDataScriptDetailsScriptResponseParameters>>(expect1);
      }
    }
    if (m.find("ScriptConnection") != m.end() && !m["ScriptConnection"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScriptConnection"].type()) {
        GetDataServiceApiResponseDataScriptDetailsScriptConnection model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScriptConnection"]));
        scriptConnection = make_shared<GetDataServiceApiResponseDataScriptDetailsScriptConnection>(model1);
      }
    }
  }


  virtual ~GetDataServiceApiResponseDataScriptDetails() = default;
};
class GetDataServiceApiResponseDataWizardDetailsWizardRequestParameters : public Darabonba::Model {
public:
  shared_ptr<string> columnName{};
  shared_ptr<string> defaultValue{};
  shared_ptr<string> exampleValue{};
  shared_ptr<bool> isRequiredParameter{};
  shared_ptr<int> parameterDataType{};
  shared_ptr<string> parameterDescription{};
  shared_ptr<string> parameterName{};
  shared_ptr<int> parameterOperator{};
  shared_ptr<int> parameterPosition{};

  GetDataServiceApiResponseDataWizardDetailsWizardRequestParameters() {}

  explicit GetDataServiceApiResponseDataWizardDetailsWizardRequestParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!columnName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("columnName is required.")));
    }
    if (!defaultValue) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("defaultValue is required.")));
    }
    if (!exampleValue) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("exampleValue is required.")));
    }
    if (!isRequiredParameter) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("isRequiredParameter is required.")));
    }
    if (!parameterDataType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterDataType is required.")));
    }
    if (!parameterDescription) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterDescription is required.")));
    }
    if (!parameterName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterName is required.")));
    }
    if (!parameterOperator) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterOperator is required.")));
    }
    if (!parameterPosition) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterPosition is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (exampleValue) {
      res["ExampleValue"] = boost::any(*exampleValue);
    }
    if (isRequiredParameter) {
      res["IsRequiredParameter"] = boost::any(*isRequiredParameter);
    }
    if (parameterDataType) {
      res["ParameterDataType"] = boost::any(*parameterDataType);
    }
    if (parameterDescription) {
      res["ParameterDescription"] = boost::any(*parameterDescription);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (parameterOperator) {
      res["ParameterOperator"] = boost::any(*parameterOperator);
    }
    if (parameterPosition) {
      res["ParameterPosition"] = boost::any(*parameterPosition);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("ExampleValue") != m.end() && !m["ExampleValue"].empty()) {
      exampleValue = make_shared<string>(boost::any_cast<string>(m["ExampleValue"]));
    }
    if (m.find("IsRequiredParameter") != m.end() && !m["IsRequiredParameter"].empty()) {
      isRequiredParameter = make_shared<bool>(boost::any_cast<bool>(m["IsRequiredParameter"]));
    }
    if (m.find("ParameterDataType") != m.end() && !m["ParameterDataType"].empty()) {
      parameterDataType = make_shared<int>(boost::any_cast<int>(m["ParameterDataType"]));
    }
    if (m.find("ParameterDescription") != m.end() && !m["ParameterDescription"].empty()) {
      parameterDescription = make_shared<string>(boost::any_cast<string>(m["ParameterDescription"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ParameterOperator") != m.end() && !m["ParameterOperator"].empty()) {
      parameterOperator = make_shared<int>(boost::any_cast<int>(m["ParameterOperator"]));
    }
    if (m.find("ParameterPosition") != m.end() && !m["ParameterPosition"].empty()) {
      parameterPosition = make_shared<int>(boost::any_cast<int>(m["ParameterPosition"]));
    }
  }


  virtual ~GetDataServiceApiResponseDataWizardDetailsWizardRequestParameters() = default;
};
class GetDataServiceApiResponseDataWizardDetailsWizardResponseParameters : public Darabonba::Model {
public:
  shared_ptr<string> columnName{};
  shared_ptr<string> exampleValue{};
  shared_ptr<int> parameterDataType{};
  shared_ptr<string> parameterDescription{};
  shared_ptr<string> parameterName{};

  GetDataServiceApiResponseDataWizardDetailsWizardResponseParameters() {}

  explicit GetDataServiceApiResponseDataWizardDetailsWizardResponseParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!columnName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("columnName is required.")));
    }
    if (!exampleValue) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("exampleValue is required.")));
    }
    if (!parameterDataType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterDataType is required.")));
    }
    if (!parameterDescription) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterDescription is required.")));
    }
    if (!parameterName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (exampleValue) {
      res["ExampleValue"] = boost::any(*exampleValue);
    }
    if (parameterDataType) {
      res["ParameterDataType"] = boost::any(*parameterDataType);
    }
    if (parameterDescription) {
      res["ParameterDescription"] = boost::any(*parameterDescription);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("ExampleValue") != m.end() && !m["ExampleValue"].empty()) {
      exampleValue = make_shared<string>(boost::any_cast<string>(m["ExampleValue"]));
    }
    if (m.find("ParameterDataType") != m.end() && !m["ParameterDataType"].empty()) {
      parameterDataType = make_shared<int>(boost::any_cast<int>(m["ParameterDataType"]));
    }
    if (m.find("ParameterDescription") != m.end() && !m["ParameterDescription"].empty()) {
      parameterDescription = make_shared<string>(boost::any_cast<string>(m["ParameterDescription"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
  }


  virtual ~GetDataServiceApiResponseDataWizardDetailsWizardResponseParameters() = default;
};
class GetDataServiceApiResponseDataWizardDetailsWizardConnection : public Darabonba::Model {
public:
  shared_ptr<long> connectionId{};
  shared_ptr<string> tableName{};

  GetDataServiceApiResponseDataWizardDetailsWizardConnection() {}

  explicit GetDataServiceApiResponseDataWizardDetailsWizardConnection(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!connectionId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("connectionId is required.")));
    }
    if (!tableName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tableName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connectionId) {
      res["ConnectionId"] = boost::any(*connectionId);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConnectionId") != m.end() && !m["ConnectionId"].empty()) {
      connectionId = make_shared<long>(boost::any_cast<long>(m["ConnectionId"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
  }


  virtual ~GetDataServiceApiResponseDataWizardDetailsWizardConnection() = default;
};
class GetDataServiceApiResponseDataWizardDetails : public Darabonba::Model {
public:
  shared_ptr<bool> isPagedResponse{};
  shared_ptr<vector<GetDataServiceApiResponseDataWizardDetailsWizardRequestParameters>> wizardRequestParameters{};
  shared_ptr<vector<GetDataServiceApiResponseDataWizardDetailsWizardResponseParameters>> wizardResponseParameters{};
  shared_ptr<GetDataServiceApiResponseDataWizardDetailsWizardConnection> wizardConnection{};

  GetDataServiceApiResponseDataWizardDetails() {}

  explicit GetDataServiceApiResponseDataWizardDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!isPagedResponse) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("isPagedResponse is required.")));
    }
    if (!wizardRequestParameters) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("wizardRequestParameters is required.")));
    }
    if (!wizardResponseParameters) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("wizardResponseParameters is required.")));
    }
    if (!wizardConnection) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("wizardConnection is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isPagedResponse) {
      res["IsPagedResponse"] = boost::any(*isPagedResponse);
    }
    if (wizardRequestParameters) {
      vector<boost::any> temp1;
      for(auto item1:*wizardRequestParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WizardRequestParameters"] = boost::any(temp1);
    }
    if (wizardResponseParameters) {
      vector<boost::any> temp1;
      for(auto item1:*wizardResponseParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WizardResponseParameters"] = boost::any(temp1);
    }
    if (wizardConnection) {
      res["WizardConnection"] = wizardConnection ? boost::any(wizardConnection->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsPagedResponse") != m.end() && !m["IsPagedResponse"].empty()) {
      isPagedResponse = make_shared<bool>(boost::any_cast<bool>(m["IsPagedResponse"]));
    }
    if (m.find("WizardRequestParameters") != m.end() && !m["WizardRequestParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["WizardRequestParameters"].type()) {
        vector<GetDataServiceApiResponseDataWizardDetailsWizardRequestParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WizardRequestParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataServiceApiResponseDataWizardDetailsWizardRequestParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        wizardRequestParameters = make_shared<vector<GetDataServiceApiResponseDataWizardDetailsWizardRequestParameters>>(expect1);
      }
    }
    if (m.find("WizardResponseParameters") != m.end() && !m["WizardResponseParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["WizardResponseParameters"].type()) {
        vector<GetDataServiceApiResponseDataWizardDetailsWizardResponseParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WizardResponseParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataServiceApiResponseDataWizardDetailsWizardResponseParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        wizardResponseParameters = make_shared<vector<GetDataServiceApiResponseDataWizardDetailsWizardResponseParameters>>(expect1);
      }
    }
    if (m.find("WizardConnection") != m.end() && !m["WizardConnection"].empty()) {
      if (typeid(map<string, boost::any>) == m["WizardConnection"].type()) {
        GetDataServiceApiResponseDataWizardDetailsWizardConnection model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WizardConnection"]));
        wizardConnection = make_shared<GetDataServiceApiResponseDataWizardDetailsWizardConnection>(model1);
      }
    }
  }


  virtual ~GetDataServiceApiResponseDataWizardDetails() = default;
};
class GetDataServiceApiResponseData : public Darabonba::Model {
public:
  shared_ptr<long> apiId{};
  shared_ptr<int> apiMode{};
  shared_ptr<string> apiName{};
  shared_ptr<string> apiPath{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> operatorId{};
  shared_ptr<long> projectId{};
  shared_ptr<int> requestMethod{};
  shared_ptr<int> responseContentType{};
  shared_ptr<int> status{};
  shared_ptr<long> tenantId{};
  shared_ptr<int> timeout{};
  shared_ptr<int> visibleRange{};
  shared_ptr<long> folderId{};
  shared_ptr<GetDataServiceApiResponseDataRegistrationDetails> registrationDetails{};
  shared_ptr<GetDataServiceApiResponseDataScriptDetails> scriptDetails{};
  shared_ptr<GetDataServiceApiResponseDataWizardDetails> wizardDetails{};
  shared_ptr<vector<int>> protocols{};

  GetDataServiceApiResponseData() {}

  explicit GetDataServiceApiResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!apiId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("apiId is required.")));
    }
    if (!apiMode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("apiMode is required.")));
    }
    if (!apiName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("apiName is required.")));
    }
    if (!apiPath) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("apiPath is required.")));
    }
    if (!createdTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("createdTime is required.")));
    }
    if (!creatorId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("creatorId is required.")));
    }
    if (!description) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("description is required.")));
    }
    if (!groupId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupId is required.")));
    }
    if (!modifiedTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("modifiedTime is required.")));
    }
    if (!operatorId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("operatorId is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!requestMethod) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestMethod is required.")));
    }
    if (!responseContentType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("responseContentType is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!tenantId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tenantId is required.")));
    }
    if (!timeout) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("timeout is required.")));
    }
    if (!visibleRange) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("visibleRange is required.")));
    }
    if (!folderId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("folderId is required.")));
    }
    if (!registrationDetails) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("registrationDetails is required.")));
    }
    if (!scriptDetails) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("scriptDetails is required.")));
    }
    if (!wizardDetails) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("wizardDetails is required.")));
    }
    if (!protocols) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("protocols is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiMode) {
      res["ApiMode"] = boost::any(*apiMode);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (apiPath) {
      res["ApiPath"] = boost::any(*apiPath);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (operatorId) {
      res["OperatorId"] = boost::any(*operatorId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (requestMethod) {
      res["RequestMethod"] = boost::any(*requestMethod);
    }
    if (responseContentType) {
      res["ResponseContentType"] = boost::any(*responseContentType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (visibleRange) {
      res["VisibleRange"] = boost::any(*visibleRange);
    }
    if (folderId) {
      res["FolderId"] = boost::any(*folderId);
    }
    if (registrationDetails) {
      res["RegistrationDetails"] = registrationDetails ? boost::any(registrationDetails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scriptDetails) {
      res["ScriptDetails"] = scriptDetails ? boost::any(scriptDetails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (wizardDetails) {
      res["WizardDetails"] = wizardDetails ? boost::any(wizardDetails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (protocols) {
      res["Protocols"] = boost::any(*protocols);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<long>(boost::any_cast<long>(m["ApiId"]));
    }
    if (m.find("ApiMode") != m.end() && !m["ApiMode"].empty()) {
      apiMode = make_shared<int>(boost::any_cast<int>(m["ApiMode"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("ApiPath") != m.end() && !m["ApiPath"].empty()) {
      apiPath = make_shared<string>(boost::any_cast<string>(m["ApiPath"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("OperatorId") != m.end() && !m["OperatorId"].empty()) {
      operatorId = make_shared<string>(boost::any_cast<string>(m["OperatorId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RequestMethod") != m.end() && !m["RequestMethod"].empty()) {
      requestMethod = make_shared<int>(boost::any_cast<int>(m["RequestMethod"]));
    }
    if (m.find("ResponseContentType") != m.end() && !m["ResponseContentType"].empty()) {
      responseContentType = make_shared<int>(boost::any_cast<int>(m["ResponseContentType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<int>(boost::any_cast<int>(m["Status"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<int>(boost::any_cast<int>(m["Timeout"]));
    }
    if (m.find("VisibleRange") != m.end() && !m["VisibleRange"].empty()) {
      visibleRange = make_shared<int>(boost::any_cast<int>(m["VisibleRange"]));
    }
    if (m.find("FolderId") != m.end() && !m["FolderId"].empty()) {
      folderId = make_shared<long>(boost::any_cast<long>(m["FolderId"]));
    }
    if (m.find("RegistrationDetails") != m.end() && !m["RegistrationDetails"].empty()) {
      if (typeid(map<string, boost::any>) == m["RegistrationDetails"].type()) {
        GetDataServiceApiResponseDataRegistrationDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RegistrationDetails"]));
        registrationDetails = make_shared<GetDataServiceApiResponseDataRegistrationDetails>(model1);
      }
    }
    if (m.find("ScriptDetails") != m.end() && !m["ScriptDetails"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScriptDetails"].type()) {
        GetDataServiceApiResponseDataScriptDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScriptDetails"]));
        scriptDetails = make_shared<GetDataServiceApiResponseDataScriptDetails>(model1);
      }
    }
    if (m.find("WizardDetails") != m.end() && !m["WizardDetails"].empty()) {
      if (typeid(map<string, boost::any>) == m["WizardDetails"].type()) {
        GetDataServiceApiResponseDataWizardDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WizardDetails"]));
        wizardDetails = make_shared<GetDataServiceApiResponseDataWizardDetails>(model1);
      }
    }
    if (m.find("Protocols") != m.end() && !m["Protocols"].empty()) {
      vector<int> toVec1;
      if (typeid(vector<boost::any>) == m["Protocols"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Protocols"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<int>(item));
        }
      }
      protocols = make_shared<vector<int>>(toVec1);
    }
  }


  virtual ~GetDataServiceApiResponseData() = default;
};
class GetDataServiceApiResponse : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<GetDataServiceApiResponseData> data{};

  GetDataServiceApiResponse() {}

  explicit GetDataServiceApiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetDataServiceApiResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetDataServiceApiResponseData>(model1);
      }
    }
  }


  virtual ~GetDataServiceApiResponse() = default;
};
class ListDataServiceApisRequest : public Darabonba::Model {
public:
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<long> tenantId{};
  shared_ptr<string> apiNameKeyword{};
  shared_ptr<string> apiPathKeyword{};
  shared_ptr<string> creatorId{};

  ListDataServiceApisRequest() {}

  explicit ListDataServiceApisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!tenantId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tenantId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (apiNameKeyword) {
      res["ApiNameKeyword"] = boost::any(*apiNameKeyword);
    }
    if (apiPathKeyword) {
      res["ApiPathKeyword"] = boost::any(*apiPathKeyword);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("ApiNameKeyword") != m.end() && !m["ApiNameKeyword"].empty()) {
      apiNameKeyword = make_shared<string>(boost::any_cast<string>(m["ApiNameKeyword"]));
    }
    if (m.find("ApiPathKeyword") != m.end() && !m["ApiPathKeyword"].empty()) {
      apiPathKeyword = make_shared<string>(boost::any_cast<string>(m["ApiPathKeyword"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
  }


  virtual ~ListDataServiceApisRequest() = default;
};
class ListDataServiceApisResponseDataApisRegistrationDetailsRegistrationErrorCodes : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorSolution{};

  ListDataServiceApisResponseDataApisRegistrationDetailsRegistrationErrorCodes() {}

  explicit ListDataServiceApisResponseDataApisRegistrationDetailsRegistrationErrorCodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!errorSolution) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorSolution is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorSolution) {
      res["ErrorSolution"] = boost::any(*errorSolution);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorSolution") != m.end() && !m["ErrorSolution"].empty()) {
      errorSolution = make_shared<string>(boost::any_cast<string>(m["ErrorSolution"]));
    }
  }


  virtual ~ListDataServiceApisResponseDataApisRegistrationDetailsRegistrationErrorCodes() = default;
};
class ListDataServiceApisResponseDataApisRegistrationDetailsRegistrationRequestParameters : public Darabonba::Model {
public:
  shared_ptr<string> columnName{};
  shared_ptr<string> defaultValue{};
  shared_ptr<string> exampleValue{};
  shared_ptr<bool> isRequiredParameter{};
  shared_ptr<int> parameterDataType{};
  shared_ptr<string> parameterDescription{};
  shared_ptr<string> parameterName{};
  shared_ptr<int> parameterOperator{};
  shared_ptr<int> parameterPosition{};

  ListDataServiceApisResponseDataApisRegistrationDetailsRegistrationRequestParameters() {}

  explicit ListDataServiceApisResponseDataApisRegistrationDetailsRegistrationRequestParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!columnName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("columnName is required.")));
    }
    if (!defaultValue) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("defaultValue is required.")));
    }
    if (!exampleValue) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("exampleValue is required.")));
    }
    if (!isRequiredParameter) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("isRequiredParameter is required.")));
    }
    if (!parameterDataType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterDataType is required.")));
    }
    if (!parameterDescription) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterDescription is required.")));
    }
    if (!parameterName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterName is required.")));
    }
    if (!parameterOperator) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterOperator is required.")));
    }
    if (!parameterPosition) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterPosition is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (exampleValue) {
      res["ExampleValue"] = boost::any(*exampleValue);
    }
    if (isRequiredParameter) {
      res["IsRequiredParameter"] = boost::any(*isRequiredParameter);
    }
    if (parameterDataType) {
      res["ParameterDataType"] = boost::any(*parameterDataType);
    }
    if (parameterDescription) {
      res["ParameterDescription"] = boost::any(*parameterDescription);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (parameterOperator) {
      res["ParameterOperator"] = boost::any(*parameterOperator);
    }
    if (parameterPosition) {
      res["ParameterPosition"] = boost::any(*parameterPosition);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("ExampleValue") != m.end() && !m["ExampleValue"].empty()) {
      exampleValue = make_shared<string>(boost::any_cast<string>(m["ExampleValue"]));
    }
    if (m.find("IsRequiredParameter") != m.end() && !m["IsRequiredParameter"].empty()) {
      isRequiredParameter = make_shared<bool>(boost::any_cast<bool>(m["IsRequiredParameter"]));
    }
    if (m.find("ParameterDataType") != m.end() && !m["ParameterDataType"].empty()) {
      parameterDataType = make_shared<int>(boost::any_cast<int>(m["ParameterDataType"]));
    }
    if (m.find("ParameterDescription") != m.end() && !m["ParameterDescription"].empty()) {
      parameterDescription = make_shared<string>(boost::any_cast<string>(m["ParameterDescription"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ParameterOperator") != m.end() && !m["ParameterOperator"].empty()) {
      parameterOperator = make_shared<int>(boost::any_cast<int>(m["ParameterOperator"]));
    }
    if (m.find("ParameterPosition") != m.end() && !m["ParameterPosition"].empty()) {
      parameterPosition = make_shared<int>(boost::any_cast<int>(m["ParameterPosition"]));
    }
  }


  virtual ~ListDataServiceApisResponseDataApisRegistrationDetailsRegistrationRequestParameters() = default;
};
class ListDataServiceApisResponseDataApisRegistrationDetails : public Darabonba::Model {
public:
  shared_ptr<string> failedResultSample{};
  shared_ptr<int> serviceContentType{};
  shared_ptr<string> serviceHost{};
  shared_ptr<string> servicePath{};
  shared_ptr<string> serviceRequestBodyDescription{};
  shared_ptr<string> successfulResultSample{};
  shared_ptr<vector<ListDataServiceApisResponseDataApisRegistrationDetailsRegistrationErrorCodes>> registrationErrorCodes{};
  shared_ptr<vector<ListDataServiceApisResponseDataApisRegistrationDetailsRegistrationRequestParameters>> registrationRequestParameters{};

  ListDataServiceApisResponseDataApisRegistrationDetails() {}

  explicit ListDataServiceApisResponseDataApisRegistrationDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!failedResultSample) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("failedResultSample is required.")));
    }
    if (!serviceContentType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("serviceContentType is required.")));
    }
    if (!serviceHost) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("serviceHost is required.")));
    }
    if (!servicePath) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("servicePath is required.")));
    }
    if (!serviceRequestBodyDescription) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("serviceRequestBodyDescription is required.")));
    }
    if (!successfulResultSample) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("successfulResultSample is required.")));
    }
    if (!registrationErrorCodes) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("registrationErrorCodes is required.")));
    }
    if (!registrationRequestParameters) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("registrationRequestParameters is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failedResultSample) {
      res["FailedResultSample"] = boost::any(*failedResultSample);
    }
    if (serviceContentType) {
      res["ServiceContentType"] = boost::any(*serviceContentType);
    }
    if (serviceHost) {
      res["ServiceHost"] = boost::any(*serviceHost);
    }
    if (servicePath) {
      res["ServicePath"] = boost::any(*servicePath);
    }
    if (serviceRequestBodyDescription) {
      res["ServiceRequestBodyDescription"] = boost::any(*serviceRequestBodyDescription);
    }
    if (successfulResultSample) {
      res["SuccessfulResultSample"] = boost::any(*successfulResultSample);
    }
    if (registrationErrorCodes) {
      vector<boost::any> temp1;
      for(auto item1:*registrationErrorCodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RegistrationErrorCodes"] = boost::any(temp1);
    }
    if (registrationRequestParameters) {
      vector<boost::any> temp1;
      for(auto item1:*registrationRequestParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RegistrationRequestParameters"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailedResultSample") != m.end() && !m["FailedResultSample"].empty()) {
      failedResultSample = make_shared<string>(boost::any_cast<string>(m["FailedResultSample"]));
    }
    if (m.find("ServiceContentType") != m.end() && !m["ServiceContentType"].empty()) {
      serviceContentType = make_shared<int>(boost::any_cast<int>(m["ServiceContentType"]));
    }
    if (m.find("ServiceHost") != m.end() && !m["ServiceHost"].empty()) {
      serviceHost = make_shared<string>(boost::any_cast<string>(m["ServiceHost"]));
    }
    if (m.find("ServicePath") != m.end() && !m["ServicePath"].empty()) {
      servicePath = make_shared<string>(boost::any_cast<string>(m["ServicePath"]));
    }
    if (m.find("ServiceRequestBodyDescription") != m.end() && !m["ServiceRequestBodyDescription"].empty()) {
      serviceRequestBodyDescription = make_shared<string>(boost::any_cast<string>(m["ServiceRequestBodyDescription"]));
    }
    if (m.find("SuccessfulResultSample") != m.end() && !m["SuccessfulResultSample"].empty()) {
      successfulResultSample = make_shared<string>(boost::any_cast<string>(m["SuccessfulResultSample"]));
    }
    if (m.find("RegistrationErrorCodes") != m.end() && !m["RegistrationErrorCodes"].empty()) {
      if (typeid(vector<boost::any>) == m["RegistrationErrorCodes"].type()) {
        vector<ListDataServiceApisResponseDataApisRegistrationDetailsRegistrationErrorCodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RegistrationErrorCodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataServiceApisResponseDataApisRegistrationDetailsRegistrationErrorCodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        registrationErrorCodes = make_shared<vector<ListDataServiceApisResponseDataApisRegistrationDetailsRegistrationErrorCodes>>(expect1);
      }
    }
    if (m.find("RegistrationRequestParameters") != m.end() && !m["RegistrationRequestParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["RegistrationRequestParameters"].type()) {
        vector<ListDataServiceApisResponseDataApisRegistrationDetailsRegistrationRequestParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RegistrationRequestParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataServiceApisResponseDataApisRegistrationDetailsRegistrationRequestParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        registrationRequestParameters = make_shared<vector<ListDataServiceApisResponseDataApisRegistrationDetailsRegistrationRequestParameters>>(expect1);
      }
    }
  }


  virtual ~ListDataServiceApisResponseDataApisRegistrationDetails() = default;
};
class ListDataServiceApisResponseDataApisScriptDetailsScriptRequestParameters : public Darabonba::Model {
public:
  shared_ptr<string> columnName{};
  shared_ptr<string> defaultValue{};
  shared_ptr<string> exampleValue{};
  shared_ptr<bool> isRequiredParameter{};
  shared_ptr<int> parameterDataType{};
  shared_ptr<string> parameterDescription{};
  shared_ptr<string> parameterName{};
  shared_ptr<int> parameterOperator{};
  shared_ptr<int> parameterPosition{};

  ListDataServiceApisResponseDataApisScriptDetailsScriptRequestParameters() {}

  explicit ListDataServiceApisResponseDataApisScriptDetailsScriptRequestParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!columnName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("columnName is required.")));
    }
    if (!defaultValue) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("defaultValue is required.")));
    }
    if (!exampleValue) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("exampleValue is required.")));
    }
    if (!isRequiredParameter) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("isRequiredParameter is required.")));
    }
    if (!parameterDataType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterDataType is required.")));
    }
    if (!parameterDescription) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterDescription is required.")));
    }
    if (!parameterName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterName is required.")));
    }
    if (!parameterOperator) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterOperator is required.")));
    }
    if (!parameterPosition) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterPosition is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (exampleValue) {
      res["ExampleValue"] = boost::any(*exampleValue);
    }
    if (isRequiredParameter) {
      res["IsRequiredParameter"] = boost::any(*isRequiredParameter);
    }
    if (parameterDataType) {
      res["ParameterDataType"] = boost::any(*parameterDataType);
    }
    if (parameterDescription) {
      res["ParameterDescription"] = boost::any(*parameterDescription);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (parameterOperator) {
      res["ParameterOperator"] = boost::any(*parameterOperator);
    }
    if (parameterPosition) {
      res["ParameterPosition"] = boost::any(*parameterPosition);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("ExampleValue") != m.end() && !m["ExampleValue"].empty()) {
      exampleValue = make_shared<string>(boost::any_cast<string>(m["ExampleValue"]));
    }
    if (m.find("IsRequiredParameter") != m.end() && !m["IsRequiredParameter"].empty()) {
      isRequiredParameter = make_shared<bool>(boost::any_cast<bool>(m["IsRequiredParameter"]));
    }
    if (m.find("ParameterDataType") != m.end() && !m["ParameterDataType"].empty()) {
      parameterDataType = make_shared<int>(boost::any_cast<int>(m["ParameterDataType"]));
    }
    if (m.find("ParameterDescription") != m.end() && !m["ParameterDescription"].empty()) {
      parameterDescription = make_shared<string>(boost::any_cast<string>(m["ParameterDescription"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ParameterOperator") != m.end() && !m["ParameterOperator"].empty()) {
      parameterOperator = make_shared<int>(boost::any_cast<int>(m["ParameterOperator"]));
    }
    if (m.find("ParameterPosition") != m.end() && !m["ParameterPosition"].empty()) {
      parameterPosition = make_shared<int>(boost::any_cast<int>(m["ParameterPosition"]));
    }
  }


  virtual ~ListDataServiceApisResponseDataApisScriptDetailsScriptRequestParameters() = default;
};
class ListDataServiceApisResponseDataApisScriptDetailsScriptResponseParameters : public Darabonba::Model {
public:
  shared_ptr<string> columnName{};
  shared_ptr<string> exampleValue{};
  shared_ptr<int> parameterDataType{};
  shared_ptr<string> parameterDescription{};
  shared_ptr<string> parameterName{};

  ListDataServiceApisResponseDataApisScriptDetailsScriptResponseParameters() {}

  explicit ListDataServiceApisResponseDataApisScriptDetailsScriptResponseParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!columnName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("columnName is required.")));
    }
    if (!exampleValue) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("exampleValue is required.")));
    }
    if (!parameterDataType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterDataType is required.")));
    }
    if (!parameterDescription) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterDescription is required.")));
    }
    if (!parameterName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (exampleValue) {
      res["ExampleValue"] = boost::any(*exampleValue);
    }
    if (parameterDataType) {
      res["ParameterDataType"] = boost::any(*parameterDataType);
    }
    if (parameterDescription) {
      res["ParameterDescription"] = boost::any(*parameterDescription);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("ExampleValue") != m.end() && !m["ExampleValue"].empty()) {
      exampleValue = make_shared<string>(boost::any_cast<string>(m["ExampleValue"]));
    }
    if (m.find("ParameterDataType") != m.end() && !m["ParameterDataType"].empty()) {
      parameterDataType = make_shared<int>(boost::any_cast<int>(m["ParameterDataType"]));
    }
    if (m.find("ParameterDescription") != m.end() && !m["ParameterDescription"].empty()) {
      parameterDescription = make_shared<string>(boost::any_cast<string>(m["ParameterDescription"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
  }


  virtual ~ListDataServiceApisResponseDataApisScriptDetailsScriptResponseParameters() = default;
};
class ListDataServiceApisResponseDataApisScriptDetailsScriptConnection : public Darabonba::Model {
public:
  shared_ptr<long> connectionId{};
  shared_ptr<string> tableName{};

  ListDataServiceApisResponseDataApisScriptDetailsScriptConnection() {}

  explicit ListDataServiceApisResponseDataApisScriptDetailsScriptConnection(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!connectionId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("connectionId is required.")));
    }
    if (!tableName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tableName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connectionId) {
      res["ConnectionId"] = boost::any(*connectionId);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConnectionId") != m.end() && !m["ConnectionId"].empty()) {
      connectionId = make_shared<long>(boost::any_cast<long>(m["ConnectionId"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
  }


  virtual ~ListDataServiceApisResponseDataApisScriptDetailsScriptConnection() = default;
};
class ListDataServiceApisResponseDataApisScriptDetails : public Darabonba::Model {
public:
  shared_ptr<bool> isPagedResponse{};
  shared_ptr<string> script{};
  shared_ptr<vector<ListDataServiceApisResponseDataApisScriptDetailsScriptRequestParameters>> scriptRequestParameters{};
  shared_ptr<vector<ListDataServiceApisResponseDataApisScriptDetailsScriptResponseParameters>> scriptResponseParameters{};
  shared_ptr<ListDataServiceApisResponseDataApisScriptDetailsScriptConnection> scriptConnection{};

  ListDataServiceApisResponseDataApisScriptDetails() {}

  explicit ListDataServiceApisResponseDataApisScriptDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!isPagedResponse) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("isPagedResponse is required.")));
    }
    if (!script) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("script is required.")));
    }
    if (!scriptRequestParameters) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("scriptRequestParameters is required.")));
    }
    if (!scriptResponseParameters) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("scriptResponseParameters is required.")));
    }
    if (!scriptConnection) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("scriptConnection is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isPagedResponse) {
      res["IsPagedResponse"] = boost::any(*isPagedResponse);
    }
    if (script) {
      res["Script"] = boost::any(*script);
    }
    if (scriptRequestParameters) {
      vector<boost::any> temp1;
      for(auto item1:*scriptRequestParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScriptRequestParameters"] = boost::any(temp1);
    }
    if (scriptResponseParameters) {
      vector<boost::any> temp1;
      for(auto item1:*scriptResponseParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScriptResponseParameters"] = boost::any(temp1);
    }
    if (scriptConnection) {
      res["ScriptConnection"] = scriptConnection ? boost::any(scriptConnection->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsPagedResponse") != m.end() && !m["IsPagedResponse"].empty()) {
      isPagedResponse = make_shared<bool>(boost::any_cast<bool>(m["IsPagedResponse"]));
    }
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      script = make_shared<string>(boost::any_cast<string>(m["Script"]));
    }
    if (m.find("ScriptRequestParameters") != m.end() && !m["ScriptRequestParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["ScriptRequestParameters"].type()) {
        vector<ListDataServiceApisResponseDataApisScriptDetailsScriptRequestParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScriptRequestParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataServiceApisResponseDataApisScriptDetailsScriptRequestParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scriptRequestParameters = make_shared<vector<ListDataServiceApisResponseDataApisScriptDetailsScriptRequestParameters>>(expect1);
      }
    }
    if (m.find("ScriptResponseParameters") != m.end() && !m["ScriptResponseParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["ScriptResponseParameters"].type()) {
        vector<ListDataServiceApisResponseDataApisScriptDetailsScriptResponseParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScriptResponseParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataServiceApisResponseDataApisScriptDetailsScriptResponseParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scriptResponseParameters = make_shared<vector<ListDataServiceApisResponseDataApisScriptDetailsScriptResponseParameters>>(expect1);
      }
    }
    if (m.find("ScriptConnection") != m.end() && !m["ScriptConnection"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScriptConnection"].type()) {
        ListDataServiceApisResponseDataApisScriptDetailsScriptConnection model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScriptConnection"]));
        scriptConnection = make_shared<ListDataServiceApisResponseDataApisScriptDetailsScriptConnection>(model1);
      }
    }
  }


  virtual ~ListDataServiceApisResponseDataApisScriptDetails() = default;
};
class ListDataServiceApisResponseDataApisWizardDetailsWizardRequestParameters : public Darabonba::Model {
public:
  shared_ptr<string> columnName{};
  shared_ptr<string> defaultValue{};
  shared_ptr<string> exampleValue{};
  shared_ptr<bool> isRequiredParameter{};
  shared_ptr<int> parameterDataType{};
  shared_ptr<string> parameterDescription{};
  shared_ptr<string> parameterName{};
  shared_ptr<int> parameterOperator{};
  shared_ptr<int> parameterPosition{};

  ListDataServiceApisResponseDataApisWizardDetailsWizardRequestParameters() {}

  explicit ListDataServiceApisResponseDataApisWizardDetailsWizardRequestParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!columnName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("columnName is required.")));
    }
    if (!defaultValue) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("defaultValue is required.")));
    }
    if (!exampleValue) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("exampleValue is required.")));
    }
    if (!isRequiredParameter) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("isRequiredParameter is required.")));
    }
    if (!parameterDataType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterDataType is required.")));
    }
    if (!parameterDescription) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterDescription is required.")));
    }
    if (!parameterName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterName is required.")));
    }
    if (!parameterOperator) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterOperator is required.")));
    }
    if (!parameterPosition) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterPosition is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (exampleValue) {
      res["ExampleValue"] = boost::any(*exampleValue);
    }
    if (isRequiredParameter) {
      res["IsRequiredParameter"] = boost::any(*isRequiredParameter);
    }
    if (parameterDataType) {
      res["ParameterDataType"] = boost::any(*parameterDataType);
    }
    if (parameterDescription) {
      res["ParameterDescription"] = boost::any(*parameterDescription);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (parameterOperator) {
      res["ParameterOperator"] = boost::any(*parameterOperator);
    }
    if (parameterPosition) {
      res["ParameterPosition"] = boost::any(*parameterPosition);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("ExampleValue") != m.end() && !m["ExampleValue"].empty()) {
      exampleValue = make_shared<string>(boost::any_cast<string>(m["ExampleValue"]));
    }
    if (m.find("IsRequiredParameter") != m.end() && !m["IsRequiredParameter"].empty()) {
      isRequiredParameter = make_shared<bool>(boost::any_cast<bool>(m["IsRequiredParameter"]));
    }
    if (m.find("ParameterDataType") != m.end() && !m["ParameterDataType"].empty()) {
      parameterDataType = make_shared<int>(boost::any_cast<int>(m["ParameterDataType"]));
    }
    if (m.find("ParameterDescription") != m.end() && !m["ParameterDescription"].empty()) {
      parameterDescription = make_shared<string>(boost::any_cast<string>(m["ParameterDescription"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ParameterOperator") != m.end() && !m["ParameterOperator"].empty()) {
      parameterOperator = make_shared<int>(boost::any_cast<int>(m["ParameterOperator"]));
    }
    if (m.find("ParameterPosition") != m.end() && !m["ParameterPosition"].empty()) {
      parameterPosition = make_shared<int>(boost::any_cast<int>(m["ParameterPosition"]));
    }
  }


  virtual ~ListDataServiceApisResponseDataApisWizardDetailsWizardRequestParameters() = default;
};
class ListDataServiceApisResponseDataApisWizardDetailsWizardResponseParameters : public Darabonba::Model {
public:
  shared_ptr<string> columnName{};
  shared_ptr<string> exampleValue{};
  shared_ptr<int> parameterDataType{};
  shared_ptr<string> parameterDescription{};
  shared_ptr<string> parameterName{};

  ListDataServiceApisResponseDataApisWizardDetailsWizardResponseParameters() {}

  explicit ListDataServiceApisResponseDataApisWizardDetailsWizardResponseParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!columnName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("columnName is required.")));
    }
    if (!exampleValue) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("exampleValue is required.")));
    }
    if (!parameterDataType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterDataType is required.")));
    }
    if (!parameterDescription) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterDescription is required.")));
    }
    if (!parameterName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (exampleValue) {
      res["ExampleValue"] = boost::any(*exampleValue);
    }
    if (parameterDataType) {
      res["ParameterDataType"] = boost::any(*parameterDataType);
    }
    if (parameterDescription) {
      res["ParameterDescription"] = boost::any(*parameterDescription);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("ExampleValue") != m.end() && !m["ExampleValue"].empty()) {
      exampleValue = make_shared<string>(boost::any_cast<string>(m["ExampleValue"]));
    }
    if (m.find("ParameterDataType") != m.end() && !m["ParameterDataType"].empty()) {
      parameterDataType = make_shared<int>(boost::any_cast<int>(m["ParameterDataType"]));
    }
    if (m.find("ParameterDescription") != m.end() && !m["ParameterDescription"].empty()) {
      parameterDescription = make_shared<string>(boost::any_cast<string>(m["ParameterDescription"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
  }


  virtual ~ListDataServiceApisResponseDataApisWizardDetailsWizardResponseParameters() = default;
};
class ListDataServiceApisResponseDataApisWizardDetailsWizardConnection : public Darabonba::Model {
public:
  shared_ptr<long> connectionId{};
  shared_ptr<string> tableName{};

  ListDataServiceApisResponseDataApisWizardDetailsWizardConnection() {}

  explicit ListDataServiceApisResponseDataApisWizardDetailsWizardConnection(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!connectionId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("connectionId is required.")));
    }
    if (!tableName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tableName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connectionId) {
      res["ConnectionId"] = boost::any(*connectionId);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConnectionId") != m.end() && !m["ConnectionId"].empty()) {
      connectionId = make_shared<long>(boost::any_cast<long>(m["ConnectionId"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
  }


  virtual ~ListDataServiceApisResponseDataApisWizardDetailsWizardConnection() = default;
};
class ListDataServiceApisResponseDataApisWizardDetails : public Darabonba::Model {
public:
  shared_ptr<bool> isPagedResponse{};
  shared_ptr<vector<ListDataServiceApisResponseDataApisWizardDetailsWizardRequestParameters>> wizardRequestParameters{};
  shared_ptr<vector<ListDataServiceApisResponseDataApisWizardDetailsWizardResponseParameters>> wizardResponseParameters{};
  shared_ptr<ListDataServiceApisResponseDataApisWizardDetailsWizardConnection> wizardConnection{};

  ListDataServiceApisResponseDataApisWizardDetails() {}

  explicit ListDataServiceApisResponseDataApisWizardDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!isPagedResponse) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("isPagedResponse is required.")));
    }
    if (!wizardRequestParameters) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("wizardRequestParameters is required.")));
    }
    if (!wizardResponseParameters) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("wizardResponseParameters is required.")));
    }
    if (!wizardConnection) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("wizardConnection is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isPagedResponse) {
      res["IsPagedResponse"] = boost::any(*isPagedResponse);
    }
    if (wizardRequestParameters) {
      vector<boost::any> temp1;
      for(auto item1:*wizardRequestParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WizardRequestParameters"] = boost::any(temp1);
    }
    if (wizardResponseParameters) {
      vector<boost::any> temp1;
      for(auto item1:*wizardResponseParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WizardResponseParameters"] = boost::any(temp1);
    }
    if (wizardConnection) {
      res["WizardConnection"] = wizardConnection ? boost::any(wizardConnection->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsPagedResponse") != m.end() && !m["IsPagedResponse"].empty()) {
      isPagedResponse = make_shared<bool>(boost::any_cast<bool>(m["IsPagedResponse"]));
    }
    if (m.find("WizardRequestParameters") != m.end() && !m["WizardRequestParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["WizardRequestParameters"].type()) {
        vector<ListDataServiceApisResponseDataApisWizardDetailsWizardRequestParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WizardRequestParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataServiceApisResponseDataApisWizardDetailsWizardRequestParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        wizardRequestParameters = make_shared<vector<ListDataServiceApisResponseDataApisWizardDetailsWizardRequestParameters>>(expect1);
      }
    }
    if (m.find("WizardResponseParameters") != m.end() && !m["WizardResponseParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["WizardResponseParameters"].type()) {
        vector<ListDataServiceApisResponseDataApisWizardDetailsWizardResponseParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WizardResponseParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataServiceApisResponseDataApisWizardDetailsWizardResponseParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        wizardResponseParameters = make_shared<vector<ListDataServiceApisResponseDataApisWizardDetailsWizardResponseParameters>>(expect1);
      }
    }
    if (m.find("WizardConnection") != m.end() && !m["WizardConnection"].empty()) {
      if (typeid(map<string, boost::any>) == m["WizardConnection"].type()) {
        ListDataServiceApisResponseDataApisWizardDetailsWizardConnection model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WizardConnection"]));
        wizardConnection = make_shared<ListDataServiceApisResponseDataApisWizardDetailsWizardConnection>(model1);
      }
    }
  }


  virtual ~ListDataServiceApisResponseDataApisWizardDetails() = default;
};
class ListDataServiceApisResponseDataApis : public Darabonba::Model {
public:
  shared_ptr<long> apiId{};
  shared_ptr<int> apiMode{};
  shared_ptr<string> apiName{};
  shared_ptr<string> apiPath{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> operatorId{};
  shared_ptr<long> projectId{};
  shared_ptr<int> requestMethod{};
  shared_ptr<int> responseContentType{};
  shared_ptr<int> status{};
  shared_ptr<long> tenantId{};
  shared_ptr<int> timeout{};
  shared_ptr<int> visibleRange{};
  shared_ptr<long> folderId{};
  shared_ptr<ListDataServiceApisResponseDataApisRegistrationDetails> registrationDetails{};
  shared_ptr<ListDataServiceApisResponseDataApisScriptDetails> scriptDetails{};
  shared_ptr<ListDataServiceApisResponseDataApisWizardDetails> wizardDetails{};
  shared_ptr<vector<int>> protocols{};

  ListDataServiceApisResponseDataApis() {}

  explicit ListDataServiceApisResponseDataApis(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!apiId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("apiId is required.")));
    }
    if (!apiMode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("apiMode is required.")));
    }
    if (!apiName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("apiName is required.")));
    }
    if (!apiPath) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("apiPath is required.")));
    }
    if (!createdTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("createdTime is required.")));
    }
    if (!creatorId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("creatorId is required.")));
    }
    if (!description) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("description is required.")));
    }
    if (!groupId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupId is required.")));
    }
    if (!modifiedTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("modifiedTime is required.")));
    }
    if (!operatorId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("operatorId is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!requestMethod) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestMethod is required.")));
    }
    if (!responseContentType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("responseContentType is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!tenantId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tenantId is required.")));
    }
    if (!timeout) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("timeout is required.")));
    }
    if (!visibleRange) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("visibleRange is required.")));
    }
    if (!folderId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("folderId is required.")));
    }
    if (!registrationDetails) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("registrationDetails is required.")));
    }
    if (!scriptDetails) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("scriptDetails is required.")));
    }
    if (!wizardDetails) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("wizardDetails is required.")));
    }
    if (!protocols) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("protocols is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiMode) {
      res["ApiMode"] = boost::any(*apiMode);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (apiPath) {
      res["ApiPath"] = boost::any(*apiPath);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (operatorId) {
      res["OperatorId"] = boost::any(*operatorId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (requestMethod) {
      res["RequestMethod"] = boost::any(*requestMethod);
    }
    if (responseContentType) {
      res["ResponseContentType"] = boost::any(*responseContentType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (visibleRange) {
      res["VisibleRange"] = boost::any(*visibleRange);
    }
    if (folderId) {
      res["FolderId"] = boost::any(*folderId);
    }
    if (registrationDetails) {
      res["RegistrationDetails"] = registrationDetails ? boost::any(registrationDetails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scriptDetails) {
      res["ScriptDetails"] = scriptDetails ? boost::any(scriptDetails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (wizardDetails) {
      res["WizardDetails"] = wizardDetails ? boost::any(wizardDetails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (protocols) {
      res["Protocols"] = boost::any(*protocols);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<long>(boost::any_cast<long>(m["ApiId"]));
    }
    if (m.find("ApiMode") != m.end() && !m["ApiMode"].empty()) {
      apiMode = make_shared<int>(boost::any_cast<int>(m["ApiMode"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("ApiPath") != m.end() && !m["ApiPath"].empty()) {
      apiPath = make_shared<string>(boost::any_cast<string>(m["ApiPath"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("OperatorId") != m.end() && !m["OperatorId"].empty()) {
      operatorId = make_shared<string>(boost::any_cast<string>(m["OperatorId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RequestMethod") != m.end() && !m["RequestMethod"].empty()) {
      requestMethod = make_shared<int>(boost::any_cast<int>(m["RequestMethod"]));
    }
    if (m.find("ResponseContentType") != m.end() && !m["ResponseContentType"].empty()) {
      responseContentType = make_shared<int>(boost::any_cast<int>(m["ResponseContentType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<int>(boost::any_cast<int>(m["Status"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<int>(boost::any_cast<int>(m["Timeout"]));
    }
    if (m.find("VisibleRange") != m.end() && !m["VisibleRange"].empty()) {
      visibleRange = make_shared<int>(boost::any_cast<int>(m["VisibleRange"]));
    }
    if (m.find("FolderId") != m.end() && !m["FolderId"].empty()) {
      folderId = make_shared<long>(boost::any_cast<long>(m["FolderId"]));
    }
    if (m.find("RegistrationDetails") != m.end() && !m["RegistrationDetails"].empty()) {
      if (typeid(map<string, boost::any>) == m["RegistrationDetails"].type()) {
        ListDataServiceApisResponseDataApisRegistrationDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RegistrationDetails"]));
        registrationDetails = make_shared<ListDataServiceApisResponseDataApisRegistrationDetails>(model1);
      }
    }
    if (m.find("ScriptDetails") != m.end() && !m["ScriptDetails"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScriptDetails"].type()) {
        ListDataServiceApisResponseDataApisScriptDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScriptDetails"]));
        scriptDetails = make_shared<ListDataServiceApisResponseDataApisScriptDetails>(model1);
      }
    }
    if (m.find("WizardDetails") != m.end() && !m["WizardDetails"].empty()) {
      if (typeid(map<string, boost::any>) == m["WizardDetails"].type()) {
        ListDataServiceApisResponseDataApisWizardDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WizardDetails"]));
        wizardDetails = make_shared<ListDataServiceApisResponseDataApisWizardDetails>(model1);
      }
    }
    if (m.find("Protocols") != m.end() && !m["Protocols"].empty()) {
      vector<int> toVec1;
      if (typeid(vector<boost::any>) == m["Protocols"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Protocols"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<int>(item));
        }
      }
      protocols = make_shared<vector<int>>(toVec1);
    }
  }


  virtual ~ListDataServiceApisResponseDataApis() = default;
};
class ListDataServiceApisResponseData : public Darabonba::Model {
public:
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> totalCount{};
  shared_ptr<vector<ListDataServiceApisResponseDataApis>> apis{};

  ListDataServiceApisResponseData() {}

  explicit ListDataServiceApisResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageNumber) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNumber is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!totalCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("totalCount is required.")));
    }
    if (!apis) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("apis is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (apis) {
      vector<boost::any> temp1;
      for(auto item1:*apis){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Apis"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<int>(boost::any_cast<int>(m["TotalCount"]));
    }
    if (m.find("Apis") != m.end() && !m["Apis"].empty()) {
      if (typeid(vector<boost::any>) == m["Apis"].type()) {
        vector<ListDataServiceApisResponseDataApis> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Apis"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataServiceApisResponseDataApis model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apis = make_shared<vector<ListDataServiceApisResponseDataApis>>(expect1);
      }
    }
  }


  virtual ~ListDataServiceApisResponseData() = default;
};
class ListDataServiceApisResponse : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<ListDataServiceApisResponseData> data{};

  ListDataServiceApisResponse() {}

  explicit ListDataServiceApisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListDataServiceApisResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListDataServiceApisResponseData>(model1);
      }
    }
  }


  virtual ~ListDataServiceApisResponse() = default;
};
class GetDataServicePublishedApiRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<long> tenantId{};
  shared_ptr<long> apiId{};

  GetDataServicePublishedApiRequest() {}

  explicit GetDataServicePublishedApiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!tenantId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tenantId is required.")));
    }
    if (!apiId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("apiId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<long>(boost::any_cast<long>(m["ApiId"]));
    }
  }


  virtual ~GetDataServicePublishedApiRequest() = default;
};
class GetDataServicePublishedApiResponseDataRegistrationDetailsRegistrationErrorCodes : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorSolution{};

  GetDataServicePublishedApiResponseDataRegistrationDetailsRegistrationErrorCodes() {}

  explicit GetDataServicePublishedApiResponseDataRegistrationDetailsRegistrationErrorCodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!errorSolution) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorSolution is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorSolution) {
      res["ErrorSolution"] = boost::any(*errorSolution);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorSolution") != m.end() && !m["ErrorSolution"].empty()) {
      errorSolution = make_shared<string>(boost::any_cast<string>(m["ErrorSolution"]));
    }
  }


  virtual ~GetDataServicePublishedApiResponseDataRegistrationDetailsRegistrationErrorCodes() = default;
};
class GetDataServicePublishedApiResponseDataRegistrationDetailsRegistrationRequestParameters : public Darabonba::Model {
public:
  shared_ptr<string> defaultValue{};
  shared_ptr<string> exampleValue{};
  shared_ptr<bool> isRequiredParameter{};
  shared_ptr<int> parameterDataType{};
  shared_ptr<string> parameterDescription{};
  shared_ptr<string> parameterName{};
  shared_ptr<int> parameterOperator{};
  shared_ptr<int> parameterPosition{};

  GetDataServicePublishedApiResponseDataRegistrationDetailsRegistrationRequestParameters() {}

  explicit GetDataServicePublishedApiResponseDataRegistrationDetailsRegistrationRequestParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!defaultValue) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("defaultValue is required.")));
    }
    if (!exampleValue) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("exampleValue is required.")));
    }
    if (!isRequiredParameter) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("isRequiredParameter is required.")));
    }
    if (!parameterDataType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterDataType is required.")));
    }
    if (!parameterDescription) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterDescription is required.")));
    }
    if (!parameterName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterName is required.")));
    }
    if (!parameterOperator) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterOperator is required.")));
    }
    if (!parameterPosition) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterPosition is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (exampleValue) {
      res["ExampleValue"] = boost::any(*exampleValue);
    }
    if (isRequiredParameter) {
      res["IsRequiredParameter"] = boost::any(*isRequiredParameter);
    }
    if (parameterDataType) {
      res["ParameterDataType"] = boost::any(*parameterDataType);
    }
    if (parameterDescription) {
      res["ParameterDescription"] = boost::any(*parameterDescription);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (parameterOperator) {
      res["ParameterOperator"] = boost::any(*parameterOperator);
    }
    if (parameterPosition) {
      res["ParameterPosition"] = boost::any(*parameterPosition);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("ExampleValue") != m.end() && !m["ExampleValue"].empty()) {
      exampleValue = make_shared<string>(boost::any_cast<string>(m["ExampleValue"]));
    }
    if (m.find("IsRequiredParameter") != m.end() && !m["IsRequiredParameter"].empty()) {
      isRequiredParameter = make_shared<bool>(boost::any_cast<bool>(m["IsRequiredParameter"]));
    }
    if (m.find("ParameterDataType") != m.end() && !m["ParameterDataType"].empty()) {
      parameterDataType = make_shared<int>(boost::any_cast<int>(m["ParameterDataType"]));
    }
    if (m.find("ParameterDescription") != m.end() && !m["ParameterDescription"].empty()) {
      parameterDescription = make_shared<string>(boost::any_cast<string>(m["ParameterDescription"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ParameterOperator") != m.end() && !m["ParameterOperator"].empty()) {
      parameterOperator = make_shared<int>(boost::any_cast<int>(m["ParameterOperator"]));
    }
    if (m.find("ParameterPosition") != m.end() && !m["ParameterPosition"].empty()) {
      parameterPosition = make_shared<int>(boost::any_cast<int>(m["ParameterPosition"]));
    }
  }


  virtual ~GetDataServicePublishedApiResponseDataRegistrationDetailsRegistrationRequestParameters() = default;
};
class GetDataServicePublishedApiResponseDataRegistrationDetails : public Darabonba::Model {
public:
  shared_ptr<string> failedResultSample{};
  shared_ptr<int> serviceContentType{};
  shared_ptr<string> serviceHost{};
  shared_ptr<string> servicePath{};
  shared_ptr<string> serviceRequestBodyDescription{};
  shared_ptr<string> successfulResultSample{};
  shared_ptr<vector<GetDataServicePublishedApiResponseDataRegistrationDetailsRegistrationErrorCodes>> registrationErrorCodes{};
  shared_ptr<vector<GetDataServicePublishedApiResponseDataRegistrationDetailsRegistrationRequestParameters>> registrationRequestParameters{};

  GetDataServicePublishedApiResponseDataRegistrationDetails() {}

  explicit GetDataServicePublishedApiResponseDataRegistrationDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!failedResultSample) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("failedResultSample is required.")));
    }
    if (!serviceContentType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("serviceContentType is required.")));
    }
    if (!serviceHost) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("serviceHost is required.")));
    }
    if (!servicePath) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("servicePath is required.")));
    }
    if (!serviceRequestBodyDescription) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("serviceRequestBodyDescription is required.")));
    }
    if (!successfulResultSample) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("successfulResultSample is required.")));
    }
    if (!registrationErrorCodes) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("registrationErrorCodes is required.")));
    }
    if (!registrationRequestParameters) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("registrationRequestParameters is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failedResultSample) {
      res["FailedResultSample"] = boost::any(*failedResultSample);
    }
    if (serviceContentType) {
      res["ServiceContentType"] = boost::any(*serviceContentType);
    }
    if (serviceHost) {
      res["ServiceHost"] = boost::any(*serviceHost);
    }
    if (servicePath) {
      res["ServicePath"] = boost::any(*servicePath);
    }
    if (serviceRequestBodyDescription) {
      res["ServiceRequestBodyDescription"] = boost::any(*serviceRequestBodyDescription);
    }
    if (successfulResultSample) {
      res["SuccessfulResultSample"] = boost::any(*successfulResultSample);
    }
    if (registrationErrorCodes) {
      vector<boost::any> temp1;
      for(auto item1:*registrationErrorCodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RegistrationErrorCodes"] = boost::any(temp1);
    }
    if (registrationRequestParameters) {
      vector<boost::any> temp1;
      for(auto item1:*registrationRequestParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RegistrationRequestParameters"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailedResultSample") != m.end() && !m["FailedResultSample"].empty()) {
      failedResultSample = make_shared<string>(boost::any_cast<string>(m["FailedResultSample"]));
    }
    if (m.find("ServiceContentType") != m.end() && !m["ServiceContentType"].empty()) {
      serviceContentType = make_shared<int>(boost::any_cast<int>(m["ServiceContentType"]));
    }
    if (m.find("ServiceHost") != m.end() && !m["ServiceHost"].empty()) {
      serviceHost = make_shared<string>(boost::any_cast<string>(m["ServiceHost"]));
    }
    if (m.find("ServicePath") != m.end() && !m["ServicePath"].empty()) {
      servicePath = make_shared<string>(boost::any_cast<string>(m["ServicePath"]));
    }
    if (m.find("ServiceRequestBodyDescription") != m.end() && !m["ServiceRequestBodyDescription"].empty()) {
      serviceRequestBodyDescription = make_shared<string>(boost::any_cast<string>(m["ServiceRequestBodyDescription"]));
    }
    if (m.find("SuccessfulResultSample") != m.end() && !m["SuccessfulResultSample"].empty()) {
      successfulResultSample = make_shared<string>(boost::any_cast<string>(m["SuccessfulResultSample"]));
    }
    if (m.find("RegistrationErrorCodes") != m.end() && !m["RegistrationErrorCodes"].empty()) {
      if (typeid(vector<boost::any>) == m["RegistrationErrorCodes"].type()) {
        vector<GetDataServicePublishedApiResponseDataRegistrationDetailsRegistrationErrorCodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RegistrationErrorCodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataServicePublishedApiResponseDataRegistrationDetailsRegistrationErrorCodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        registrationErrorCodes = make_shared<vector<GetDataServicePublishedApiResponseDataRegistrationDetailsRegistrationErrorCodes>>(expect1);
      }
    }
    if (m.find("RegistrationRequestParameters") != m.end() && !m["RegistrationRequestParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["RegistrationRequestParameters"].type()) {
        vector<GetDataServicePublishedApiResponseDataRegistrationDetailsRegistrationRequestParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RegistrationRequestParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataServicePublishedApiResponseDataRegistrationDetailsRegistrationRequestParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        registrationRequestParameters = make_shared<vector<GetDataServicePublishedApiResponseDataRegistrationDetailsRegistrationRequestParameters>>(expect1);
      }
    }
  }


  virtual ~GetDataServicePublishedApiResponseDataRegistrationDetails() = default;
};
class GetDataServicePublishedApiResponseDataScriptDetailsScriptErrorCodes : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorSolution{};

  GetDataServicePublishedApiResponseDataScriptDetailsScriptErrorCodes() {}

  explicit GetDataServicePublishedApiResponseDataScriptDetailsScriptErrorCodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!errorSolution) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorSolution is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorSolution) {
      res["ErrorSolution"] = boost::any(*errorSolution);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorSolution") != m.end() && !m["ErrorSolution"].empty()) {
      errorSolution = make_shared<string>(boost::any_cast<string>(m["ErrorSolution"]));
    }
  }


  virtual ~GetDataServicePublishedApiResponseDataScriptDetailsScriptErrorCodes() = default;
};
class GetDataServicePublishedApiResponseDataScriptDetailsScriptRequestParameters : public Darabonba::Model {
public:
  shared_ptr<string> defaultValue{};
  shared_ptr<string> exampleValue{};
  shared_ptr<bool> isRequiredParameter{};
  shared_ptr<int> parameterDataType{};
  shared_ptr<string> parameterDescription{};
  shared_ptr<string> parameterName{};
  shared_ptr<int> parameterOperator{};
  shared_ptr<int> parameterPosition{};

  GetDataServicePublishedApiResponseDataScriptDetailsScriptRequestParameters() {}

  explicit GetDataServicePublishedApiResponseDataScriptDetailsScriptRequestParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!defaultValue) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("defaultValue is required.")));
    }
    if (!exampleValue) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("exampleValue is required.")));
    }
    if (!isRequiredParameter) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("isRequiredParameter is required.")));
    }
    if (!parameterDataType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterDataType is required.")));
    }
    if (!parameterDescription) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterDescription is required.")));
    }
    if (!parameterName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterName is required.")));
    }
    if (!parameterOperator) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterOperator is required.")));
    }
    if (!parameterPosition) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterPosition is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (exampleValue) {
      res["ExampleValue"] = boost::any(*exampleValue);
    }
    if (isRequiredParameter) {
      res["IsRequiredParameter"] = boost::any(*isRequiredParameter);
    }
    if (parameterDataType) {
      res["ParameterDataType"] = boost::any(*parameterDataType);
    }
    if (parameterDescription) {
      res["ParameterDescription"] = boost::any(*parameterDescription);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (parameterOperator) {
      res["ParameterOperator"] = boost::any(*parameterOperator);
    }
    if (parameterPosition) {
      res["ParameterPosition"] = boost::any(*parameterPosition);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("ExampleValue") != m.end() && !m["ExampleValue"].empty()) {
      exampleValue = make_shared<string>(boost::any_cast<string>(m["ExampleValue"]));
    }
    if (m.find("IsRequiredParameter") != m.end() && !m["IsRequiredParameter"].empty()) {
      isRequiredParameter = make_shared<bool>(boost::any_cast<bool>(m["IsRequiredParameter"]));
    }
    if (m.find("ParameterDataType") != m.end() && !m["ParameterDataType"].empty()) {
      parameterDataType = make_shared<int>(boost::any_cast<int>(m["ParameterDataType"]));
    }
    if (m.find("ParameterDescription") != m.end() && !m["ParameterDescription"].empty()) {
      parameterDescription = make_shared<string>(boost::any_cast<string>(m["ParameterDescription"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ParameterOperator") != m.end() && !m["ParameterOperator"].empty()) {
      parameterOperator = make_shared<int>(boost::any_cast<int>(m["ParameterOperator"]));
    }
    if (m.find("ParameterPosition") != m.end() && !m["ParameterPosition"].empty()) {
      parameterPosition = make_shared<int>(boost::any_cast<int>(m["ParameterPosition"]));
    }
  }


  virtual ~GetDataServicePublishedApiResponseDataScriptDetailsScriptRequestParameters() = default;
};
class GetDataServicePublishedApiResponseDataScriptDetailsScriptResponseParameters : public Darabonba::Model {
public:
  shared_ptr<string> exampleValue{};
  shared_ptr<int> parameterDataType{};
  shared_ptr<string> parameterDescription{};
  shared_ptr<string> parameterName{};

  GetDataServicePublishedApiResponseDataScriptDetailsScriptResponseParameters() {}

  explicit GetDataServicePublishedApiResponseDataScriptDetailsScriptResponseParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!exampleValue) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("exampleValue is required.")));
    }
    if (!parameterDataType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterDataType is required.")));
    }
    if (!parameterDescription) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterDescription is required.")));
    }
    if (!parameterName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (exampleValue) {
      res["ExampleValue"] = boost::any(*exampleValue);
    }
    if (parameterDataType) {
      res["ParameterDataType"] = boost::any(*parameterDataType);
    }
    if (parameterDescription) {
      res["ParameterDescription"] = boost::any(*parameterDescription);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExampleValue") != m.end() && !m["ExampleValue"].empty()) {
      exampleValue = make_shared<string>(boost::any_cast<string>(m["ExampleValue"]));
    }
    if (m.find("ParameterDataType") != m.end() && !m["ParameterDataType"].empty()) {
      parameterDataType = make_shared<int>(boost::any_cast<int>(m["ParameterDataType"]));
    }
    if (m.find("ParameterDescription") != m.end() && !m["ParameterDescription"].empty()) {
      parameterDescription = make_shared<string>(boost::any_cast<string>(m["ParameterDescription"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
  }


  virtual ~GetDataServicePublishedApiResponseDataScriptDetailsScriptResponseParameters() = default;
};
class GetDataServicePublishedApiResponseDataScriptDetailsScriptConnection : public Darabonba::Model {
public:
  shared_ptr<long> connectionId{};
  shared_ptr<string> tableName{};

  GetDataServicePublishedApiResponseDataScriptDetailsScriptConnection() {}

  explicit GetDataServicePublishedApiResponseDataScriptDetailsScriptConnection(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!connectionId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("connectionId is required.")));
    }
    if (!tableName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tableName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connectionId) {
      res["ConnectionId"] = boost::any(*connectionId);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConnectionId") != m.end() && !m["ConnectionId"].empty()) {
      connectionId = make_shared<long>(boost::any_cast<long>(m["ConnectionId"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
  }


  virtual ~GetDataServicePublishedApiResponseDataScriptDetailsScriptConnection() = default;
};
class GetDataServicePublishedApiResponseDataScriptDetails : public Darabonba::Model {
public:
  shared_ptr<string> failedResultSample{};
  shared_ptr<bool> isPagedResponse{};
  shared_ptr<string> script{};
  shared_ptr<string> successfulResultSample{};
  shared_ptr<vector<GetDataServicePublishedApiResponseDataScriptDetailsScriptErrorCodes>> scriptErrorCodes{};
  shared_ptr<vector<GetDataServicePublishedApiResponseDataScriptDetailsScriptRequestParameters>> scriptRequestParameters{};
  shared_ptr<vector<GetDataServicePublishedApiResponseDataScriptDetailsScriptResponseParameters>> scriptResponseParameters{};
  shared_ptr<GetDataServicePublishedApiResponseDataScriptDetailsScriptConnection> scriptConnection{};

  GetDataServicePublishedApiResponseDataScriptDetails() {}

  explicit GetDataServicePublishedApiResponseDataScriptDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!failedResultSample) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("failedResultSample is required.")));
    }
    if (!isPagedResponse) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("isPagedResponse is required.")));
    }
    if (!script) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("script is required.")));
    }
    if (!successfulResultSample) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("successfulResultSample is required.")));
    }
    if (!scriptErrorCodes) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("scriptErrorCodes is required.")));
    }
    if (!scriptRequestParameters) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("scriptRequestParameters is required.")));
    }
    if (!scriptResponseParameters) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("scriptResponseParameters is required.")));
    }
    if (!scriptConnection) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("scriptConnection is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failedResultSample) {
      res["FailedResultSample"] = boost::any(*failedResultSample);
    }
    if (isPagedResponse) {
      res["IsPagedResponse"] = boost::any(*isPagedResponse);
    }
    if (script) {
      res["Script"] = boost::any(*script);
    }
    if (successfulResultSample) {
      res["SuccessfulResultSample"] = boost::any(*successfulResultSample);
    }
    if (scriptErrorCodes) {
      vector<boost::any> temp1;
      for(auto item1:*scriptErrorCodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScriptErrorCodes"] = boost::any(temp1);
    }
    if (scriptRequestParameters) {
      vector<boost::any> temp1;
      for(auto item1:*scriptRequestParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScriptRequestParameters"] = boost::any(temp1);
    }
    if (scriptResponseParameters) {
      vector<boost::any> temp1;
      for(auto item1:*scriptResponseParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScriptResponseParameters"] = boost::any(temp1);
    }
    if (scriptConnection) {
      res["ScriptConnection"] = scriptConnection ? boost::any(scriptConnection->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailedResultSample") != m.end() && !m["FailedResultSample"].empty()) {
      failedResultSample = make_shared<string>(boost::any_cast<string>(m["FailedResultSample"]));
    }
    if (m.find("IsPagedResponse") != m.end() && !m["IsPagedResponse"].empty()) {
      isPagedResponse = make_shared<bool>(boost::any_cast<bool>(m["IsPagedResponse"]));
    }
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      script = make_shared<string>(boost::any_cast<string>(m["Script"]));
    }
    if (m.find("SuccessfulResultSample") != m.end() && !m["SuccessfulResultSample"].empty()) {
      successfulResultSample = make_shared<string>(boost::any_cast<string>(m["SuccessfulResultSample"]));
    }
    if (m.find("ScriptErrorCodes") != m.end() && !m["ScriptErrorCodes"].empty()) {
      if (typeid(vector<boost::any>) == m["ScriptErrorCodes"].type()) {
        vector<GetDataServicePublishedApiResponseDataScriptDetailsScriptErrorCodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScriptErrorCodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataServicePublishedApiResponseDataScriptDetailsScriptErrorCodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scriptErrorCodes = make_shared<vector<GetDataServicePublishedApiResponseDataScriptDetailsScriptErrorCodes>>(expect1);
      }
    }
    if (m.find("ScriptRequestParameters") != m.end() && !m["ScriptRequestParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["ScriptRequestParameters"].type()) {
        vector<GetDataServicePublishedApiResponseDataScriptDetailsScriptRequestParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScriptRequestParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataServicePublishedApiResponseDataScriptDetailsScriptRequestParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scriptRequestParameters = make_shared<vector<GetDataServicePublishedApiResponseDataScriptDetailsScriptRequestParameters>>(expect1);
      }
    }
    if (m.find("ScriptResponseParameters") != m.end() && !m["ScriptResponseParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["ScriptResponseParameters"].type()) {
        vector<GetDataServicePublishedApiResponseDataScriptDetailsScriptResponseParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScriptResponseParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataServicePublishedApiResponseDataScriptDetailsScriptResponseParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scriptResponseParameters = make_shared<vector<GetDataServicePublishedApiResponseDataScriptDetailsScriptResponseParameters>>(expect1);
      }
    }
    if (m.find("ScriptConnection") != m.end() && !m["ScriptConnection"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScriptConnection"].type()) {
        GetDataServicePublishedApiResponseDataScriptDetailsScriptConnection model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScriptConnection"]));
        scriptConnection = make_shared<GetDataServicePublishedApiResponseDataScriptDetailsScriptConnection>(model1);
      }
    }
  }


  virtual ~GetDataServicePublishedApiResponseDataScriptDetails() = default;
};
class GetDataServicePublishedApiResponseDataWizardDetailsWizardErrorCodes : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorSolution{};

  GetDataServicePublishedApiResponseDataWizardDetailsWizardErrorCodes() {}

  explicit GetDataServicePublishedApiResponseDataWizardDetailsWizardErrorCodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!errorSolution) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorSolution is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorSolution) {
      res["ErrorSolution"] = boost::any(*errorSolution);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorSolution") != m.end() && !m["ErrorSolution"].empty()) {
      errorSolution = make_shared<string>(boost::any_cast<string>(m["ErrorSolution"]));
    }
  }


  virtual ~GetDataServicePublishedApiResponseDataWizardDetailsWizardErrorCodes() = default;
};
class GetDataServicePublishedApiResponseDataWizardDetailsWizardRequestParameters : public Darabonba::Model {
public:
  shared_ptr<string> defaultValue{};
  shared_ptr<string> exampleValue{};
  shared_ptr<bool> isRequiredParameter{};
  shared_ptr<int> parameterDataType{};
  shared_ptr<string> parameterDescription{};
  shared_ptr<string> parameterName{};
  shared_ptr<int> parameterOperator{};
  shared_ptr<int> parameterPosition{};

  GetDataServicePublishedApiResponseDataWizardDetailsWizardRequestParameters() {}

  explicit GetDataServicePublishedApiResponseDataWizardDetailsWizardRequestParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!defaultValue) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("defaultValue is required.")));
    }
    if (!exampleValue) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("exampleValue is required.")));
    }
    if (!isRequiredParameter) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("isRequiredParameter is required.")));
    }
    if (!parameterDataType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterDataType is required.")));
    }
    if (!parameterDescription) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterDescription is required.")));
    }
    if (!parameterName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterName is required.")));
    }
    if (!parameterOperator) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterOperator is required.")));
    }
    if (!parameterPosition) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterPosition is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (exampleValue) {
      res["ExampleValue"] = boost::any(*exampleValue);
    }
    if (isRequiredParameter) {
      res["IsRequiredParameter"] = boost::any(*isRequiredParameter);
    }
    if (parameterDataType) {
      res["ParameterDataType"] = boost::any(*parameterDataType);
    }
    if (parameterDescription) {
      res["ParameterDescription"] = boost::any(*parameterDescription);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (parameterOperator) {
      res["ParameterOperator"] = boost::any(*parameterOperator);
    }
    if (parameterPosition) {
      res["ParameterPosition"] = boost::any(*parameterPosition);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("ExampleValue") != m.end() && !m["ExampleValue"].empty()) {
      exampleValue = make_shared<string>(boost::any_cast<string>(m["ExampleValue"]));
    }
    if (m.find("IsRequiredParameter") != m.end() && !m["IsRequiredParameter"].empty()) {
      isRequiredParameter = make_shared<bool>(boost::any_cast<bool>(m["IsRequiredParameter"]));
    }
    if (m.find("ParameterDataType") != m.end() && !m["ParameterDataType"].empty()) {
      parameterDataType = make_shared<int>(boost::any_cast<int>(m["ParameterDataType"]));
    }
    if (m.find("ParameterDescription") != m.end() && !m["ParameterDescription"].empty()) {
      parameterDescription = make_shared<string>(boost::any_cast<string>(m["ParameterDescription"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ParameterOperator") != m.end() && !m["ParameterOperator"].empty()) {
      parameterOperator = make_shared<int>(boost::any_cast<int>(m["ParameterOperator"]));
    }
    if (m.find("ParameterPosition") != m.end() && !m["ParameterPosition"].empty()) {
      parameterPosition = make_shared<int>(boost::any_cast<int>(m["ParameterPosition"]));
    }
  }


  virtual ~GetDataServicePublishedApiResponseDataWizardDetailsWizardRequestParameters() = default;
};
class GetDataServicePublishedApiResponseDataWizardDetailsWizardResponseParameters : public Darabonba::Model {
public:
  shared_ptr<string> exampleValue{};
  shared_ptr<int> parameterDataType{};
  shared_ptr<string> parameterDescription{};
  shared_ptr<string> parameterName{};

  GetDataServicePublishedApiResponseDataWizardDetailsWizardResponseParameters() {}

  explicit GetDataServicePublishedApiResponseDataWizardDetailsWizardResponseParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!exampleValue) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("exampleValue is required.")));
    }
    if (!parameterDataType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterDataType is required.")));
    }
    if (!parameterDescription) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterDescription is required.")));
    }
    if (!parameterName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("parameterName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (exampleValue) {
      res["ExampleValue"] = boost::any(*exampleValue);
    }
    if (parameterDataType) {
      res["ParameterDataType"] = boost::any(*parameterDataType);
    }
    if (parameterDescription) {
      res["ParameterDescription"] = boost::any(*parameterDescription);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExampleValue") != m.end() && !m["ExampleValue"].empty()) {
      exampleValue = make_shared<string>(boost::any_cast<string>(m["ExampleValue"]));
    }
    if (m.find("ParameterDataType") != m.end() && !m["ParameterDataType"].empty()) {
      parameterDataType = make_shared<int>(boost::any_cast<int>(m["ParameterDataType"]));
    }
    if (m.find("ParameterDescription") != m.end() && !m["ParameterDescription"].empty()) {
      parameterDescription = make_shared<string>(boost::any_cast<string>(m["ParameterDescription"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
  }


  virtual ~GetDataServicePublishedApiResponseDataWizardDetailsWizardResponseParameters() = default;
};
class GetDataServicePublishedApiResponseDataWizardDetailsWizardConnection : public Darabonba::Model {
public:
  shared_ptr<long> connectionId{};
  shared_ptr<string> tableName{};

  GetDataServicePublishedApiResponseDataWizardDetailsWizardConnection() {}

  explicit GetDataServicePublishedApiResponseDataWizardDetailsWizardConnection(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!connectionId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("connectionId is required.")));
    }
    if (!tableName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tableName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connectionId) {
      res["ConnectionId"] = boost::any(*connectionId);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConnectionId") != m.end() && !m["ConnectionId"].empty()) {
      connectionId = make_shared<long>(boost::any_cast<long>(m["ConnectionId"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
  }


  virtual ~GetDataServicePublishedApiResponseDataWizardDetailsWizardConnection() = default;
};
class GetDataServicePublishedApiResponseDataWizardDetails : public Darabonba::Model {
public:
  shared_ptr<string> failedResultSample{};
  shared_ptr<bool> isPagedResponse{};
  shared_ptr<string> successfulResultSample{};
  shared_ptr<vector<GetDataServicePublishedApiResponseDataWizardDetailsWizardErrorCodes>> wizardErrorCodes{};
  shared_ptr<vector<GetDataServicePublishedApiResponseDataWizardDetailsWizardRequestParameters>> wizardRequestParameters{};
  shared_ptr<vector<GetDataServicePublishedApiResponseDataWizardDetailsWizardResponseParameters>> wizardResponseParameters{};
  shared_ptr<GetDataServicePublishedApiResponseDataWizardDetailsWizardConnection> wizardConnection{};

  GetDataServicePublishedApiResponseDataWizardDetails() {}

  explicit GetDataServicePublishedApiResponseDataWizardDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!failedResultSample) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("failedResultSample is required.")));
    }
    if (!isPagedResponse) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("isPagedResponse is required.")));
    }
    if (!successfulResultSample) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("successfulResultSample is required.")));
    }
    if (!wizardErrorCodes) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("wizardErrorCodes is required.")));
    }
    if (!wizardRequestParameters) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("wizardRequestParameters is required.")));
    }
    if (!wizardResponseParameters) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("wizardResponseParameters is required.")));
    }
    if (!wizardConnection) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("wizardConnection is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failedResultSample) {
      res["FailedResultSample"] = boost::any(*failedResultSample);
    }
    if (isPagedResponse) {
      res["IsPagedResponse"] = boost::any(*isPagedResponse);
    }
    if (successfulResultSample) {
      res["SuccessfulResultSample"] = boost::any(*successfulResultSample);
    }
    if (wizardErrorCodes) {
      vector<boost::any> temp1;
      for(auto item1:*wizardErrorCodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WizardErrorCodes"] = boost::any(temp1);
    }
    if (wizardRequestParameters) {
      vector<boost::any> temp1;
      for(auto item1:*wizardRequestParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WizardRequestParameters"] = boost::any(temp1);
    }
    if (wizardResponseParameters) {
      vector<boost::any> temp1;
      for(auto item1:*wizardResponseParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WizardResponseParameters"] = boost::any(temp1);
    }
    if (wizardConnection) {
      res["WizardConnection"] = wizardConnection ? boost::any(wizardConnection->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailedResultSample") != m.end() && !m["FailedResultSample"].empty()) {
      failedResultSample = make_shared<string>(boost::any_cast<string>(m["FailedResultSample"]));
    }
    if (m.find("IsPagedResponse") != m.end() && !m["IsPagedResponse"].empty()) {
      isPagedResponse = make_shared<bool>(boost::any_cast<bool>(m["IsPagedResponse"]));
    }
    if (m.find("SuccessfulResultSample") != m.end() && !m["SuccessfulResultSample"].empty()) {
      successfulResultSample = make_shared<string>(boost::any_cast<string>(m["SuccessfulResultSample"]));
    }
    if (m.find("WizardErrorCodes") != m.end() && !m["WizardErrorCodes"].empty()) {
      if (typeid(vector<boost::any>) == m["WizardErrorCodes"].type()) {
        vector<GetDataServicePublishedApiResponseDataWizardDetailsWizardErrorCodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WizardErrorCodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataServicePublishedApiResponseDataWizardDetailsWizardErrorCodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        wizardErrorCodes = make_shared<vector<GetDataServicePublishedApiResponseDataWizardDetailsWizardErrorCodes>>(expect1);
      }
    }
    if (m.find("WizardRequestParameters") != m.end() && !m["WizardRequestParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["WizardRequestParameters"].type()) {
        vector<GetDataServicePublishedApiResponseDataWizardDetailsWizardRequestParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WizardRequestParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataServicePublishedApiResponseDataWizardDetailsWizardRequestParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        wizardRequestParameters = make_shared<vector<GetDataServicePublishedApiResponseDataWizardDetailsWizardRequestParameters>>(expect1);
      }
    }
    if (m.find("WizardResponseParameters") != m.end() && !m["WizardResponseParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["WizardResponseParameters"].type()) {
        vector<GetDataServicePublishedApiResponseDataWizardDetailsWizardResponseParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WizardResponseParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataServicePublishedApiResponseDataWizardDetailsWizardResponseParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        wizardResponseParameters = make_shared<vector<GetDataServicePublishedApiResponseDataWizardDetailsWizardResponseParameters>>(expect1);
      }
    }
    if (m.find("WizardConnection") != m.end() && !m["WizardConnection"].empty()) {
      if (typeid(map<string, boost::any>) == m["WizardConnection"].type()) {
        GetDataServicePublishedApiResponseDataWizardDetailsWizardConnection model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WizardConnection"]));
        wizardConnection = make_shared<GetDataServicePublishedApiResponseDataWizardDetailsWizardConnection>(model1);
      }
    }
  }


  virtual ~GetDataServicePublishedApiResponseDataWizardDetails() = default;
};
class GetDataServicePublishedApiResponseData : public Darabonba::Model {
public:
  shared_ptr<long> apiId{};
  shared_ptr<int> apiMode{};
  shared_ptr<string> apiName{};
  shared_ptr<string> apiPath{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> operatorId{};
  shared_ptr<long> projectId{};
  shared_ptr<int> requestMethod{};
  shared_ptr<int> responseContentType{};
  shared_ptr<int> status{};
  shared_ptr<long> tenantId{};
  shared_ptr<int> timeout{};
  shared_ptr<int> visibleRange{};
  shared_ptr<GetDataServicePublishedApiResponseDataRegistrationDetails> registrationDetails{};
  shared_ptr<GetDataServicePublishedApiResponseDataScriptDetails> scriptDetails{};
  shared_ptr<GetDataServicePublishedApiResponseDataWizardDetails> wizardDetails{};
  shared_ptr<vector<int>> protocols{};

  GetDataServicePublishedApiResponseData() {}

  explicit GetDataServicePublishedApiResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!apiId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("apiId is required.")));
    }
    if (!apiMode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("apiMode is required.")));
    }
    if (!apiName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("apiName is required.")));
    }
    if (!apiPath) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("apiPath is required.")));
    }
    if (!createdTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("createdTime is required.")));
    }
    if (!creatorId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("creatorId is required.")));
    }
    if (!description) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("description is required.")));
    }
    if (!groupId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupId is required.")));
    }
    if (!modifiedTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("modifiedTime is required.")));
    }
    if (!operatorId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("operatorId is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!requestMethod) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestMethod is required.")));
    }
    if (!responseContentType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("responseContentType is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!tenantId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tenantId is required.")));
    }
    if (!timeout) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("timeout is required.")));
    }
    if (!visibleRange) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("visibleRange is required.")));
    }
    if (!registrationDetails) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("registrationDetails is required.")));
    }
    if (!scriptDetails) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("scriptDetails is required.")));
    }
    if (!wizardDetails) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("wizardDetails is required.")));
    }
    if (!protocols) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("protocols is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiMode) {
      res["ApiMode"] = boost::any(*apiMode);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (apiPath) {
      res["ApiPath"] = boost::any(*apiPath);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (operatorId) {
      res["OperatorId"] = boost::any(*operatorId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (requestMethod) {
      res["RequestMethod"] = boost::any(*requestMethod);
    }
    if (responseContentType) {
      res["ResponseContentType"] = boost::any(*responseContentType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (visibleRange) {
      res["VisibleRange"] = boost::any(*visibleRange);
    }
    if (registrationDetails) {
      res["RegistrationDetails"] = registrationDetails ? boost::any(registrationDetails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scriptDetails) {
      res["ScriptDetails"] = scriptDetails ? boost::any(scriptDetails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (wizardDetails) {
      res["WizardDetails"] = wizardDetails ? boost::any(wizardDetails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (protocols) {
      res["Protocols"] = boost::any(*protocols);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<long>(boost::any_cast<long>(m["ApiId"]));
    }
    if (m.find("ApiMode") != m.end() && !m["ApiMode"].empty()) {
      apiMode = make_shared<int>(boost::any_cast<int>(m["ApiMode"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("ApiPath") != m.end() && !m["ApiPath"].empty()) {
      apiPath = make_shared<string>(boost::any_cast<string>(m["ApiPath"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("OperatorId") != m.end() && !m["OperatorId"].empty()) {
      operatorId = make_shared<string>(boost::any_cast<string>(m["OperatorId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RequestMethod") != m.end() && !m["RequestMethod"].empty()) {
      requestMethod = make_shared<int>(boost::any_cast<int>(m["RequestMethod"]));
    }
    if (m.find("ResponseContentType") != m.end() && !m["ResponseContentType"].empty()) {
      responseContentType = make_shared<int>(boost::any_cast<int>(m["ResponseContentType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<int>(boost::any_cast<int>(m["Status"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<int>(boost::any_cast<int>(m["Timeout"]));
    }
    if (m.find("VisibleRange") != m.end() && !m["VisibleRange"].empty()) {
      visibleRange = make_shared<int>(boost::any_cast<int>(m["VisibleRange"]));
    }
    if (m.find("RegistrationDetails") != m.end() && !m["RegistrationDetails"].empty()) {
      if (typeid(map<string, boost::any>) == m["RegistrationDetails"].type()) {
        GetDataServicePublishedApiResponseDataRegistrationDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RegistrationDetails"]));
        registrationDetails = make_shared<GetDataServicePublishedApiResponseDataRegistrationDetails>(model1);
      }
    }
    if (m.find("ScriptDetails") != m.end() && !m["ScriptDetails"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScriptDetails"].type()) {
        GetDataServicePublishedApiResponseDataScriptDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScriptDetails"]));
        scriptDetails = make_shared<GetDataServicePublishedApiResponseDataScriptDetails>(model1);
      }
    }
    if (m.find("WizardDetails") != m.end() && !m["WizardDetails"].empty()) {
      if (typeid(map<string, boost::any>) == m["WizardDetails"].type()) {
        GetDataServicePublishedApiResponseDataWizardDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WizardDetails"]));
        wizardDetails = make_shared<GetDataServicePublishedApiResponseDataWizardDetails>(model1);
      }
    }
    if (m.find("Protocols") != m.end() && !m["Protocols"].empty()) {
      vector<int> toVec1;
      if (typeid(vector<boost::any>) == m["Protocols"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Protocols"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<int>(item));
        }
      }
      protocols = make_shared<vector<int>>(toVec1);
    }
  }


  virtual ~GetDataServicePublishedApiResponseData() = default;
};
class GetDataServicePublishedApiResponse : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<GetDataServicePublishedApiResponseData> data{};

  GetDataServicePublishedApiResponse() {}

  explicit GetDataServicePublishedApiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetDataServicePublishedApiResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetDataServicePublishedApiResponseData>(model1);
      }
    }
  }


  virtual ~GetDataServicePublishedApiResponse() = default;
};
class GetBaselineKeyPathRequest : public Darabonba::Model {
public:
  shared_ptr<long> baselineId{};
  shared_ptr<string> bizdate{};
  shared_ptr<int> inGroupId{};

  GetBaselineKeyPathRequest() {}

  explicit GetBaselineKeyPathRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!baselineId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("baselineId is required.")));
    }
    if (!bizdate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("bizdate is required.")));
    }
    if (!inGroupId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("inGroupId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (bizdate) {
      res["Bizdate"] = boost::any(*bizdate);
    }
    if (inGroupId) {
      res["InGroupId"] = boost::any(*inGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("Bizdate") != m.end() && !m["Bizdate"].empty()) {
      bizdate = make_shared<string>(boost::any_cast<string>(m["Bizdate"]));
    }
    if (m.find("InGroupId") != m.end() && !m["InGroupId"].empty()) {
      inGroupId = make_shared<int>(boost::any_cast<int>(m["InGroupId"]));
    }
  }


  virtual ~GetBaselineKeyPathRequest() = default;
};
class GetBaselineKeyPathResponseDataRuns : public Darabonba::Model {
public:
  shared_ptr<long> absTime{};
  shared_ptr<long> beginCast{};
  shared_ptr<long> beginRunningTime{};
  shared_ptr<long> beginWaitResTime{};
  shared_ptr<long> beginWaitTimeTime{};
  shared_ptr<long> bizdate{};
  shared_ptr<long> cycTime{};
  shared_ptr<long> endCast{};
  shared_ptr<long> finishTime{};
  shared_ptr<int> inGroupId{};
  shared_ptr<long> instanceId{};
  shared_ptr<long> nodeId{};
  shared_ptr<string> nodeName{};
  shared_ptr<string> owner{};
  shared_ptr<long> projectId{};
  shared_ptr<string> status{};

  GetBaselineKeyPathResponseDataRuns() {}

  explicit GetBaselineKeyPathResponseDataRuns(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!absTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("absTime is required.")));
    }
    if (!beginCast) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("beginCast is required.")));
    }
    if (!beginRunningTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("beginRunningTime is required.")));
    }
    if (!beginWaitResTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("beginWaitResTime is required.")));
    }
    if (!beginWaitTimeTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("beginWaitTimeTime is required.")));
    }
    if (!bizdate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("bizdate is required.")));
    }
    if (!cycTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("cycTime is required.")));
    }
    if (!endCast) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("endCast is required.")));
    }
    if (!finishTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("finishTime is required.")));
    }
    if (!inGroupId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("inGroupId is required.")));
    }
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
    if (!nodeId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeId is required.")));
    }
    if (!nodeName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeName is required.")));
    }
    if (!owner) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("owner is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (absTime) {
      res["AbsTime"] = boost::any(*absTime);
    }
    if (beginCast) {
      res["BeginCast"] = boost::any(*beginCast);
    }
    if (beginRunningTime) {
      res["BeginRunningTime"] = boost::any(*beginRunningTime);
    }
    if (beginWaitResTime) {
      res["BeginWaitResTime"] = boost::any(*beginWaitResTime);
    }
    if (beginWaitTimeTime) {
      res["BeginWaitTimeTime"] = boost::any(*beginWaitTimeTime);
    }
    if (bizdate) {
      res["Bizdate"] = boost::any(*bizdate);
    }
    if (cycTime) {
      res["CycTime"] = boost::any(*cycTime);
    }
    if (endCast) {
      res["EndCast"] = boost::any(*endCast);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (inGroupId) {
      res["InGroupId"] = boost::any(*inGroupId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbsTime") != m.end() && !m["AbsTime"].empty()) {
      absTime = make_shared<long>(boost::any_cast<long>(m["AbsTime"]));
    }
    if (m.find("BeginCast") != m.end() && !m["BeginCast"].empty()) {
      beginCast = make_shared<long>(boost::any_cast<long>(m["BeginCast"]));
    }
    if (m.find("BeginRunningTime") != m.end() && !m["BeginRunningTime"].empty()) {
      beginRunningTime = make_shared<long>(boost::any_cast<long>(m["BeginRunningTime"]));
    }
    if (m.find("BeginWaitResTime") != m.end() && !m["BeginWaitResTime"].empty()) {
      beginWaitResTime = make_shared<long>(boost::any_cast<long>(m["BeginWaitResTime"]));
    }
    if (m.find("BeginWaitTimeTime") != m.end() && !m["BeginWaitTimeTime"].empty()) {
      beginWaitTimeTime = make_shared<long>(boost::any_cast<long>(m["BeginWaitTimeTime"]));
    }
    if (m.find("Bizdate") != m.end() && !m["Bizdate"].empty()) {
      bizdate = make_shared<long>(boost::any_cast<long>(m["Bizdate"]));
    }
    if (m.find("CycTime") != m.end() && !m["CycTime"].empty()) {
      cycTime = make_shared<long>(boost::any_cast<long>(m["CycTime"]));
    }
    if (m.find("EndCast") != m.end() && !m["EndCast"].empty()) {
      endCast = make_shared<long>(boost::any_cast<long>(m["EndCast"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<long>(boost::any_cast<long>(m["FinishTime"]));
    }
    if (m.find("InGroupId") != m.end() && !m["InGroupId"].empty()) {
      inGroupId = make_shared<int>(boost::any_cast<int>(m["InGroupId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetBaselineKeyPathResponseDataRuns() = default;
};
class GetBaselineKeyPathResponseDataTopics : public Darabonba::Model {
public:
  shared_ptr<long> instanceId{};
  shared_ptr<long> topicId{};
  shared_ptr<long> topicName{};
  shared_ptr<long> addTime{};

  GetBaselineKeyPathResponseDataTopics() {}

  explicit GetBaselineKeyPathResponseDataTopics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
    if (!topicId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("topicId is required.")));
    }
    if (!topicName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("topicName is required.")));
    }
    if (!addTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("addTime is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (topicId) {
      res["TopicId"] = boost::any(*topicId);
    }
    if (topicName) {
      res["TopicName"] = boost::any(*topicName);
    }
    if (addTime) {
      res["AddTime"] = boost::any(*addTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("TopicId") != m.end() && !m["TopicId"].empty()) {
      topicId = make_shared<long>(boost::any_cast<long>(m["TopicId"]));
    }
    if (m.find("TopicName") != m.end() && !m["TopicName"].empty()) {
      topicName = make_shared<long>(boost::any_cast<long>(m["TopicName"]));
    }
    if (m.find("AddTime") != m.end() && !m["AddTime"].empty()) {
      addTime = make_shared<long>(boost::any_cast<long>(m["AddTime"]));
    }
  }


  virtual ~GetBaselineKeyPathResponseDataTopics() = default;
};
class GetBaselineKeyPathResponseData : public Darabonba::Model {
public:
  shared_ptr<long> instanceId{};
  shared_ptr<long> projectId{};
  shared_ptr<long> nodeId{};
  shared_ptr<string> nodeName{};
  shared_ptr<long> bizdate{};
  shared_ptr<int> inGroupId{};
  shared_ptr<string> owner{};
  shared_ptr<int> prgType{};
  shared_ptr<vector<GetBaselineKeyPathResponseDataRuns>> runs{};
  shared_ptr<vector<GetBaselineKeyPathResponseDataTopics>> topics{};

  GetBaselineKeyPathResponseData() {}

  explicit GetBaselineKeyPathResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!nodeId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeId is required.")));
    }
    if (!nodeName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeName is required.")));
    }
    if (!bizdate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("bizdate is required.")));
    }
    if (!inGroupId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("inGroupId is required.")));
    }
    if (!owner) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("owner is required.")));
    }
    if (!prgType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("prgType is required.")));
    }
    if (!runs) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("runs is required.")));
    }
    if (!topics) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("topics is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (bizdate) {
      res["Bizdate"] = boost::any(*bizdate);
    }
    if (inGroupId) {
      res["InGroupId"] = boost::any(*inGroupId);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (prgType) {
      res["PrgType"] = boost::any(*prgType);
    }
    if (runs) {
      vector<boost::any> temp1;
      for(auto item1:*runs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Runs"] = boost::any(temp1);
    }
    if (topics) {
      vector<boost::any> temp1;
      for(auto item1:*topics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Topics"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("Bizdate") != m.end() && !m["Bizdate"].empty()) {
      bizdate = make_shared<long>(boost::any_cast<long>(m["Bizdate"]));
    }
    if (m.find("InGroupId") != m.end() && !m["InGroupId"].empty()) {
      inGroupId = make_shared<int>(boost::any_cast<int>(m["InGroupId"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("PrgType") != m.end() && !m["PrgType"].empty()) {
      prgType = make_shared<int>(boost::any_cast<int>(m["PrgType"]));
    }
    if (m.find("Runs") != m.end() && !m["Runs"].empty()) {
      if (typeid(vector<boost::any>) == m["Runs"].type()) {
        vector<GetBaselineKeyPathResponseDataRuns> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Runs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetBaselineKeyPathResponseDataRuns model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        runs = make_shared<vector<GetBaselineKeyPathResponseDataRuns>>(expect1);
      }
    }
    if (m.find("Topics") != m.end() && !m["Topics"].empty()) {
      if (typeid(vector<boost::any>) == m["Topics"].type()) {
        vector<GetBaselineKeyPathResponseDataTopics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Topics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetBaselineKeyPathResponseDataTopics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        topics = make_shared<vector<GetBaselineKeyPathResponseDataTopics>>(expect1);
      }
    }
  }


  virtual ~GetBaselineKeyPathResponseData() = default;
};
class GetBaselineKeyPathResponse : public Darabonba::Model {
public:
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetBaselineKeyPathResponseData>> data{};

  GetBaselineKeyPathResponse() {}

  explicit GetBaselineKeyPathResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<GetBaselineKeyPathResponseData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetBaselineKeyPathResponseData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<GetBaselineKeyPathResponseData>>(expect1);
      }
    }
  }


  virtual ~GetBaselineKeyPathResponse() = default;
};
class GetRemindRequest : public Darabonba::Model {
public:
  shared_ptr<long> remindId{};

  GetRemindRequest() {}

  explicit GetRemindRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!remindId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("remindId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (remindId) {
      res["RemindId"] = boost::any(*remindId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RemindId") != m.end() && !m["RemindId"].empty()) {
      remindId = make_shared<long>(boost::any_cast<long>(m["RemindId"]));
    }
  }


  virtual ~GetRemindRequest() = default;
};
class GetRemindResponseDataRobots : public Darabonba::Model {
public:
  shared_ptr<string> webUrl{};
  shared_ptr<bool> atAll{};

  GetRemindResponseDataRobots() {}

  explicit GetRemindResponseDataRobots(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!webUrl) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("webUrl is required.")));
    }
    if (!atAll) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("atAll is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (webUrl) {
      res["WebUrl"] = boost::any(*webUrl);
    }
    if (atAll) {
      res["AtAll"] = boost::any(*atAll);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WebUrl") != m.end() && !m["WebUrl"].empty()) {
      webUrl = make_shared<string>(boost::any_cast<string>(m["WebUrl"]));
    }
    if (m.find("AtAll") != m.end() && !m["AtAll"].empty()) {
      atAll = make_shared<bool>(boost::any_cast<bool>(m["AtAll"]));
    }
  }


  virtual ~GetRemindResponseDataRobots() = default;
};
class GetRemindResponseDataNodes : public Darabonba::Model {
public:
  shared_ptr<long> nodeId{};
  shared_ptr<string> nodeName{};
  shared_ptr<string> owner{};
  shared_ptr<long> projectId{};

  GetRemindResponseDataNodes() {}

  explicit GetRemindResponseDataNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!nodeId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeId is required.")));
    }
    if (!nodeName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeName is required.")));
    }
    if (!owner) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("owner is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~GetRemindResponseDataNodes() = default;
};
class GetRemindResponseDataBaselines : public Darabonba::Model {
public:
  shared_ptr<long> baselineId{};
  shared_ptr<string> baselineName{};

  GetRemindResponseDataBaselines() {}

  explicit GetRemindResponseDataBaselines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!baselineId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("baselineId is required.")));
    }
    if (!baselineName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("baselineName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (baselineName) {
      res["BaselineName"] = boost::any(*baselineName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("BaselineName") != m.end() && !m["BaselineName"].empty()) {
      baselineName = make_shared<string>(boost::any_cast<string>(m["BaselineName"]));
    }
  }


  virtual ~GetRemindResponseDataBaselines() = default;
};
class GetRemindResponseDataProjects : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};

  GetRemindResponseDataProjects() {}

  explicit GetRemindResponseDataProjects(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~GetRemindResponseDataProjects() = default;
};
class GetRemindResponseDataBizProcesses : public Darabonba::Model {
public:
  shared_ptr<long> bizId{};
  shared_ptr<string> bizProcessName{};

  GetRemindResponseDataBizProcesses() {}

  explicit GetRemindResponseDataBizProcesses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!bizId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("bizId is required.")));
    }
    if (!bizProcessName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("bizProcessName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizProcessName) {
      res["BizProcessName"] = boost::any(*bizProcessName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<long>(boost::any_cast<long>(m["BizId"]));
    }
    if (m.find("BizProcessName") != m.end() && !m["BizProcessName"].empty()) {
      bizProcessName = make_shared<string>(boost::any_cast<string>(m["BizProcessName"]));
    }
  }


  virtual ~GetRemindResponseDataBizProcesses() = default;
};
class GetRemindResponseData : public Darabonba::Model {
public:
  shared_ptr<long> remindId{};
  shared_ptr<string> remindName{};
  shared_ptr<string> dndStart{};
  shared_ptr<string> dndEnd{};
  shared_ptr<string> remindUnit{};
  shared_ptr<string> remindType{};
  shared_ptr<string> alertUnit{};
  shared_ptr<bool> useflag{};
  shared_ptr<string> founder{};
  shared_ptr<int> alertInterval{};
  shared_ptr<string> detail{};
  shared_ptr<int> maxAlertTimes{};
  shared_ptr<vector<GetRemindResponseDataRobots>> robots{};
  shared_ptr<vector<GetRemindResponseDataNodes>> nodes{};
  shared_ptr<vector<GetRemindResponseDataBaselines>> baselines{};
  shared_ptr<vector<GetRemindResponseDataProjects>> projects{};
  shared_ptr<vector<GetRemindResponseDataBizProcesses>> bizProcesses{};
  shared_ptr<vector<string>> alertMethods{};
  shared_ptr<vector<string>> alertTargets{};

  GetRemindResponseData() {}

  explicit GetRemindResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!remindId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("remindId is required.")));
    }
    if (!remindName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("remindName is required.")));
    }
    if (!dndStart) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dndStart is required.")));
    }
    if (!dndEnd) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dndEnd is required.")));
    }
    if (!remindUnit) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("remindUnit is required.")));
    }
    if (!remindType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("remindType is required.")));
    }
    if (!alertUnit) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("alertUnit is required.")));
    }
    if (!useflag) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("useflag is required.")));
    }
    if (!founder) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("founder is required.")));
    }
    if (!alertInterval) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("alertInterval is required.")));
    }
    if (!detail) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("detail is required.")));
    }
    if (!maxAlertTimes) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("maxAlertTimes is required.")));
    }
    if (!robots) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("robots is required.")));
    }
    if (!nodes) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodes is required.")));
    }
    if (!baselines) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("baselines is required.")));
    }
    if (!projects) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projects is required.")));
    }
    if (!bizProcesses) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("bizProcesses is required.")));
    }
    if (!alertMethods) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("alertMethods is required.")));
    }
    if (!alertTargets) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("alertTargets is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (remindId) {
      res["RemindId"] = boost::any(*remindId);
    }
    if (remindName) {
      res["RemindName"] = boost::any(*remindName);
    }
    if (dndStart) {
      res["DndStart"] = boost::any(*dndStart);
    }
    if (dndEnd) {
      res["DndEnd"] = boost::any(*dndEnd);
    }
    if (remindUnit) {
      res["RemindUnit"] = boost::any(*remindUnit);
    }
    if (remindType) {
      res["RemindType"] = boost::any(*remindType);
    }
    if (alertUnit) {
      res["AlertUnit"] = boost::any(*alertUnit);
    }
    if (useflag) {
      res["Useflag"] = boost::any(*useflag);
    }
    if (founder) {
      res["Founder"] = boost::any(*founder);
    }
    if (alertInterval) {
      res["AlertInterval"] = boost::any(*alertInterval);
    }
    if (detail) {
      res["Detail"] = boost::any(*detail);
    }
    if (maxAlertTimes) {
      res["MaxAlertTimes"] = boost::any(*maxAlertTimes);
    }
    if (robots) {
      vector<boost::any> temp1;
      for(auto item1:*robots){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Robots"] = boost::any(temp1);
    }
    if (nodes) {
      vector<boost::any> temp1;
      for(auto item1:*nodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Nodes"] = boost::any(temp1);
    }
    if (baselines) {
      vector<boost::any> temp1;
      for(auto item1:*baselines){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Baselines"] = boost::any(temp1);
    }
    if (projects) {
      vector<boost::any> temp1;
      for(auto item1:*projects){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Projects"] = boost::any(temp1);
    }
    if (bizProcesses) {
      vector<boost::any> temp1;
      for(auto item1:*bizProcesses){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BizProcesses"] = boost::any(temp1);
    }
    if (alertMethods) {
      res["AlertMethods"] = boost::any(*alertMethods);
    }
    if (alertTargets) {
      res["AlertTargets"] = boost::any(*alertTargets);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RemindId") != m.end() && !m["RemindId"].empty()) {
      remindId = make_shared<long>(boost::any_cast<long>(m["RemindId"]));
    }
    if (m.find("RemindName") != m.end() && !m["RemindName"].empty()) {
      remindName = make_shared<string>(boost::any_cast<string>(m["RemindName"]));
    }
    if (m.find("DndStart") != m.end() && !m["DndStart"].empty()) {
      dndStart = make_shared<string>(boost::any_cast<string>(m["DndStart"]));
    }
    if (m.find("DndEnd") != m.end() && !m["DndEnd"].empty()) {
      dndEnd = make_shared<string>(boost::any_cast<string>(m["DndEnd"]));
    }
    if (m.find("RemindUnit") != m.end() && !m["RemindUnit"].empty()) {
      remindUnit = make_shared<string>(boost::any_cast<string>(m["RemindUnit"]));
    }
    if (m.find("RemindType") != m.end() && !m["RemindType"].empty()) {
      remindType = make_shared<string>(boost::any_cast<string>(m["RemindType"]));
    }
    if (m.find("AlertUnit") != m.end() && !m["AlertUnit"].empty()) {
      alertUnit = make_shared<string>(boost::any_cast<string>(m["AlertUnit"]));
    }
    if (m.find("Useflag") != m.end() && !m["Useflag"].empty()) {
      useflag = make_shared<bool>(boost::any_cast<bool>(m["Useflag"]));
    }
    if (m.find("Founder") != m.end() && !m["Founder"].empty()) {
      founder = make_shared<string>(boost::any_cast<string>(m["Founder"]));
    }
    if (m.find("AlertInterval") != m.end() && !m["AlertInterval"].empty()) {
      alertInterval = make_shared<int>(boost::any_cast<int>(m["AlertInterval"]));
    }
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      detail = make_shared<string>(boost::any_cast<string>(m["Detail"]));
    }
    if (m.find("MaxAlertTimes") != m.end() && !m["MaxAlertTimes"].empty()) {
      maxAlertTimes = make_shared<int>(boost::any_cast<int>(m["MaxAlertTimes"]));
    }
    if (m.find("Robots") != m.end() && !m["Robots"].empty()) {
      if (typeid(vector<boost::any>) == m["Robots"].type()) {
        vector<GetRemindResponseDataRobots> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Robots"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRemindResponseDataRobots model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        robots = make_shared<vector<GetRemindResponseDataRobots>>(expect1);
      }
    }
    if (m.find("Nodes") != m.end() && !m["Nodes"].empty()) {
      if (typeid(vector<boost::any>) == m["Nodes"].type()) {
        vector<GetRemindResponseDataNodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Nodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRemindResponseDataNodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodes = make_shared<vector<GetRemindResponseDataNodes>>(expect1);
      }
    }
    if (m.find("Baselines") != m.end() && !m["Baselines"].empty()) {
      if (typeid(vector<boost::any>) == m["Baselines"].type()) {
        vector<GetRemindResponseDataBaselines> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Baselines"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRemindResponseDataBaselines model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        baselines = make_shared<vector<GetRemindResponseDataBaselines>>(expect1);
      }
    }
    if (m.find("Projects") != m.end() && !m["Projects"].empty()) {
      if (typeid(vector<boost::any>) == m["Projects"].type()) {
        vector<GetRemindResponseDataProjects> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Projects"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRemindResponseDataProjects model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        projects = make_shared<vector<GetRemindResponseDataProjects>>(expect1);
      }
    }
    if (m.find("BizProcesses") != m.end() && !m["BizProcesses"].empty()) {
      if (typeid(vector<boost::any>) == m["BizProcesses"].type()) {
        vector<GetRemindResponseDataBizProcesses> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BizProcesses"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRemindResponseDataBizProcesses model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bizProcesses = make_shared<vector<GetRemindResponseDataBizProcesses>>(expect1);
      }
    }
    if (m.find("AlertMethods") != m.end() && !m["AlertMethods"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AlertMethods"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AlertMethods"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      alertMethods = make_shared<vector<string>>(toVec1);
    }
    if (m.find("AlertTargets") != m.end() && !m["AlertTargets"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AlertTargets"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AlertTargets"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      alertTargets = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetRemindResponseData() = default;
};
class GetRemindResponse : public Darabonba::Model {
public:
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<GetRemindResponseData> data{};

  GetRemindResponse() {}

  explicit GetRemindResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetRemindResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetRemindResponseData>(model1);
      }
    }
  }


  virtual ~GetRemindResponse() = default;
};
class GetMetaTableIntroWikiRequest : public Darabonba::Model {
public:
  shared_ptr<string> tableGuid{};
  shared_ptr<long> wikiVersion{};

  GetMetaTableIntroWikiRequest() {}

  explicit GetMetaTableIntroWikiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!tableGuid) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tableGuid is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (wikiVersion) {
      res["WikiVersion"] = boost::any(*wikiVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("WikiVersion") != m.end() && !m["WikiVersion"].empty()) {
      wikiVersion = make_shared<long>(boost::any_cast<long>(m["WikiVersion"]));
    }
  }


  virtual ~GetMetaTableIntroWikiRequest() = default;
};
class GetMetaTableIntroWikiResponseData : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<long> modifiedTime{};
  shared_ptr<string> creator{};
  shared_ptr<long> version{};
  shared_ptr<string> creatorName{};
  shared_ptr<string> content{};

  GetMetaTableIntroWikiResponseData() {}

  explicit GetMetaTableIntroWikiResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!createTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("createTime is required.")));
    }
    if (!modifiedTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("modifiedTime is required.")));
    }
    if (!creator) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("creator is required.")));
    }
    if (!version) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("version is required.")));
    }
    if (!creatorName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("creatorName is required.")));
    }
    if (!content) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("content is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    if (creatorName) {
      res["CreatorName"] = boost::any(*creatorName);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<long>(boost::any_cast<long>(m["ModifiedTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["Version"]));
    }
    if (m.find("CreatorName") != m.end() && !m["CreatorName"].empty()) {
      creatorName = make_shared<string>(boost::any_cast<string>(m["CreatorName"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
  }


  virtual ~GetMetaTableIntroWikiResponseData() = default;
};
class GetMetaTableIntroWikiResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<bool> success{};
  shared_ptr<GetMetaTableIntroWikiResponseData> data{};

  GetMetaTableIntroWikiResponse() {}

  explicit GetMetaTableIntroWikiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetMetaTableIntroWikiResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetMetaTableIntroWikiResponseData>(model1);
      }
    }
  }


  virtual ~GetMetaTableIntroWikiResponse() = default;
};
class GetBaselineStatusRequest : public Darabonba::Model {
public:
  shared_ptr<long> baselineId{};
  shared_ptr<string> bizdate{};
  shared_ptr<int> inGroupId{};

  GetBaselineStatusRequest() {}

  explicit GetBaselineStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!baselineId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("baselineId is required.")));
    }
    if (!bizdate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("bizdate is required.")));
    }
    if (!inGroupId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("inGroupId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (bizdate) {
      res["Bizdate"] = boost::any(*bizdate);
    }
    if (inGroupId) {
      res["InGroupId"] = boost::any(*inGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("Bizdate") != m.end() && !m["Bizdate"].empty()) {
      bizdate = make_shared<string>(boost::any_cast<string>(m["Bizdate"]));
    }
    if (m.find("InGroupId") != m.end() && !m["InGroupId"].empty()) {
      inGroupId = make_shared<int>(boost::any_cast<int>(m["InGroupId"]));
    }
  }


  virtual ~GetBaselineStatusRequest() = default;
};
class GetBaselineStatusResponseDataLastInstance : public Darabonba::Model {
public:
  shared_ptr<long> instanceId{};
  shared_ptr<string> status{};
  shared_ptr<long> projectId{};
  shared_ptr<string> owner{};
  shared_ptr<long> nodeId{};
  shared_ptr<long> finishTime{};
  shared_ptr<long> endCast{};
  shared_ptr<string> nodeName{};

  GetBaselineStatusResponseDataLastInstance() {}

  explicit GetBaselineStatusResponseDataLastInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!owner) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("owner is required.")));
    }
    if (!nodeId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeId is required.")));
    }
    if (!finishTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("finishTime is required.")));
    }
    if (!endCast) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("endCast is required.")));
    }
    if (!nodeName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (endCast) {
      res["EndCast"] = boost::any(*endCast);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<long>(boost::any_cast<long>(m["FinishTime"]));
    }
    if (m.find("EndCast") != m.end() && !m["EndCast"].empty()) {
      endCast = make_shared<long>(boost::any_cast<long>(m["EndCast"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
  }


  virtual ~GetBaselineStatusResponseDataLastInstance() = default;
};
class GetBaselineStatusResponseDataBlockInstance : public Darabonba::Model {
public:
  shared_ptr<long> instanceId{};
  shared_ptr<string> status{};
  shared_ptr<long> projectId{};
  shared_ptr<string> owner{};
  shared_ptr<long> nodeId{};
  shared_ptr<long> finishTime{};
  shared_ptr<long> endCast{};
  shared_ptr<string> nodeName{};

  GetBaselineStatusResponseDataBlockInstance() {}

  explicit GetBaselineStatusResponseDataBlockInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!owner) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("owner is required.")));
    }
    if (!nodeId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeId is required.")));
    }
    if (!finishTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("finishTime is required.")));
    }
    if (!endCast) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("endCast is required.")));
    }
    if (!nodeName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (endCast) {
      res["EndCast"] = boost::any(*endCast);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<long>(boost::any_cast<long>(m["FinishTime"]));
    }
    if (m.find("EndCast") != m.end() && !m["EndCast"].empty()) {
      endCast = make_shared<long>(boost::any_cast<long>(m["EndCast"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
  }


  virtual ~GetBaselineStatusResponseDataBlockInstance() = default;
};
class GetBaselineStatusResponseData : public Darabonba::Model {
public:
  shared_ptr<string> baselineName{};
  shared_ptr<long> baselineId{};
  shared_ptr<long> bizdate{};
  shared_ptr<string> owner{};
  shared_ptr<long> expTime{};
  shared_ptr<long> finishTime{};
  shared_ptr<long> endCast{};
  shared_ptr<long> slaTime{};
  shared_ptr<int> priority{};
  shared_ptr<long> projectId{};
  shared_ptr<double> buffer{};
  shared_ptr<string> status{};
  shared_ptr<string> finishStatus{};
  shared_ptr<int> inGroupId{};
  shared_ptr<GetBaselineStatusResponseDataLastInstance> lastInstance{};
  shared_ptr<GetBaselineStatusResponseDataBlockInstance> blockInstance{};

  GetBaselineStatusResponseData() {}

  explicit GetBaselineStatusResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!baselineName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("baselineName is required.")));
    }
    if (!baselineId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("baselineId is required.")));
    }
    if (!bizdate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("bizdate is required.")));
    }
    if (!owner) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("owner is required.")));
    }
    if (!expTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("expTime is required.")));
    }
    if (!finishTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("finishTime is required.")));
    }
    if (!endCast) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("endCast is required.")));
    }
    if (!slaTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("slaTime is required.")));
    }
    if (!priority) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("priority is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!buffer) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("buffer is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!finishStatus) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("finishStatus is required.")));
    }
    if (!inGroupId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("inGroupId is required.")));
    }
    if (!lastInstance) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("lastInstance is required.")));
    }
    if (!blockInstance) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("blockInstance is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineName) {
      res["BaselineName"] = boost::any(*baselineName);
    }
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (bizdate) {
      res["Bizdate"] = boost::any(*bizdate);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (expTime) {
      res["ExpTime"] = boost::any(*expTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (endCast) {
      res["EndCast"] = boost::any(*endCast);
    }
    if (slaTime) {
      res["SlaTime"] = boost::any(*slaTime);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (buffer) {
      res["Buffer"] = boost::any(*buffer);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (finishStatus) {
      res["FinishStatus"] = boost::any(*finishStatus);
    }
    if (inGroupId) {
      res["InGroupId"] = boost::any(*inGroupId);
    }
    if (lastInstance) {
      res["LastInstance"] = lastInstance ? boost::any(lastInstance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (blockInstance) {
      res["BlockInstance"] = blockInstance ? boost::any(blockInstance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineName") != m.end() && !m["BaselineName"].empty()) {
      baselineName = make_shared<string>(boost::any_cast<string>(m["BaselineName"]));
    }
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("Bizdate") != m.end() && !m["Bizdate"].empty()) {
      bizdate = make_shared<long>(boost::any_cast<long>(m["Bizdate"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ExpTime") != m.end() && !m["ExpTime"].empty()) {
      expTime = make_shared<long>(boost::any_cast<long>(m["ExpTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<long>(boost::any_cast<long>(m["FinishTime"]));
    }
    if (m.find("EndCast") != m.end() && !m["EndCast"].empty()) {
      endCast = make_shared<long>(boost::any_cast<long>(m["EndCast"]));
    }
    if (m.find("SlaTime") != m.end() && !m["SlaTime"].empty()) {
      slaTime = make_shared<long>(boost::any_cast<long>(m["SlaTime"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<int>(boost::any_cast<int>(m["Priority"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Buffer") != m.end() && !m["Buffer"].empty()) {
      buffer = make_shared<double>(boost::any_cast<double>(m["Buffer"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("FinishStatus") != m.end() && !m["FinishStatus"].empty()) {
      finishStatus = make_shared<string>(boost::any_cast<string>(m["FinishStatus"]));
    }
    if (m.find("InGroupId") != m.end() && !m["InGroupId"].empty()) {
      inGroupId = make_shared<int>(boost::any_cast<int>(m["InGroupId"]));
    }
    if (m.find("LastInstance") != m.end() && !m["LastInstance"].empty()) {
      if (typeid(map<string, boost::any>) == m["LastInstance"].type()) {
        GetBaselineStatusResponseDataLastInstance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LastInstance"]));
        lastInstance = make_shared<GetBaselineStatusResponseDataLastInstance>(model1);
      }
    }
    if (m.find("BlockInstance") != m.end() && !m["BlockInstance"].empty()) {
      if (typeid(map<string, boost::any>) == m["BlockInstance"].type()) {
        GetBaselineStatusResponseDataBlockInstance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BlockInstance"]));
        blockInstance = make_shared<GetBaselineStatusResponseDataBlockInstance>(model1);
      }
    }
  }


  virtual ~GetBaselineStatusResponseData() = default;
};
class GetBaselineStatusResponse : public Darabonba::Model {
public:
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<GetBaselineStatusResponseData> data{};

  GetBaselineStatusResponse() {}

  explicit GetBaselineStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetBaselineStatusResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetBaselineStatusResponseData>(model1);
      }
    }
  }


  virtual ~GetBaselineStatusResponse() = default;
};
class DeleteDataServiceApiRequest : public Darabonba::Model {
public:
  shared_ptr<long> tenantId{};
  shared_ptr<long> projectId{};
  shared_ptr<long> apiId{};

  DeleteDataServiceApiRequest() {}

  explicit DeleteDataServiceApiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!tenantId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tenantId is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!apiId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("apiId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<long>(boost::any_cast<long>(m["ApiId"]));
    }
  }


  virtual ~DeleteDataServiceApiRequest() = default;
};
class DeleteDataServiceApiResponse : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteDataServiceApiResponse() {}

  explicit DeleteDataServiceApiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteDataServiceApiResponse() = default;
};
class PublishDataServiceApiRequest : public Darabonba::Model {
public:
  shared_ptr<long> tenantId{};
  shared_ptr<long> projectId{};
  shared_ptr<long> apiId{};

  PublishDataServiceApiRequest() {}

  explicit PublishDataServiceApiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!tenantId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tenantId is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!apiId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("apiId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<long>(boost::any_cast<long>(m["ApiId"]));
    }
  }


  virtual ~PublishDataServiceApiRequest() = default;
};
class PublishDataServiceApiResponse : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  PublishDataServiceApiResponse() {}

  explicit PublishDataServiceApiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~PublishDataServiceApiResponse() = default;
};
class GetMetaTableLineageRequest : public Darabonba::Model {
public:
  shared_ptr<string> tableGuid{};
  shared_ptr<string> direction{};
  shared_ptr<string> nextPrimaryKey{};
  shared_ptr<int> pageSize{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> databaseName{};
  shared_ptr<string> tableName{};
  shared_ptr<string> dataSourceType{};

  GetMetaTableLineageRequest() {}

  explicit GetMetaTableLineageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!direction) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("direction is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (direction) {
      res["Direction"] = boost::any(*direction);
    }
    if (nextPrimaryKey) {
      res["NextPrimaryKey"] = boost::any(*nextPrimaryKey);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (dataSourceType) {
      res["DataSourceType"] = boost::any(*dataSourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("Direction") != m.end() && !m["Direction"].empty()) {
      direction = make_shared<string>(boost::any_cast<string>(m["Direction"]));
    }
    if (m.find("NextPrimaryKey") != m.end() && !m["NextPrimaryKey"].empty()) {
      nextPrimaryKey = make_shared<string>(boost::any_cast<string>(m["NextPrimaryKey"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("DataSourceType") != m.end() && !m["DataSourceType"].empty()) {
      dataSourceType = make_shared<string>(boost::any_cast<string>(m["DataSourceType"]));
    }
  }


  virtual ~GetMetaTableLineageRequest() = default;
};
class GetMetaTableLineageResponseDataDataEntityList : public Darabonba::Model {
public:
  shared_ptr<string> tableName{};
  shared_ptr<string> tableGuid{};

  GetMetaTableLineageResponseDataDataEntityList() {}

  explicit GetMetaTableLineageResponseDataDataEntityList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!tableName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tableName is required.")));
    }
    if (!tableGuid) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tableGuid is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
  }


  virtual ~GetMetaTableLineageResponseDataDataEntityList() = default;
};
class GetMetaTableLineageResponseData : public Darabonba::Model {
public:
  shared_ptr<bool> hasNext{};
  shared_ptr<string> nextPrimaryKey{};
  shared_ptr<vector<GetMetaTableLineageResponseDataDataEntityList>> dataEntityList{};

  GetMetaTableLineageResponseData() {}

  explicit GetMetaTableLineageResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!hasNext) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("hasNext is required.")));
    }
    if (!nextPrimaryKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nextPrimaryKey is required.")));
    }
    if (!dataEntityList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dataEntityList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hasNext) {
      res["HasNext"] = boost::any(*hasNext);
    }
    if (nextPrimaryKey) {
      res["NextPrimaryKey"] = boost::any(*nextPrimaryKey);
    }
    if (dataEntityList) {
      vector<boost::any> temp1;
      for(auto item1:*dataEntityList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataEntityList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HasNext") != m.end() && !m["HasNext"].empty()) {
      hasNext = make_shared<bool>(boost::any_cast<bool>(m["HasNext"]));
    }
    if (m.find("NextPrimaryKey") != m.end() && !m["NextPrimaryKey"].empty()) {
      nextPrimaryKey = make_shared<string>(boost::any_cast<string>(m["NextPrimaryKey"]));
    }
    if (m.find("DataEntityList") != m.end() && !m["DataEntityList"].empty()) {
      if (typeid(vector<boost::any>) == m["DataEntityList"].type()) {
        vector<GetMetaTableLineageResponseDataDataEntityList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataEntityList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMetaTableLineageResponseDataDataEntityList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataEntityList = make_shared<vector<GetMetaTableLineageResponseDataDataEntityList>>(expect1);
      }
    }
  }


  virtual ~GetMetaTableLineageResponseData() = default;
};
class GetMetaTableLineageResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<bool> success{};
  shared_ptr<GetMetaTableLineageResponseData> data{};

  GetMetaTableLineageResponse() {}

  explicit GetMetaTableLineageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetMetaTableLineageResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetMetaTableLineageResponseData>(model1);
      }
    }
  }


  virtual ~GetMetaTableLineageResponse() = default;
};
class ListBaselineStatusesRequest : public Darabonba::Model {
public:
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<string> bizdate{};
  shared_ptr<string> priority{};
  shared_ptr<string> searchText{};
  shared_ptr<string> owner{};
  shared_ptr<long> topicId{};
  shared_ptr<string> finishStatus{};
  shared_ptr<string> status{};
  shared_ptr<string> baselineTypes{};

  ListBaselineStatusesRequest() {}

  explicit ListBaselineStatusesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageNumber) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNumber is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!bizdate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("bizdate is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (bizdate) {
      res["Bizdate"] = boost::any(*bizdate);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (searchText) {
      res["SearchText"] = boost::any(*searchText);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (topicId) {
      res["TopicId"] = boost::any(*topicId);
    }
    if (finishStatus) {
      res["FinishStatus"] = boost::any(*finishStatus);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (baselineTypes) {
      res["BaselineTypes"] = boost::any(*baselineTypes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("Bizdate") != m.end() && !m["Bizdate"].empty()) {
      bizdate = make_shared<string>(boost::any_cast<string>(m["Bizdate"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("SearchText") != m.end() && !m["SearchText"].empty()) {
      searchText = make_shared<string>(boost::any_cast<string>(m["SearchText"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("TopicId") != m.end() && !m["TopicId"].empty()) {
      topicId = make_shared<long>(boost::any_cast<long>(m["TopicId"]));
    }
    if (m.find("FinishStatus") != m.end() && !m["FinishStatus"].empty()) {
      finishStatus = make_shared<string>(boost::any_cast<string>(m["FinishStatus"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("BaselineTypes") != m.end() && !m["BaselineTypes"].empty()) {
      baselineTypes = make_shared<string>(boost::any_cast<string>(m["BaselineTypes"]));
    }
  }


  virtual ~ListBaselineStatusesRequest() = default;
};
class ListBaselineStatusesResponseDataBaselineStatuses : public Darabonba::Model {
public:
  shared_ptr<string> baselineName{};
  shared_ptr<long> baselineId{};
  shared_ptr<long> bizdate{};
  shared_ptr<string> owner{};
  shared_ptr<long> expTime{};
  shared_ptr<long> finishTime{};
  shared_ptr<long> endCast{};
  shared_ptr<long> slaTime{};
  shared_ptr<int> priority{};
  shared_ptr<long> projectId{};
  shared_ptr<long> buffer{};
  shared_ptr<string> status{};
  shared_ptr<string> finishStatus{};
  shared_ptr<int> inGroupId{};

  ListBaselineStatusesResponseDataBaselineStatuses() {}

  explicit ListBaselineStatusesResponseDataBaselineStatuses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!baselineName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("baselineName is required.")));
    }
    if (!baselineId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("baselineId is required.")));
    }
    if (!bizdate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("bizdate is required.")));
    }
    if (!owner) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("owner is required.")));
    }
    if (!expTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("expTime is required.")));
    }
    if (!finishTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("finishTime is required.")));
    }
    if (!endCast) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("endCast is required.")));
    }
    if (!slaTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("slaTime is required.")));
    }
    if (!priority) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("priority is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!buffer) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("buffer is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!finishStatus) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("finishStatus is required.")));
    }
    if (!inGroupId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("inGroupId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineName) {
      res["BaselineName"] = boost::any(*baselineName);
    }
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (bizdate) {
      res["Bizdate"] = boost::any(*bizdate);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (expTime) {
      res["ExpTime"] = boost::any(*expTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (endCast) {
      res["EndCast"] = boost::any(*endCast);
    }
    if (slaTime) {
      res["SlaTime"] = boost::any(*slaTime);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (buffer) {
      res["Buffer"] = boost::any(*buffer);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (finishStatus) {
      res["FinishStatus"] = boost::any(*finishStatus);
    }
    if (inGroupId) {
      res["InGroupId"] = boost::any(*inGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineName") != m.end() && !m["BaselineName"].empty()) {
      baselineName = make_shared<string>(boost::any_cast<string>(m["BaselineName"]));
    }
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("Bizdate") != m.end() && !m["Bizdate"].empty()) {
      bizdate = make_shared<long>(boost::any_cast<long>(m["Bizdate"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ExpTime") != m.end() && !m["ExpTime"].empty()) {
      expTime = make_shared<long>(boost::any_cast<long>(m["ExpTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<long>(boost::any_cast<long>(m["FinishTime"]));
    }
    if (m.find("EndCast") != m.end() && !m["EndCast"].empty()) {
      endCast = make_shared<long>(boost::any_cast<long>(m["EndCast"]));
    }
    if (m.find("SlaTime") != m.end() && !m["SlaTime"].empty()) {
      slaTime = make_shared<long>(boost::any_cast<long>(m["SlaTime"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<int>(boost::any_cast<int>(m["Priority"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Buffer") != m.end() && !m["Buffer"].empty()) {
      buffer = make_shared<long>(boost::any_cast<long>(m["Buffer"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("FinishStatus") != m.end() && !m["FinishStatus"].empty()) {
      finishStatus = make_shared<string>(boost::any_cast<string>(m["FinishStatus"]));
    }
    if (m.find("InGroupId") != m.end() && !m["InGroupId"].empty()) {
      inGroupId = make_shared<int>(boost::any_cast<int>(m["InGroupId"]));
    }
  }


  virtual ~ListBaselineStatusesResponseDataBaselineStatuses() = default;
};
class ListBaselineStatusesResponseData : public Darabonba::Model {
public:
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> totalCount{};
  shared_ptr<vector<ListBaselineStatusesResponseDataBaselineStatuses>> baselineStatuses{};

  ListBaselineStatusesResponseData() {}

  explicit ListBaselineStatusesResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageNumber) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNumber is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!totalCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("totalCount is required.")));
    }
    if (!baselineStatuses) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("baselineStatuses is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (baselineStatuses) {
      vector<boost::any> temp1;
      for(auto item1:*baselineStatuses){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BaselineStatuses"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<int>(boost::any_cast<int>(m["TotalCount"]));
    }
    if (m.find("BaselineStatuses") != m.end() && !m["BaselineStatuses"].empty()) {
      if (typeid(vector<boost::any>) == m["BaselineStatuses"].type()) {
        vector<ListBaselineStatusesResponseDataBaselineStatuses> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BaselineStatuses"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListBaselineStatusesResponseDataBaselineStatuses model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        baselineStatuses = make_shared<vector<ListBaselineStatusesResponseDataBaselineStatuses>>(expect1);
      }
    }
  }


  virtual ~ListBaselineStatusesResponseData() = default;
};
class ListBaselineStatusesResponse : public Darabonba::Model {
public:
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<ListBaselineStatusesResponseData> data{};

  ListBaselineStatusesResponse() {}

  explicit ListBaselineStatusesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListBaselineStatusesResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListBaselineStatusesResponseData>(model1);
      }
    }
  }


  virtual ~ListBaselineStatusesResponse() = default;
};
class ListRemindsRequest : public Darabonba::Model {
public:
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<string> founder{};
  shared_ptr<long> nodeId{};
  shared_ptr<string> remindTypes{};
  shared_ptr<string> alertTarget{};
  shared_ptr<string> searchText{};

  ListRemindsRequest() {}

  explicit ListRemindsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageNumber) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNumber is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (founder) {
      res["Founder"] = boost::any(*founder);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (remindTypes) {
      res["RemindTypes"] = boost::any(*remindTypes);
    }
    if (alertTarget) {
      res["AlertTarget"] = boost::any(*alertTarget);
    }
    if (searchText) {
      res["SearchText"] = boost::any(*searchText);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("Founder") != m.end() && !m["Founder"].empty()) {
      founder = make_shared<string>(boost::any_cast<string>(m["Founder"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("RemindTypes") != m.end() && !m["RemindTypes"].empty()) {
      remindTypes = make_shared<string>(boost::any_cast<string>(m["RemindTypes"]));
    }
    if (m.find("AlertTarget") != m.end() && !m["AlertTarget"].empty()) {
      alertTarget = make_shared<string>(boost::any_cast<string>(m["AlertTarget"]));
    }
    if (m.find("SearchText") != m.end() && !m["SearchText"].empty()) {
      searchText = make_shared<string>(boost::any_cast<string>(m["SearchText"]));
    }
  }


  virtual ~ListRemindsRequest() = default;
};
class ListRemindsResponseDataReminds : public Darabonba::Model {
public:
  shared_ptr<long> remindId{};
  shared_ptr<string> remindName{};
  shared_ptr<string> dndStart{};
  shared_ptr<string> dndEnd{};
  shared_ptr<string> remindUnit{};
  shared_ptr<string> remindType{};
  shared_ptr<string> alertUnit{};
  shared_ptr<bool> useflag{};
  shared_ptr<string> founder{};
  shared_ptr<vector<long>> nodeIds{};
  shared_ptr<vector<long>> baselineIds{};
  shared_ptr<vector<long>> projectIds{};
  shared_ptr<vector<long>> bizProcessIds{};
  shared_ptr<vector<string>> alertMethods{};
  shared_ptr<vector<string>> alertTargets{};

  ListRemindsResponseDataReminds() {}

  explicit ListRemindsResponseDataReminds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!remindId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("remindId is required.")));
    }
    if (!remindName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("remindName is required.")));
    }
    if (!dndStart) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dndStart is required.")));
    }
    if (!dndEnd) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dndEnd is required.")));
    }
    if (!remindUnit) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("remindUnit is required.")));
    }
    if (!remindType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("remindType is required.")));
    }
    if (!alertUnit) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("alertUnit is required.")));
    }
    if (!useflag) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("useflag is required.")));
    }
    if (!founder) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("founder is required.")));
    }
    if (!nodeIds) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeIds is required.")));
    }
    if (!baselineIds) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("baselineIds is required.")));
    }
    if (!projectIds) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectIds is required.")));
    }
    if (!bizProcessIds) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("bizProcessIds is required.")));
    }
    if (!alertMethods) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("alertMethods is required.")));
    }
    if (!alertTargets) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("alertTargets is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (remindId) {
      res["RemindId"] = boost::any(*remindId);
    }
    if (remindName) {
      res["RemindName"] = boost::any(*remindName);
    }
    if (dndStart) {
      res["DndStart"] = boost::any(*dndStart);
    }
    if (dndEnd) {
      res["DndEnd"] = boost::any(*dndEnd);
    }
    if (remindUnit) {
      res["RemindUnit"] = boost::any(*remindUnit);
    }
    if (remindType) {
      res["RemindType"] = boost::any(*remindType);
    }
    if (alertUnit) {
      res["AlertUnit"] = boost::any(*alertUnit);
    }
    if (useflag) {
      res["Useflag"] = boost::any(*useflag);
    }
    if (founder) {
      res["Founder"] = boost::any(*founder);
    }
    if (nodeIds) {
      res["NodeIds"] = boost::any(*nodeIds);
    }
    if (baselineIds) {
      res["BaselineIds"] = boost::any(*baselineIds);
    }
    if (projectIds) {
      res["ProjectIds"] = boost::any(*projectIds);
    }
    if (bizProcessIds) {
      res["BizProcessIds"] = boost::any(*bizProcessIds);
    }
    if (alertMethods) {
      res["AlertMethods"] = boost::any(*alertMethods);
    }
    if (alertTargets) {
      res["AlertTargets"] = boost::any(*alertTargets);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RemindId") != m.end() && !m["RemindId"].empty()) {
      remindId = make_shared<long>(boost::any_cast<long>(m["RemindId"]));
    }
    if (m.find("RemindName") != m.end() && !m["RemindName"].empty()) {
      remindName = make_shared<string>(boost::any_cast<string>(m["RemindName"]));
    }
    if (m.find("DndStart") != m.end() && !m["DndStart"].empty()) {
      dndStart = make_shared<string>(boost::any_cast<string>(m["DndStart"]));
    }
    if (m.find("DndEnd") != m.end() && !m["DndEnd"].empty()) {
      dndEnd = make_shared<string>(boost::any_cast<string>(m["DndEnd"]));
    }
    if (m.find("RemindUnit") != m.end() && !m["RemindUnit"].empty()) {
      remindUnit = make_shared<string>(boost::any_cast<string>(m["RemindUnit"]));
    }
    if (m.find("RemindType") != m.end() && !m["RemindType"].empty()) {
      remindType = make_shared<string>(boost::any_cast<string>(m["RemindType"]));
    }
    if (m.find("AlertUnit") != m.end() && !m["AlertUnit"].empty()) {
      alertUnit = make_shared<string>(boost::any_cast<string>(m["AlertUnit"]));
    }
    if (m.find("Useflag") != m.end() && !m["Useflag"].empty()) {
      useflag = make_shared<bool>(boost::any_cast<bool>(m["Useflag"]));
    }
    if (m.find("Founder") != m.end() && !m["Founder"].empty()) {
      founder = make_shared<string>(boost::any_cast<string>(m["Founder"]));
    }
    if (m.find("NodeIds") != m.end() && !m["NodeIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["NodeIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NodeIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      nodeIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("BaselineIds") != m.end() && !m["BaselineIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["BaselineIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["BaselineIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      baselineIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("ProjectIds") != m.end() && !m["ProjectIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["ProjectIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ProjectIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      projectIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("BizProcessIds") != m.end() && !m["BizProcessIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["BizProcessIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["BizProcessIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      bizProcessIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("AlertMethods") != m.end() && !m["AlertMethods"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AlertMethods"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AlertMethods"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      alertMethods = make_shared<vector<string>>(toVec1);
    }
    if (m.find("AlertTargets") != m.end() && !m["AlertTargets"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AlertTargets"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AlertTargets"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      alertTargets = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListRemindsResponseDataReminds() = default;
};
class ListRemindsResponseData : public Darabonba::Model {
public:
  shared_ptr<int> pageNumber{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> totalCount{};
  shared_ptr<vector<ListRemindsResponseDataReminds>> reminds{};

  ListRemindsResponseData() {}

  explicit ListRemindsResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageNumber) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNumber is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!totalCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("totalCount is required.")));
    }
    if (!reminds) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("reminds is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (reminds) {
      vector<boost::any> temp1;
      for(auto item1:*reminds){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Reminds"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<int>(boost::any_cast<int>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<int>(boost::any_cast<int>(m["TotalCount"]));
    }
    if (m.find("Reminds") != m.end() && !m["Reminds"].empty()) {
      if (typeid(vector<boost::any>) == m["Reminds"].type()) {
        vector<ListRemindsResponseDataReminds> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Reminds"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRemindsResponseDataReminds model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        reminds = make_shared<vector<ListRemindsResponseDataReminds>>(expect1);
      }
    }
  }


  virtual ~ListRemindsResponseData() = default;
};
class ListRemindsResponse : public Darabonba::Model {
public:
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<ListRemindsResponseData> data{};

  ListRemindsResponse() {}

  explicit ListRemindsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListRemindsResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListRemindsResponseData>(model1);
      }
    }
  }


  virtual ~ListRemindsResponse() = default;
};
class DeleteQualityEntityRequest : public Darabonba::Model {
public:
  shared_ptr<long> entityId{};
  shared_ptr<string> projectName{};
  shared_ptr<string> envType{};

  DeleteQualityEntityRequest() {}

  explicit DeleteQualityEntityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!entityId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("entityId is required.")));
    }
    if (!projectName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectName is required.")));
    }
    if (!envType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("envType is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entityId) {
      res["EntityId"] = boost::any(*entityId);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EntityId") != m.end() && !m["EntityId"].empty()) {
      entityId = make_shared<long>(boost::any_cast<long>(m["EntityId"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
  }


  virtual ~DeleteQualityEntityRequest() = default;
};
class DeleteQualityEntityResponse : public Darabonba::Model {
public:
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  DeleteQualityEntityResponse() {}

  explicit DeleteQualityEntityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteQualityEntityResponse() = default;
};
class CreateQualityFollowerRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectName{};
  shared_ptr<string> follower{};
  shared_ptr<int> alarmMode{};
  shared_ptr<long> entityId{};

  CreateQualityFollowerRequest() {}

  explicit CreateQualityFollowerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectName is required.")));
    }
    if (!follower) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("follower is required.")));
    }
    if (!alarmMode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("alarmMode is required.")));
    }
    if (!entityId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("entityId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (follower) {
      res["Follower"] = boost::any(*follower);
    }
    if (alarmMode) {
      res["AlarmMode"] = boost::any(*alarmMode);
    }
    if (entityId) {
      res["EntityId"] = boost::any(*entityId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Follower") != m.end() && !m["Follower"].empty()) {
      follower = make_shared<string>(boost::any_cast<string>(m["Follower"]));
    }
    if (m.find("AlarmMode") != m.end() && !m["AlarmMode"].empty()) {
      alarmMode = make_shared<int>(boost::any_cast<int>(m["AlarmMode"]));
    }
    if (m.find("EntityId") != m.end() && !m["EntityId"].empty()) {
      entityId = make_shared<long>(boost::any_cast<long>(m["EntityId"]));
    }
  }


  virtual ~CreateQualityFollowerRequest() = default;
};
class CreateQualityFollowerResponse : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<int> data{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};

  CreateQualityFollowerResponse() {}

  explicit CreateQualityFollowerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<int>(boost::any_cast<int>(m["Data"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateQualityFollowerResponse() = default;
};
class CreateDataServiceApiRequest : public Darabonba::Model {
public:
  shared_ptr<long> tenantId{};
  shared_ptr<long> projectId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> groupId{};
  shared_ptr<int> apiMode{};
  shared_ptr<int> requestMethod{};
  shared_ptr<int> responseContentType{};
  shared_ptr<int> timeout{};
  shared_ptr<int> visibleRange{};
  shared_ptr<string> protocols{};
  shared_ptr<string> wizardDetails{};
  shared_ptr<string> scriptDetails{};
  shared_ptr<string> registrationDetails{};
  shared_ptr<string> apiPath{};
  shared_ptr<string> apiDescription{};
  shared_ptr<long> folderId{};

  CreateDataServiceApiRequest() {}

  explicit CreateDataServiceApiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!tenantId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tenantId is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!apiName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("apiName is required.")));
    }
    if (!groupId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupId is required.")));
    }
    if (!apiMode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("apiMode is required.")));
    }
    if (!requestMethod) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestMethod is required.")));
    }
    if (!responseContentType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("responseContentType is required.")));
    }
    if (!timeout) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("timeout is required.")));
    }
    if (!visibleRange) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("visibleRange is required.")));
    }
    if (!protocols) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("protocols is required.")));
    }
    if (!apiPath) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("apiPath is required.")));
    }
    if (!apiDescription) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("apiDescription is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (apiMode) {
      res["ApiMode"] = boost::any(*apiMode);
    }
    if (requestMethod) {
      res["RequestMethod"] = boost::any(*requestMethod);
    }
    if (responseContentType) {
      res["ResponseContentType"] = boost::any(*responseContentType);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (visibleRange) {
      res["VisibleRange"] = boost::any(*visibleRange);
    }
    if (protocols) {
      res["Protocols"] = boost::any(*protocols);
    }
    if (wizardDetails) {
      res["WizardDetails"] = boost::any(*wizardDetails);
    }
    if (scriptDetails) {
      res["ScriptDetails"] = boost::any(*scriptDetails);
    }
    if (registrationDetails) {
      res["RegistrationDetails"] = boost::any(*registrationDetails);
    }
    if (apiPath) {
      res["ApiPath"] = boost::any(*apiPath);
    }
    if (apiDescription) {
      res["ApiDescription"] = boost::any(*apiDescription);
    }
    if (folderId) {
      res["FolderId"] = boost::any(*folderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("ApiMode") != m.end() && !m["ApiMode"].empty()) {
      apiMode = make_shared<int>(boost::any_cast<int>(m["ApiMode"]));
    }
    if (m.find("RequestMethod") != m.end() && !m["RequestMethod"].empty()) {
      requestMethod = make_shared<int>(boost::any_cast<int>(m["RequestMethod"]));
    }
    if (m.find("ResponseContentType") != m.end() && !m["ResponseContentType"].empty()) {
      responseContentType = make_shared<int>(boost::any_cast<int>(m["ResponseContentType"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<int>(boost::any_cast<int>(m["Timeout"]));
    }
    if (m.find("VisibleRange") != m.end() && !m["VisibleRange"].empty()) {
      visibleRange = make_shared<int>(boost::any_cast<int>(m["VisibleRange"]));
    }
    if (m.find("Protocols") != m.end() && !m["Protocols"].empty()) {
      protocols = make_shared<string>(boost::any_cast<string>(m["Protocols"]));
    }
    if (m.find("WizardDetails") != m.end() && !m["WizardDetails"].empty()) {
      wizardDetails = make_shared<string>(boost::any_cast<string>(m["WizardDetails"]));
    }
    if (m.find("ScriptDetails") != m.end() && !m["ScriptDetails"].empty()) {
      scriptDetails = make_shared<string>(boost::any_cast<string>(m["ScriptDetails"]));
    }
    if (m.find("RegistrationDetails") != m.end() && !m["RegistrationDetails"].empty()) {
      registrationDetails = make_shared<string>(boost::any_cast<string>(m["RegistrationDetails"]));
    }
    if (m.find("ApiPath") != m.end() && !m["ApiPath"].empty()) {
      apiPath = make_shared<string>(boost::any_cast<string>(m["ApiPath"]));
    }
    if (m.find("ApiDescription") != m.end() && !m["ApiDescription"].empty()) {
      apiDescription = make_shared<string>(boost::any_cast<string>(m["ApiDescription"]));
    }
    if (m.find("FolderId") != m.end() && !m["FolderId"].empty()) {
      folderId = make_shared<long>(boost::any_cast<long>(m["FolderId"]));
    }
  }


  virtual ~CreateDataServiceApiRequest() = default;
};
class CreateDataServiceApiResponse : public Darabonba::Model {
public:
  shared_ptr<long> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<bool> success{};
  shared_ptr<string> requestId{};

  CreateDataServiceApiResponse() {}

  explicit CreateDataServiceApiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDataServiceApiResponse() = default;
};
class AbolishDataServiceApiRequest : public Darabonba::Model {
public:
  shared_ptr<long> tenantId{};
  shared_ptr<long> projectId{};
  shared_ptr<long> apiId{};

  AbolishDataServiceApiRequest() {}

  explicit AbolishDataServiceApiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!tenantId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tenantId is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!apiId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("apiId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<long>(boost::any_cast<long>(m["ApiId"]));
    }
  }


  virtual ~AbolishDataServiceApiRequest() = default;
};
class AbolishDataServiceApiResponse : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  AbolishDataServiceApiResponse() {}

  explicit AbolishDataServiceApiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AbolishDataServiceApiResponse() = default;
};
class GetQualityEntityRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectName{};
  shared_ptr<string> tableName{};
  shared_ptr<string> envType{};
  shared_ptr<string> matchExpression{};

  GetQualityEntityRequest() {}

  explicit GetQualityEntityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectName is required.")));
    }
    if (!tableName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tableName is required.")));
    }
    if (!envType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("envType is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (matchExpression) {
      res["MatchExpression"] = boost::any(*matchExpression);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("MatchExpression") != m.end() && !m["MatchExpression"].empty()) {
      matchExpression = make_shared<string>(boost::any_cast<string>(m["MatchExpression"]));
    }
  }


  virtual ~GetQualityEntityRequest() = default;
};
class GetQualityEntityResponseData : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> projectName{};
  shared_ptr<string> tableName{};
  shared_ptr<string> envType{};
  shared_ptr<string> matchExpression{};
  shared_ptr<int> entityLevel{};
  shared_ptr<string> onDuty{};
  shared_ptr<string> modifyUser{};
  shared_ptr<long> createTime{};
  shared_ptr<long> modifyTime{};
  shared_ptr<int> sql{};
  shared_ptr<int> task{};
  shared_ptr<string> followers{};
  shared_ptr<bool> hasRelativeNode{};
  shared_ptr<string> relativeNode{};
  shared_ptr<string> onDutyAccountName{};

  GetQualityEntityResponseData() {}

  explicit GetQualityEntityResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!id) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("id is required.")));
    }
    if (!projectName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectName is required.")));
    }
    if (!tableName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tableName is required.")));
    }
    if (!envType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("envType is required.")));
    }
    if (!matchExpression) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("matchExpression is required.")));
    }
    if (!entityLevel) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("entityLevel is required.")));
    }
    if (!onDuty) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("onDuty is required.")));
    }
    if (!modifyUser) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("modifyUser is required.")));
    }
    if (!createTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("createTime is required.")));
    }
    if (!modifyTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("modifyTime is required.")));
    }
    if (!sql) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("sql is required.")));
    }
    if (!task) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("task is required.")));
    }
    if (!followers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("followers is required.")));
    }
    if (!hasRelativeNode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("hasRelativeNode is required.")));
    }
    if (!relativeNode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("relativeNode is required.")));
    }
    if (!onDutyAccountName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("onDutyAccountName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (matchExpression) {
      res["MatchExpression"] = boost::any(*matchExpression);
    }
    if (entityLevel) {
      res["EntityLevel"] = boost::any(*entityLevel);
    }
    if (onDuty) {
      res["OnDuty"] = boost::any(*onDuty);
    }
    if (modifyUser) {
      res["ModifyUser"] = boost::any(*modifyUser);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (sql) {
      res["Sql"] = boost::any(*sql);
    }
    if (task) {
      res["Task"] = boost::any(*task);
    }
    if (followers) {
      res["Followers"] = boost::any(*followers);
    }
    if (hasRelativeNode) {
      res["HasRelativeNode"] = boost::any(*hasRelativeNode);
    }
    if (relativeNode) {
      res["RelativeNode"] = boost::any(*relativeNode);
    }
    if (onDutyAccountName) {
      res["OnDutyAccountName"] = boost::any(*onDutyAccountName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("MatchExpression") != m.end() && !m["MatchExpression"].empty()) {
      matchExpression = make_shared<string>(boost::any_cast<string>(m["MatchExpression"]));
    }
    if (m.find("EntityLevel") != m.end() && !m["EntityLevel"].empty()) {
      entityLevel = make_shared<int>(boost::any_cast<int>(m["EntityLevel"]));
    }
    if (m.find("OnDuty") != m.end() && !m["OnDuty"].empty()) {
      onDuty = make_shared<string>(boost::any_cast<string>(m["OnDuty"]));
    }
    if (m.find("ModifyUser") != m.end() && !m["ModifyUser"].empty()) {
      modifyUser = make_shared<string>(boost::any_cast<string>(m["ModifyUser"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("Sql") != m.end() && !m["Sql"].empty()) {
      sql = make_shared<int>(boost::any_cast<int>(m["Sql"]));
    }
    if (m.find("Task") != m.end() && !m["Task"].empty()) {
      task = make_shared<int>(boost::any_cast<int>(m["Task"]));
    }
    if (m.find("Followers") != m.end() && !m["Followers"].empty()) {
      followers = make_shared<string>(boost::any_cast<string>(m["Followers"]));
    }
    if (m.find("HasRelativeNode") != m.end() && !m["HasRelativeNode"].empty()) {
      hasRelativeNode = make_shared<bool>(boost::any_cast<bool>(m["HasRelativeNode"]));
    }
    if (m.find("RelativeNode") != m.end() && !m["RelativeNode"].empty()) {
      relativeNode = make_shared<string>(boost::any_cast<string>(m["RelativeNode"]));
    }
    if (m.find("OnDutyAccountName") != m.end() && !m["OnDutyAccountName"].empty()) {
      onDutyAccountName = make_shared<string>(boost::any_cast<string>(m["OnDutyAccountName"]));
    }
  }


  virtual ~GetQualityEntityResponseData() = default;
};
class GetQualityEntityResponse : public Darabonba::Model {
public:
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetQualityEntityResponseData>> data{};

  GetQualityEntityResponse() {}

  explicit GetQualityEntityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<GetQualityEntityResponseData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetQualityEntityResponseData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<GetQualityEntityResponseData>>(expect1);
      }
    }
  }


  virtual ~GetQualityEntityResponse() = default;
};
class GetQualityFollowerRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectName{};
  shared_ptr<long> entityId{};

  GetQualityFollowerRequest() {}

  explicit GetQualityFollowerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectName is required.")));
    }
    if (!entityId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("entityId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (entityId) {
      res["EntityId"] = boost::any(*entityId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("EntityId") != m.end() && !m["EntityId"].empty()) {
      entityId = make_shared<long>(boost::any_cast<long>(m["EntityId"]));
    }
  }


  virtual ~GetQualityFollowerRequest() = default;
};
class GetQualityFollowerResponseData : public Darabonba::Model {
public:
  shared_ptr<string> projectName{};
  shared_ptr<string> tableName{};
  shared_ptr<long> id{};
  shared_ptr<string> entityId{};
  shared_ptr<string> follower{};
  shared_ptr<int> alarmMode{};
  shared_ptr<string> followerAccountName{};

  GetQualityFollowerResponseData() {}

  explicit GetQualityFollowerResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectName is required.")));
    }
    if (!tableName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tableName is required.")));
    }
    if (!id) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("id is required.")));
    }
    if (!entityId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("entityId is required.")));
    }
    if (!follower) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("follower is required.")));
    }
    if (!alarmMode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("alarmMode is required.")));
    }
    if (!followerAccountName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("followerAccountName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (entityId) {
      res["EntityId"] = boost::any(*entityId);
    }
    if (follower) {
      res["Follower"] = boost::any(*follower);
    }
    if (alarmMode) {
      res["AlarmMode"] = boost::any(*alarmMode);
    }
    if (followerAccountName) {
      res["FollowerAccountName"] = boost::any(*followerAccountName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("EntityId") != m.end() && !m["EntityId"].empty()) {
      entityId = make_shared<string>(boost::any_cast<string>(m["EntityId"]));
    }
    if (m.find("Follower") != m.end() && !m["Follower"].empty()) {
      follower = make_shared<string>(boost::any_cast<string>(m["Follower"]));
    }
    if (m.find("AlarmMode") != m.end() && !m["AlarmMode"].empty()) {
      alarmMode = make_shared<int>(boost::any_cast<int>(m["AlarmMode"]));
    }
    if (m.find("FollowerAccountName") != m.end() && !m["FollowerAccountName"].empty()) {
      followerAccountName = make_shared<string>(boost::any_cast<string>(m["FollowerAccountName"]));
    }
  }


  virtual ~GetQualityFollowerResponseData() = default;
};
class GetQualityFollowerResponse : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetQualityFollowerResponseData>> data{};

  GetQualityFollowerResponse() {}

  explicit GetQualityFollowerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<GetQualityFollowerResponseData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetQualityFollowerResponseData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<GetQualityFollowerResponseData>>(expect1);
      }
    }
  }


  virtual ~GetQualityFollowerResponse() = default;
};
class DeleteQualityFollowerRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectName{};
  shared_ptr<long> followerId{};

  DeleteQualityFollowerRequest() {}

  explicit DeleteQualityFollowerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectName is required.")));
    }
    if (!followerId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("followerId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (followerId) {
      res["FollowerId"] = boost::any(*followerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("FollowerId") != m.end() && !m["FollowerId"].empty()) {
      followerId = make_shared<long>(boost::any_cast<long>(m["FollowerId"]));
    }
  }


  virtual ~DeleteQualityFollowerRequest() = default;
};
class DeleteQualityFollowerResponse : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<bool> data{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};

  DeleteQualityFollowerResponse() {}

  explicit DeleteQualityFollowerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteQualityFollowerResponse() = default;
};
class CreateQualityEntityRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectName{};
  shared_ptr<string> tableName{};
  shared_ptr<string> envType{};
  shared_ptr<string> matchExpression{};
  shared_ptr<int> entityLevel{};

  CreateQualityEntityRequest() {}

  explicit CreateQualityEntityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectName is required.")));
    }
    if (!tableName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tableName is required.")));
    }
    if (!envType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("envType is required.")));
    }
    if (!matchExpression) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("matchExpression is required.")));
    }
    if (!entityLevel) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("entityLevel is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (matchExpression) {
      res["MatchExpression"] = boost::any(*matchExpression);
    }
    if (entityLevel) {
      res["EntityLevel"] = boost::any(*entityLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("MatchExpression") != m.end() && !m["MatchExpression"].empty()) {
      matchExpression = make_shared<string>(boost::any_cast<string>(m["MatchExpression"]));
    }
    if (m.find("EntityLevel") != m.end() && !m["EntityLevel"].empty()) {
      entityLevel = make_shared<int>(boost::any_cast<int>(m["EntityLevel"]));
    }
  }


  virtual ~CreateQualityEntityRequest() = default;
};
class CreateQualityEntityResponse : public Darabonba::Model {
public:
  shared_ptr<bool> success{};
  shared_ptr<int> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};

  CreateQualityEntityResponse() {}

  explicit CreateQualityEntityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<int>(boost::any_cast<int>(m["Data"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateQualityEntityResponse() = default;
};
class CreateQualityRuleRequest : public Darabonba::Model {
public:
  shared_ptr<int> blockType{};
  shared_ptr<long> entityId{};
  shared_ptr<string> comment{};
  shared_ptr<int> checker{};
  shared_ptr<string> expectValue{};
  shared_ptr<string> trend{};
  shared_ptr<string> methodName{};
  shared_ptr<string> operator_{};
  shared_ptr<string> projectName{};
  shared_ptr<string> property{};
  shared_ptr<string> propertyType{};
  shared_ptr<int> ruleType{};
  shared_ptr<string> whereCondition{};
  shared_ptr<string> criticalThreshold{};
  shared_ptr<string> warningThreshold{};
  shared_ptr<int> templateId{};
  shared_ptr<string> ruleName{};
  shared_ptr<int> predictType{};

  CreateQualityRuleRequest() {}

  explicit CreateQualityRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!blockType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("blockType is required.")));
    }
    if (!entityId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("entityId is required.")));
    }
    if (!projectName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectName is required.")));
    }
    if (!ruleType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleType is required.")));
    }
    if (!ruleName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleName is required.")));
    }
    if (!predictType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("predictType is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockType) {
      res["BlockType"] = boost::any(*blockType);
    }
    if (entityId) {
      res["EntityId"] = boost::any(*entityId);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (checker) {
      res["Checker"] = boost::any(*checker);
    }
    if (expectValue) {
      res["ExpectValue"] = boost::any(*expectValue);
    }
    if (trend) {
      res["Trend"] = boost::any(*trend);
    }
    if (methodName) {
      res["MethodName"] = boost::any(*methodName);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (property) {
      res["Property"] = boost::any(*property);
    }
    if (propertyType) {
      res["PropertyType"] = boost::any(*propertyType);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    if (whereCondition) {
      res["WhereCondition"] = boost::any(*whereCondition);
    }
    if (criticalThreshold) {
      res["CriticalThreshold"] = boost::any(*criticalThreshold);
    }
    if (warningThreshold) {
      res["WarningThreshold"] = boost::any(*warningThreshold);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (predictType) {
      res["PredictType"] = boost::any(*predictType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockType") != m.end() && !m["BlockType"].empty()) {
      blockType = make_shared<int>(boost::any_cast<int>(m["BlockType"]));
    }
    if (m.find("EntityId") != m.end() && !m["EntityId"].empty()) {
      entityId = make_shared<long>(boost::any_cast<long>(m["EntityId"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Checker") != m.end() && !m["Checker"].empty()) {
      checker = make_shared<int>(boost::any_cast<int>(m["Checker"]));
    }
    if (m.find("ExpectValue") != m.end() && !m["ExpectValue"].empty()) {
      expectValue = make_shared<string>(boost::any_cast<string>(m["ExpectValue"]));
    }
    if (m.find("Trend") != m.end() && !m["Trend"].empty()) {
      trend = make_shared<string>(boost::any_cast<string>(m["Trend"]));
    }
    if (m.find("MethodName") != m.end() && !m["MethodName"].empty()) {
      methodName = make_shared<string>(boost::any_cast<string>(m["MethodName"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Property") != m.end() && !m["Property"].empty()) {
      property = make_shared<string>(boost::any_cast<string>(m["Property"]));
    }
    if (m.find("PropertyType") != m.end() && !m["PropertyType"].empty()) {
      propertyType = make_shared<string>(boost::any_cast<string>(m["PropertyType"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<int>(boost::any_cast<int>(m["RuleType"]));
    }
    if (m.find("WhereCondition") != m.end() && !m["WhereCondition"].empty()) {
      whereCondition = make_shared<string>(boost::any_cast<string>(m["WhereCondition"]));
    }
    if (m.find("CriticalThreshold") != m.end() && !m["CriticalThreshold"].empty()) {
      criticalThreshold = make_shared<string>(boost::any_cast<string>(m["CriticalThreshold"]));
    }
    if (m.find("WarningThreshold") != m.end() && !m["WarningThreshold"].empty()) {
      warningThreshold = make_shared<string>(boost::any_cast<string>(m["WarningThreshold"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<int>(boost::any_cast<int>(m["TemplateId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("PredictType") != m.end() && !m["PredictType"].empty()) {
      predictType = make_shared<int>(boost::any_cast<int>(m["PredictType"]));
    }
  }


  virtual ~CreateQualityRuleRequest() = default;
};
class CreateQualityRuleResponse : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> data{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};

  CreateQualityRuleResponse() {}

  explicit CreateQualityRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateQualityRuleResponse() = default;
};
class UpdateQualityFollowerRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectName{};
  shared_ptr<long> followerId{};
  shared_ptr<string> follower{};
  shared_ptr<int> alarmMode{};

  UpdateQualityFollowerRequest() {}

  explicit UpdateQualityFollowerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!projectName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectName is required.")));
    }
    if (!followerId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("followerId is required.")));
    }
    if (!follower) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("follower is required.")));
    }
    if (!alarmMode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("alarmMode is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (followerId) {
      res["FollowerId"] = boost::any(*followerId);
    }
    if (follower) {
      res["Follower"] = boost::any(*follower);
    }
    if (alarmMode) {
      res["AlarmMode"] = boost::any(*alarmMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("FollowerId") != m.end() && !m["FollowerId"].empty()) {
      followerId = make_shared<long>(boost::any_cast<long>(m["FollowerId"]));
    }
    if (m.find("Follower") != m.end() && !m["Follower"].empty()) {
      follower = make_shared<string>(boost::any_cast<string>(m["Follower"]));
    }
    if (m.find("AlarmMode") != m.end() && !m["AlarmMode"].empty()) {
      alarmMode = make_shared<int>(boost::any_cast<int>(m["AlarmMode"]));
    }
  }


  virtual ~UpdateQualityFollowerRequest() = default;
};
class UpdateQualityFollowerResponse : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<bool> data{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<string> requestId{};

  UpdateQualityFollowerResponse() {}

  explicit UpdateQualityFollowerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateQualityFollowerResponse() = default;
};
class CreateQualityRelativeNodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> envType{};
  shared_ptr<string> matchExpression{};
  shared_ptr<long> nodeId{};
  shared_ptr<long> projectId{};
  shared_ptr<string> targetNodeProjectName{};
  shared_ptr<string> projectName{};
  shared_ptr<string> tableName{};
  shared_ptr<long> targetNodeProjectId{};

  CreateQualityRelativeNodeRequest() {}

  explicit CreateQualityRelativeNodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!envType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("envType is required.")));
    }
    if (!matchExpression) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("matchExpression is required.")));
    }
    if (!nodeId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeId is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!targetNodeProjectName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("targetNodeProjectName is required.")));
    }
    if (!projectName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectName is required.")));
    }
    if (!tableName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tableName is required.")));
    }
    if (!targetNodeProjectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("targetNodeProjectId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (matchExpression) {
      res["MatchExpression"] = boost::any(*matchExpression);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (targetNodeProjectName) {
      res["TargetNodeProjectName"] = boost::any(*targetNodeProjectName);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (targetNodeProjectId) {
      res["TargetNodeProjectId"] = boost::any(*targetNodeProjectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("MatchExpression") != m.end() && !m["MatchExpression"].empty()) {
      matchExpression = make_shared<string>(boost::any_cast<string>(m["MatchExpression"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TargetNodeProjectName") != m.end() && !m["TargetNodeProjectName"].empty()) {
      targetNodeProjectName = make_shared<string>(boost::any_cast<string>(m["TargetNodeProjectName"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("TargetNodeProjectId") != m.end() && !m["TargetNodeProjectId"].empty()) {
      targetNodeProjectId = make_shared<long>(boost::any_cast<long>(m["TargetNodeProjectId"]));
    }
  }


  virtual ~CreateQualityRelativeNodeRequest() = default;
};
class CreateQualityRelativeNodeResponse : public Darabonba::Model {
public:
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  CreateQualityRelativeNodeResponse() {}

  explicit CreateQualityRelativeNodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateQualityRelativeNodeResponse() = default;
};
class DeleteQualityRelativeNodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> envType{};
  shared_ptr<string> matchExpression{};
  shared_ptr<long> nodeId{};
  shared_ptr<long> projectId{};
  shared_ptr<string> targetNodeProjectName{};
  shared_ptr<string> projectName{};
  shared_ptr<string> tableName{};
  shared_ptr<long> targetNodeProjectId{};

  DeleteQualityRelativeNodeRequest() {}

  explicit DeleteQualityRelativeNodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!envType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("envType is required.")));
    }
    if (!matchExpression) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("matchExpression is required.")));
    }
    if (!nodeId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeId is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
    if (!targetNodeProjectName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("targetNodeProjectName is required.")));
    }
    if (!projectName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectName is required.")));
    }
    if (!tableName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tableName is required.")));
    }
    if (!targetNodeProjectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("targetNodeProjectId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (matchExpression) {
      res["MatchExpression"] = boost::any(*matchExpression);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (targetNodeProjectName) {
      res["TargetNodeProjectName"] = boost::any(*targetNodeProjectName);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (targetNodeProjectId) {
      res["TargetNodeProjectId"] = boost::any(*targetNodeProjectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("MatchExpression") != m.end() && !m["MatchExpression"].empty()) {
      matchExpression = make_shared<string>(boost::any_cast<string>(m["MatchExpression"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TargetNodeProjectName") != m.end() && !m["TargetNodeProjectName"].empty()) {
      targetNodeProjectName = make_shared<string>(boost::any_cast<string>(m["TargetNodeProjectName"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("TargetNodeProjectId") != m.end() && !m["TargetNodeProjectId"].empty()) {
      targetNodeProjectId = make_shared<long>(boost::any_cast<long>(m["TargetNodeProjectId"]));
    }
  }


  virtual ~DeleteQualityRelativeNodeRequest() = default;
};
class DeleteQualityRelativeNodeResponse : public Darabonba::Model {
public:
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> httpStatusCode{};
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  DeleteQualityRelativeNodeResponse() {}

  explicit DeleteQualityRelativeNodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorCode is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!httpStatusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("httpStatusCode is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<int>(boost::any_cast<int>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteQualityRelativeNodeResponse() = default;
};
class Client : Alibabacloud_RPC::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_RPC::Config>& config);
  GenerateDISyncTaskConfigForCreatingResponse generateDISyncTaskConfigForCreating(shared_ptr<GenerateDISyncTaskConfigForCreatingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GenerateDISyncTaskConfigForCreatingResponse generateDISyncTaskConfigForCreatingSimply(shared_ptr<GenerateDISyncTaskConfigForCreatingRequest> request);
  GenerateDISyncTaskConfigForUpdatingResponse generateDISyncTaskConfigForUpdating(shared_ptr<GenerateDISyncTaskConfigForUpdatingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GenerateDISyncTaskConfigForUpdatingResponse generateDISyncTaskConfigForUpdatingSimply(shared_ptr<GenerateDISyncTaskConfigForUpdatingRequest> request);
  QueryDISyncTaskConfigProcessResultResponse queryDISyncTaskConfigProcessResult(shared_ptr<QueryDISyncTaskConfigProcessResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDISyncTaskConfigProcessResultResponse queryDISyncTaskConfigProcessResultSimply(shared_ptr<QueryDISyncTaskConfigProcessResultRequest> request);
  ListProjectIdsResponse listProjectIds(shared_ptr<ListProjectIdsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListProjectIdsResponse listProjectIdsSimply(shared_ptr<ListProjectIdsRequest> request);
  TerminateDISyncInstanceResponse terminateDISyncInstance(shared_ptr<TerminateDISyncInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TerminateDISyncInstanceResponse terminateDISyncInstanceSimply(shared_ptr<TerminateDISyncInstanceRequest> request);
  DeleteDISyncTaskResponse deleteDISyncTask(shared_ptr<DeleteDISyncTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDISyncTaskResponse deleteDISyncTaskSimply(shared_ptr<DeleteDISyncTaskRequest> request);
  DeployDISyncTaskResponse deployDISyncTask(shared_ptr<DeployDISyncTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeployDISyncTaskResponse deployDISyncTaskSimply(shared_ptr<DeployDISyncTaskRequest> request);
  StartDISyncInstanceResponse startDISyncInstance(shared_ptr<StartDISyncInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartDISyncInstanceResponse startDISyncInstanceSimply(shared_ptr<StartDISyncInstanceRequest> request);
  GetDISyncInstanceInfoResponse getDISyncInstanceInfo(shared_ptr<GetDISyncInstanceInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDISyncInstanceInfoResponse getDISyncInstanceInfoSimply(shared_ptr<GetDISyncInstanceInfoRequest> request);
  StopDISyncInstanceResponse stopDISyncInstance(shared_ptr<StopDISyncInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopDISyncInstanceResponse stopDISyncInstanceSimply(shared_ptr<StopDISyncInstanceRequest> request);
  GetDISyncTaskResponse getDISyncTask(shared_ptr<GetDISyncTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDISyncTaskResponse getDISyncTaskSimply(shared_ptr<GetDISyncTaskRequest> request);
  CheckMetaTableTaskResponse checkMetaTableTask(shared_ptr<CheckMetaTableTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckMetaTableTaskResponse checkMetaTableTaskSimply(shared_ptr<CheckMetaTableTaskRequest> request);
  CheckEngineMetaPartitionResponse checkEngineMetaPartition(shared_ptr<CheckEngineMetaPartitionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckEngineMetaPartitionResponse checkEngineMetaPartitionSimply(shared_ptr<CheckEngineMetaPartitionRequest> request);
  CheckEngineMetaTableResponse checkEngineMetaTable(shared_ptr<CheckEngineMetaTableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckEngineMetaTableResponse checkEngineMetaTableSimply(shared_ptr<CheckEngineMetaTableRequest> request);
  ImportDataSourcesResponse importDataSources(shared_ptr<ImportDataSourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ImportDataSourcesResponse importDataSourcesSimply(shared_ptr<ImportDataSourcesRequest> request);
  ExportDataSourcesResponse exportDataSources(shared_ptr<ExportDataSourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExportDataSourcesResponse exportDataSourcesSimply(shared_ptr<ExportDataSourcesRequest> request);
  GetDataSourceMetaResponse getDataSourceMeta(shared_ptr<GetDataSourceMetaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDataSourceMetaResponse getDataSourceMetaSimply(shared_ptr<GetDataSourceMetaRequest> request);
  SetDataSourceShareResponse setDataSourceShare(shared_ptr<SetDataSourceShareRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetDataSourceShareResponse setDataSourceShareSimply(shared_ptr<SetDataSourceShareRequest> request);
  ListDIProjectConfigResponse listDIProjectConfig(shared_ptr<ListDIProjectConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDIProjectConfigResponse listDIProjectConfigSimply(shared_ptr<ListDIProjectConfigRequest> request);
  ExportConnectionsResponse exportConnections(shared_ptr<ExportConnectionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExportConnectionsResponse exportConnectionsSimply(shared_ptr<ExportConnectionsRequest> request);
  ListRefDISyncTasksResponse listRefDISyncTasks(shared_ptr<ListRefDISyncTasksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRefDISyncTasksResponse listRefDISyncTasksSimply(shared_ptr<ListRefDISyncTasksRequest> request);
  SetConnectionShareResponse setConnectionShare(shared_ptr<SetConnectionShareRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetConnectionShareResponse setConnectionShareSimply(shared_ptr<SetConnectionShareRequest> request);
  ImportConnectionsResponse importConnections(shared_ptr<ImportConnectionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ImportConnectionsResponse importConnectionsSimply(shared_ptr<ImportConnectionsRequest> request);
  GetConnectionMetaResponse getConnectionMeta(shared_ptr<GetConnectionMetaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetConnectionMetaResponse getConnectionMetaSimply(shared_ptr<GetConnectionMetaRequest> request);
  UpdateDIProjectConfigResponse updateDIProjectConfig(shared_ptr<UpdateDIProjectConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDIProjectConfigResponse updateDIProjectConfigSimply(shared_ptr<UpdateDIProjectConfigRequest> request);
  CreateDISyncTaskResponse createDISyncTask(shared_ptr<CreateDISyncTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDISyncTaskResponse createDISyncTaskSimply(shared_ptr<CreateDISyncTaskRequest> request);
  UpdateDISyncTaskResponse updateDISyncTask(shared_ptr<UpdateDISyncTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDISyncTaskResponse updateDISyncTaskSimply(shared_ptr<UpdateDISyncTaskRequest> request);
  TestNetworkConnectionResponse testNetworkConnection(shared_ptr<TestNetworkConnectionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TestNetworkConnectionResponse testNetworkConnectionSimply(shared_ptr<TestNetworkConnectionRequest> request);
  UpdateNodeRunModeResponse updateNodeRunMode(shared_ptr<UpdateNodeRunModeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateNodeRunModeResponse updateNodeRunModeSimply(shared_ptr<UpdateNodeRunModeRequest> request);
  UpdateNodeOwnerResponse updateNodeOwner(shared_ptr<UpdateNodeOwnerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateNodeOwnerResponse updateNodeOwnerSimply(shared_ptr<UpdateNodeOwnerRequest> request);
  QueryPublicModelEngineResponse queryPublicModelEngine(shared_ptr<QueryPublicModelEngineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryPublicModelEngineResponse queryPublicModelEngineSimply(shared_ptr<QueryPublicModelEngineRequest> request);
  DeleteViewResponse deleteView(shared_ptr<DeleteViewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteViewResponse deleteViewSimply(shared_ptr<DeleteViewRequest> request);
  CreateViewResponse createView(shared_ptr<CreateViewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateViewResponse createViewSimply(shared_ptr<CreateViewRequest> request);
  CheckFileDeploymentResponse checkFileDeployment(shared_ptr<CheckFileDeploymentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckFileDeploymentResponse checkFileDeploymentSimply(shared_ptr<CheckFileDeploymentRequest> request);
  ImportDISyncTasksResponse importDISyncTasks(shared_ptr<ImportDISyncTasksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ImportDISyncTasksResponse importDISyncTasksSimply(shared_ptr<ImportDISyncTasksRequest> request);
  ExportDISyncTasksResponse exportDISyncTasks(shared_ptr<ExportDISyncTasksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExportDISyncTasksResponse exportDISyncTasksSimply(shared_ptr<ExportDISyncTasksRequest> request);
  ListDISyncTasksResponse listDISyncTasks(shared_ptr<ListDISyncTasksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDISyncTasksResponse listDISyncTasksSimply(shared_ptr<ListDISyncTasksRequest> request);
  RevokeColumnPermissionResponse revokeColumnPermission(shared_ptr<RevokeColumnPermissionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RevokeColumnPermissionResponse revokeColumnPermissionSimply(shared_ptr<RevokeColumnPermissionRequest> request);
  RevokeTablePermissionResponse revokeTablePermission(shared_ptr<RevokeTablePermissionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RevokeTablePermissionResponse revokeTablePermissionSimply(shared_ptr<RevokeTablePermissionRequest> request);
  GetMetaTableThemeLevelResponse getMetaTableThemeLevel(shared_ptr<GetMetaTableThemeLevelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMetaTableThemeLevelResponse getMetaTableThemeLevelSimply(shared_ptr<GetMetaTableThemeLevelRequest> request);
  GetPermissionApplyOrderDetailResponse getPermissionApplyOrderDetail(shared_ptr<GetPermissionApplyOrderDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPermissionApplyOrderDetailResponse getPermissionApplyOrderDetailSimply(shared_ptr<GetPermissionApplyOrderDetailRequest> request);
  ListPermissionApplyOrdersResponse listPermissionApplyOrders(shared_ptr<ListPermissionApplyOrdersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPermissionApplyOrdersResponse listPermissionApplyOrdersSimply(shared_ptr<ListPermissionApplyOrdersRequest> request);
  CreatePermissionApplyOrderResponse createPermissionApplyOrder(shared_ptr<CreatePermissionApplyOrderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreatePermissionApplyOrderResponse createPermissionApplyOrderSimply(shared_ptr<CreatePermissionApplyOrderRequest> request);
  ApprovePermissionApplyOrderResponse approvePermissionApplyOrder(shared_ptr<ApprovePermissionApplyOrderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ApprovePermissionApplyOrderResponse approvePermissionApplyOrderSimply(shared_ptr<ApprovePermissionApplyOrderRequest> request);
  ListSuccessInstanceAmountResponse listSuccessInstanceAmount(shared_ptr<ListSuccessInstanceAmountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSuccessInstanceAmountResponse listSuccessInstanceAmountSimply(shared_ptr<ListSuccessInstanceAmountRequest> request);
  ListFileTypeResponse listFileType(shared_ptr<ListFileTypeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFileTypeResponse listFileTypeSimply(shared_ptr<ListFileTypeRequest> request);
  ListInstanceAmountResponse listInstanceAmount(shared_ptr<ListInstanceAmountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListInstanceAmountResponse listInstanceAmountSimply(shared_ptr<ListInstanceAmountRequest> request);
  ListDataSourcesResponse listDataSources(shared_ptr<ListDataSourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDataSourcesResponse listDataSourcesSimply(shared_ptr<ListDataSourcesRequest> request);
  ListNodesByBaselineResponse listNodesByBaseline(shared_ptr<ListNodesByBaselineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListNodesByBaselineResponse listNodesByBaselineSimply(shared_ptr<ListNodesByBaselineRequest> request);
  ListManualDagInstancesResponse listManualDagInstances(shared_ptr<ListManualDagInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListManualDagInstancesResponse listManualDagInstancesSimply(shared_ptr<ListManualDagInstancesRequest> request);
  GetInstanceStatusStatisticResponse getInstanceStatusStatistic(shared_ptr<GetInstanceStatusStatisticRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetInstanceStatusStatisticResponse getInstanceStatusStatisticSimply(shared_ptr<GetInstanceStatusStatisticRequest> request);
  DeleteDataSourceResponse deleteDataSource(shared_ptr<DeleteDataSourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDataSourceResponse deleteDataSourceSimply(shared_ptr<DeleteDataSourceRequest> request);
  CreateDataSourceResponse createDataSource(shared_ptr<CreateDataSourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDataSourceResponse createDataSourceSimply(shared_ptr<CreateDataSourceRequest> request);
  TopTenErrorTimesInstanceResponse topTenErrorTimesInstance(shared_ptr<TopTenErrorTimesInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TopTenErrorTimesInstanceResponse topTenErrorTimesInstanceSimply(shared_ptr<TopTenErrorTimesInstanceRequest> request);
  TopTenElapsedTimeInstanceResponse topTenElapsedTimeInstance(shared_ptr<TopTenElapsedTimeInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TopTenElapsedTimeInstanceResponse topTenElapsedTimeInstanceSimply(shared_ptr<TopTenElapsedTimeInstanceRequest> request);
  GetProjectResponse getProject(shared_ptr<GetProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetProjectResponse getProjectSimply(shared_ptr<GetProjectRequest> request);
  ListNodesByOutputResponse listNodesByOutput(shared_ptr<ListNodesByOutputRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListNodesByOutputResponse listNodesByOutputSimply(shared_ptr<ListNodesByOutputRequest> request);
  GetFileTypeStatisticResponse getFileTypeStatistic(shared_ptr<GetFileTypeStatisticRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetFileTypeStatisticResponse getFileTypeStatisticSimply(shared_ptr<GetFileTypeStatisticRequest> request);
  RunSmokeTestResponse runSmokeTest(shared_ptr<RunSmokeTestRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunSmokeTestResponse runSmokeTestSimply(shared_ptr<RunSmokeTestRequest> request);
  ListNodeInputOrOutputResponse listNodeInputOrOutput(shared_ptr<ListNodeInputOrOutputRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListNodeInputOrOutputResponse listNodeInputOrOutputSimply(shared_ptr<ListNodeInputOrOutputRequest> request);
  RunCycleDagNodesResponse runCycleDagNodes(shared_ptr<RunCycleDagNodesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunCycleDagNodesResponse runCycleDagNodesSimply(shared_ptr<RunCycleDagNodesRequest> request);
  RunManualDagNodesResponse runManualDagNodes(shared_ptr<RunManualDagNodesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunManualDagNodesResponse runManualDagNodesSimply(shared_ptr<RunManualDagNodesRequest> request);
  UpdateDataSourceResponse updateDataSource(shared_ptr<UpdateDataSourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDataSourceResponse updateDataSourceSimply(shared_ptr<UpdateDataSourceRequest> request);
  UpdateTableAddColumnResponse updateTableAddColumn(shared_ptr<UpdateTableAddColumnRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateTableAddColumnResponse updateTableAddColumnSimply(shared_ptr<UpdateTableAddColumnRequest> request);
  GetMigrationProcessResponse getMigrationProcess(shared_ptr<GetMigrationProcessRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMigrationProcessResponse getMigrationProcessSimply(shared_ptr<GetMigrationProcessRequest> request);
  CreateImportMigrationResponse createImportMigration(shared_ptr<CreateImportMigrationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateImportMigrationResponse createImportMigrationSimply(shared_ptr<CreateImportMigrationRequest> request);
  CreateImportMigrationResponse createImportMigrationAdvance(shared_ptr<CreateImportMigrationAdvanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartMigrationResponse startMigration(shared_ptr<StartMigrationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartMigrationResponse startMigrationSimply(shared_ptr<StartMigrationRequest> request);
  GetNodeParentsResponse getNodeParents(shared_ptr<GetNodeParentsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetNodeParentsResponse getNodeParentsSimply(shared_ptr<GetNodeParentsRequest> request);
  GetNodeChildrenResponse getNodeChildren(shared_ptr<GetNodeChildrenRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetNodeChildrenResponse getNodeChildrenSimply(shared_ptr<GetNodeChildrenRequest> request);
  GetSensitiveDataResponse getSensitiveData(shared_ptr<GetSensitiveDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSensitiveDataResponse getSensitiveDataSimply(shared_ptr<GetSensitiveDataRequest> request);
  DesensitizeDataResponse desensitizeData(shared_ptr<DesensitizeDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DesensitizeDataResponse desensitizeDataSimply(shared_ptr<DesensitizeDataRequest> request);
  GetOpRiskDataResponse getOpRiskData(shared_ptr<GetOpRiskDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetOpRiskDataResponse getOpRiskDataSimply(shared_ptr<GetOpRiskDataRequest> request);
  ScanSensitiveDataResponse scanSensitiveData(shared_ptr<ScanSensitiveDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ScanSensitiveDataResponse scanSensitiveDataSimply(shared_ptr<ScanSensitiveDataRequest> request);
  GetOpSensitiveDataResponse getOpSensitiveData(shared_ptr<GetOpSensitiveDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetOpSensitiveDataResponse getOpSensitiveDataSimply(shared_ptr<GetOpSensitiveDataRequest> request);
  CreateBusinessResponse createBusiness(shared_ptr<CreateBusinessRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateBusinessResponse createBusinessSimply(shared_ptr<CreateBusinessRequest> request);
  RunTriggerNodeResponse runTriggerNode(shared_ptr<RunTriggerNodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunTriggerNodeResponse runTriggerNodeSimply(shared_ptr<RunTriggerNodeRequest> request);
  GetDagResponse getDag(shared_ptr<GetDagRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDagResponse getDagSimply(shared_ptr<GetDagRequest> request);
  SearchNodesByOutputResponse searchNodesByOutput(shared_ptr<SearchNodesByOutputRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchNodesByOutputResponse searchNodesByOutputSimply(shared_ptr<SearchNodesByOutputRequest> request);
  GetManualDagInstancesResponse getManualDagInstances(shared_ptr<GetManualDagInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetManualDagInstancesResponse getManualDagInstancesSimply(shared_ptr<GetManualDagInstancesRequest> request);
  CreateManualDagResponse createManualDag(shared_ptr<CreateManualDagRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateManualDagResponse createManualDagSimply(shared_ptr<CreateManualDagRequest> request);
  ListQualityResultsByEntityResponse listQualityResultsByEntity(shared_ptr<ListQualityResultsByEntityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListQualityResultsByEntityResponse listQualityResultsByEntitySimply(shared_ptr<ListQualityResultsByEntityRequest> request);
  GetNodeTypeListInfoResponse getNodeTypeListInfo(shared_ptr<GetNodeTypeListInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetNodeTypeListInfoResponse getNodeTypeListInfoSimply(shared_ptr<GetNodeTypeListInfoRequest> request);
  GetInstanceStatusCountResponse getInstanceStatusCount(shared_ptr<GetInstanceStatusCountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetInstanceStatusCountResponse getInstanceStatusCountSimply(shared_ptr<GetInstanceStatusCountRequest> request);
  ListDataServiceFoldersResponse listDataServiceFolders(shared_ptr<ListDataServiceFoldersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDataServiceFoldersResponse listDataServiceFoldersSimply(shared_ptr<ListDataServiceFoldersRequest> request);
  ListQualityResultsByRuleResponse listQualityResultsByRule(shared_ptr<ListQualityResultsByRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListQualityResultsByRuleResponse listQualityResultsByRuleSimply(shared_ptr<ListQualityResultsByRuleRequest> request);
  ListMetaDBResponse listMetaDB(shared_ptr<ListMetaDBRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMetaDBResponse listMetaDBSimply(shared_ptr<ListMetaDBRequest> request);
  CreateTableResponse createTable(shared_ptr<CreateTableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateTableResponse createTableSimply(shared_ptr<CreateTableRequest> request);
  CreateTableThemeResponse createTableTheme(shared_ptr<CreateTableThemeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateTableThemeResponse createTableThemeSimply(shared_ptr<CreateTableThemeRequest> request);
  GetInstanceErrorRankResponse getInstanceErrorRank(shared_ptr<GetInstanceErrorRankRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetInstanceErrorRankResponse getInstanceErrorRankSimply(shared_ptr<GetInstanceErrorRankRequest> request);
  GetDDLJobStatusResponse getDDLJobStatus(shared_ptr<GetDDLJobStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDDLJobStatusResponse getDDLJobStatusSimply(shared_ptr<GetDDLJobStatusRequest> request);
  GetInstanceConsumeTimeRankResponse getInstanceConsumeTimeRank(shared_ptr<GetInstanceConsumeTimeRankRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetInstanceConsumeTimeRankResponse getInstanceConsumeTimeRankSimply(shared_ptr<GetInstanceConsumeTimeRankRequest> request);
  CreateDataServiceApiAuthorityResponse createDataServiceApiAuthority(shared_ptr<CreateDataServiceApiAuthorityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDataServiceApiAuthorityResponse createDataServiceApiAuthoritySimply(shared_ptr<CreateDataServiceApiAuthorityRequest> request);
  DeleteDataServiceApiAuthorityResponse deleteDataServiceApiAuthority(shared_ptr<DeleteDataServiceApiAuthorityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDataServiceApiAuthorityResponse deleteDataServiceApiAuthoritySimply(shared_ptr<DeleteDataServiceApiAuthorityRequest> request);
  CreateDataServiceGroupResponse createDataServiceGroup(shared_ptr<CreateDataServiceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDataServiceGroupResponse createDataServiceGroupSimply(shared_ptr<CreateDataServiceGroupRequest> request);
  UpdateMetaTableResponse updateMetaTable(shared_ptr<UpdateMetaTableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMetaTableResponse updateMetaTableSimply(shared_ptr<UpdateMetaTableRequest> request);
  GetInstanceCountTrendResponse getInstanceCountTrend(shared_ptr<GetInstanceCountTrendRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetInstanceCountTrendResponse getInstanceCountTrendSimply(shared_ptr<GetInstanceCountTrendRequest> request);
  DeleteTableResponse deleteTable(shared_ptr<DeleteTableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteTableResponse deleteTableSimply(shared_ptr<DeleteTableRequest> request);
  ListTableThemeResponse listTableTheme(shared_ptr<ListTableThemeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTableThemeResponse listTableThemeSimply(shared_ptr<ListTableThemeRequest> request);
  GetSuccessInstanceTrendResponse getSuccessInstanceTrend(shared_ptr<GetSuccessInstanceTrendRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSuccessInstanceTrendResponse getSuccessInstanceTrendSimply(shared_ptr<GetSuccessInstanceTrendRequest> request);
  UpdateTableResponse updateTable(shared_ptr<UpdateTableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateTableResponse updateTableSimply(shared_ptr<UpdateTableRequest> request);
  GetDataServiceFolderResponse getDataServiceFolder(shared_ptr<GetDataServiceFolderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDataServiceFolderResponse getDataServiceFolderSimply(shared_ptr<GetDataServiceFolderRequest> request);
  ListTableLevelResponse listTableLevel(shared_ptr<ListTableLevelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTableLevelResponse listTableLevelSimply(shared_ptr<ListTableLevelRequest> request);
  ListDataServiceGroupsResponse listDataServiceGroups(shared_ptr<ListDataServiceGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDataServiceGroupsResponse listDataServiceGroupsSimply(shared_ptr<ListDataServiceGroupsRequest> request);
  UpdateTableThemeResponse updateTableTheme(shared_ptr<UpdateTableThemeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateTableThemeResponse updateTableThemeSimply(shared_ptr<UpdateTableThemeRequest> request);
  CreateDataServiceFolderResponse createDataServiceFolder(shared_ptr<CreateDataServiceFolderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDataServiceFolderResponse createDataServiceFolderSimply(shared_ptr<CreateDataServiceFolderRequest> request);
  GetDataServiceGroupResponse getDataServiceGroup(shared_ptr<GetDataServiceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDataServiceGroupResponse getDataServiceGroupSimply(shared_ptr<GetDataServiceGroupRequest> request);
  CreateTableLevelResponse createTableLevel(shared_ptr<CreateTableLevelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateTableLevelResponse createTableLevelSimply(shared_ptr<CreateTableLevelRequest> request);
  UpdateMetaTableIntroWikiResponse updateMetaTableIntroWiki(shared_ptr<UpdateMetaTableIntroWikiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMetaTableIntroWikiResponse updateMetaTableIntroWikiSimply(shared_ptr<UpdateMetaTableIntroWikiRequest> request);
  DeleteTableLevelResponse deleteTableLevel(shared_ptr<DeleteTableLevelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteTableLevelResponse deleteTableLevelSimply(shared_ptr<DeleteTableLevelRequest> request);
  UpdateTableLevelResponse updateTableLevel(shared_ptr<UpdateTableLevelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateTableLevelResponse updateTableLevelSimply(shared_ptr<UpdateTableLevelRequest> request);
  DeleteTableThemeResponse deleteTableTheme(shared_ptr<DeleteTableThemeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteTableThemeResponse deleteTableThemeSimply(shared_ptr<DeleteTableThemeRequest> request);
  ListProgramTypeCountResponse listProgramTypeCount(shared_ptr<ListProgramTypeCountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListProgramTypeCountResponse listProgramTypeCountSimply(shared_ptr<ListProgramTypeCountRequest> request);
  UpdateTableModelInfoResponse updateTableModelInfo(shared_ptr<UpdateTableModelInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateTableModelInfoResponse updateTableModelInfoSimply(shared_ptr<UpdateTableModelInfoRequest> request);
  ListProjectsResponse listProjects(shared_ptr<ListProjectsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListProjectsResponse listProjectsSimply(shared_ptr<ListProjectsRequest> request);
  ListProjectMembersResponse listProjectMembers(shared_ptr<ListProjectMembersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListProjectMembersResponse listProjectMembersSimply(shared_ptr<ListProjectMembersRequest> request);
  CreateProjectMemberResponse createProjectMember(shared_ptr<CreateProjectMemberRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateProjectMemberResponse createProjectMemberSimply(shared_ptr<CreateProjectMemberRequest> request);
  ListProjectRolesResponse listProjectRoles(shared_ptr<ListProjectRolesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListProjectRolesResponse listProjectRolesSimply(shared_ptr<ListProjectRolesRequest> request);
  AddProjectMemberToRoleResponse addProjectMemberToRole(shared_ptr<AddProjectMemberToRoleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddProjectMemberToRoleResponse addProjectMemberToRoleSimply(shared_ptr<AddProjectMemberToRoleRequest> request);
  RemoveProjectMemberFromRoleResponse removeProjectMemberFromRole(shared_ptr<RemoveProjectMemberFromRoleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveProjectMemberFromRoleResponse removeProjectMemberFromRoleSimply(shared_ptr<RemoveProjectMemberFromRoleRequest> request);
  DeleteProjectMemberResponse deleteProjectMember(shared_ptr<DeleteProjectMemberRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteProjectMemberResponse deleteProjectMemberSimply(shared_ptr<DeleteProjectMemberRequest> request);
  CreateDagComplementResponse createDagComplement(shared_ptr<CreateDagComplementRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDagComplementResponse createDagComplementSimply(shared_ptr<CreateDagComplementRequest> request);
  CreateDagTestResponse createDagTest(shared_ptr<CreateDagTestRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDagTestResponse createDagTestSimply(shared_ptr<CreateDagTestRequest> request);
  ListCalcEnginesResponse listCalcEngines(shared_ptr<ListCalcEnginesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCalcEnginesResponse listCalcEnginesSimply(shared_ptr<ListCalcEnginesRequest> request);
  ListConnectionsResponse listConnections(shared_ptr<ListConnectionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListConnectionsResponse listConnectionsSimply(shared_ptr<ListConnectionsRequest> request);
  UpdateConnectionResponse updateConnection(shared_ptr<UpdateConnectionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateConnectionResponse updateConnectionSimply(shared_ptr<UpdateConnectionRequest> request);
  DeleteConnectionResponse deleteConnection(shared_ptr<DeleteConnectionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteConnectionResponse deleteConnectionSimply(shared_ptr<DeleteConnectionRequest> request);
  GetProjectDetailResponse getProjectDetail(shared_ptr<GetProjectDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetProjectDetailResponse getProjectDetailSimply(shared_ptr<GetProjectDetailRequest> request);
  ListResourceGroupsResponse listResourceGroups(shared_ptr<ListResourceGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListResourceGroupsResponse listResourceGroupsSimply(shared_ptr<ListResourceGroupsRequest> request);
  CreateConnectionResponse createConnection(shared_ptr<CreateConnectionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateConnectionResponse createConnectionSimply(shared_ptr<CreateConnectionRequest> request);
  GetDataServiceApplicationResponse getDataServiceApplication(shared_ptr<GetDataServiceApplicationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDataServiceApplicationResponse getDataServiceApplicationSimply(shared_ptr<GetDataServiceApplicationRequest> request);
  ListDataServiceApplicationsResponse listDataServiceApplications(shared_ptr<ListDataServiceApplicationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDataServiceApplicationsResponse listDataServiceApplicationsSimply(shared_ptr<ListDataServiceApplicationsRequest> request);
  GetNodeOnBaselineResponse getNodeOnBaseline(shared_ptr<GetNodeOnBaselineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetNodeOnBaselineResponse getNodeOnBaselineSimply(shared_ptr<GetNodeOnBaselineRequest> request);
  ListBaselineConfigsResponse listBaselineConfigs(shared_ptr<ListBaselineConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListBaselineConfigsResponse listBaselineConfigsSimply(shared_ptr<ListBaselineConfigsRequest> request);
  GetMetaTableChangeLogResponse getMetaTableChangeLog(shared_ptr<GetMetaTableChangeLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMetaTableChangeLogResponse getMetaTableChangeLogSimply(shared_ptr<GetMetaTableChangeLogRequest> request);
  GetMetaTableOutputResponse getMetaTableOutput(shared_ptr<GetMetaTableOutputRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMetaTableOutputResponse getMetaTableOutputSimply(shared_ptr<GetMetaTableOutputRequest> request);
  GetMetaTablePartitionResponse getMetaTablePartition(shared_ptr<GetMetaTablePartitionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMetaTablePartitionResponse getMetaTablePartitionSimply(shared_ptr<GetMetaTablePartitionRequest> request);
  GetMetaTableFullInfoResponse getMetaTableFullInfo(shared_ptr<GetMetaTableFullInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMetaTableFullInfoResponse getMetaTableFullInfoSimply(shared_ptr<GetMetaTableFullInfoRequest> request);
  GetFileVersionResponse getFileVersion(shared_ptr<GetFileVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetFileVersionResponse getFileVersionSimply(shared_ptr<GetFileVersionRequest> request);
  GetMetaTableBasicInfoResponse getMetaTableBasicInfo(shared_ptr<GetMetaTableBasicInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMetaTableBasicInfoResponse getMetaTableBasicInfoSimply(shared_ptr<GetMetaTableBasicInfoRequest> request);
  GetMetaTableColumnResponse getMetaTableColumn(shared_ptr<GetMetaTableColumnRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMetaTableColumnResponse getMetaTableColumnSimply(shared_ptr<GetMetaTableColumnRequest> request);
  GetMetaDBInfoResponse getMetaDBInfo(shared_ptr<GetMetaDBInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMetaDBInfoResponse getMetaDBInfoSimply(shared_ptr<GetMetaDBInfoRequest> request);
  GetMetaCategoryResponse getMetaCategory(shared_ptr<GetMetaCategoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMetaCategoryResponse getMetaCategorySimply(shared_ptr<GetMetaCategoryRequest> request);
  ListAlertMessagesResponse listAlertMessages(shared_ptr<ListAlertMessagesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAlertMessagesResponse listAlertMessagesSimply(shared_ptr<ListAlertMessagesRequest> request);
  GetBaselineConfigResponse getBaselineConfig(shared_ptr<GetBaselineConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetBaselineConfigResponse getBaselineConfigSimply(shared_ptr<GetBaselineConfigRequest> request);
  SearchMetaTablesResponse searchMetaTables(shared_ptr<SearchMetaTablesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchMetaTablesResponse searchMetaTablesSimply(shared_ptr<SearchMetaTablesRequest> request);
  GetMetaTableListByCategoryResponse getMetaTableListByCategory(shared_ptr<GetMetaTableListByCategoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMetaTableListByCategoryResponse getMetaTableListByCategorySimply(shared_ptr<GetMetaTableListByCategoryRequest> request);
  DeleteMetaCategoryResponse deleteMetaCategory(shared_ptr<DeleteMetaCategoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMetaCategoryResponse deleteMetaCategorySimply(shared_ptr<DeleteMetaCategoryRequest> request);
  UpdateMetaCategoryResponse updateMetaCategory(shared_ptr<UpdateMetaCategoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMetaCategoryResponse updateMetaCategorySimply(shared_ptr<UpdateMetaCategoryRequest> request);
  ListTopicsResponse listTopics(shared_ptr<ListTopicsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTopicsResponse listTopicsSimply(shared_ptr<ListTopicsRequest> request);
  ListFileVersionsResponse listFileVersions(shared_ptr<ListFileVersionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFileVersionsResponse listFileVersionsSimply(shared_ptr<ListFileVersionsRequest> request);
  CreateMetaCategoryResponse createMetaCategory(shared_ptr<CreateMetaCategoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMetaCategoryResponse createMetaCategorySimply(shared_ptr<CreateMetaCategoryRequest> request);
  ListNodeIOResponse listNodeIO(shared_ptr<ListNodeIORequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListNodeIOResponse listNodeIOSimply(shared_ptr<ListNodeIORequest> request);
  GetTopicInfluenceResponse getTopicInfluence(shared_ptr<GetTopicInfluenceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTopicInfluenceResponse getTopicInfluenceSimply(shared_ptr<GetTopicInfluenceRequest> request);
  GetTopicResponse getTopic(shared_ptr<GetTopicRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTopicResponse getTopicSimply(shared_ptr<GetTopicRequest> request);
  DeleteFromMetaCategoryResponse deleteFromMetaCategory(shared_ptr<DeleteFromMetaCategoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteFromMetaCategoryResponse deleteFromMetaCategorySimply(shared_ptr<DeleteFromMetaCategoryRequest> request);
  GetNodeResponse getNode(shared_ptr<GetNodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetNodeResponse getNodeSimply(shared_ptr<GetNodeRequest> request);
  ListNodesResponse listNodes(shared_ptr<ListNodesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListNodesResponse listNodesSimply(shared_ptr<ListNodesRequest> request);
  GetNodeCodeResponse getNodeCode(shared_ptr<GetNodeCodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetNodeCodeResponse getNodeCodeSimply(shared_ptr<GetNodeCodeRequest> request);
  EstablishRelationTableToBusinessResponse establishRelationTableToBusiness(shared_ptr<EstablishRelationTableToBusinessRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EstablishRelationTableToBusinessResponse establishRelationTableToBusinessSimply(shared_ptr<EstablishRelationTableToBusinessRequest> request);
  UpdateDataServiceApiResponse updateDataServiceApi(shared_ptr<UpdateDataServiceApiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDataServiceApiResponse updateDataServiceApiSimply(shared_ptr<UpdateDataServiceApiRequest> request);
  UpdateUdfFileResponse updateUdfFile(shared_ptr<UpdateUdfFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateUdfFileResponse updateUdfFileSimply(shared_ptr<UpdateUdfFileRequest> request);
  CreateUdfFileResponse createUdfFile(shared_ptr<CreateUdfFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateUdfFileResponse createUdfFileSimply(shared_ptr<CreateUdfFileRequest> request);
  ListFilesResponse listFiles(shared_ptr<ListFilesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFilesResponse listFilesSimply(shared_ptr<ListFilesRequest> request);
  ListDataServiceAuthorizedApisResponse listDataServiceAuthorizedApis(shared_ptr<ListDataServiceAuthorizedApisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDataServiceAuthorizedApisResponse listDataServiceAuthorizedApisSimply(shared_ptr<ListDataServiceAuthorizedApisRequest> request);
  UpdateFileResponse updateFile(shared_ptr<UpdateFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateFileResponse updateFileSimply(shared_ptr<UpdateFileRequest> request);
  DeleteFolderResponse deleteFolder(shared_ptr<DeleteFolderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteFolderResponse deleteFolderSimply(shared_ptr<DeleteFolderRequest> request);
  ListFoldersResponse listFolders(shared_ptr<ListFoldersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFoldersResponse listFoldersSimply(shared_ptr<ListFoldersRequest> request);
  CheckMetaPartitionResponse checkMetaPartition(shared_ptr<CheckMetaPartitionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckMetaPartitionResponse checkMetaPartitionSimply(shared_ptr<CheckMetaPartitionRequest> request);
  UpdateFolderResponse updateFolder(shared_ptr<UpdateFolderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateFolderResponse updateFolderSimply(shared_ptr<UpdateFolderRequest> request);
  DeleteRemindResponse deleteRemind(shared_ptr<DeleteRemindRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRemindResponse deleteRemindSimply(shared_ptr<DeleteRemindRequest> request);
  AddToMetaCategoryResponse addToMetaCategory(shared_ptr<AddToMetaCategoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddToMetaCategoryResponse addToMetaCategorySimply(shared_ptr<AddToMetaCategoryRequest> request);
  ListInstancesResponse listInstances(shared_ptr<ListInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListInstancesResponse listInstancesSimply(shared_ptr<ListInstancesRequest> request);
  SetSuccessInstanceResponse setSuccessInstance(shared_ptr<SetSuccessInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetSuccessInstanceResponse setSuccessInstanceSimply(shared_ptr<SetSuccessInstanceRequest> request);
  CreateFileResponse createFile(shared_ptr<CreateFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFileResponse createFileSimply(shared_ptr<CreateFileRequest> request);
  StopInstanceResponse stopInstance(shared_ptr<StopInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopInstanceResponse stopInstanceSimply(shared_ptr<StopInstanceRequest> request);
  ResumeInstanceResponse resumeInstance(shared_ptr<ResumeInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResumeInstanceResponse resumeInstanceSimply(shared_ptr<ResumeInstanceRequest> request);
  SuspendInstanceResponse suspendInstance(shared_ptr<SuspendInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SuspendInstanceResponse suspendInstanceSimply(shared_ptr<SuspendInstanceRequest> request);
  RestartInstanceResponse restartInstance(shared_ptr<RestartInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RestartInstanceResponse restartInstanceSimply(shared_ptr<RestartInstanceRequest> request);
  ListDataServiceApiAuthoritiesResponse listDataServiceApiAuthorities(shared_ptr<ListDataServiceApiAuthoritiesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDataServiceApiAuthoritiesResponse listDataServiceApiAuthoritiesSimply(shared_ptr<ListDataServiceApiAuthoritiesRequest> request);
  ListDataServicePublishedApisResponse listDataServicePublishedApis(shared_ptr<ListDataServicePublishedApisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDataServicePublishedApisResponse listDataServicePublishedApisSimply(shared_ptr<ListDataServicePublishedApisRequest> request);
  GetInstanceLogResponse getInstanceLog(shared_ptr<GetInstanceLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetInstanceLogResponse getInstanceLogSimply(shared_ptr<GetInstanceLogRequest> request);
  CreateFolderResponse createFolder(shared_ptr<CreateFolderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFolderResponse createFolderSimply(shared_ptr<CreateFolderRequest> request);
  GetBusinessResponse getBusiness(shared_ptr<GetBusinessRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetBusinessResponse getBusinessSimply(shared_ptr<GetBusinessRequest> request);
  GetInstanceResponse getInstance(shared_ptr<GetInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetInstanceResponse getInstanceSimply(shared_ptr<GetInstanceRequest> request);
  GetFileResponse getFile(shared_ptr<GetFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetFileResponse getFileSimply(shared_ptr<GetFileRequest> request);
  ListBusinessResponse listBusiness(shared_ptr<ListBusinessRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListBusinessResponse listBusinessSimply(shared_ptr<ListBusinessRequest> request);
  GetMetaDBTableListResponse getMetaDBTableList(shared_ptr<GetMetaDBTableListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMetaDBTableListResponse getMetaDBTableListSimply(shared_ptr<GetMetaDBTableListRequest> request);
  CheckMetaTableResponse checkMetaTable(shared_ptr<CheckMetaTableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckMetaTableResponse checkMetaTableSimply(shared_ptr<CheckMetaTableRequest> request);
  GetFolderResponse getFolder(shared_ptr<GetFolderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetFolderResponse getFolderSimply(shared_ptr<GetFolderRequest> request);
  DeployFileResponse deployFile(shared_ptr<DeployFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeployFileResponse deployFileSimply(shared_ptr<DeployFileRequest> request);
  DeleteBusinessResponse deleteBusiness(shared_ptr<DeleteBusinessRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteBusinessResponse deleteBusinessSimply(shared_ptr<DeleteBusinessRequest> request);
  DeleteFileResponse deleteFile(shared_ptr<DeleteFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteFileResponse deleteFileSimply(shared_ptr<DeleteFileRequest> request);
  ListQualityRulesResponse listQualityRules(shared_ptr<ListQualityRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListQualityRulesResponse listQualityRulesSimply(shared_ptr<ListQualityRulesRequest> request);
  CreateRemindResponse createRemind(shared_ptr<CreateRemindRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRemindResponse createRemindSimply(shared_ptr<CreateRemindRequest> request);
  GetQualityRuleResponse getQualityRule(shared_ptr<GetQualityRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetQualityRuleResponse getQualityRuleSimply(shared_ptr<GetQualityRuleRequest> request);
  GetDeploymentResponse getDeployment(shared_ptr<GetDeploymentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDeploymentResponse getDeploymentSimply(shared_ptr<GetDeploymentRequest> request);
  UpdateRemindResponse updateRemind(shared_ptr<UpdateRemindRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateRemindResponse updateRemindSimply(shared_ptr<UpdateRemindRequest> request);
  GetMetaColumnLineageResponse getMetaColumnLineage(shared_ptr<GetMetaColumnLineageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMetaColumnLineageResponse getMetaColumnLineageSimply(shared_ptr<GetMetaColumnLineageRequest> request);
  UpdateBusinessResponse updateBusiness(shared_ptr<UpdateBusinessRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateBusinessResponse updateBusinessSimply(shared_ptr<UpdateBusinessRequest> request);
  UpdateQualityRuleResponse updateQualityRule(shared_ptr<UpdateQualityRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateQualityRuleResponse updateQualityRuleSimply(shared_ptr<UpdateQualityRuleRequest> request);
  DeleteQualityRuleResponse deleteQualityRule(shared_ptr<DeleteQualityRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteQualityRuleResponse deleteQualityRuleSimply(shared_ptr<DeleteQualityRuleRequest> request);
  SubmitFileResponse submitFile(shared_ptr<SubmitFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitFileResponse submitFileSimply(shared_ptr<SubmitFileRequest> request);
  GetDataServiceApiResponse getDataServiceApi(shared_ptr<GetDataServiceApiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDataServiceApiResponse getDataServiceApiSimply(shared_ptr<GetDataServiceApiRequest> request);
  ListDataServiceApisResponse listDataServiceApis(shared_ptr<ListDataServiceApisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDataServiceApisResponse listDataServiceApisSimply(shared_ptr<ListDataServiceApisRequest> request);
  GetDataServicePublishedApiResponse getDataServicePublishedApi(shared_ptr<GetDataServicePublishedApiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDataServicePublishedApiResponse getDataServicePublishedApiSimply(shared_ptr<GetDataServicePublishedApiRequest> request);
  GetBaselineKeyPathResponse getBaselineKeyPath(shared_ptr<GetBaselineKeyPathRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetBaselineKeyPathResponse getBaselineKeyPathSimply(shared_ptr<GetBaselineKeyPathRequest> request);
  GetRemindResponse getRemind(shared_ptr<GetRemindRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRemindResponse getRemindSimply(shared_ptr<GetRemindRequest> request);
  GetMetaTableIntroWikiResponse getMetaTableIntroWiki(shared_ptr<GetMetaTableIntroWikiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMetaTableIntroWikiResponse getMetaTableIntroWikiSimply(shared_ptr<GetMetaTableIntroWikiRequest> request);
  GetBaselineStatusResponse getBaselineStatus(shared_ptr<GetBaselineStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetBaselineStatusResponse getBaselineStatusSimply(shared_ptr<GetBaselineStatusRequest> request);
  DeleteDataServiceApiResponse deleteDataServiceApi(shared_ptr<DeleteDataServiceApiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDataServiceApiResponse deleteDataServiceApiSimply(shared_ptr<DeleteDataServiceApiRequest> request);
  PublishDataServiceApiResponse publishDataServiceApi(shared_ptr<PublishDataServiceApiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PublishDataServiceApiResponse publishDataServiceApiSimply(shared_ptr<PublishDataServiceApiRequest> request);
  GetMetaTableLineageResponse getMetaTableLineage(shared_ptr<GetMetaTableLineageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMetaTableLineageResponse getMetaTableLineageSimply(shared_ptr<GetMetaTableLineageRequest> request);
  ListBaselineStatusesResponse listBaselineStatuses(shared_ptr<ListBaselineStatusesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListBaselineStatusesResponse listBaselineStatusesSimply(shared_ptr<ListBaselineStatusesRequest> request);
  ListRemindsResponse listReminds(shared_ptr<ListRemindsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRemindsResponse listRemindsSimply(shared_ptr<ListRemindsRequest> request);
  DeleteQualityEntityResponse deleteQualityEntity(shared_ptr<DeleteQualityEntityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteQualityEntityResponse deleteQualityEntitySimply(shared_ptr<DeleteQualityEntityRequest> request);
  CreateQualityFollowerResponse createQualityFollower(shared_ptr<CreateQualityFollowerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateQualityFollowerResponse createQualityFollowerSimply(shared_ptr<CreateQualityFollowerRequest> request);
  CreateDataServiceApiResponse createDataServiceApi(shared_ptr<CreateDataServiceApiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDataServiceApiResponse createDataServiceApiSimply(shared_ptr<CreateDataServiceApiRequest> request);
  AbolishDataServiceApiResponse abolishDataServiceApi(shared_ptr<AbolishDataServiceApiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AbolishDataServiceApiResponse abolishDataServiceApiSimply(shared_ptr<AbolishDataServiceApiRequest> request);
  GetQualityEntityResponse getQualityEntity(shared_ptr<GetQualityEntityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetQualityEntityResponse getQualityEntitySimply(shared_ptr<GetQualityEntityRequest> request);
  GetQualityFollowerResponse getQualityFollower(shared_ptr<GetQualityFollowerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetQualityFollowerResponse getQualityFollowerSimply(shared_ptr<GetQualityFollowerRequest> request);
  DeleteQualityFollowerResponse deleteQualityFollower(shared_ptr<DeleteQualityFollowerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteQualityFollowerResponse deleteQualityFollowerSimply(shared_ptr<DeleteQualityFollowerRequest> request);
  CreateQualityEntityResponse createQualityEntity(shared_ptr<CreateQualityEntityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateQualityEntityResponse createQualityEntitySimply(shared_ptr<CreateQualityEntityRequest> request);
  CreateQualityRuleResponse createQualityRule(shared_ptr<CreateQualityRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateQualityRuleResponse createQualityRuleSimply(shared_ptr<CreateQualityRuleRequest> request);
  UpdateQualityFollowerResponse updateQualityFollower(shared_ptr<UpdateQualityFollowerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateQualityFollowerResponse updateQualityFollowerSimply(shared_ptr<UpdateQualityFollowerRequest> request);
  CreateQualityRelativeNodeResponse createQualityRelativeNode(shared_ptr<CreateQualityRelativeNodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateQualityRelativeNodeResponse createQualityRelativeNodeSimply(shared_ptr<CreateQualityRelativeNodeRequest> request);
  DeleteQualityRelativeNodeResponse deleteQualityRelativeNode(shared_ptr<DeleteQualityRelativeNodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteQualityRelativeNodeResponse deleteQualityRelativeNodeSimply(shared_ptr<DeleteQualityRelativeNodeRequest> request);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Dataworks-public20200518

#endif
