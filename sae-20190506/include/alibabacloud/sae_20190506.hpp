// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_SAE20190506_H_
#define ALIBABACLOUD_SAE20190506_H_

#include <alibabacloud/open_api.hpp>
#include <boost/any.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Sae20190506 {
class AclEntryConfig : public Darabonba::Model {
public:
  shared_ptr<string> entry{};

  AclEntryConfig() {}

  explicit AclEntryConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entry) {
      res["entry"] = boost::any(*entry);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("entry") != m.end() && !m["entry"].empty()) {
      entry = make_shared<string>(boost::any_cast<string>(m["entry"]));
    }
  }


  virtual ~AclEntryConfig() = default;
};
class AclConfig : public Darabonba::Model {
public:
  shared_ptr<vector<AclEntryConfig>> aclEntries{};

  AclConfig() {}

  explicit AclConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclEntries) {
      vector<boost::any> temp1;
      for(auto item1:*aclEntries){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["aclEntries"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("aclEntries") != m.end() && !m["aclEntries"].empty()) {
      if (typeid(vector<boost::any>) == m["aclEntries"].type()) {
        vector<AclEntryConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["aclEntries"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AclEntryConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        aclEntries = make_shared<vector<AclEntryConfig>>(expect1);
      }
    }
  }


  virtual ~AclConfig() = default;
};
class AppStackInstanceEndpoints : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> name{};
  shared_ptr<string> protocol{};

  AppStackInstanceEndpoints() {}

  explicit AppStackInstanceEndpoints(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
  }


  virtual ~AppStackInstanceEndpoints() = default;
};
class AppStackInstanceParameters : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  AppStackInstanceParameters() {}

  explicit AppStackInstanceParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~AppStackInstanceParameters() = default;
};
class AppStackInstance : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<vector<AppStackInstanceEndpoints>> endpoints{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<vector<AppStackInstanceParameters>> parameters{};
  shared_ptr<string> stackId{};
  shared_ptr<string> status{};
  shared_ptr<long> updateTime{};

  AppStackInstance() {}

  explicit AppStackInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (endpoints) {
      vector<boost::any> temp1;
      for(auto item1:*endpoints){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Endpoints"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (parameters) {
      vector<boost::any> temp1;
      for(auto item1:*parameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Parameters"] = boost::any(temp1);
    }
    if (stackId) {
      res["StackId"] = boost::any(*stackId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Endpoints") != m.end() && !m["Endpoints"].empty()) {
      if (typeid(vector<boost::any>) == m["Endpoints"].type()) {
        vector<AppStackInstanceEndpoints> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Endpoints"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AppStackInstanceEndpoints model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        endpoints = make_shared<vector<AppStackInstanceEndpoints>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("Parameters") != m.end() && !m["Parameters"].empty()) {
      if (typeid(vector<boost::any>) == m["Parameters"].type()) {
        vector<AppStackInstanceParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Parameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AppStackInstanceParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        parameters = make_shared<vector<AppStackInstanceParameters>>(expect1);
      }
    }
    if (m.find("StackId") != m.end() && !m["StackId"].empty()) {
      stackId = make_shared<string>(boost::any_cast<string>(m["StackId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~AppStackInstance() = default;
};
class AppStackResource : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> productCode{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceName{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> stackId{};
  shared_ptr<string> status{};

  AppStackResource() {}

  explicit AppStackResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (productCode) {
      res["ProductCode"] = boost::any(*productCode);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceName) {
      res["ResourceName"] = boost::any(*resourceName);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (stackId) {
      res["StackId"] = boost::any(*stackId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ProductCode") != m.end() && !m["ProductCode"].empty()) {
      productCode = make_shared<string>(boost::any_cast<string>(m["ProductCode"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceName") != m.end() && !m["ResourceName"].empty()) {
      resourceName = make_shared<string>(boost::any_cast<string>(m["ResourceName"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("StackId") != m.end() && !m["StackId"].empty()) {
      stackId = make_shared<string>(boost::any_cast<string>(m["StackId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~AppStackResource() = default;
};
class AppStackTaskSteps : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> duration{};
  shared_ptr<long> endTime{};
  shared_ptr<string> id{};
  shared_ptr<string> message{};
  shared_ptr<string> name{};
  shared_ptr<long> startTime{};
  shared_ptr<string> status{};

  AppStackTaskSteps() {}

  explicit AppStackTaskSteps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~AppStackTaskSteps() = default;
};
class AppStackTask : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> stackId{};
  shared_ptr<long> startTime{};
  shared_ptr<string> status{};
  shared_ptr<vector<AppStackTaskSteps>> steps{};
  shared_ptr<string> taskId{};

  AppStackTask() {}

  explicit AppStackTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (stackId) {
      res["StackId"] = boost::any(*stackId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (steps) {
      vector<boost::any> temp1;
      for(auto item1:*steps){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Steps"] = boost::any(temp1);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("StackId") != m.end() && !m["StackId"].empty()) {
      stackId = make_shared<string>(boost::any_cast<string>(m["StackId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Steps") != m.end() && !m["Steps"].empty()) {
      if (typeid(vector<boost::any>) == m["Steps"].type()) {
        vector<AppStackTaskSteps> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Steps"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AppStackTaskSteps model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        steps = make_shared<vector<AppStackTaskSteps>>(expect1);
      }
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~AppStackTask() = default;
};
class DNSOption : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  DNSOption() {}

  explicit DNSOption(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~DNSOption() = default;
};
class CustomDNS : public Darabonba::Model {
public:
  shared_ptr<vector<DNSOption>> dnsOptions{};
  shared_ptr<vector<string>> nameServers{};
  shared_ptr<vector<string>> searches{};

  CustomDNS() {}

  explicit CustomDNS(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dnsOptions) {
      vector<boost::any> temp1;
      for(auto item1:*dnsOptions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["dnsOptions"] = boost::any(temp1);
    }
    if (nameServers) {
      res["nameServers"] = boost::any(*nameServers);
    }
    if (searches) {
      res["searches"] = boost::any(*searches);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dnsOptions") != m.end() && !m["dnsOptions"].empty()) {
      if (typeid(vector<boost::any>) == m["dnsOptions"].type()) {
        vector<DNSOption> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["dnsOptions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DNSOption model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dnsOptions = make_shared<vector<DNSOption>>(expect1);
      }
    }
    if (m.find("nameServers") != m.end() && !m["nameServers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["nameServers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["nameServers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nameServers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("searches") != m.end() && !m["searches"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["searches"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["searches"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      searches = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CustomDNS() = default;
};
class CustomHealthCheckConfig : public Darabonba::Model {
public:
  shared_ptr<long> failureThreshold{};
  shared_ptr<string> httpGetUrl{};
  shared_ptr<long> initialDelaySeconds{};
  shared_ptr<long> periodSeconds{};
  shared_ptr<long> successThreshold{};
  shared_ptr<long> timeoutSeconds{};

  CustomHealthCheckConfig() {}

  explicit CustomHealthCheckConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failureThreshold) {
      res["failureThreshold"] = boost::any(*failureThreshold);
    }
    if (httpGetUrl) {
      res["httpGetUrl"] = boost::any(*httpGetUrl);
    }
    if (initialDelaySeconds) {
      res["initialDelaySeconds"] = boost::any(*initialDelaySeconds);
    }
    if (periodSeconds) {
      res["periodSeconds"] = boost::any(*periodSeconds);
    }
    if (successThreshold) {
      res["successThreshold"] = boost::any(*successThreshold);
    }
    if (timeoutSeconds) {
      res["timeoutSeconds"] = boost::any(*timeoutSeconds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("failureThreshold") != m.end() && !m["failureThreshold"].empty()) {
      failureThreshold = make_shared<long>(boost::any_cast<long>(m["failureThreshold"]));
    }
    if (m.find("httpGetUrl") != m.end() && !m["httpGetUrl"].empty()) {
      httpGetUrl = make_shared<string>(boost::any_cast<string>(m["httpGetUrl"]));
    }
    if (m.find("initialDelaySeconds") != m.end() && !m["initialDelaySeconds"].empty()) {
      initialDelaySeconds = make_shared<long>(boost::any_cast<long>(m["initialDelaySeconds"]));
    }
    if (m.find("periodSeconds") != m.end() && !m["periodSeconds"].empty()) {
      periodSeconds = make_shared<long>(boost::any_cast<long>(m["periodSeconds"]));
    }
    if (m.find("successThreshold") != m.end() && !m["successThreshold"].empty()) {
      successThreshold = make_shared<long>(boost::any_cast<long>(m["successThreshold"]));
    }
    if (m.find("timeoutSeconds") != m.end() && !m["timeoutSeconds"].empty()) {
      timeoutSeconds = make_shared<long>(boost::any_cast<long>(m["timeoutSeconds"]));
    }
  }


  virtual ~CustomHealthCheckConfig() = default;
};
class HostAlias : public Darabonba::Model {
public:
  shared_ptr<vector<string>> hostnames{};
  shared_ptr<string> ip{};

  HostAlias() {}

  explicit HostAlias(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostnames) {
      res["hostnames"] = boost::any(*hostnames);
    }
    if (ip) {
      res["ip"] = boost::any(*ip);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("hostnames") != m.end() && !m["hostnames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["hostnames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["hostnames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      hostnames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ip") != m.end() && !m["ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["ip"]));
    }
  }


  virtual ~HostAlias() = default;
};
class CustomHostAlias : public Darabonba::Model {
public:
  shared_ptr<vector<HostAlias>> hostAliases{};

  CustomHostAlias() {}

  explicit CustomHostAlias(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostAliases) {
      vector<boost::any> temp1;
      for(auto item1:*hostAliases){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["hostAliases"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("hostAliases") != m.end() && !m["hostAliases"].empty()) {
      if (typeid(vector<boost::any>) == m["hostAliases"].type()) {
        vector<HostAlias> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["hostAliases"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HostAlias model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hostAliases = make_shared<vector<HostAlias>>(expect1);
      }
    }
  }


  virtual ~CustomHostAlias() = default;
};
class CustomRuntimeConfig : public Darabonba::Model {
public:
  shared_ptr<vector<string>> args{};
  shared_ptr<vector<string>> command{};

  CustomRuntimeConfig() {}

  explicit CustomRuntimeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (args) {
      res["args"] = boost::any(*args);
    }
    if (command) {
      res["command"] = boost::any(*command);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("args") != m.end() && !m["args"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["args"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["args"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      args = make_shared<vector<string>>(toVec1);
    }
    if (m.find("command") != m.end() && !m["command"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["command"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["command"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      command = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CustomRuntimeConfig() = default;
};
class HTTPTriggerConfig : public Darabonba::Model {
public:
  shared_ptr<AclConfig> aclConfig{};
  shared_ptr<boost::any> authConfig{};
  shared_ptr<string> authType{};
  shared_ptr<bool> disableURLInternet{};
  shared_ptr<bool> safeMode{};

  HTTPTriggerConfig() {}

  explicit HTTPTriggerConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclConfig) {
      res["aclConfig"] = aclConfig ? boost::any(aclConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (authConfig) {
      res["authConfig"] = boost::any(*authConfig);
    }
    if (authType) {
      res["authType"] = boost::any(*authType);
    }
    if (disableURLInternet) {
      res["disableURLInternet"] = boost::any(*disableURLInternet);
    }
    if (safeMode) {
      res["safeMode"] = boost::any(*safeMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("aclConfig") != m.end() && !m["aclConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["aclConfig"].type()) {
        AclConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["aclConfig"]));
        aclConfig = make_shared<AclConfig>(model1);
      }
    }
    if (m.find("authConfig") != m.end() && !m["authConfig"].empty()) {
      authConfig = make_shared<boost::any>(boost::any_cast<boost::any>(m["authConfig"]));
    }
    if (m.find("authType") != m.end() && !m["authType"].empty()) {
      authType = make_shared<string>(boost::any_cast<string>(m["authType"]));
    }
    if (m.find("disableURLInternet") != m.end() && !m["disableURLInternet"].empty()) {
      disableURLInternet = make_shared<bool>(boost::any_cast<bool>(m["disableURLInternet"]));
    }
    if (m.find("safeMode") != m.end() && !m["safeMode"].empty()) {
      safeMode = make_shared<bool>(boost::any_cast<bool>(m["safeMode"]));
    }
  }


  virtual ~HTTPTriggerConfig() = default;
};
class RegistryAuthConfig : public Darabonba::Model {
public:
  shared_ptr<string> password{};
  shared_ptr<string> role{};
  shared_ptr<string> userName{};

  RegistryAuthConfig() {}

  explicit RegistryAuthConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (password) {
      res["password"] = boost::any(*password);
    }
    if (role) {
      res["role"] = boost::any(*role);
    }
    if (userName) {
      res["userName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("password") != m.end() && !m["password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["password"]));
    }
    if (m.find("role") != m.end() && !m["role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["role"]));
    }
    if (m.find("userName") != m.end() && !m["userName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["userName"]));
    }
  }


  virtual ~RegistryAuthConfig() = default;
};
class RegistryCertConfig : public Darabonba::Model {
public:
  shared_ptr<bool> insecure{};
  shared_ptr<string> rootCaCertBase64{};

  RegistryCertConfig() {}

  explicit RegistryCertConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (insecure) {
      res["insecure"] = boost::any(*insecure);
    }
    if (rootCaCertBase64) {
      res["rootCaCertBase64"] = boost::any(*rootCaCertBase64);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("insecure") != m.end() && !m["insecure"].empty()) {
      insecure = make_shared<bool>(boost::any_cast<bool>(m["insecure"]));
    }
    if (m.find("rootCaCertBase64") != m.end() && !m["rootCaCertBase64"].empty()) {
      rootCaCertBase64 = make_shared<string>(boost::any_cast<string>(m["rootCaCertBase64"]));
    }
  }


  virtual ~RegistryCertConfig() = default;
};
class RegistryConfig : public Darabonba::Model {
public:
  shared_ptr<RegistryAuthConfig> authConfig{};
  shared_ptr<RegistryCertConfig> certConfig{};

  RegistryConfig() {}

  explicit RegistryConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authConfig) {
      res["authConfig"] = authConfig ? boost::any(authConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (certConfig) {
      res["certConfig"] = certConfig ? boost::any(certConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("authConfig") != m.end() && !m["authConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["authConfig"].type()) {
        RegistryAuthConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["authConfig"]));
        authConfig = make_shared<RegistryAuthConfig>(model1);
      }
    }
    if (m.find("certConfig") != m.end() && !m["certConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["certConfig"].type()) {
        RegistryCertConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["certConfig"]));
        certConfig = make_shared<RegistryCertConfig>(model1);
      }
    }
  }


  virtual ~RegistryConfig() = default;
};
class ImageConfig : public Darabonba::Model {
public:
  shared_ptr<string> accelerationType{};
  shared_ptr<string> image{};
  shared_ptr<string> instanceID{};
  shared_ptr<RegistryConfig> registryConfig{};

  ImageConfig() {}

  explicit ImageConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accelerationType) {
      res["accelerationType"] = boost::any(*accelerationType);
    }
    if (image) {
      res["image"] = boost::any(*image);
    }
    if (instanceID) {
      res["instanceID"] = boost::any(*instanceID);
    }
    if (registryConfig) {
      res["registryConfig"] = registryConfig ? boost::any(registryConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accelerationType") != m.end() && !m["accelerationType"].empty()) {
      accelerationType = make_shared<string>(boost::any_cast<string>(m["accelerationType"]));
    }
    if (m.find("image") != m.end() && !m["image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["image"]));
    }
    if (m.find("instanceID") != m.end() && !m["instanceID"].empty()) {
      instanceID = make_shared<string>(boost::any_cast<string>(m["instanceID"]));
    }
    if (m.find("registryConfig") != m.end() && !m["registryConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["registryConfig"].type()) {
        RegistryConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["registryConfig"]));
        registryConfig = make_shared<RegistryConfig>(model1);
      }
    }
  }


  virtual ~ImageConfig() = default;
};
class LifecycleHook : public Darabonba::Model {
public:
  shared_ptr<string> handler{};
  shared_ptr<long> timeout{};

  LifecycleHook() {}

  explicit LifecycleHook(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (handler) {
      res["handler"] = boost::any(*handler);
    }
    if (timeout) {
      res["timeout"] = boost::any(*timeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("handler") != m.end() && !m["handler"].empty()) {
      handler = make_shared<string>(boost::any_cast<string>(m["handler"]));
    }
    if (m.find("timeout") != m.end() && !m["timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["timeout"]));
    }
  }


  virtual ~LifecycleHook() = default;
};
class InstanceLifecycleConfig : public Darabonba::Model {
public:
  shared_ptr<LifecycleHook> preFreeze{};
  shared_ptr<LifecycleHook> preStop{};

  InstanceLifecycleConfig() {}

  explicit InstanceLifecycleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (preFreeze) {
      res["preFreeze"] = preFreeze ? boost::any(preFreeze->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (preStop) {
      res["preStop"] = preStop ? boost::any(preStop->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("preFreeze") != m.end() && !m["preFreeze"].empty()) {
      if (typeid(map<string, boost::any>) == m["preFreeze"].type()) {
        LifecycleHook model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["preFreeze"]));
        preFreeze = make_shared<LifecycleHook>(model1);
      }
    }
    if (m.find("preStop") != m.end() && !m["preStop"].empty()) {
      if (typeid(map<string, boost::any>) == m["preStop"].type()) {
        LifecycleHook model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["preStop"]));
        preStop = make_shared<LifecycleHook>(model1);
      }
    }
  }


  virtual ~InstanceLifecycleConfig() = default;
};
class ProbeProbeHandlerHttpGetHttpHeaders : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  ProbeProbeHandlerHttpGetHttpHeaders() {}

  explicit ProbeProbeHandlerHttpGetHttpHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~ProbeProbeHandlerHttpGetHttpHeaders() = default;
};
class ProbeProbeHandlerHttpGet : public Darabonba::Model {
public:
  shared_ptr<vector<ProbeProbeHandlerHttpGetHttpHeaders>> httpHeaders{};
  shared_ptr<string> path{};
  shared_ptr<long> port{};

  ProbeProbeHandlerHttpGet() {}

  explicit ProbeProbeHandlerHttpGet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpHeaders) {
      vector<boost::any> temp1;
      for(auto item1:*httpHeaders){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["httpHeaders"] = boost::any(temp1);
    }
    if (path) {
      res["path"] = boost::any(*path);
    }
    if (port) {
      res["port"] = boost::any(*port);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("httpHeaders") != m.end() && !m["httpHeaders"].empty()) {
      if (typeid(vector<boost::any>) == m["httpHeaders"].type()) {
        vector<ProbeProbeHandlerHttpGetHttpHeaders> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["httpHeaders"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ProbeProbeHandlerHttpGetHttpHeaders model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        httpHeaders = make_shared<vector<ProbeProbeHandlerHttpGetHttpHeaders>>(expect1);
      }
    }
    if (m.find("path") != m.end() && !m["path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["path"]));
    }
    if (m.find("port") != m.end() && !m["port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["port"]));
    }
  }


  virtual ~ProbeProbeHandlerHttpGet() = default;
};
class ProbeProbeHandlerTcpSocket : public Darabonba::Model {
public:
  shared_ptr<long> port{};

  ProbeProbeHandlerTcpSocket() {}

  explicit ProbeProbeHandlerTcpSocket(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (port) {
      res["port"] = boost::any(*port);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("port") != m.end() && !m["port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["port"]));
    }
  }


  virtual ~ProbeProbeHandlerTcpSocket() = default;
};
class ProbeProbeHandler : public Darabonba::Model {
public:
  shared_ptr<ProbeProbeHandlerHttpGet> httpGet{};
  shared_ptr<ProbeProbeHandlerTcpSocket> tcpSocket{};

  ProbeProbeHandler() {}

  explicit ProbeProbeHandler(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpGet) {
      res["httpGet"] = httpGet ? boost::any(httpGet->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tcpSocket) {
      res["tcpSocket"] = tcpSocket ? boost::any(tcpSocket->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("httpGet") != m.end() && !m["httpGet"].empty()) {
      if (typeid(map<string, boost::any>) == m["httpGet"].type()) {
        ProbeProbeHandlerHttpGet model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["httpGet"]));
        httpGet = make_shared<ProbeProbeHandlerHttpGet>(model1);
      }
    }
    if (m.find("tcpSocket") != m.end() && !m["tcpSocket"].empty()) {
      if (typeid(map<string, boost::any>) == m["tcpSocket"].type()) {
        ProbeProbeHandlerTcpSocket model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["tcpSocket"]));
        tcpSocket = make_shared<ProbeProbeHandlerTcpSocket>(model1);
      }
    }
  }


  virtual ~ProbeProbeHandler() = default;
};
class Probe : public Darabonba::Model {
public:
  shared_ptr<long> failureThreshold{};
  shared_ptr<long> initialDelaySeconds{};
  shared_ptr<long> periodSeconds{};
  shared_ptr<ProbeProbeHandler> probeHandler{};
  shared_ptr<long> timeoutSeconds{};

  Probe() {}

  explicit Probe(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failureThreshold) {
      res["failureThreshold"] = boost::any(*failureThreshold);
    }
    if (initialDelaySeconds) {
      res["initialDelaySeconds"] = boost::any(*initialDelaySeconds);
    }
    if (periodSeconds) {
      res["periodSeconds"] = boost::any(*periodSeconds);
    }
    if (probeHandler) {
      res["probeHandler"] = probeHandler ? boost::any(probeHandler->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timeoutSeconds) {
      res["timeoutSeconds"] = boost::any(*timeoutSeconds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("failureThreshold") != m.end() && !m["failureThreshold"].empty()) {
      failureThreshold = make_shared<long>(boost::any_cast<long>(m["failureThreshold"]));
    }
    if (m.find("initialDelaySeconds") != m.end() && !m["initialDelaySeconds"].empty()) {
      initialDelaySeconds = make_shared<long>(boost::any_cast<long>(m["initialDelaySeconds"]));
    }
    if (m.find("periodSeconds") != m.end() && !m["periodSeconds"].empty()) {
      periodSeconds = make_shared<long>(boost::any_cast<long>(m["periodSeconds"]));
    }
    if (m.find("probeHandler") != m.end() && !m["probeHandler"].empty()) {
      if (typeid(map<string, boost::any>) == m["probeHandler"].type()) {
        ProbeProbeHandler model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["probeHandler"]));
        probeHandler = make_shared<ProbeProbeHandler>(model1);
      }
    }
    if (m.find("timeoutSeconds") != m.end() && !m["timeoutSeconds"].empty()) {
      timeoutSeconds = make_shared<long>(boost::any_cast<long>(m["timeoutSeconds"]));
    }
  }


  virtual ~Probe() = default;
};
class LogConfig : public Darabonba::Model {
public:
  shared_ptr<bool> enableInstanceMetrics{};
  shared_ptr<bool> enableRequestMetrics{};
  shared_ptr<string> logBeginRule{};
  shared_ptr<string> logstore{};
  shared_ptr<string> project{};
  shared_ptr<bool> pushToUserSLS{};

  LogConfig() {}

  explicit LogConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableInstanceMetrics) {
      res["enableInstanceMetrics"] = boost::any(*enableInstanceMetrics);
    }
    if (enableRequestMetrics) {
      res["enableRequestMetrics"] = boost::any(*enableRequestMetrics);
    }
    if (logBeginRule) {
      res["logBeginRule"] = boost::any(*logBeginRule);
    }
    if (logstore) {
      res["logstore"] = boost::any(*logstore);
    }
    if (project) {
      res["project"] = boost::any(*project);
    }
    if (pushToUserSLS) {
      res["pushToUserSLS"] = boost::any(*pushToUserSLS);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("enableInstanceMetrics") != m.end() && !m["enableInstanceMetrics"].empty()) {
      enableInstanceMetrics = make_shared<bool>(boost::any_cast<bool>(m["enableInstanceMetrics"]));
    }
    if (m.find("enableRequestMetrics") != m.end() && !m["enableRequestMetrics"].empty()) {
      enableRequestMetrics = make_shared<bool>(boost::any_cast<bool>(m["enableRequestMetrics"]));
    }
    if (m.find("logBeginRule") != m.end() && !m["logBeginRule"].empty()) {
      logBeginRule = make_shared<string>(boost::any_cast<string>(m["logBeginRule"]));
    }
    if (m.find("logstore") != m.end() && !m["logstore"].empty()) {
      logstore = make_shared<string>(boost::any_cast<string>(m["logstore"]));
    }
    if (m.find("project") != m.end() && !m["project"].empty()) {
      project = make_shared<string>(boost::any_cast<string>(m["project"]));
    }
    if (m.find("pushToUserSLS") != m.end() && !m["pushToUserSLS"].empty()) {
      pushToUserSLS = make_shared<bool>(boost::any_cast<bool>(m["pushToUserSLS"]));
    }
  }


  virtual ~LogConfig() = default;
};
class NASMountConfig : public Darabonba::Model {
public:
  shared_ptr<bool> enableTLS{};
  shared_ptr<string> mountDir{};
  shared_ptr<string> serverAddr{};

  NASMountConfig() {}

  explicit NASMountConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableTLS) {
      res["enableTLS"] = boost::any(*enableTLS);
    }
    if (mountDir) {
      res["mountDir"] = boost::any(*mountDir);
    }
    if (serverAddr) {
      res["serverAddr"] = boost::any(*serverAddr);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("enableTLS") != m.end() && !m["enableTLS"].empty()) {
      enableTLS = make_shared<bool>(boost::any_cast<bool>(m["enableTLS"]));
    }
    if (m.find("mountDir") != m.end() && !m["mountDir"].empty()) {
      mountDir = make_shared<string>(boost::any_cast<string>(m["mountDir"]));
    }
    if (m.find("serverAddr") != m.end() && !m["serverAddr"].empty()) {
      serverAddr = make_shared<string>(boost::any_cast<string>(m["serverAddr"]));
    }
  }


  virtual ~NASMountConfig() = default;
};
class NASConfig : public Darabonba::Model {
public:
  shared_ptr<vector<NASMountConfig>> mountPoints{};

  NASConfig() {}

  explicit NASConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mountPoints) {
      vector<boost::any> temp1;
      for(auto item1:*mountPoints){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["mountPoints"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("mountPoints") != m.end() && !m["mountPoints"].empty()) {
      if (typeid(vector<boost::any>) == m["mountPoints"].type()) {
        vector<NASMountConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["mountPoints"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            NASMountConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mountPoints = make_shared<vector<NASMountConfig>>(expect1);
      }
    }
  }


  virtual ~NASConfig() = default;
};
class OSSMountPoint : public Darabonba::Model {
public:
  shared_ptr<string> bucketName{};
  shared_ptr<string> bucketPath{};
  shared_ptr<string> mountDir{};
  shared_ptr<bool> readOnly{};

  OSSMountPoint() {}

  explicit OSSMountPoint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucketName) {
      res["bucketName"] = boost::any(*bucketName);
    }
    if (bucketPath) {
      res["bucketPath"] = boost::any(*bucketPath);
    }
    if (mountDir) {
      res["mountDir"] = boost::any(*mountDir);
    }
    if (readOnly) {
      res["readOnly"] = boost::any(*readOnly);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("bucketName") != m.end() && !m["bucketName"].empty()) {
      bucketName = make_shared<string>(boost::any_cast<string>(m["bucketName"]));
    }
    if (m.find("bucketPath") != m.end() && !m["bucketPath"].empty()) {
      bucketPath = make_shared<string>(boost::any_cast<string>(m["bucketPath"]));
    }
    if (m.find("mountDir") != m.end() && !m["mountDir"].empty()) {
      mountDir = make_shared<string>(boost::any_cast<string>(m["mountDir"]));
    }
    if (m.find("readOnly") != m.end() && !m["readOnly"].empty()) {
      readOnly = make_shared<bool>(boost::any_cast<bool>(m["readOnly"]));
    }
  }


  virtual ~OSSMountPoint() = default;
};
class OSSMountConfig : public Darabonba::Model {
public:
  shared_ptr<vector<OSSMountPoint>> mountPoints{};

  OSSMountConfig() {}

  explicit OSSMountConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mountPoints) {
      vector<boost::any> temp1;
      for(auto item1:*mountPoints){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["mountPoints"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("mountPoints") != m.end() && !m["mountPoints"].empty()) {
      if (typeid(vector<boost::any>) == m["mountPoints"].type()) {
        vector<OSSMountPoint> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["mountPoints"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            OSSMountPoint model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mountPoints = make_shared<vector<OSSMountPoint>>(expect1);
      }
    }
  }


  virtual ~OSSMountConfig() = default;
};
class ScaleConfig : public Darabonba::Model {
public:
  shared_ptr<bool> alwaysAllocateCPU{};
  shared_ptr<long> maximumInstanceCount{};
  shared_ptr<long> minimumInstanceCount{};
  shared_ptr<string> requestId{};

  ScaleConfig() {}

  explicit ScaleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alwaysAllocateCPU) {
      res["alwaysAllocateCPU"] = boost::any(*alwaysAllocateCPU);
    }
    if (maximumInstanceCount) {
      res["maximumInstanceCount"] = boost::any(*maximumInstanceCount);
    }
    if (minimumInstanceCount) {
      res["minimumInstanceCount"] = boost::any(*minimumInstanceCount);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("alwaysAllocateCPU") != m.end() && !m["alwaysAllocateCPU"].empty()) {
      alwaysAllocateCPU = make_shared<bool>(boost::any_cast<bool>(m["alwaysAllocateCPU"]));
    }
    if (m.find("maximumInstanceCount") != m.end() && !m["maximumInstanceCount"].empty()) {
      maximumInstanceCount = make_shared<long>(boost::any_cast<long>(m["maximumInstanceCount"]));
    }
    if (m.find("minimumInstanceCount") != m.end() && !m["minimumInstanceCount"].empty()) {
      minimumInstanceCount = make_shared<long>(boost::any_cast<long>(m["minimumInstanceCount"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~ScaleConfig() = default;
};
class SLSConfigCollectConfigs : public Darabonba::Model {
public:
  shared_ptr<string> logPath{};
  shared_ptr<string> logType{};
  shared_ptr<string> logstoreName{};
  shared_ptr<string> logtailName{};
  shared_ptr<string> projectName{};

  SLSConfigCollectConfigs() {}

  explicit SLSConfigCollectConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logPath) {
      res["logPath"] = boost::any(*logPath);
    }
    if (logType) {
      res["logType"] = boost::any(*logType);
    }
    if (logstoreName) {
      res["logstoreName"] = boost::any(*logstoreName);
    }
    if (logtailName) {
      res["logtailName"] = boost::any(*logtailName);
    }
    if (projectName) {
      res["projectName"] = boost::any(*projectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("logPath") != m.end() && !m["logPath"].empty()) {
      logPath = make_shared<string>(boost::any_cast<string>(m["logPath"]));
    }
    if (m.find("logType") != m.end() && !m["logType"].empty()) {
      logType = make_shared<string>(boost::any_cast<string>(m["logType"]));
    }
    if (m.find("logstoreName") != m.end() && !m["logstoreName"].empty()) {
      logstoreName = make_shared<string>(boost::any_cast<string>(m["logstoreName"]));
    }
    if (m.find("logtailName") != m.end() && !m["logtailName"].empty()) {
      logtailName = make_shared<string>(boost::any_cast<string>(m["logtailName"]));
    }
    if (m.find("projectName") != m.end() && !m["projectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["projectName"]));
    }
  }


  virtual ~SLSConfigCollectConfigs() = default;
};
class SLSConfig : public Darabonba::Model {
public:
  shared_ptr<vector<SLSConfigCollectConfigs>> collectConfigs{};

  SLSConfig() {}

  explicit SLSConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (collectConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*collectConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["collectConfigs"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("collectConfigs") != m.end() && !m["collectConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["collectConfigs"].type()) {
        vector<SLSConfigCollectConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["collectConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SLSConfigCollectConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        collectConfigs = make_shared<vector<SLSConfigCollectConfigs>>(expect1);
      }
    }
  }


  virtual ~SLSConfig() = default;
};
class JaegerConfig : public Darabonba::Model {
public:
  shared_ptr<string> endpoint{};

  JaegerConfig() {}

  explicit JaegerConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endpoint) {
      res["endpoint"] = boost::any(*endpoint);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("endpoint") != m.end() && !m["endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["endpoint"]));
    }
  }


  virtual ~JaegerConfig() = default;
};
class TracingConfig : public Darabonba::Model {
public:
  shared_ptr<JaegerConfig> jaegerConfig{};
  shared_ptr<boost::any> params{};
  shared_ptr<string> type{};

  TracingConfig() {}

  explicit TracingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jaegerConfig) {
      res["jaegerConfig"] = jaegerConfig ? boost::any(jaegerConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (params) {
      res["params"] = boost::any(*params);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("jaegerConfig") != m.end() && !m["jaegerConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["jaegerConfig"].type()) {
        JaegerConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["jaegerConfig"]));
        jaegerConfig = make_shared<JaegerConfig>(model1);
      }
    }
    if (m.find("params") != m.end() && !m["params"].empty()) {
      params = make_shared<boost::any>(boost::any_cast<boost::any>(m["params"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~TracingConfig() = default;
};
class Version : public Darabonba::Model {
public:
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<string> image{};
  shared_ptr<string> lastModifiedTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> versionId{};
  shared_ptr<double> weight{};

  Version() {}

  explicit Version(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdTime) {
      res["createdTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (image) {
      res["image"] = boost::any(*image);
    }
    if (lastModifiedTime) {
      res["lastModifiedTime"] = boost::any(*lastModifiedTime);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (versionId) {
      res["versionId"] = boost::any(*versionId);
    }
    if (weight) {
      res["weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("createdTime") != m.end() && !m["createdTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["createdTime"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("image") != m.end() && !m["image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["image"]));
    }
    if (m.find("lastModifiedTime") != m.end() && !m["lastModifiedTime"].empty()) {
      lastModifiedTime = make_shared<string>(boost::any_cast<string>(m["lastModifiedTime"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("versionId") != m.end() && !m["versionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["versionId"]));
    }
    if (m.find("weight") != m.end() && !m["weight"].empty()) {
      weight = make_shared<double>(boost::any_cast<double>(m["weight"]));
    }
  }


  virtual ~Version() = default;
};
class VPCConfig : public Darabonba::Model {
public:
  shared_ptr<bool> anytunnelViaENI{};
  shared_ptr<string> role{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<vector<string>> vSwitchIds{};
  shared_ptr<string> vpcId{};

  VPCConfig() {}

  explicit VPCConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (anytunnelViaENI) {
      res["anytunnelViaENI"] = boost::any(*anytunnelViaENI);
    }
    if (role) {
      res["role"] = boost::any(*role);
    }
    if (securityGroupId) {
      res["securityGroupId"] = boost::any(*securityGroupId);
    }
    if (vSwitchIds) {
      res["vSwitchIds"] = boost::any(*vSwitchIds);
    }
    if (vpcId) {
      res["vpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("anytunnelViaENI") != m.end() && !m["anytunnelViaENI"].empty()) {
      anytunnelViaENI = make_shared<bool>(boost::any_cast<bool>(m["anytunnelViaENI"]));
    }
    if (m.find("role") != m.end() && !m["role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["role"]));
    }
    if (m.find("securityGroupId") != m.end() && !m["securityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["securityGroupId"]));
    }
    if (m.find("vSwitchIds") != m.end() && !m["vSwitchIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["vSwitchIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["vSwitchIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vSwitchIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("vpcId") != m.end() && !m["vpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["vpcId"]));
    }
  }


  virtual ~VPCConfig() = default;
};
class Application : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> applicationId{};
  shared_ptr<string> applicationName{};
  shared_ptr<string> args{};
  shared_ptr<long> caPort{};
  shared_ptr<string> codeChecksum{};
  shared_ptr<long> codeSize{};
  shared_ptr<string> command{};
  shared_ptr<double> cpu{};
  shared_ptr<string> createdTime{};
  shared_ptr<CustomDNS> customDNS{};
  shared_ptr<string> customDomainName{};
  shared_ptr<CustomHealthCheckConfig> customHealthCheckConfig{};
  shared_ptr<CustomHostAlias> customHostAlias{};
  shared_ptr<CustomRuntimeConfig> customRuntimeConfig{};
  shared_ptr<string> description{};
  shared_ptr<long> diskSize{};
  shared_ptr<bool> enableAppMetric{};
  shared_ptr<bool> enableArmsAdvanced{};
  shared_ptr<map<string, string>> environmentVariables{};
  shared_ptr<long> gpuMemorySize{};
  shared_ptr<string> handler{};
  shared_ptr<HTTPTriggerConfig> httpTriggerConfig{};
  shared_ptr<ImageConfig> imageConfig{};
  shared_ptr<long> initializationTimeout{};
  shared_ptr<string> initializer{};
  shared_ptr<long> instanceConcurrency{};
  shared_ptr<InstanceLifecycleConfig> instanceLifecycleConfig{};
  shared_ptr<long> instanceSoftConcurrency{};
  shared_ptr<string> instanceType{};
  shared_ptr<bool> internetAccess{};
  shared_ptr<string> lastModifiedTime{};
  shared_ptr<vector<string>> layers{};
  shared_ptr<vector<string>> layersArnV2{};
  shared_ptr<Probe> livenessProbe{};
  shared_ptr<LogConfig> logConfig{};
  shared_ptr<long> memorySize{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> namespaceID{};
  shared_ptr<string> namespaceName{};
  shared_ptr<NASConfig> nasConfig{};
  shared_ptr<OSSMountConfig> ossMountConfig{};
  shared_ptr<string> programmingLanguage{};
  shared_ptr<string> runtime{};
  shared_ptr<ScaleConfig> scaleConfig{};
  shared_ptr<SLSConfig> slsConfig{};
  shared_ptr<Probe> startupProbe{};
  shared_ptr<long> timeout{};
  shared_ptr<TracingConfig> tracingConfig{};
  shared_ptr<string> urlInternet{};
  shared_ptr<string> urlIntranet{};
  shared_ptr<Version> version{};
  shared_ptr<VPCConfig> vpcConfig{};

  Application() {}

  explicit Application(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (applicationId) {
      res["applicationId"] = boost::any(*applicationId);
    }
    if (applicationName) {
      res["applicationName"] = boost::any(*applicationName);
    }
    if (args) {
      res["args"] = boost::any(*args);
    }
    if (caPort) {
      res["caPort"] = boost::any(*caPort);
    }
    if (codeChecksum) {
      res["codeChecksum"] = boost::any(*codeChecksum);
    }
    if (codeSize) {
      res["codeSize"] = boost::any(*codeSize);
    }
    if (command) {
      res["command"] = boost::any(*command);
    }
    if (cpu) {
      res["cpu"] = boost::any(*cpu);
    }
    if (createdTime) {
      res["createdTime"] = boost::any(*createdTime);
    }
    if (customDNS) {
      res["customDNS"] = customDNS ? boost::any(customDNS->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (customDomainName) {
      res["customDomainName"] = boost::any(*customDomainName);
    }
    if (customHealthCheckConfig) {
      res["customHealthCheckConfig"] = customHealthCheckConfig ? boost::any(customHealthCheckConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (customHostAlias) {
      res["customHostAlias"] = customHostAlias ? boost::any(customHostAlias->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (customRuntimeConfig) {
      res["customRuntimeConfig"] = customRuntimeConfig ? boost::any(customRuntimeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (diskSize) {
      res["diskSize"] = boost::any(*diskSize);
    }
    if (enableAppMetric) {
      res["enableAppMetric"] = boost::any(*enableAppMetric);
    }
    if (enableArmsAdvanced) {
      res["enableArmsAdvanced"] = boost::any(*enableArmsAdvanced);
    }
    if (environmentVariables) {
      res["environmentVariables"] = boost::any(*environmentVariables);
    }
    if (gpuMemorySize) {
      res["gpuMemorySize"] = boost::any(*gpuMemorySize);
    }
    if (handler) {
      res["handler"] = boost::any(*handler);
    }
    if (httpTriggerConfig) {
      res["httpTriggerConfig"] = httpTriggerConfig ? boost::any(httpTriggerConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (imageConfig) {
      res["imageConfig"] = imageConfig ? boost::any(imageConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (initializationTimeout) {
      res["initializationTimeout"] = boost::any(*initializationTimeout);
    }
    if (initializer) {
      res["initializer"] = boost::any(*initializer);
    }
    if (instanceConcurrency) {
      res["instanceConcurrency"] = boost::any(*instanceConcurrency);
    }
    if (instanceLifecycleConfig) {
      res["instanceLifecycleConfig"] = instanceLifecycleConfig ? boost::any(instanceLifecycleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceSoftConcurrency) {
      res["instanceSoftConcurrency"] = boost::any(*instanceSoftConcurrency);
    }
    if (instanceType) {
      res["instanceType"] = boost::any(*instanceType);
    }
    if (internetAccess) {
      res["internetAccess"] = boost::any(*internetAccess);
    }
    if (lastModifiedTime) {
      res["lastModifiedTime"] = boost::any(*lastModifiedTime);
    }
    if (layers) {
      res["layers"] = boost::any(*layers);
    }
    if (layersArnV2) {
      res["layersArnV2"] = boost::any(*layersArnV2);
    }
    if (livenessProbe) {
      res["livenessProbe"] = livenessProbe ? boost::any(livenessProbe->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (logConfig) {
      res["logConfig"] = logConfig ? boost::any(logConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (memorySize) {
      res["memorySize"] = boost::any(*memorySize);
    }
    if (namespace_) {
      res["namespace"] = boost::any(*namespace_);
    }
    if (namespaceID) {
      res["namespaceID"] = boost::any(*namespaceID);
    }
    if (namespaceName) {
      res["namespaceName"] = boost::any(*namespaceName);
    }
    if (nasConfig) {
      res["nasConfig"] = nasConfig ? boost::any(nasConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ossMountConfig) {
      res["ossMountConfig"] = ossMountConfig ? boost::any(ossMountConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (programmingLanguage) {
      res["programmingLanguage"] = boost::any(*programmingLanguage);
    }
    if (runtime) {
      res["runtime"] = boost::any(*runtime);
    }
    if (scaleConfig) {
      res["scaleConfig"] = scaleConfig ? boost::any(scaleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (slsConfig) {
      res["slsConfig"] = slsConfig ? boost::any(slsConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (startupProbe) {
      res["startupProbe"] = startupProbe ? boost::any(startupProbe->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timeout) {
      res["timeout"] = boost::any(*timeout);
    }
    if (tracingConfig) {
      res["tracingConfig"] = tracingConfig ? boost::any(tracingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (urlInternet) {
      res["urlInternet"] = boost::any(*urlInternet);
    }
    if (urlIntranet) {
      res["urlIntranet"] = boost::any(*urlIntranet);
    }
    if (version) {
      res["version"] = version ? boost::any(version->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vpcConfig) {
      res["vpcConfig"] = vpcConfig ? boost::any(vpcConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("applicationId") != m.end() && !m["applicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["applicationId"]));
    }
    if (m.find("applicationName") != m.end() && !m["applicationName"].empty()) {
      applicationName = make_shared<string>(boost::any_cast<string>(m["applicationName"]));
    }
    if (m.find("args") != m.end() && !m["args"].empty()) {
      args = make_shared<string>(boost::any_cast<string>(m["args"]));
    }
    if (m.find("caPort") != m.end() && !m["caPort"].empty()) {
      caPort = make_shared<long>(boost::any_cast<long>(m["caPort"]));
    }
    if (m.find("codeChecksum") != m.end() && !m["codeChecksum"].empty()) {
      codeChecksum = make_shared<string>(boost::any_cast<string>(m["codeChecksum"]));
    }
    if (m.find("codeSize") != m.end() && !m["codeSize"].empty()) {
      codeSize = make_shared<long>(boost::any_cast<long>(m["codeSize"]));
    }
    if (m.find("command") != m.end() && !m["command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["command"]));
    }
    if (m.find("cpu") != m.end() && !m["cpu"].empty()) {
      cpu = make_shared<double>(boost::any_cast<double>(m["cpu"]));
    }
    if (m.find("createdTime") != m.end() && !m["createdTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["createdTime"]));
    }
    if (m.find("customDNS") != m.end() && !m["customDNS"].empty()) {
      if (typeid(map<string, boost::any>) == m["customDNS"].type()) {
        CustomDNS model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["customDNS"]));
        customDNS = make_shared<CustomDNS>(model1);
      }
    }
    if (m.find("customDomainName") != m.end() && !m["customDomainName"].empty()) {
      customDomainName = make_shared<string>(boost::any_cast<string>(m["customDomainName"]));
    }
    if (m.find("customHealthCheckConfig") != m.end() && !m["customHealthCheckConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["customHealthCheckConfig"].type()) {
        CustomHealthCheckConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["customHealthCheckConfig"]));
        customHealthCheckConfig = make_shared<CustomHealthCheckConfig>(model1);
      }
    }
    if (m.find("customHostAlias") != m.end() && !m["customHostAlias"].empty()) {
      if (typeid(map<string, boost::any>) == m["customHostAlias"].type()) {
        CustomHostAlias model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["customHostAlias"]));
        customHostAlias = make_shared<CustomHostAlias>(model1);
      }
    }
    if (m.find("customRuntimeConfig") != m.end() && !m["customRuntimeConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["customRuntimeConfig"].type()) {
        CustomRuntimeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["customRuntimeConfig"]));
        customRuntimeConfig = make_shared<CustomRuntimeConfig>(model1);
      }
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("diskSize") != m.end() && !m["diskSize"].empty()) {
      diskSize = make_shared<long>(boost::any_cast<long>(m["diskSize"]));
    }
    if (m.find("enableAppMetric") != m.end() && !m["enableAppMetric"].empty()) {
      enableAppMetric = make_shared<bool>(boost::any_cast<bool>(m["enableAppMetric"]));
    }
    if (m.find("enableArmsAdvanced") != m.end() && !m["enableArmsAdvanced"].empty()) {
      enableArmsAdvanced = make_shared<bool>(boost::any_cast<bool>(m["enableArmsAdvanced"]));
    }
    if (m.find("environmentVariables") != m.end() && !m["environmentVariables"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["environmentVariables"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      environmentVariables = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("gpuMemorySize") != m.end() && !m["gpuMemorySize"].empty()) {
      gpuMemorySize = make_shared<long>(boost::any_cast<long>(m["gpuMemorySize"]));
    }
    if (m.find("handler") != m.end() && !m["handler"].empty()) {
      handler = make_shared<string>(boost::any_cast<string>(m["handler"]));
    }
    if (m.find("httpTriggerConfig") != m.end() && !m["httpTriggerConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["httpTriggerConfig"].type()) {
        HTTPTriggerConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["httpTriggerConfig"]));
        httpTriggerConfig = make_shared<HTTPTriggerConfig>(model1);
      }
    }
    if (m.find("imageConfig") != m.end() && !m["imageConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["imageConfig"].type()) {
        ImageConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["imageConfig"]));
        imageConfig = make_shared<ImageConfig>(model1);
      }
    }
    if (m.find("initializationTimeout") != m.end() && !m["initializationTimeout"].empty()) {
      initializationTimeout = make_shared<long>(boost::any_cast<long>(m["initializationTimeout"]));
    }
    if (m.find("initializer") != m.end() && !m["initializer"].empty()) {
      initializer = make_shared<string>(boost::any_cast<string>(m["initializer"]));
    }
    if (m.find("instanceConcurrency") != m.end() && !m["instanceConcurrency"].empty()) {
      instanceConcurrency = make_shared<long>(boost::any_cast<long>(m["instanceConcurrency"]));
    }
    if (m.find("instanceLifecycleConfig") != m.end() && !m["instanceLifecycleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["instanceLifecycleConfig"].type()) {
        InstanceLifecycleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["instanceLifecycleConfig"]));
        instanceLifecycleConfig = make_shared<InstanceLifecycleConfig>(model1);
      }
    }
    if (m.find("instanceSoftConcurrency") != m.end() && !m["instanceSoftConcurrency"].empty()) {
      instanceSoftConcurrency = make_shared<long>(boost::any_cast<long>(m["instanceSoftConcurrency"]));
    }
    if (m.find("instanceType") != m.end() && !m["instanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["instanceType"]));
    }
    if (m.find("internetAccess") != m.end() && !m["internetAccess"].empty()) {
      internetAccess = make_shared<bool>(boost::any_cast<bool>(m["internetAccess"]));
    }
    if (m.find("lastModifiedTime") != m.end() && !m["lastModifiedTime"].empty()) {
      lastModifiedTime = make_shared<string>(boost::any_cast<string>(m["lastModifiedTime"]));
    }
    if (m.find("layers") != m.end() && !m["layers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["layers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["layers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      layers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("layersArnV2") != m.end() && !m["layersArnV2"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["layersArnV2"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["layersArnV2"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      layersArnV2 = make_shared<vector<string>>(toVec1);
    }
    if (m.find("livenessProbe") != m.end() && !m["livenessProbe"].empty()) {
      if (typeid(map<string, boost::any>) == m["livenessProbe"].type()) {
        Probe model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["livenessProbe"]));
        livenessProbe = make_shared<Probe>(model1);
      }
    }
    if (m.find("logConfig") != m.end() && !m["logConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["logConfig"].type()) {
        LogConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["logConfig"]));
        logConfig = make_shared<LogConfig>(model1);
      }
    }
    if (m.find("memorySize") != m.end() && !m["memorySize"].empty()) {
      memorySize = make_shared<long>(boost::any_cast<long>(m["memorySize"]));
    }
    if (m.find("namespace") != m.end() && !m["namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["namespace"]));
    }
    if (m.find("namespaceID") != m.end() && !m["namespaceID"].empty()) {
      namespaceID = make_shared<string>(boost::any_cast<string>(m["namespaceID"]));
    }
    if (m.find("namespaceName") != m.end() && !m["namespaceName"].empty()) {
      namespaceName = make_shared<string>(boost::any_cast<string>(m["namespaceName"]));
    }
    if (m.find("nasConfig") != m.end() && !m["nasConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["nasConfig"].type()) {
        NASConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["nasConfig"]));
        nasConfig = make_shared<NASConfig>(model1);
      }
    }
    if (m.find("ossMountConfig") != m.end() && !m["ossMountConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ossMountConfig"].type()) {
        OSSMountConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ossMountConfig"]));
        ossMountConfig = make_shared<OSSMountConfig>(model1);
      }
    }
    if (m.find("programmingLanguage") != m.end() && !m["programmingLanguage"].empty()) {
      programmingLanguage = make_shared<string>(boost::any_cast<string>(m["programmingLanguage"]));
    }
    if (m.find("runtime") != m.end() && !m["runtime"].empty()) {
      runtime = make_shared<string>(boost::any_cast<string>(m["runtime"]));
    }
    if (m.find("scaleConfig") != m.end() && !m["scaleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["scaleConfig"].type()) {
        ScaleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["scaleConfig"]));
        scaleConfig = make_shared<ScaleConfig>(model1);
      }
    }
    if (m.find("slsConfig") != m.end() && !m["slsConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["slsConfig"].type()) {
        SLSConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["slsConfig"]));
        slsConfig = make_shared<SLSConfig>(model1);
      }
    }
    if (m.find("startupProbe") != m.end() && !m["startupProbe"].empty()) {
      if (typeid(map<string, boost::any>) == m["startupProbe"].type()) {
        Probe model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["startupProbe"]));
        startupProbe = make_shared<Probe>(model1);
      }
    }
    if (m.find("timeout") != m.end() && !m["timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["timeout"]));
    }
    if (m.find("tracingConfig") != m.end() && !m["tracingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["tracingConfig"].type()) {
        TracingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["tracingConfig"]));
        tracingConfig = make_shared<TracingConfig>(model1);
      }
    }
    if (m.find("urlInternet") != m.end() && !m["urlInternet"].empty()) {
      urlInternet = make_shared<string>(boost::any_cast<string>(m["urlInternet"]));
    }
    if (m.find("urlIntranet") != m.end() && !m["urlIntranet"].empty()) {
      urlIntranet = make_shared<string>(boost::any_cast<string>(m["urlIntranet"]));
    }
    if (m.find("version") != m.end() && !m["version"].empty()) {
      if (typeid(map<string, boost::any>) == m["version"].type()) {
        Version model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["version"]));
        version = make_shared<Version>(model1);
      }
    }
    if (m.find("vpcConfig") != m.end() && !m["vpcConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["vpcConfig"].type()) {
        VPCConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["vpcConfig"]));
        vpcConfig = make_shared<VPCConfig>(model1);
      }
    }
  }


  virtual ~Application() = default;
};
class ApplicationStatus : public Darabonba::Model {
public:
  shared_ptr<long> instanceCount{};
  shared_ptr<ScaleConfig> scaleConfig{};

  ApplicationStatus() {}

  explicit ApplicationStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceCount) {
      res["instanceCount"] = boost::any(*instanceCount);
    }
    if (scaleConfig) {
      res["scaleConfig"] = scaleConfig ? boost::any(scaleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("instanceCount") != m.end() && !m["instanceCount"].empty()) {
      instanceCount = make_shared<long>(boost::any_cast<long>(m["instanceCount"]));
    }
    if (m.find("scaleConfig") != m.end() && !m["scaleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["scaleConfig"].type()) {
        ScaleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["scaleConfig"]));
        scaleConfig = make_shared<ScaleConfig>(model1);
      }
    }
  }


  virtual ~ApplicationStatus() = default;
};
class ApplicationWithStatus : public Darabonba::Model {
public:
  shared_ptr<Application> application{};
  shared_ptr<ApplicationStatus> status{};

  ApplicationWithStatus() {}

  explicit ApplicationWithStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (application) {
      res["application"] = application ? boost::any(application->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["status"] = status ? boost::any(status->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("application") != m.end() && !m["application"].empty()) {
      if (typeid(map<string, boost::any>) == m["application"].type()) {
        Application model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["application"]));
        application = make_shared<Application>(model1);
      }
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      if (typeid(map<string, boost::any>) == m["status"].type()) {
        ApplicationStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["status"]));
        status = make_shared<ApplicationStatus>(model1);
      }
    }
  }


  virtual ~ApplicationWithStatus() = default;
};
class ArmsConfig : public Darabonba::Model {
public:
  shared_ptr<string> agentVersion{};
  shared_ptr<string> appId{};
  shared_ptr<string> licenseKey{};

  ArmsConfig() {}

  explicit ArmsConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentVersion) {
      res["agentVersion"] = boost::any(*agentVersion);
    }
    if (appId) {
      res["appId"] = boost::any(*appId);
    }
    if (licenseKey) {
      res["licenseKey"] = boost::any(*licenseKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("agentVersion") != m.end() && !m["agentVersion"].empty()) {
      agentVersion = make_shared<string>(boost::any_cast<string>(m["agentVersion"]));
    }
    if (m.find("appId") != m.end() && !m["appId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["appId"]));
    }
    if (m.find("licenseKey") != m.end() && !m["licenseKey"].empty()) {
      licenseKey = make_shared<string>(boost::any_cast<string>(m["licenseKey"]));
    }
  }


  virtual ~ArmsConfig() = default;
};
class TomcatConfig : public Darabonba::Model {
public:
  shared_ptr<string> contextPath{};
  shared_ptr<long> maxThreads{};
  shared_ptr<long> port{};
  shared_ptr<string> uriEncoding{};
  shared_ptr<bool> useBodyEncodingForUri{};
  shared_ptr<string> version{};

  TomcatConfig() {}

  explicit TomcatConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contextPath) {
      res["ContextPath"] = boost::any(*contextPath);
    }
    if (maxThreads) {
      res["MaxThreads"] = boost::any(*maxThreads);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (uriEncoding) {
      res["UriEncoding"] = boost::any(*uriEncoding);
    }
    if (useBodyEncodingForUri) {
      res["UseBodyEncodingForUri"] = boost::any(*useBodyEncodingForUri);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContextPath") != m.end() && !m["ContextPath"].empty()) {
      contextPath = make_shared<string>(boost::any_cast<string>(m["ContextPath"]));
    }
    if (m.find("MaxThreads") != m.end() && !m["MaxThreads"].empty()) {
      maxThreads = make_shared<long>(boost::any_cast<long>(m["MaxThreads"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("UriEncoding") != m.end() && !m["UriEncoding"].empty()) {
      uriEncoding = make_shared<string>(boost::any_cast<string>(m["UriEncoding"]));
    }
    if (m.find("UseBodyEncodingForUri") != m.end() && !m["UseBodyEncodingForUri"].empty()) {
      useBodyEncodingForUri = make_shared<bool>(boost::any_cast<bool>(m["UseBodyEncodingForUri"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~TomcatConfig() = default;
};
class BuildPipelineBuildConfig : public Darabonba::Model {
public:
  shared_ptr<string> beforeBuildCommand{};
  shared_ptr<string> buildType{};
  shared_ptr<string> dockerfilePath{};
  shared_ptr<string> runCommand{};
  shared_ptr<string> runtimeType{};
  shared_ptr<string> runtimeVersion{};
  shared_ptr<TomcatConfig> tomcatConfig{};
  shared_ptr<string> workingDir{};

  BuildPipelineBuildConfig() {}

  explicit BuildPipelineBuildConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beforeBuildCommand) {
      res["BeforeBuildCommand"] = boost::any(*beforeBuildCommand);
    }
    if (buildType) {
      res["BuildType"] = boost::any(*buildType);
    }
    if (dockerfilePath) {
      res["DockerfilePath"] = boost::any(*dockerfilePath);
    }
    if (runCommand) {
      res["RunCommand"] = boost::any(*runCommand);
    }
    if (runtimeType) {
      res["RuntimeType"] = boost::any(*runtimeType);
    }
    if (runtimeVersion) {
      res["RuntimeVersion"] = boost::any(*runtimeVersion);
    }
    if (tomcatConfig) {
      res["TomcatConfig"] = tomcatConfig ? boost::any(tomcatConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (workingDir) {
      res["WorkingDir"] = boost::any(*workingDir);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BeforeBuildCommand") != m.end() && !m["BeforeBuildCommand"].empty()) {
      beforeBuildCommand = make_shared<string>(boost::any_cast<string>(m["BeforeBuildCommand"]));
    }
    if (m.find("BuildType") != m.end() && !m["BuildType"].empty()) {
      buildType = make_shared<string>(boost::any_cast<string>(m["BuildType"]));
    }
    if (m.find("DockerfilePath") != m.end() && !m["DockerfilePath"].empty()) {
      dockerfilePath = make_shared<string>(boost::any_cast<string>(m["DockerfilePath"]));
    }
    if (m.find("RunCommand") != m.end() && !m["RunCommand"].empty()) {
      runCommand = make_shared<string>(boost::any_cast<string>(m["RunCommand"]));
    }
    if (m.find("RuntimeType") != m.end() && !m["RuntimeType"].empty()) {
      runtimeType = make_shared<string>(boost::any_cast<string>(m["RuntimeType"]));
    }
    if (m.find("RuntimeVersion") != m.end() && !m["RuntimeVersion"].empty()) {
      runtimeVersion = make_shared<string>(boost::any_cast<string>(m["RuntimeVersion"]));
    }
    if (m.find("TomcatConfig") != m.end() && !m["TomcatConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TomcatConfig"].type()) {
        TomcatConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TomcatConfig"]));
        tomcatConfig = make_shared<TomcatConfig>(model1);
      }
    }
    if (m.find("WorkingDir") != m.end() && !m["WorkingDir"].empty()) {
      workingDir = make_shared<string>(boost::any_cast<string>(m["WorkingDir"]));
    }
  }


  virtual ~BuildPipelineBuildConfig() = default;
};
class BuildPipelineCodeConfig : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> branchName{};
  shared_ptr<string> commitId{};
  shared_ptr<string> commitUrl{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> provider{};
  shared_ptr<string> repoFullName{};
  shared_ptr<string> repoId{};

  BuildPipelineCodeConfig() {}

  explicit BuildPipelineCodeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (branchName) {
      res["BranchName"] = boost::any(*branchName);
    }
    if (commitId) {
      res["CommitId"] = boost::any(*commitId);
    }
    if (commitUrl) {
      res["CommitUrl"] = boost::any(*commitUrl);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (provider) {
      res["Provider"] = boost::any(*provider);
    }
    if (repoFullName) {
      res["RepoFullName"] = boost::any(*repoFullName);
    }
    if (repoId) {
      res["RepoId"] = boost::any(*repoId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("BranchName") != m.end() && !m["BranchName"].empty()) {
      branchName = make_shared<string>(boost::any_cast<string>(m["BranchName"]));
    }
    if (m.find("CommitId") != m.end() && !m["CommitId"].empty()) {
      commitId = make_shared<string>(boost::any_cast<string>(m["CommitId"]));
    }
    if (m.find("CommitUrl") != m.end() && !m["CommitUrl"].empty()) {
      commitUrl = make_shared<string>(boost::any_cast<string>(m["CommitUrl"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("Provider") != m.end() && !m["Provider"].empty()) {
      provider = make_shared<string>(boost::any_cast<string>(m["Provider"]));
    }
    if (m.find("RepoFullName") != m.end() && !m["RepoFullName"].empty()) {
      repoFullName = make_shared<string>(boost::any_cast<string>(m["RepoFullName"]));
    }
    if (m.find("RepoId") != m.end() && !m["RepoId"].empty()) {
      repoId = make_shared<string>(boost::any_cast<string>(m["RepoId"]));
    }
  }


  virtual ~BuildPipelineCodeConfig() = default;
};
class BuildPipelineDeployConfig : public Darabonba::Model {
public:
  shared_ptr<bool> alwaysAllocateCPU{};
  shared_ptr<long> maximumInstanceCount{};
  shared_ptr<long> minimumInstanceCount{};
  shared_ptr<string> updateApplicationInput{};
  shared_ptr<bool> updateTraffic{};

  BuildPipelineDeployConfig() {}

  explicit BuildPipelineDeployConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alwaysAllocateCPU) {
      res["AlwaysAllocateCPU"] = boost::any(*alwaysAllocateCPU);
    }
    if (maximumInstanceCount) {
      res["MaximumInstanceCount"] = boost::any(*maximumInstanceCount);
    }
    if (minimumInstanceCount) {
      res["MinimumInstanceCount"] = boost::any(*minimumInstanceCount);
    }
    if (updateApplicationInput) {
      res["UpdateApplicationInput"] = boost::any(*updateApplicationInput);
    }
    if (updateTraffic) {
      res["UpdateTraffic"] = boost::any(*updateTraffic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlwaysAllocateCPU") != m.end() && !m["AlwaysAllocateCPU"].empty()) {
      alwaysAllocateCPU = make_shared<bool>(boost::any_cast<bool>(m["AlwaysAllocateCPU"]));
    }
    if (m.find("MaximumInstanceCount") != m.end() && !m["MaximumInstanceCount"].empty()) {
      maximumInstanceCount = make_shared<long>(boost::any_cast<long>(m["MaximumInstanceCount"]));
    }
    if (m.find("MinimumInstanceCount") != m.end() && !m["MinimumInstanceCount"].empty()) {
      minimumInstanceCount = make_shared<long>(boost::any_cast<long>(m["MinimumInstanceCount"]));
    }
    if (m.find("UpdateApplicationInput") != m.end() && !m["UpdateApplicationInput"].empty()) {
      updateApplicationInput = make_shared<string>(boost::any_cast<string>(m["UpdateApplicationInput"]));
    }
    if (m.find("UpdateTraffic") != m.end() && !m["UpdateTraffic"].empty()) {
      updateTraffic = make_shared<bool>(boost::any_cast<bool>(m["UpdateTraffic"]));
    }
  }


  virtual ~BuildPipelineDeployConfig() = default;
};
class BuildPipelineImageConfig : public Darabonba::Model {
public:
  shared_ptr<string> instanceType{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> repository{};

  BuildPipelineImageConfig() {}

  explicit BuildPipelineImageConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (repository) {
      res["Repository"] = boost::any(*repository);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Repository") != m.end() && !m["Repository"].empty()) {
      repository = make_shared<string>(boost::any_cast<string>(m["Repository"]));
    }
  }


  virtual ~BuildPipelineImageConfig() = default;
};
class BuildPipelinePackageConfig : public Darabonba::Model {
public:
  shared_ptr<string> packageName{};
  shared_ptr<string> packageType{};
  shared_ptr<string> packageUrl{};
  shared_ptr<string> packageVersion{};

  BuildPipelinePackageConfig() {}

  explicit BuildPipelinePackageConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (packageName) {
      res["PackageName"] = boost::any(*packageName);
    }
    if (packageType) {
      res["PackageType"] = boost::any(*packageType);
    }
    if (packageUrl) {
      res["PackageUrl"] = boost::any(*packageUrl);
    }
    if (packageVersion) {
      res["PackageVersion"] = boost::any(*packageVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PackageName") != m.end() && !m["PackageName"].empty()) {
      packageName = make_shared<string>(boost::any_cast<string>(m["PackageName"]));
    }
    if (m.find("PackageType") != m.end() && !m["PackageType"].empty()) {
      packageType = make_shared<string>(boost::any_cast<string>(m["PackageType"]));
    }
    if (m.find("PackageUrl") != m.end() && !m["PackageUrl"].empty()) {
      packageUrl = make_shared<string>(boost::any_cast<string>(m["PackageUrl"]));
    }
    if (m.find("PackageVersion") != m.end() && !m["PackageVersion"].empty()) {
      packageVersion = make_shared<string>(boost::any_cast<string>(m["PackageVersion"]));
    }
  }


  virtual ~BuildPipelinePackageConfig() = default;
};
class BuildPipelineTriggerConfig : public Darabonba::Model {
public:
  shared_ptr<string> branchName{};
  shared_ptr<string> tagName{};
  shared_ptr<string> type{};

  BuildPipelineTriggerConfig() {}

  explicit BuildPipelineTriggerConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (branchName) {
      res["BranchName"] = boost::any(*branchName);
    }
    if (tagName) {
      res["TagName"] = boost::any(*tagName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BranchName") != m.end() && !m["BranchName"].empty()) {
      branchName = make_shared<string>(boost::any_cast<string>(m["BranchName"]));
    }
    if (m.find("TagName") != m.end() && !m["TagName"].empty()) {
      tagName = make_shared<string>(boost::any_cast<string>(m["TagName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~BuildPipelineTriggerConfig() = default;
};
class BuildPipeline : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};
  shared_ptr<string> applicationName{};
  shared_ptr<BuildPipelineBuildConfig> buildConfig{};
  shared_ptr<BuildPipelineCodeConfig> codeConfig{};
  shared_ptr<BuildPipelineDeployConfig> deployConfig{};
  shared_ptr<bool> enabled{};
  shared_ptr<BuildPipelineImageConfig> imageConfig{};
  shared_ptr<BuildPipelinePackageConfig> packageConfig{};
  shared_ptr<BuildPipelineTriggerConfig> triggerConfig{};

  BuildPipeline() {}

  explicit BuildPipeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (applicationName) {
      res["ApplicationName"] = boost::any(*applicationName);
    }
    if (buildConfig) {
      res["BuildConfig"] = buildConfig ? boost::any(buildConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (codeConfig) {
      res["CodeConfig"] = codeConfig ? boost::any(codeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (deployConfig) {
      res["DeployConfig"] = deployConfig ? boost::any(deployConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (imageConfig) {
      res["ImageConfig"] = imageConfig ? boost::any(imageConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (packageConfig) {
      res["PackageConfig"] = packageConfig ? boost::any(packageConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (triggerConfig) {
      res["TriggerConfig"] = triggerConfig ? boost::any(triggerConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("ApplicationName") != m.end() && !m["ApplicationName"].empty()) {
      applicationName = make_shared<string>(boost::any_cast<string>(m["ApplicationName"]));
    }
    if (m.find("BuildConfig") != m.end() && !m["BuildConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["BuildConfig"].type()) {
        BuildPipelineBuildConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BuildConfig"]));
        buildConfig = make_shared<BuildPipelineBuildConfig>(model1);
      }
    }
    if (m.find("CodeConfig") != m.end() && !m["CodeConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CodeConfig"].type()) {
        BuildPipelineCodeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CodeConfig"]));
        codeConfig = make_shared<BuildPipelineCodeConfig>(model1);
      }
    }
    if (m.find("DeployConfig") != m.end() && !m["DeployConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeployConfig"].type()) {
        BuildPipelineDeployConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeployConfig"]));
        deployConfig = make_shared<BuildPipelineDeployConfig>(model1);
      }
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("ImageConfig") != m.end() && !m["ImageConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ImageConfig"].type()) {
        BuildPipelineImageConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ImageConfig"]));
        imageConfig = make_shared<BuildPipelineImageConfig>(model1);
      }
    }
    if (m.find("PackageConfig") != m.end() && !m["PackageConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["PackageConfig"].type()) {
        BuildPipelinePackageConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PackageConfig"]));
        packageConfig = make_shared<BuildPipelinePackageConfig>(model1);
      }
    }
    if (m.find("TriggerConfig") != m.end() && !m["TriggerConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TriggerConfig"].type()) {
        BuildPipelineTriggerConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TriggerConfig"]));
        triggerConfig = make_shared<BuildPipelineTriggerConfig>(model1);
      }
    }
  }


  virtual ~BuildPipeline() = default;
};
class BuildPipelineRunBuildConfigTrigger : public Darabonba::Model {
public:
  shared_ptr<string> branchName{};
  shared_ptr<string> tagName{};
  shared_ptr<string> type{};

  BuildPipelineRunBuildConfigTrigger() {}

  explicit BuildPipelineRunBuildConfigTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (branchName) {
      res["BranchName"] = boost::any(*branchName);
    }
    if (tagName) {
      res["TagName"] = boost::any(*tagName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BranchName") != m.end() && !m["BranchName"].empty()) {
      branchName = make_shared<string>(boost::any_cast<string>(m["BranchName"]));
    }
    if (m.find("TagName") != m.end() && !m["TagName"].empty()) {
      tagName = make_shared<string>(boost::any_cast<string>(m["TagName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~BuildPipelineRunBuildConfigTrigger() = default;
};
class BuildPipelineRunBuildConfig : public Darabonba::Model {
public:
  shared_ptr<string> beforeBuildCommand{};
  shared_ptr<string> buildType{};
  shared_ptr<string> dockerfilePath{};
  shared_ptr<string> runCommand{};
  shared_ptr<string> runtimeType{};
  shared_ptr<string> runtimeVersion{};
  shared_ptr<TomcatConfig> tomcatConfig{};
  shared_ptr<BuildPipelineRunBuildConfigTrigger> trigger{};
  shared_ptr<string> workingDir{};

  BuildPipelineRunBuildConfig() {}

  explicit BuildPipelineRunBuildConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beforeBuildCommand) {
      res["BeforeBuildCommand"] = boost::any(*beforeBuildCommand);
    }
    if (buildType) {
      res["BuildType"] = boost::any(*buildType);
    }
    if (dockerfilePath) {
      res["DockerfilePath"] = boost::any(*dockerfilePath);
    }
    if (runCommand) {
      res["RunCommand"] = boost::any(*runCommand);
    }
    if (runtimeType) {
      res["RuntimeType"] = boost::any(*runtimeType);
    }
    if (runtimeVersion) {
      res["RuntimeVersion"] = boost::any(*runtimeVersion);
    }
    if (tomcatConfig) {
      res["TomcatConfig"] = tomcatConfig ? boost::any(tomcatConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (trigger) {
      res["Trigger"] = trigger ? boost::any(trigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (workingDir) {
      res["WorkingDir"] = boost::any(*workingDir);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BeforeBuildCommand") != m.end() && !m["BeforeBuildCommand"].empty()) {
      beforeBuildCommand = make_shared<string>(boost::any_cast<string>(m["BeforeBuildCommand"]));
    }
    if (m.find("BuildType") != m.end() && !m["BuildType"].empty()) {
      buildType = make_shared<string>(boost::any_cast<string>(m["BuildType"]));
    }
    if (m.find("DockerfilePath") != m.end() && !m["DockerfilePath"].empty()) {
      dockerfilePath = make_shared<string>(boost::any_cast<string>(m["DockerfilePath"]));
    }
    if (m.find("RunCommand") != m.end() && !m["RunCommand"].empty()) {
      runCommand = make_shared<string>(boost::any_cast<string>(m["RunCommand"]));
    }
    if (m.find("RuntimeType") != m.end() && !m["RuntimeType"].empty()) {
      runtimeType = make_shared<string>(boost::any_cast<string>(m["RuntimeType"]));
    }
    if (m.find("RuntimeVersion") != m.end() && !m["RuntimeVersion"].empty()) {
      runtimeVersion = make_shared<string>(boost::any_cast<string>(m["RuntimeVersion"]));
    }
    if (m.find("TomcatConfig") != m.end() && !m["TomcatConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TomcatConfig"].type()) {
        TomcatConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TomcatConfig"]));
        tomcatConfig = make_shared<TomcatConfig>(model1);
      }
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["Trigger"].type()) {
        BuildPipelineRunBuildConfigTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Trigger"]));
        trigger = make_shared<BuildPipelineRunBuildConfigTrigger>(model1);
      }
    }
    if (m.find("WorkingDir") != m.end() && !m["WorkingDir"].empty()) {
      workingDir = make_shared<string>(boost::any_cast<string>(m["WorkingDir"]));
    }
  }


  virtual ~BuildPipelineRunBuildConfig() = default;
};
class BuildPipelineRunCodeConfig : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> branchName{};
  shared_ptr<string> commitId{};
  shared_ptr<string> commitUrl{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> provider{};
  shared_ptr<string> repoFullName{};
  shared_ptr<string> repoId{};

  BuildPipelineRunCodeConfig() {}

  explicit BuildPipelineRunCodeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (branchName) {
      res["BranchName"] = boost::any(*branchName);
    }
    if (commitId) {
      res["CommitId"] = boost::any(*commitId);
    }
    if (commitUrl) {
      res["CommitUrl"] = boost::any(*commitUrl);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (provider) {
      res["Provider"] = boost::any(*provider);
    }
    if (repoFullName) {
      res["RepoFullName"] = boost::any(*repoFullName);
    }
    if (repoId) {
      res["RepoId"] = boost::any(*repoId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("BranchName") != m.end() && !m["BranchName"].empty()) {
      branchName = make_shared<string>(boost::any_cast<string>(m["BranchName"]));
    }
    if (m.find("CommitId") != m.end() && !m["CommitId"].empty()) {
      commitId = make_shared<string>(boost::any_cast<string>(m["CommitId"]));
    }
    if (m.find("CommitUrl") != m.end() && !m["CommitUrl"].empty()) {
      commitUrl = make_shared<string>(boost::any_cast<string>(m["CommitUrl"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("Provider") != m.end() && !m["Provider"].empty()) {
      provider = make_shared<string>(boost::any_cast<string>(m["Provider"]));
    }
    if (m.find("RepoFullName") != m.end() && !m["RepoFullName"].empty()) {
      repoFullName = make_shared<string>(boost::any_cast<string>(m["RepoFullName"]));
    }
    if (m.find("RepoId") != m.end() && !m["RepoId"].empty()) {
      repoId = make_shared<string>(boost::any_cast<string>(m["RepoId"]));
    }
  }


  virtual ~BuildPipelineRunCodeConfig() = default;
};
class BuildPipelineRunDeployConfig : public Darabonba::Model {
public:
  shared_ptr<bool> alwaysAllocateCPU{};
  shared_ptr<long> maximumInstanceCount{};
  shared_ptr<long> minimumInstanceCount{};
  shared_ptr<string> updateApplicationInput{};
  shared_ptr<bool> updateTraffic{};

  BuildPipelineRunDeployConfig() {}

  explicit BuildPipelineRunDeployConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alwaysAllocateCPU) {
      res["AlwaysAllocateCPU"] = boost::any(*alwaysAllocateCPU);
    }
    if (maximumInstanceCount) {
      res["MaximumInstanceCount"] = boost::any(*maximumInstanceCount);
    }
    if (minimumInstanceCount) {
      res["MinimumInstanceCount"] = boost::any(*minimumInstanceCount);
    }
    if (updateApplicationInput) {
      res["UpdateApplicationInput"] = boost::any(*updateApplicationInput);
    }
    if (updateTraffic) {
      res["UpdateTraffic"] = boost::any(*updateTraffic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlwaysAllocateCPU") != m.end() && !m["AlwaysAllocateCPU"].empty()) {
      alwaysAllocateCPU = make_shared<bool>(boost::any_cast<bool>(m["AlwaysAllocateCPU"]));
    }
    if (m.find("MaximumInstanceCount") != m.end() && !m["MaximumInstanceCount"].empty()) {
      maximumInstanceCount = make_shared<long>(boost::any_cast<long>(m["MaximumInstanceCount"]));
    }
    if (m.find("MinimumInstanceCount") != m.end() && !m["MinimumInstanceCount"].empty()) {
      minimumInstanceCount = make_shared<long>(boost::any_cast<long>(m["MinimumInstanceCount"]));
    }
    if (m.find("UpdateApplicationInput") != m.end() && !m["UpdateApplicationInput"].empty()) {
      updateApplicationInput = make_shared<string>(boost::any_cast<string>(m["UpdateApplicationInput"]));
    }
    if (m.find("UpdateTraffic") != m.end() && !m["UpdateTraffic"].empty()) {
      updateTraffic = make_shared<bool>(boost::any_cast<bool>(m["UpdateTraffic"]));
    }
  }


  virtual ~BuildPipelineRunDeployConfig() = default;
};
class BuildPipelineRunImageConfig : public Darabonba::Model {
public:
  shared_ptr<string> instanceType{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> repository{};

  BuildPipelineRunImageConfig() {}

  explicit BuildPipelineRunImageConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (repository) {
      res["Repository"] = boost::any(*repository);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Repository") != m.end() && !m["Repository"].empty()) {
      repository = make_shared<string>(boost::any_cast<string>(m["Repository"]));
    }
  }


  virtual ~BuildPipelineRunImageConfig() = default;
};
class BuildPipelineRunPackageConfig : public Darabonba::Model {
public:
  shared_ptr<string> packageName{};
  shared_ptr<string> packageType{};
  shared_ptr<string> packageUrl{};
  shared_ptr<string> packageVersion{};

  BuildPipelineRunPackageConfig() {}

  explicit BuildPipelineRunPackageConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (packageName) {
      res["PackageName"] = boost::any(*packageName);
    }
    if (packageType) {
      res["PackageType"] = boost::any(*packageType);
    }
    if (packageUrl) {
      res["PackageUrl"] = boost::any(*packageUrl);
    }
    if (packageVersion) {
      res["PackageVersion"] = boost::any(*packageVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PackageName") != m.end() && !m["PackageName"].empty()) {
      packageName = make_shared<string>(boost::any_cast<string>(m["PackageName"]));
    }
    if (m.find("PackageType") != m.end() && !m["PackageType"].empty()) {
      packageType = make_shared<string>(boost::any_cast<string>(m["PackageType"]));
    }
    if (m.find("PackageUrl") != m.end() && !m["PackageUrl"].empty()) {
      packageUrl = make_shared<string>(boost::any_cast<string>(m["PackageUrl"]));
    }
    if (m.find("PackageVersion") != m.end() && !m["PackageVersion"].empty()) {
      packageVersion = make_shared<string>(boost::any_cast<string>(m["PackageVersion"]));
    }
  }


  virtual ~BuildPipelineRunPackageConfig() = default;
};
class BuildPipelineRunSteps : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<long> duration{};
  shared_ptr<long> endTime{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> result{};
  shared_ptr<long> startTime{};
  shared_ptr<string> status{};

  BuildPipelineRunSteps() {}

  explicit BuildPipelineRunSteps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~BuildPipelineRunSteps() = default;
};
class BuildPipelineRunTriggerConfig : public Darabonba::Model {
public:
  shared_ptr<string> branchName{};
  shared_ptr<string> tagName{};
  shared_ptr<string> type{};

  BuildPipelineRunTriggerConfig() {}

  explicit BuildPipelineRunTriggerConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (branchName) {
      res["BranchName"] = boost::any(*branchName);
    }
    if (tagName) {
      res["TagName"] = boost::any(*tagName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BranchName") != m.end() && !m["BranchName"].empty()) {
      branchName = make_shared<string>(boost::any_cast<string>(m["BranchName"]));
    }
    if (m.find("TagName") != m.end() && !m["TagName"].empty()) {
      tagName = make_shared<string>(boost::any_cast<string>(m["TagName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~BuildPipelineRunTriggerConfig() = default;
};
class BuildPipelineRun : public Darabonba::Model {
public:
  shared_ptr<BuildPipelineRunBuildConfig> buildConfig{};
  shared_ptr<long> buildDuration{};
  shared_ptr<BuildPipelineRunCodeConfig> codeConfig{};
  shared_ptr<long> createTime{};
  shared_ptr<BuildPipelineRunDeployConfig> deployConfig{};
  shared_ptr<long> deployDuration{};
  shared_ptr<long> endTime{};
  shared_ptr<BuildPipelineRunImageConfig> imageConfig{};
  shared_ptr<BuildPipelineRunPackageConfig> packageConfig{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> pipelineRunId{};
  shared_ptr<long> startTime{};
  shared_ptr<string> status{};
  shared_ptr<vector<BuildPipelineRunSteps>> steps{};
  shared_ptr<BuildPipelineRunTriggerConfig> triggerConfig{};
  shared_ptr<string> versionId{};
  shared_ptr<long> waitDuration{};

  BuildPipelineRun() {}

  explicit BuildPipelineRun(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (buildConfig) {
      res["BuildConfig"] = buildConfig ? boost::any(buildConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (buildDuration) {
      res["BuildDuration"] = boost::any(*buildDuration);
    }
    if (codeConfig) {
      res["CodeConfig"] = codeConfig ? boost::any(codeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (deployConfig) {
      res["DeployConfig"] = deployConfig ? boost::any(deployConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (deployDuration) {
      res["DeployDuration"] = boost::any(*deployDuration);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (imageConfig) {
      res["ImageConfig"] = imageConfig ? boost::any(imageConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (packageConfig) {
      res["PackageConfig"] = packageConfig ? boost::any(packageConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (pipelineRunId) {
      res["PipelineRunId"] = boost::any(*pipelineRunId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (steps) {
      vector<boost::any> temp1;
      for(auto item1:*steps){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Steps"] = boost::any(temp1);
    }
    if (triggerConfig) {
      res["TriggerConfig"] = triggerConfig ? boost::any(triggerConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    if (waitDuration) {
      res["WaitDuration"] = boost::any(*waitDuration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BuildConfig") != m.end() && !m["BuildConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["BuildConfig"].type()) {
        BuildPipelineRunBuildConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BuildConfig"]));
        buildConfig = make_shared<BuildPipelineRunBuildConfig>(model1);
      }
    }
    if (m.find("BuildDuration") != m.end() && !m["BuildDuration"].empty()) {
      buildDuration = make_shared<long>(boost::any_cast<long>(m["BuildDuration"]));
    }
    if (m.find("CodeConfig") != m.end() && !m["CodeConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CodeConfig"].type()) {
        BuildPipelineRunCodeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CodeConfig"]));
        codeConfig = make_shared<BuildPipelineRunCodeConfig>(model1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DeployConfig") != m.end() && !m["DeployConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeployConfig"].type()) {
        BuildPipelineRunDeployConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeployConfig"]));
        deployConfig = make_shared<BuildPipelineRunDeployConfig>(model1);
      }
    }
    if (m.find("DeployDuration") != m.end() && !m["DeployDuration"].empty()) {
      deployDuration = make_shared<long>(boost::any_cast<long>(m["DeployDuration"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("ImageConfig") != m.end() && !m["ImageConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ImageConfig"].type()) {
        BuildPipelineRunImageConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ImageConfig"]));
        imageConfig = make_shared<BuildPipelineRunImageConfig>(model1);
      }
    }
    if (m.find("PackageConfig") != m.end() && !m["PackageConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["PackageConfig"].type()) {
        BuildPipelineRunPackageConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PackageConfig"]));
        packageConfig = make_shared<BuildPipelineRunPackageConfig>(model1);
      }
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("PipelineRunId") != m.end() && !m["PipelineRunId"].empty()) {
      pipelineRunId = make_shared<string>(boost::any_cast<string>(m["PipelineRunId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Steps") != m.end() && !m["Steps"].empty()) {
      if (typeid(vector<boost::any>) == m["Steps"].type()) {
        vector<BuildPipelineRunSteps> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Steps"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BuildPipelineRunSteps model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        steps = make_shared<vector<BuildPipelineRunSteps>>(expect1);
      }
    }
    if (m.find("TriggerConfig") != m.end() && !m["TriggerConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TriggerConfig"].type()) {
        BuildPipelineRunTriggerConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TriggerConfig"]));
        triggerConfig = make_shared<BuildPipelineRunTriggerConfig>(model1);
      }
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
    if (m.find("WaitDuration") != m.end() && !m["WaitDuration"].empty()) {
      waitDuration = make_shared<long>(boost::any_cast<long>(m["WaitDuration"]));
    }
  }


  virtual ~BuildPipelineRun() = default;
};
class BuildPipelineRunLogLine : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> offset{};

  BuildPipelineRunLogLine() {}

  explicit BuildPipelineRunLogLine(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (offset) {
      res["Offset"] = boost::any(*offset);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Offset") != m.end() && !m["Offset"].empty()) {
      offset = make_shared<long>(boost::any_cast<long>(m["Offset"]));
    }
  }


  virtual ~BuildPipelineRunLogLine() = default;
};
class CertConfig : public Darabonba::Model {
public:
  shared_ptr<string> certName{};
  shared_ptr<string> certificate{};
  shared_ptr<string> privateKey{};

  CertConfig() {}

  explicit CertConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certName) {
      res["certName"] = boost::any(*certName);
    }
    if (certificate) {
      res["certificate"] = boost::any(*certificate);
    }
    if (privateKey) {
      res["privateKey"] = boost::any(*privateKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("certName") != m.end() && !m["certName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["certName"]));
    }
    if (m.find("certificate") != m.end() && !m["certificate"].empty()) {
      certificate = make_shared<string>(boost::any_cast<string>(m["certificate"]));
    }
    if (m.find("privateKey") != m.end() && !m["privateKey"].empty()) {
      privateKey = make_shared<string>(boost::any_cast<string>(m["privateKey"]));
    }
  }


  virtual ~CertConfig() = default;
};
class RegistryAuthenticationConfig : public Darabonba::Model {
public:
  shared_ptr<string> password{};
  shared_ptr<string> userName{};

  RegistryAuthenticationConfig() {}

  explicit RegistryAuthenticationConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~RegistryAuthenticationConfig() = default;
};
class RegistryCertificateConfig : public Darabonba::Model {
public:
  shared_ptr<string> certBase64{};
  shared_ptr<bool> insecure{};

  RegistryCertificateConfig() {}

  explicit RegistryCertificateConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certBase64) {
      res["CertBase64"] = boost::any(*certBase64);
    }
    if (insecure) {
      res["Insecure"] = boost::any(*insecure);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertBase64") != m.end() && !m["CertBase64"].empty()) {
      certBase64 = make_shared<string>(boost::any_cast<string>(m["CertBase64"]));
    }
    if (m.find("Insecure") != m.end() && !m["Insecure"].empty()) {
      insecure = make_shared<bool>(boost::any_cast<bool>(m["Insecure"]));
    }
  }


  virtual ~RegistryCertificateConfig() = default;
};
class ImageRegistryConfig : public Darabonba::Model {
public:
  shared_ptr<RegistryAuthenticationConfig> authConfig{};
  shared_ptr<RegistryCertificateConfig> certConfig{};

  ImageRegistryConfig() {}

  explicit ImageRegistryConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authConfig) {
      res["AuthConfig"] = authConfig ? boost::any(authConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (certConfig) {
      res["CertConfig"] = certConfig ? boost::any(certConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthConfig") != m.end() && !m["AuthConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["AuthConfig"].type()) {
        RegistryAuthenticationConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AuthConfig"]));
        authConfig = make_shared<RegistryAuthenticationConfig>(model1);
      }
    }
    if (m.find("CertConfig") != m.end() && !m["CertConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CertConfig"].type()) {
        RegistryCertificateConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CertConfig"]));
        certConfig = make_shared<RegistryCertificateConfig>(model1);
      }
    }
  }


  virtual ~ImageRegistryConfig() = default;
};
class MetricsCollectConfig : public Darabonba::Model {
public:
  shared_ptr<bool> enablePushToUserSLS{};
  shared_ptr<string> logstoreName{};
  shared_ptr<string> projectName{};

  MetricsCollectConfig() {}

  explicit MetricsCollectConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enablePushToUserSLS) {
      res["EnablePushToUserSLS"] = boost::any(*enablePushToUserSLS);
    }
    if (logstoreName) {
      res["LogstoreName"] = boost::any(*logstoreName);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnablePushToUserSLS") != m.end() && !m["EnablePushToUserSLS"].empty()) {
      enablePushToUserSLS = make_shared<bool>(boost::any_cast<bool>(m["EnablePushToUserSLS"]));
    }
    if (m.find("LogstoreName") != m.end() && !m["LogstoreName"].empty()) {
      logstoreName = make_shared<string>(boost::any_cast<string>(m["LogstoreName"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
  }


  virtual ~MetricsCollectConfig() = default;
};
class ContainerResources : public Darabonba::Model {
public:
  shared_ptr<long> cpu{};
  shared_ptr<long> memory{};

  ContainerResources() {}

  explicit ContainerResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
  }


  virtual ~ContainerResources() = default;
};
class SLSCollectConfig : public Darabonba::Model {
public:
  shared_ptr<string> logPath{};
  shared_ptr<string> logType{};
  shared_ptr<string> logstoreName{};
  shared_ptr<string> logtailName{};
  shared_ptr<string> machineGroup{};
  shared_ptr<string> projectName{};

  SLSCollectConfig() {}

  explicit SLSCollectConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logPath) {
      res["LogPath"] = boost::any(*logPath);
    }
    if (logType) {
      res["LogType"] = boost::any(*logType);
    }
    if (logstoreName) {
      res["LogstoreName"] = boost::any(*logstoreName);
    }
    if (logtailName) {
      res["LogtailName"] = boost::any(*logtailName);
    }
    if (machineGroup) {
      res["MachineGroup"] = boost::any(*machineGroup);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogPath") != m.end() && !m["LogPath"].empty()) {
      logPath = make_shared<string>(boost::any_cast<string>(m["LogPath"]));
    }
    if (m.find("LogType") != m.end() && !m["LogType"].empty()) {
      logType = make_shared<string>(boost::any_cast<string>(m["LogType"]));
    }
    if (m.find("LogstoreName") != m.end() && !m["LogstoreName"].empty()) {
      logstoreName = make_shared<string>(boost::any_cast<string>(m["LogstoreName"]));
    }
    if (m.find("LogtailName") != m.end() && !m["LogtailName"].empty()) {
      logtailName = make_shared<string>(boost::any_cast<string>(m["LogtailName"]));
    }
    if (m.find("MachineGroup") != m.end() && !m["MachineGroup"].empty()) {
      machineGroup = make_shared<string>(boost::any_cast<string>(m["MachineGroup"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
  }


  virtual ~SLSCollectConfig() = default;
};
class SLSCollectConfigs : public Darabonba::Model {
public:
  shared_ptr<vector<SLSCollectConfig>> collectConfigs{};

  SLSCollectConfigs() {}

  explicit SLSCollectConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (collectConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*collectConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CollectConfigs"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CollectConfigs") != m.end() && !m["CollectConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["CollectConfigs"].type()) {
        vector<SLSCollectConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CollectConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SLSCollectConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        collectConfigs = make_shared<vector<SLSCollectConfig>>(expect1);
      }
    }
  }


  virtual ~SLSCollectConfigs() = default;
};
class HTTPHeader : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  HTTPHeader() {}

  explicit HTTPHeader(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~HTTPHeader() = default;
};
class HTTPGetAction : public Darabonba::Model {
public:
  shared_ptr<string> host{};
  shared_ptr<vector<HTTPHeader>> httpHeaders{};
  shared_ptr<string> path{};
  shared_ptr<long> port{};
  shared_ptr<string> scheme{};

  HTTPGetAction() {}

  explicit HTTPGetAction(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (httpHeaders) {
      vector<boost::any> temp1;
      for(auto item1:*httpHeaders){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HttpHeaders"] = boost::any(temp1);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (scheme) {
      res["Scheme"] = boost::any(*scheme);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("HttpHeaders") != m.end() && !m["HttpHeaders"].empty()) {
      if (typeid(vector<boost::any>) == m["HttpHeaders"].type()) {
        vector<HTTPHeader> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HttpHeaders"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HTTPHeader model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        httpHeaders = make_shared<vector<HTTPHeader>>(expect1);
      }
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Scheme") != m.end() && !m["Scheme"].empty()) {
      scheme = make_shared<string>(boost::any_cast<string>(m["Scheme"]));
    }
  }


  virtual ~HTTPGetAction() = default;
};
class TCPSocketAction : public Darabonba::Model {
public:
  shared_ptr<string> host{};
  shared_ptr<long> port{};

  TCPSocketAction() {}

  explicit TCPSocketAction(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
  }


  virtual ~TCPSocketAction() = default;
};
class ProbeHandler : public Darabonba::Model {
public:
  shared_ptr<HTTPGetAction> httpGet{};
  shared_ptr<TCPSocketAction> tcpSocket{};

  ProbeHandler() {}

  explicit ProbeHandler(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpGet) {
      res["HttpGet"] = httpGet ? boost::any(httpGet->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tcpSocket) {
      res["TcpSocket"] = tcpSocket ? boost::any(tcpSocket->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpGet") != m.end() && !m["HttpGet"].empty()) {
      if (typeid(map<string, boost::any>) == m["HttpGet"].type()) {
        HTTPGetAction model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HttpGet"]));
        httpGet = make_shared<HTTPGetAction>(model1);
      }
    }
    if (m.find("TcpSocket") != m.end() && !m["TcpSocket"].empty()) {
      if (typeid(map<string, boost::any>) == m["TcpSocket"].type()) {
        TCPSocketAction model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TcpSocket"]));
        tcpSocket = make_shared<TCPSocketAction>(model1);
      }
    }
  }


  virtual ~ProbeHandler() = default;
};
class StartupProbe : public Darabonba::Model {
public:
  shared_ptr<long> failureThreshold{};
  shared_ptr<long> initialDelaySeconds{};
  shared_ptr<long> periodSeconds{};
  shared_ptr<ProbeHandler> probeHandler{};
  shared_ptr<long> timeoutSeconds{};

  StartupProbe() {}

  explicit StartupProbe(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failureThreshold) {
      res["FailureThreshold"] = boost::any(*failureThreshold);
    }
    if (initialDelaySeconds) {
      res["InitialDelaySeconds"] = boost::any(*initialDelaySeconds);
    }
    if (periodSeconds) {
      res["PeriodSeconds"] = boost::any(*periodSeconds);
    }
    if (probeHandler) {
      res["ProbeHandler"] = probeHandler ? boost::any(probeHandler->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timeoutSeconds) {
      res["TimeoutSeconds"] = boost::any(*timeoutSeconds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailureThreshold") != m.end() && !m["FailureThreshold"].empty()) {
      failureThreshold = make_shared<long>(boost::any_cast<long>(m["FailureThreshold"]));
    }
    if (m.find("InitialDelaySeconds") != m.end() && !m["InitialDelaySeconds"].empty()) {
      initialDelaySeconds = make_shared<long>(boost::any_cast<long>(m["InitialDelaySeconds"]));
    }
    if (m.find("PeriodSeconds") != m.end() && !m["PeriodSeconds"].empty()) {
      periodSeconds = make_shared<long>(boost::any_cast<long>(m["PeriodSeconds"]));
    }
    if (m.find("ProbeHandler") != m.end() && !m["ProbeHandler"].empty()) {
      if (typeid(map<string, boost::any>) == m["ProbeHandler"].type()) {
        ProbeHandler model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ProbeHandler"]));
        probeHandler = make_shared<ProbeHandler>(model1);
      }
    }
    if (m.find("TimeoutSeconds") != m.end() && !m["TimeoutSeconds"].empty()) {
      timeoutSeconds = make_shared<long>(boost::any_cast<long>(m["TimeoutSeconds"]));
    }
  }


  virtual ~StartupProbe() = default;
};
class WebNASMountPoint : public Darabonba::Model {
public:
  shared_ptr<string> mountDir{};
  shared_ptr<string> nasAddr{};
  shared_ptr<string> nasPath{};

  WebNASMountPoint() {}

  explicit WebNASMountPoint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mountDir) {
      res["MountDir"] = boost::any(*mountDir);
    }
    if (nasAddr) {
      res["NasAddr"] = boost::any(*nasAddr);
    }
    if (nasPath) {
      res["NasPath"] = boost::any(*nasPath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MountDir") != m.end() && !m["MountDir"].empty()) {
      mountDir = make_shared<string>(boost::any_cast<string>(m["MountDir"]));
    }
    if (m.find("NasAddr") != m.end() && !m["NasAddr"].empty()) {
      nasAddr = make_shared<string>(boost::any_cast<string>(m["NasAddr"]));
    }
    if (m.find("NasPath") != m.end() && !m["NasPath"].empty()) {
      nasPath = make_shared<string>(boost::any_cast<string>(m["NasPath"]));
    }
  }


  virtual ~WebNASMountPoint() = default;
};
class WebNASConfig : public Darabonba::Model {
public:
  shared_ptr<vector<WebNASMountPoint>> mountPoints{};

  WebNASConfig() {}

  explicit WebNASConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mountPoints) {
      vector<boost::any> temp1;
      for(auto item1:*mountPoints){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MountPoints"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MountPoints") != m.end() && !m["MountPoints"].empty()) {
      if (typeid(vector<boost::any>) == m["MountPoints"].type()) {
        vector<WebNASMountPoint> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MountPoints"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            WebNASMountPoint model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mountPoints = make_shared<vector<WebNASMountPoint>>(expect1);
      }
    }
  }


  virtual ~WebNASConfig() = default;
};
class WebOSSMountPoint : public Darabonba::Model {
public:
  shared_ptr<string> bucketName{};
  shared_ptr<string> bucketPath{};
  shared_ptr<string> mountDir{};
  shared_ptr<bool> readOnly{};

  WebOSSMountPoint() {}

  explicit WebOSSMountPoint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucketName) {
      res["BucketName"] = boost::any(*bucketName);
    }
    if (bucketPath) {
      res["BucketPath"] = boost::any(*bucketPath);
    }
    if (mountDir) {
      res["MountDir"] = boost::any(*mountDir);
    }
    if (readOnly) {
      res["ReadOnly"] = boost::any(*readOnly);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BucketName") != m.end() && !m["BucketName"].empty()) {
      bucketName = make_shared<string>(boost::any_cast<string>(m["BucketName"]));
    }
    if (m.find("BucketPath") != m.end() && !m["BucketPath"].empty()) {
      bucketPath = make_shared<string>(boost::any_cast<string>(m["BucketPath"]));
    }
    if (m.find("MountDir") != m.end() && !m["MountDir"].empty()) {
      mountDir = make_shared<string>(boost::any_cast<string>(m["MountDir"]));
    }
    if (m.find("ReadOnly") != m.end() && !m["ReadOnly"].empty()) {
      readOnly = make_shared<bool>(boost::any_cast<bool>(m["ReadOnly"]));
    }
  }


  virtual ~WebOSSMountPoint() = default;
};
class WebOSSConfig : public Darabonba::Model {
public:
  shared_ptr<vector<WebOSSMountPoint>> mountPoints{};

  WebOSSConfig() {}

  explicit WebOSSConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mountPoints) {
      vector<boost::any> temp1;
      for(auto item1:*mountPoints){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MountPoints"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MountPoints") != m.end() && !m["MountPoints"].empty()) {
      if (typeid(vector<boost::any>) == m["MountPoints"].type()) {
        vector<WebOSSMountPoint> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MountPoints"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            WebOSSMountPoint model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mountPoints = make_shared<vector<WebOSSMountPoint>>(expect1);
      }
    }
  }


  virtual ~WebOSSConfig() = default;
};
class Container : public Darabonba::Model {
public:
  shared_ptr<string> args{};
  shared_ptr<string> command{};
  shared_ptr<map<string, string>> environmentVariables{};
  shared_ptr<string> image{};
  shared_ptr<ImageRegistryConfig> imageRegistryConfig{};
  shared_ptr<MetricsCollectConfig> metricsCollectConfig{};
  shared_ptr<long> port{};
  shared_ptr<long> requestConcurrency{};
  shared_ptr<long> requestTimeout{};
  shared_ptr<ContainerResources> resources{};
  shared_ptr<SLSCollectConfigs> SLSCollectConfigs{};
  shared_ptr<StartupProbe> startupProbe{};
  shared_ptr<WebNASConfig> webNASConfig{};
  shared_ptr<WebOSSConfig> webOSSConfig{};

  Container() {}

  explicit Container(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (args) {
      res["Args"] = boost::any(*args);
    }
    if (command) {
      res["Command"] = boost::any(*command);
    }
    if (environmentVariables) {
      res["EnvironmentVariables"] = boost::any(*environmentVariables);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (imageRegistryConfig) {
      res["ImageRegistryConfig"] = imageRegistryConfig ? boost::any(imageRegistryConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (metricsCollectConfig) {
      res["MetricsCollectConfig"] = metricsCollectConfig ? boost::any(metricsCollectConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (requestConcurrency) {
      res["RequestConcurrency"] = boost::any(*requestConcurrency);
    }
    if (requestTimeout) {
      res["RequestTimeout"] = boost::any(*requestTimeout);
    }
    if (resources) {
      res["Resources"] = resources ? boost::any(resources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (SLSCollectConfigs) {
      res["SLSCollectConfigs"] = SLSCollectConfigs ? boost::any(SLSCollectConfigs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (startupProbe) {
      res["StartupProbe"] = startupProbe ? boost::any(startupProbe->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (webNASConfig) {
      res["WebNASConfig"] = webNASConfig ? boost::any(webNASConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (webOSSConfig) {
      res["WebOSSConfig"] = webOSSConfig ? boost::any(webOSSConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Args") != m.end() && !m["Args"].empty()) {
      args = make_shared<string>(boost::any_cast<string>(m["Args"]));
    }
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
    if (m.find("EnvironmentVariables") != m.end() && !m["EnvironmentVariables"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["EnvironmentVariables"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      environmentVariables = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("ImageRegistryConfig") != m.end() && !m["ImageRegistryConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ImageRegistryConfig"].type()) {
        ImageRegistryConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ImageRegistryConfig"]));
        imageRegistryConfig = make_shared<ImageRegistryConfig>(model1);
      }
    }
    if (m.find("MetricsCollectConfig") != m.end() && !m["MetricsCollectConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["MetricsCollectConfig"].type()) {
        MetricsCollectConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MetricsCollectConfig"]));
        metricsCollectConfig = make_shared<MetricsCollectConfig>(model1);
      }
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("RequestConcurrency") != m.end() && !m["RequestConcurrency"].empty()) {
      requestConcurrency = make_shared<long>(boost::any_cast<long>(m["RequestConcurrency"]));
    }
    if (m.find("RequestTimeout") != m.end() && !m["RequestTimeout"].empty()) {
      requestTimeout = make_shared<long>(boost::any_cast<long>(m["RequestTimeout"]));
    }
    if (m.find("Resources") != m.end() && !m["Resources"].empty()) {
      if (typeid(map<string, boost::any>) == m["Resources"].type()) {
        ContainerResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Resources"]));
        resources = make_shared<ContainerResources>(model1);
      }
    }
    if (m.find("SLSCollectConfigs") != m.end() && !m["SLSCollectConfigs"].empty()) {
      if (typeid(map<string, boost::any>) == m["SLSCollectConfigs"].type()) {
        SLSCollectConfigs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SLSCollectConfigs"]));
        SLSCollectConfigs = make_shared<SLSCollectConfigs>(model1);
      }
    }
    if (m.find("StartupProbe") != m.end() && !m["StartupProbe"].empty()) {
      if (typeid(map<string, boost::any>) == m["StartupProbe"].type()) {
        StartupProbe model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StartupProbe"]));
        startupProbe = make_shared<StartupProbe>(model1);
      }
    }
    if (m.find("WebNASConfig") != m.end() && !m["WebNASConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["WebNASConfig"].type()) {
        WebNASConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WebNASConfig"]));
        webNASConfig = make_shared<WebNASConfig>(model1);
      }
    }
    if (m.find("WebOSSConfig") != m.end() && !m["WebOSSConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["WebOSSConfig"].type()) {
        WebOSSConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WebOSSConfig"]));
        webOSSConfig = make_shared<WebOSSConfig>(model1);
      }
    }
  }


  virtual ~Container() = default;
};
class InputCodeLocation : public Darabonba::Model {
public:
  shared_ptr<string> ossBucketName{};
  shared_ptr<string> ossObjectName{};
  shared_ptr<string> zipFile{};

  InputCodeLocation() {}

  explicit InputCodeLocation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ossBucketName) {
      res["ossBucketName"] = boost::any(*ossBucketName);
    }
    if (ossObjectName) {
      res["ossObjectName"] = boost::any(*ossObjectName);
    }
    if (zipFile) {
      res["zipFile"] = boost::any(*zipFile);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ossBucketName") != m.end() && !m["ossBucketName"].empty()) {
      ossBucketName = make_shared<string>(boost::any_cast<string>(m["ossBucketName"]));
    }
    if (m.find("ossObjectName") != m.end() && !m["ossObjectName"].empty()) {
      ossObjectName = make_shared<string>(boost::any_cast<string>(m["ossObjectName"]));
    }
    if (m.find("zipFile") != m.end() && !m["zipFile"].empty()) {
      zipFile = make_shared<string>(boost::any_cast<string>(m["zipFile"]));
    }
  }


  virtual ~InputCodeLocation() = default;
};
class CreateApplicationInput : public Darabonba::Model {
public:
  shared_ptr<string> applicationName{};
  shared_ptr<string> args{};
  shared_ptr<long> caPort{};
  shared_ptr<InputCodeLocation> code{};
  shared_ptr<string> command{};
  shared_ptr<double> cpu{};
  shared_ptr<CustomDNS> customDNS{};
  shared_ptr<CustomHealthCheckConfig> customHealthCheckConfig{};
  shared_ptr<CustomHostAlias> customHostAlias{};
  shared_ptr<CustomRuntimeConfig> customRuntimeConfig{};
  shared_ptr<string> description{};
  shared_ptr<long> diskSize{};
  shared_ptr<bool> enableAppMetric{};
  shared_ptr<map<string, string>> environmentVariables{};
  shared_ptr<long> gpuMemorySize{};
  shared_ptr<string> handler{};
  shared_ptr<HTTPTriggerConfig> httpTriggerConfig{};
  shared_ptr<ImageConfig> imageConfig{};
  shared_ptr<long> initializationTimeout{};
  shared_ptr<string> initializer{};
  shared_ptr<long> instanceConcurrency{};
  shared_ptr<InstanceLifecycleConfig> instanceLifecycleConfig{};
  shared_ptr<long> instanceSoftConcurrency{};
  shared_ptr<string> instanceType{};
  shared_ptr<bool> internetAccess{};
  shared_ptr<vector<string>> layers{};
  shared_ptr<Probe> livenessProbe{};
  shared_ptr<LogConfig> logConfig{};
  shared_ptr<long> memorySize{};
  shared_ptr<string> namespaceID{};
  shared_ptr<NASConfig> nasConfig{};
  shared_ptr<OSSMountConfig> ossMountConfig{};
  shared_ptr<string> programmingLanguage{};
  shared_ptr<string> runtime{};
  shared_ptr<ScaleConfig> scaleConfig{};
  shared_ptr<SLSConfig> slsConfig{};
  shared_ptr<Probe> startupProbe{};
  shared_ptr<long> timeout{};
  shared_ptr<TracingConfig> tracingConfig{};
  shared_ptr<VPCConfig> vpcConfig{};

  CreateApplicationInput() {}

  explicit CreateApplicationInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationName) {
      res["applicationName"] = boost::any(*applicationName);
    }
    if (args) {
      res["args"] = boost::any(*args);
    }
    if (caPort) {
      res["caPort"] = boost::any(*caPort);
    }
    if (code) {
      res["code"] = code ? boost::any(code->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (command) {
      res["command"] = boost::any(*command);
    }
    if (cpu) {
      res["cpu"] = boost::any(*cpu);
    }
    if (customDNS) {
      res["customDNS"] = customDNS ? boost::any(customDNS->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (customHealthCheckConfig) {
      res["customHealthCheckConfig"] = customHealthCheckConfig ? boost::any(customHealthCheckConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (customHostAlias) {
      res["customHostAlias"] = customHostAlias ? boost::any(customHostAlias->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (customRuntimeConfig) {
      res["customRuntimeConfig"] = customRuntimeConfig ? boost::any(customRuntimeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (diskSize) {
      res["diskSize"] = boost::any(*diskSize);
    }
    if (enableAppMetric) {
      res["enableAppMetric"] = boost::any(*enableAppMetric);
    }
    if (environmentVariables) {
      res["environmentVariables"] = boost::any(*environmentVariables);
    }
    if (gpuMemorySize) {
      res["gpuMemorySize"] = boost::any(*gpuMemorySize);
    }
    if (handler) {
      res["handler"] = boost::any(*handler);
    }
    if (httpTriggerConfig) {
      res["httpTriggerConfig"] = httpTriggerConfig ? boost::any(httpTriggerConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (imageConfig) {
      res["imageConfig"] = imageConfig ? boost::any(imageConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (initializationTimeout) {
      res["initializationTimeout"] = boost::any(*initializationTimeout);
    }
    if (initializer) {
      res["initializer"] = boost::any(*initializer);
    }
    if (instanceConcurrency) {
      res["instanceConcurrency"] = boost::any(*instanceConcurrency);
    }
    if (instanceLifecycleConfig) {
      res["instanceLifecycleConfig"] = instanceLifecycleConfig ? boost::any(instanceLifecycleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceSoftConcurrency) {
      res["instanceSoftConcurrency"] = boost::any(*instanceSoftConcurrency);
    }
    if (instanceType) {
      res["instanceType"] = boost::any(*instanceType);
    }
    if (internetAccess) {
      res["internetAccess"] = boost::any(*internetAccess);
    }
    if (layers) {
      res["layers"] = boost::any(*layers);
    }
    if (livenessProbe) {
      res["livenessProbe"] = livenessProbe ? boost::any(livenessProbe->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (logConfig) {
      res["logConfig"] = logConfig ? boost::any(logConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (memorySize) {
      res["memorySize"] = boost::any(*memorySize);
    }
    if (namespaceID) {
      res["namespaceID"] = boost::any(*namespaceID);
    }
    if (nasConfig) {
      res["nasConfig"] = nasConfig ? boost::any(nasConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ossMountConfig) {
      res["ossMountConfig"] = ossMountConfig ? boost::any(ossMountConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (programmingLanguage) {
      res["programmingLanguage"] = boost::any(*programmingLanguage);
    }
    if (runtime) {
      res["runtime"] = boost::any(*runtime);
    }
    if (scaleConfig) {
      res["scaleConfig"] = scaleConfig ? boost::any(scaleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (slsConfig) {
      res["slsConfig"] = slsConfig ? boost::any(slsConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (startupProbe) {
      res["startupProbe"] = startupProbe ? boost::any(startupProbe->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timeout) {
      res["timeout"] = boost::any(*timeout);
    }
    if (tracingConfig) {
      res["tracingConfig"] = tracingConfig ? boost::any(tracingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vpcConfig) {
      res["vpcConfig"] = vpcConfig ? boost::any(vpcConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("applicationName") != m.end() && !m["applicationName"].empty()) {
      applicationName = make_shared<string>(boost::any_cast<string>(m["applicationName"]));
    }
    if (m.find("args") != m.end() && !m["args"].empty()) {
      args = make_shared<string>(boost::any_cast<string>(m["args"]));
    }
    if (m.find("caPort") != m.end() && !m["caPort"].empty()) {
      caPort = make_shared<long>(boost::any_cast<long>(m["caPort"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      if (typeid(map<string, boost::any>) == m["code"].type()) {
        InputCodeLocation model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["code"]));
        code = make_shared<InputCodeLocation>(model1);
      }
    }
    if (m.find("command") != m.end() && !m["command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["command"]));
    }
    if (m.find("cpu") != m.end() && !m["cpu"].empty()) {
      cpu = make_shared<double>(boost::any_cast<double>(m["cpu"]));
    }
    if (m.find("customDNS") != m.end() && !m["customDNS"].empty()) {
      if (typeid(map<string, boost::any>) == m["customDNS"].type()) {
        CustomDNS model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["customDNS"]));
        customDNS = make_shared<CustomDNS>(model1);
      }
    }
    if (m.find("customHealthCheckConfig") != m.end() && !m["customHealthCheckConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["customHealthCheckConfig"].type()) {
        CustomHealthCheckConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["customHealthCheckConfig"]));
        customHealthCheckConfig = make_shared<CustomHealthCheckConfig>(model1);
      }
    }
    if (m.find("customHostAlias") != m.end() && !m["customHostAlias"].empty()) {
      if (typeid(map<string, boost::any>) == m["customHostAlias"].type()) {
        CustomHostAlias model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["customHostAlias"]));
        customHostAlias = make_shared<CustomHostAlias>(model1);
      }
    }
    if (m.find("customRuntimeConfig") != m.end() && !m["customRuntimeConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["customRuntimeConfig"].type()) {
        CustomRuntimeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["customRuntimeConfig"]));
        customRuntimeConfig = make_shared<CustomRuntimeConfig>(model1);
      }
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("diskSize") != m.end() && !m["diskSize"].empty()) {
      diskSize = make_shared<long>(boost::any_cast<long>(m["diskSize"]));
    }
    if (m.find("enableAppMetric") != m.end() && !m["enableAppMetric"].empty()) {
      enableAppMetric = make_shared<bool>(boost::any_cast<bool>(m["enableAppMetric"]));
    }
    if (m.find("environmentVariables") != m.end() && !m["environmentVariables"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["environmentVariables"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      environmentVariables = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("gpuMemorySize") != m.end() && !m["gpuMemorySize"].empty()) {
      gpuMemorySize = make_shared<long>(boost::any_cast<long>(m["gpuMemorySize"]));
    }
    if (m.find("handler") != m.end() && !m["handler"].empty()) {
      handler = make_shared<string>(boost::any_cast<string>(m["handler"]));
    }
    if (m.find("httpTriggerConfig") != m.end() && !m["httpTriggerConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["httpTriggerConfig"].type()) {
        HTTPTriggerConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["httpTriggerConfig"]));
        httpTriggerConfig = make_shared<HTTPTriggerConfig>(model1);
      }
    }
    if (m.find("imageConfig") != m.end() && !m["imageConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["imageConfig"].type()) {
        ImageConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["imageConfig"]));
        imageConfig = make_shared<ImageConfig>(model1);
      }
    }
    if (m.find("initializationTimeout") != m.end() && !m["initializationTimeout"].empty()) {
      initializationTimeout = make_shared<long>(boost::any_cast<long>(m["initializationTimeout"]));
    }
    if (m.find("initializer") != m.end() && !m["initializer"].empty()) {
      initializer = make_shared<string>(boost::any_cast<string>(m["initializer"]));
    }
    if (m.find("instanceConcurrency") != m.end() && !m["instanceConcurrency"].empty()) {
      instanceConcurrency = make_shared<long>(boost::any_cast<long>(m["instanceConcurrency"]));
    }
    if (m.find("instanceLifecycleConfig") != m.end() && !m["instanceLifecycleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["instanceLifecycleConfig"].type()) {
        InstanceLifecycleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["instanceLifecycleConfig"]));
        instanceLifecycleConfig = make_shared<InstanceLifecycleConfig>(model1);
      }
    }
    if (m.find("instanceSoftConcurrency") != m.end() && !m["instanceSoftConcurrency"].empty()) {
      instanceSoftConcurrency = make_shared<long>(boost::any_cast<long>(m["instanceSoftConcurrency"]));
    }
    if (m.find("instanceType") != m.end() && !m["instanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["instanceType"]));
    }
    if (m.find("internetAccess") != m.end() && !m["internetAccess"].empty()) {
      internetAccess = make_shared<bool>(boost::any_cast<bool>(m["internetAccess"]));
    }
    if (m.find("layers") != m.end() && !m["layers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["layers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["layers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      layers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("livenessProbe") != m.end() && !m["livenessProbe"].empty()) {
      if (typeid(map<string, boost::any>) == m["livenessProbe"].type()) {
        Probe model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["livenessProbe"]));
        livenessProbe = make_shared<Probe>(model1);
      }
    }
    if (m.find("logConfig") != m.end() && !m["logConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["logConfig"].type()) {
        LogConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["logConfig"]));
        logConfig = make_shared<LogConfig>(model1);
      }
    }
    if (m.find("memorySize") != m.end() && !m["memorySize"].empty()) {
      memorySize = make_shared<long>(boost::any_cast<long>(m["memorySize"]));
    }
    if (m.find("namespaceID") != m.end() && !m["namespaceID"].empty()) {
      namespaceID = make_shared<string>(boost::any_cast<string>(m["namespaceID"]));
    }
    if (m.find("nasConfig") != m.end() && !m["nasConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["nasConfig"].type()) {
        NASConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["nasConfig"]));
        nasConfig = make_shared<NASConfig>(model1);
      }
    }
    if (m.find("ossMountConfig") != m.end() && !m["ossMountConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ossMountConfig"].type()) {
        OSSMountConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ossMountConfig"]));
        ossMountConfig = make_shared<OSSMountConfig>(model1);
      }
    }
    if (m.find("programmingLanguage") != m.end() && !m["programmingLanguage"].empty()) {
      programmingLanguage = make_shared<string>(boost::any_cast<string>(m["programmingLanguage"]));
    }
    if (m.find("runtime") != m.end() && !m["runtime"].empty()) {
      runtime = make_shared<string>(boost::any_cast<string>(m["runtime"]));
    }
    if (m.find("scaleConfig") != m.end() && !m["scaleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["scaleConfig"].type()) {
        ScaleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["scaleConfig"]));
        scaleConfig = make_shared<ScaleConfig>(model1);
      }
    }
    if (m.find("slsConfig") != m.end() && !m["slsConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["slsConfig"].type()) {
        SLSConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["slsConfig"]));
        slsConfig = make_shared<SLSConfig>(model1);
      }
    }
    if (m.find("startupProbe") != m.end() && !m["startupProbe"].empty()) {
      if (typeid(map<string, boost::any>) == m["startupProbe"].type()) {
        Probe model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["startupProbe"]));
        startupProbe = make_shared<Probe>(model1);
      }
    }
    if (m.find("timeout") != m.end() && !m["timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["timeout"]));
    }
    if (m.find("tracingConfig") != m.end() && !m["tracingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["tracingConfig"].type()) {
        TracingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["tracingConfig"]));
        tracingConfig = make_shared<TracingConfig>(model1);
      }
    }
    if (m.find("vpcConfig") != m.end() && !m["vpcConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["vpcConfig"].type()) {
        VPCConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["vpcConfig"]));
        vpcConfig = make_shared<VPCConfig>(model1);
      }
    }
  }


  virtual ~CreateApplicationInput() = default;
};
class TLSConfig : public Darabonba::Model {
public:
  shared_ptr<vector<string>> cipherSuites{};
  shared_ptr<string> maxVersion{};
  shared_ptr<string> minVersion{};

  TLSConfig() {}

  explicit TLSConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cipherSuites) {
      res["cipherSuites"] = boost::any(*cipherSuites);
    }
    if (maxVersion) {
      res["maxVersion"] = boost::any(*maxVersion);
    }
    if (minVersion) {
      res["minVersion"] = boost::any(*minVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cipherSuites") != m.end() && !m["cipherSuites"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["cipherSuites"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["cipherSuites"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      cipherSuites = make_shared<vector<string>>(toVec1);
    }
    if (m.find("maxVersion") != m.end() && !m["maxVersion"].empty()) {
      maxVersion = make_shared<string>(boost::any_cast<string>(m["maxVersion"]));
    }
    if (m.find("minVersion") != m.end() && !m["minVersion"].empty()) {
      minVersion = make_shared<string>(boost::any_cast<string>(m["minVersion"]));
    }
  }


  virtual ~TLSConfig() = default;
};
class WAFConfig : public Darabonba::Model {
public:
  shared_ptr<bool> enableWAF{};

  WAFConfig() {}

  explicit WAFConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableWAF) {
      res["enableWAF"] = boost::any(*enableWAF);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("enableWAF") != m.end() && !m["enableWAF"].empty()) {
      enableWAF = make_shared<bool>(boost::any_cast<bool>(m["enableWAF"]));
    }
  }


  virtual ~WAFConfig() = default;
};
class CreateCustomDomainInput : public Darabonba::Model {
public:
  shared_ptr<string> applicationName{};
  shared_ptr<CertConfig> certConfig{};
  shared_ptr<string> domainName{};
  shared_ptr<bool> keepFullPath{};
  shared_ptr<string> namespaceID{};
  shared_ptr<string> protocol{};
  shared_ptr<TLSConfig> tlsConfig{};
  shared_ptr<WAFConfig> wafConfig{};

  CreateCustomDomainInput() {}

  explicit CreateCustomDomainInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationName) {
      res["applicationName"] = boost::any(*applicationName);
    }
    if (certConfig) {
      res["certConfig"] = certConfig ? boost::any(certConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (domainName) {
      res["domainName"] = boost::any(*domainName);
    }
    if (keepFullPath) {
      res["keepFullPath"] = boost::any(*keepFullPath);
    }
    if (namespaceID) {
      res["namespaceID"] = boost::any(*namespaceID);
    }
    if (protocol) {
      res["protocol"] = boost::any(*protocol);
    }
    if (tlsConfig) {
      res["tlsConfig"] = tlsConfig ? boost::any(tlsConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (wafConfig) {
      res["wafConfig"] = wafConfig ? boost::any(wafConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("applicationName") != m.end() && !m["applicationName"].empty()) {
      applicationName = make_shared<string>(boost::any_cast<string>(m["applicationName"]));
    }
    if (m.find("certConfig") != m.end() && !m["certConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["certConfig"].type()) {
        CertConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["certConfig"]));
        certConfig = make_shared<CertConfig>(model1);
      }
    }
    if (m.find("domainName") != m.end() && !m["domainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["domainName"]));
    }
    if (m.find("keepFullPath") != m.end() && !m["keepFullPath"].empty()) {
      keepFullPath = make_shared<bool>(boost::any_cast<bool>(m["keepFullPath"]));
    }
    if (m.find("namespaceID") != m.end() && !m["namespaceID"].empty()) {
      namespaceID = make_shared<string>(boost::any_cast<string>(m["namespaceID"]));
    }
    if (m.find("protocol") != m.end() && !m["protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["protocol"]));
    }
    if (m.find("tlsConfig") != m.end() && !m["tlsConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["tlsConfig"].type()) {
        TLSConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["tlsConfig"]));
        tlsConfig = make_shared<TLSConfig>(model1);
      }
    }
    if (m.find("wafConfig") != m.end() && !m["wafConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["wafConfig"].type()) {
        WAFConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["wafConfig"]));
        wafConfig = make_shared<WAFConfig>(model1);
      }
    }
  }


  virtual ~CreateCustomDomainInput() = default;
};
class CreateSlsIndexRequest : public Darabonba::Model {
public:
  shared_ptr<string> logstore{};
  shared_ptr<string> project{};

  CreateSlsIndexRequest() {}

  explicit CreateSlsIndexRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logstore) {
      res["logstore"] = boost::any(*logstore);
    }
    if (project) {
      res["project"] = boost::any(*project);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("logstore") != m.end() && !m["logstore"].empty()) {
      logstore = make_shared<string>(boost::any_cast<string>(m["logstore"]));
    }
    if (m.find("project") != m.end() && !m["project"].empty()) {
      project = make_shared<string>(boost::any_cast<string>(m["project"]));
    }
  }


  virtual ~CreateSlsIndexRequest() = default;
};
class CreateSlsIndexResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> logStore{};
  shared_ptr<string> project{};

  CreateSlsIndexResponse() {}

  explicit CreateSlsIndexResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (logStore) {
      res["logStore"] = boost::any(*logStore);
    }
    if (project) {
      res["project"] = boost::any(*project);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("logStore") != m.end() && !m["logStore"].empty()) {
      logStore = make_shared<string>(boost::any_cast<string>(m["logStore"]));
    }
    if (m.find("project") != m.end() && !m["project"].empty()) {
      project = make_shared<string>(boost::any_cast<string>(m["project"]));
    }
  }


  virtual ~CreateSlsIndexResponse() = default;
};
class CreateSlsResourceResponse : public Darabonba::Model {
public:
  shared_ptr<string> logStore{};
  shared_ptr<string> project{};
  shared_ptr<string> requestId{};

  CreateSlsResourceResponse() {}

  explicit CreateSlsResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logStore) {
      res["logStore"] = boost::any(*logStore);
    }
    if (project) {
      res["project"] = boost::any(*project);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("logStore") != m.end() && !m["logStore"].empty()) {
      logStore = make_shared<string>(boost::any_cast<string>(m["logStore"]));
    }
    if (m.find("project") != m.end() && !m["project"].empty()) {
      project = make_shared<string>(boost::any_cast<string>(m["project"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~CreateSlsResourceResponse() = default;
};
class WebNetworkConfig : public Darabonba::Model {
public:
  shared_ptr<bool> internetAccess{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<vector<string>> vSwitchIds{};

  WebNetworkConfig() {}

  explicit WebNetworkConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (internetAccess) {
      res["InternetAccess"] = boost::any(*internetAccess);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (vSwitchIds) {
      res["VSwitchIds"] = boost::any(*vSwitchIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InternetAccess") != m.end() && !m["InternetAccess"].empty()) {
      internetAccess = make_shared<bool>(boost::any_cast<bool>(m["InternetAccess"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("VSwitchIds") != m.end() && !m["VSwitchIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VSwitchIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VSwitchIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vSwitchIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~WebNetworkConfig() = default;
};
class RevisionConfig : public Darabonba::Model {
public:
  shared_ptr<vector<Container>> containers{};
  shared_ptr<bool> enableArmsMetrics{};
  shared_ptr<WebNetworkConfig> webNetworkConfig{};

  RevisionConfig() {}

  explicit RevisionConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (containers) {
      vector<boost::any> temp1;
      for(auto item1:*containers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Containers"] = boost::any(temp1);
    }
    if (enableArmsMetrics) {
      res["EnableArmsMetrics"] = boost::any(*enableArmsMetrics);
    }
    if (webNetworkConfig) {
      res["WebNetworkConfig"] = webNetworkConfig ? boost::any(webNetworkConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Containers") != m.end() && !m["Containers"].empty()) {
      if (typeid(vector<boost::any>) == m["Containers"].type()) {
        vector<Container> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Containers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Container model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        containers = make_shared<vector<Container>>(expect1);
      }
    }
    if (m.find("EnableArmsMetrics") != m.end() && !m["EnableArmsMetrics"].empty()) {
      enableArmsMetrics = make_shared<bool>(boost::any_cast<bool>(m["EnableArmsMetrics"]));
    }
    if (m.find("WebNetworkConfig") != m.end() && !m["WebNetworkConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["WebNetworkConfig"].type()) {
        WebNetworkConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WebNetworkConfig"]));
        webNetworkConfig = make_shared<WebNetworkConfig>(model1);
      }
    }
  }


  virtual ~RevisionConfig() = default;
};
class WebScalingConfig : public Darabonba::Model {
public:
  shared_ptr<long> maximumInstanceCount{};
  shared_ptr<long> minimumInstanceCount{};

  WebScalingConfig() {}

  explicit WebScalingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maximumInstanceCount) {
      res["MaximumInstanceCount"] = boost::any(*maximumInstanceCount);
    }
    if (minimumInstanceCount) {
      res["MinimumInstanceCount"] = boost::any(*minimumInstanceCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaximumInstanceCount") != m.end() && !m["MaximumInstanceCount"].empty()) {
      maximumInstanceCount = make_shared<long>(boost::any_cast<long>(m["MaximumInstanceCount"]));
    }
    if (m.find("MinimumInstanceCount") != m.end() && !m["MinimumInstanceCount"].empty()) {
      minimumInstanceCount = make_shared<long>(boost::any_cast<long>(m["MinimumInstanceCount"]));
    }
  }


  virtual ~WebScalingConfig() = default;
};
class WebAclEntryConfig : public Darabonba::Model {
public:
  shared_ptr<string> entry{};

  WebAclEntryConfig() {}

  explicit WebAclEntryConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entry) {
      res["Entry"] = boost::any(*entry);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Entry") != m.end() && !m["Entry"].empty()) {
      entry = make_shared<string>(boost::any_cast<string>(m["Entry"]));
    }
  }


  virtual ~WebAclEntryConfig() = default;
};
class WebAclConfig : public Darabonba::Model {
public:
  shared_ptr<vector<WebAclEntryConfig>> webAclEntries{};

  WebAclConfig() {}

  explicit WebAclConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (webAclEntries) {
      vector<boost::any> temp1;
      for(auto item1:*webAclEntries){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WebAclEntries"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WebAclEntries") != m.end() && !m["WebAclEntries"].empty()) {
      if (typeid(vector<boost::any>) == m["WebAclEntries"].type()) {
        vector<WebAclEntryConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WebAclEntries"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            WebAclEntryConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        webAclEntries = make_shared<vector<WebAclEntryConfig>>(expect1);
      }
    }
  }


  virtual ~WebAclConfig() = default;
};
class WebTrafficConfig : public Darabonba::Model {
public:
  shared_ptr<string> authType{};
  shared_ptr<bool> disableInternetURL{};
  shared_ptr<map<string, double>> revisionsTrafficWeight{};
  shared_ptr<WebAclConfig> webAclConfig{};

  WebTrafficConfig() {}

  explicit WebTrafficConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authType) {
      res["AuthType"] = boost::any(*authType);
    }
    if (disableInternetURL) {
      res["DisableInternetURL"] = boost::any(*disableInternetURL);
    }
    if (revisionsTrafficWeight) {
      res["RevisionsTrafficWeight"] = boost::any(*revisionsTrafficWeight);
    }
    if (webAclConfig) {
      res["WebAclConfig"] = webAclConfig ? boost::any(webAclConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthType") != m.end() && !m["AuthType"].empty()) {
      authType = make_shared<string>(boost::any_cast<string>(m["AuthType"]));
    }
    if (m.find("DisableInternetURL") != m.end() && !m["DisableInternetURL"].empty()) {
      disableInternetURL = make_shared<bool>(boost::any_cast<bool>(m["DisableInternetURL"]));
    }
    if (m.find("RevisionsTrafficWeight") != m.end() && !m["RevisionsTrafficWeight"].empty()) {
      map<string, double> map1 = boost::any_cast<map<string, double>>(m["RevisionsTrafficWeight"]);
      map<string, double> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      revisionsTrafficWeight = make_shared<map<string, double>>(toMap1);
    }
    if (m.find("WebAclConfig") != m.end() && !m["WebAclConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["WebAclConfig"].type()) {
        WebAclConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WebAclConfig"]));
        webAclConfig = make_shared<WebAclConfig>(model1);
      }
    }
  }


  virtual ~WebTrafficConfig() = default;
};
class CreateWebApplicationInput : public Darabonba::Model {
public:
  shared_ptr<string> applicationName{};
  shared_ptr<string> description{};
  shared_ptr<RevisionConfig> revisionConfig{};
  shared_ptr<WebNetworkConfig> webNetworkConfig{};
  shared_ptr<WebScalingConfig> webScalingConfig{};
  shared_ptr<WebTrafficConfig> webTrafficConfig{};

  CreateWebApplicationInput() {}

  explicit CreateWebApplicationInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationName) {
      res["ApplicationName"] = boost::any(*applicationName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (revisionConfig) {
      res["RevisionConfig"] = revisionConfig ? boost::any(revisionConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (webNetworkConfig) {
      res["WebNetworkConfig"] = webNetworkConfig ? boost::any(webNetworkConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (webScalingConfig) {
      res["WebScalingConfig"] = webScalingConfig ? boost::any(webScalingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (webTrafficConfig) {
      res["WebTrafficConfig"] = webTrafficConfig ? boost::any(webTrafficConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationName") != m.end() && !m["ApplicationName"].empty()) {
      applicationName = make_shared<string>(boost::any_cast<string>(m["ApplicationName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RevisionConfig") != m.end() && !m["RevisionConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["RevisionConfig"].type()) {
        RevisionConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RevisionConfig"]));
        revisionConfig = make_shared<RevisionConfig>(model1);
      }
    }
    if (m.find("WebNetworkConfig") != m.end() && !m["WebNetworkConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["WebNetworkConfig"].type()) {
        WebNetworkConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WebNetworkConfig"]));
        webNetworkConfig = make_shared<WebNetworkConfig>(model1);
      }
    }
    if (m.find("WebScalingConfig") != m.end() && !m["WebScalingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["WebScalingConfig"].type()) {
        WebScalingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WebScalingConfig"]));
        webScalingConfig = make_shared<WebScalingConfig>(model1);
      }
    }
    if (m.find("WebTrafficConfig") != m.end() && !m["WebTrafficConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["WebTrafficConfig"].type()) {
        WebTrafficConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WebTrafficConfig"]));
        webTrafficConfig = make_shared<WebTrafficConfig>(model1);
      }
    }
  }


  virtual ~CreateWebApplicationInput() = default;
};
class PathConfig : public Darabonba::Model {
public:
  shared_ptr<string> applicationName{};
  shared_ptr<string> path{};

  PathConfig() {}

  explicit PathConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationName) {
      res["applicationName"] = boost::any(*applicationName);
    }
    if (path) {
      res["path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("applicationName") != m.end() && !m["applicationName"].empty()) {
      applicationName = make_shared<string>(boost::any_cast<string>(m["applicationName"]));
    }
    if (m.find("path") != m.end() && !m["path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["path"]));
    }
  }


  virtual ~PathConfig() = default;
};
class RouteConfig : public Darabonba::Model {
public:
  shared_ptr<vector<PathConfig>> routes{};

  RouteConfig() {}

  explicit RouteConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (routes) {
      vector<boost::any> temp1;
      for(auto item1:*routes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["routes"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("routes") != m.end() && !m["routes"].empty()) {
      if (typeid(vector<boost::any>) == m["routes"].type()) {
        vector<PathConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["routes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PathConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        routes = make_shared<vector<PathConfig>>(expect1);
      }
    }
  }


  virtual ~RouteConfig() = default;
};
class WebCertConfig : public Darabonba::Model {
public:
  shared_ptr<string> certName{};
  shared_ptr<string> certificate{};
  shared_ptr<string> privateKey{};

  WebCertConfig() {}

  explicit WebCertConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (certificate) {
      res["Certificate"] = boost::any(*certificate);
    }
    if (privateKey) {
      res["PrivateKey"] = boost::any(*privateKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("Certificate") != m.end() && !m["Certificate"].empty()) {
      certificate = make_shared<string>(boost::any_cast<string>(m["Certificate"]));
    }
    if (m.find("PrivateKey") != m.end() && !m["PrivateKey"].empty()) {
      privateKey = make_shared<string>(boost::any_cast<string>(m["PrivateKey"]));
    }
  }


  virtual ~WebCertConfig() = default;
};
class WebTLSConfig : public Darabonba::Model {
public:
  shared_ptr<vector<string>> cipherSuites{};
  shared_ptr<string> maxVersion{};
  shared_ptr<string> minVersion{};

  WebTLSConfig() {}

  explicit WebTLSConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cipherSuites) {
      res["CipherSuites"] = boost::any(*cipherSuites);
    }
    if (maxVersion) {
      res["MaxVersion"] = boost::any(*maxVersion);
    }
    if (minVersion) {
      res["MinVersion"] = boost::any(*minVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CipherSuites") != m.end() && !m["CipherSuites"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CipherSuites"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CipherSuites"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      cipherSuites = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MaxVersion") != m.end() && !m["MaxVersion"].empty()) {
      maxVersion = make_shared<string>(boost::any_cast<string>(m["MaxVersion"]));
    }
    if (m.find("MinVersion") != m.end() && !m["MinVersion"].empty()) {
      minVersion = make_shared<string>(boost::any_cast<string>(m["MinVersion"]));
    }
  }


  virtual ~WebTLSConfig() = default;
};
class WebWAFConfig : public Darabonba::Model {
public:
  shared_ptr<bool> enableWAF{};

  WebWAFConfig() {}

  explicit WebWAFConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableWAF) {
      res["EnableWAF"] = boost::any(*enableWAF);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableWAF") != m.end() && !m["EnableWAF"].empty()) {
      enableWAF = make_shared<bool>(boost::any_cast<bool>(m["EnableWAF"]));
    }
  }


  virtual ~WebWAFConfig() = default;
};
class CreateWebCustomDomainInput : public Darabonba::Model {
public:
  shared_ptr<string> defaultForwardingAppName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> protocol{};
  shared_ptr<RouteConfig> routeConfig{};
  shared_ptr<WebCertConfig> webCertConfig{};
  shared_ptr<WebTLSConfig> webTLSConfig{};
  shared_ptr<WebWAFConfig> webWAFConfig{};

  CreateWebCustomDomainInput() {}

  explicit CreateWebCustomDomainInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defaultForwardingAppName) {
      res["DefaultForwardingAppName"] = boost::any(*defaultForwardingAppName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (routeConfig) {
      res["RouteConfig"] = routeConfig ? boost::any(routeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (webCertConfig) {
      res["WebCertConfig"] = webCertConfig ? boost::any(webCertConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (webTLSConfig) {
      res["WebTLSConfig"] = webTLSConfig ? boost::any(webTLSConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (webWAFConfig) {
      res["WebWAFConfig"] = webWAFConfig ? boost::any(webWAFConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefaultForwardingAppName") != m.end() && !m["DefaultForwardingAppName"].empty()) {
      defaultForwardingAppName = make_shared<string>(boost::any_cast<string>(m["DefaultForwardingAppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("RouteConfig") != m.end() && !m["RouteConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["RouteConfig"].type()) {
        RouteConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RouteConfig"]));
        routeConfig = make_shared<RouteConfig>(model1);
      }
    }
    if (m.find("WebCertConfig") != m.end() && !m["WebCertConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["WebCertConfig"].type()) {
        WebCertConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WebCertConfig"]));
        webCertConfig = make_shared<WebCertConfig>(model1);
      }
    }
    if (m.find("WebTLSConfig") != m.end() && !m["WebTLSConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["WebTLSConfig"].type()) {
        WebTLSConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WebTLSConfig"]));
        webTLSConfig = make_shared<WebTLSConfig>(model1);
      }
    }
    if (m.find("WebWAFConfig") != m.end() && !m["WebWAFConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["WebWAFConfig"].type()) {
        WebWAFConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WebWAFConfig"]));
        webWAFConfig = make_shared<WebWAFConfig>(model1);
      }
    }
  }


  virtual ~CreateWebCustomDomainInput() = default;
};
class CustomDomain : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> apiVersion{};
  shared_ptr<CertConfig> certConfig{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> domainName{};
  shared_ptr<bool> keepFullPath{};
  shared_ptr<string> lastModifiedTime{};
  shared_ptr<string> namespaceID{};
  shared_ptr<string> protocol{};
  shared_ptr<string> requestId{};
  shared_ptr<RouteConfig> routeConfig{};
  shared_ptr<string> subdomainCount{};
  shared_ptr<TLSConfig> tlsConfig{};
  shared_ptr<WAFConfig> wafConfig{};

  CustomDomain() {}

  explicit CustomDomain(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    if (apiVersion) {
      res["apiVersion"] = boost::any(*apiVersion);
    }
    if (certConfig) {
      res["certConfig"] = certConfig ? boost::any(certConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createdTime) {
      res["createdTime"] = boost::any(*createdTime);
    }
    if (domainName) {
      res["domainName"] = boost::any(*domainName);
    }
    if (keepFullPath) {
      res["keepFullPath"] = boost::any(*keepFullPath);
    }
    if (lastModifiedTime) {
      res["lastModifiedTime"] = boost::any(*lastModifiedTime);
    }
    if (namespaceID) {
      res["namespaceID"] = boost::any(*namespaceID);
    }
    if (protocol) {
      res["protocol"] = boost::any(*protocol);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (routeConfig) {
      res["routeConfig"] = routeConfig ? boost::any(routeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subdomainCount) {
      res["subdomainCount"] = boost::any(*subdomainCount);
    }
    if (tlsConfig) {
      res["tlsConfig"] = tlsConfig ? boost::any(tlsConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (wafConfig) {
      res["wafConfig"] = wafConfig ? boost::any(wafConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
    if (m.find("apiVersion") != m.end() && !m["apiVersion"].empty()) {
      apiVersion = make_shared<string>(boost::any_cast<string>(m["apiVersion"]));
    }
    if (m.find("certConfig") != m.end() && !m["certConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["certConfig"].type()) {
        CertConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["certConfig"]));
        certConfig = make_shared<CertConfig>(model1);
      }
    }
    if (m.find("createdTime") != m.end() && !m["createdTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["createdTime"]));
    }
    if (m.find("domainName") != m.end() && !m["domainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["domainName"]));
    }
    if (m.find("keepFullPath") != m.end() && !m["keepFullPath"].empty()) {
      keepFullPath = make_shared<bool>(boost::any_cast<bool>(m["keepFullPath"]));
    }
    if (m.find("lastModifiedTime") != m.end() && !m["lastModifiedTime"].empty()) {
      lastModifiedTime = make_shared<string>(boost::any_cast<string>(m["lastModifiedTime"]));
    }
    if (m.find("namespaceID") != m.end() && !m["namespaceID"].empty()) {
      namespaceID = make_shared<string>(boost::any_cast<string>(m["namespaceID"]));
    }
    if (m.find("protocol") != m.end() && !m["protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["protocol"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("routeConfig") != m.end() && !m["routeConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["routeConfig"].type()) {
        RouteConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["routeConfig"]));
        routeConfig = make_shared<RouteConfig>(model1);
      }
    }
    if (m.find("subdomainCount") != m.end() && !m["subdomainCount"].empty()) {
      subdomainCount = make_shared<string>(boost::any_cast<string>(m["subdomainCount"]));
    }
    if (m.find("tlsConfig") != m.end() && !m["tlsConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["tlsConfig"].type()) {
        TLSConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["tlsConfig"]));
        tlsConfig = make_shared<TLSConfig>(model1);
      }
    }
    if (m.find("wafConfig") != m.end() && !m["wafConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["wafConfig"].type()) {
        WAFConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["wafConfig"]));
        wafConfig = make_shared<WAFConfig>(model1);
      }
    }
  }


  virtual ~CustomDomain() = default;
};
class WebLogEntry : public Darabonba::Model {
public:
  shared_ptr<string> message{};

  WebLogEntry() {}

  explicit WebLogEntry(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~WebLogEntry() = default;
};
class DescribeInstanceLogsOutput : public Darabonba::Model {
public:
  shared_ptr<vector<WebLogEntry>> webLogEntrys{};

  DescribeInstanceLogsOutput() {}

  explicit DescribeInstanceLogsOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (webLogEntrys) {
      vector<boost::any> temp1;
      for(auto item1:*webLogEntrys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WebLogEntrys"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WebLogEntrys") != m.end() && !m["WebLogEntrys"].empty()) {
      if (typeid(vector<boost::any>) == m["WebLogEntrys"].type()) {
        vector<WebLogEntry> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WebLogEntrys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            WebLogEntry model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        webLogEntrys = make_shared<vector<WebLogEntry>>(expect1);
      }
    }
  }


  virtual ~DescribeInstanceLogsOutput() = default;
};
class WebStaticsInfo : public Darabonba::Model {
public:
  shared_ptr<long> cpuUsage{};
  shared_ptr<long> internetTrafficOut{};
  shared_ptr<long> invocations{};
  shared_ptr<long> memoryUsage{};

  WebStaticsInfo() {}

  explicit WebStaticsInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cpuUsage) {
      res["CpuUsage"] = boost::any(*cpuUsage);
    }
    if (internetTrafficOut) {
      res["InternetTrafficOut"] = boost::any(*internetTrafficOut);
    }
    if (invocations) {
      res["Invocations"] = boost::any(*invocations);
    }
    if (memoryUsage) {
      res["MemoryUsage"] = boost::any(*memoryUsage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CpuUsage") != m.end() && !m["CpuUsage"].empty()) {
      cpuUsage = make_shared<long>(boost::any_cast<long>(m["CpuUsage"]));
    }
    if (m.find("InternetTrafficOut") != m.end() && !m["InternetTrafficOut"].empty()) {
      internetTrafficOut = make_shared<long>(boost::any_cast<long>(m["InternetTrafficOut"]));
    }
    if (m.find("Invocations") != m.end() && !m["Invocations"].empty()) {
      invocations = make_shared<long>(boost::any_cast<long>(m["Invocations"]));
    }
    if (m.find("MemoryUsage") != m.end() && !m["MemoryUsage"].empty()) {
      memoryUsage = make_shared<long>(boost::any_cast<long>(m["MemoryUsage"]));
    }
  }


  virtual ~WebStaticsInfo() = default;
};
class DescribeWebAppStaticsOutput : public Darabonba::Model {
public:
  shared_ptr<long> length{};
  shared_ptr<vector<WebStaticsInfo>> webAppStatics{};

  DescribeWebAppStaticsOutput() {}

  explicit DescribeWebAppStaticsOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (length) {
      res["Length"] = boost::any(*length);
    }
    if (webAppStatics) {
      vector<boost::any> temp1;
      for(auto item1:*webAppStatics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WebAppStatics"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Length") != m.end() && !m["Length"].empty()) {
      length = make_shared<long>(boost::any_cast<long>(m["Length"]));
    }
    if (m.find("WebAppStatics") != m.end() && !m["WebAppStatics"].empty()) {
      if (typeid(vector<boost::any>) == m["WebAppStatics"].type()) {
        vector<WebStaticsInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WebAppStatics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            WebStaticsInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        webAppStatics = make_shared<vector<WebStaticsInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeWebAppStaticsOutput() = default;
};
class DescribeWebStaticsQueryOutput : public Darabonba::Model {
public:
  shared_ptr<long> length{};
  shared_ptr<vector<WebStaticsInfo>> webStatics{};

  DescribeWebStaticsQueryOutput() {}

  explicit DescribeWebStaticsQueryOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (length) {
      res["Length"] = boost::any(*length);
    }
    if (webStatics) {
      vector<boost::any> temp1;
      for(auto item1:*webStatics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WebStatics"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Length") != m.end() && !m["Length"].empty()) {
      length = make_shared<long>(boost::any_cast<long>(m["Length"]));
    }
    if (m.find("WebStatics") != m.end() && !m["WebStatics"].empty()) {
      if (typeid(vector<boost::any>) == m["WebStatics"].type()) {
        vector<WebStaticsInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WebStatics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            WebStaticsInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        webStatics = make_shared<vector<WebStaticsInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeWebStaticsQueryOutput() = default;
};
class ExecAction : public Darabonba::Model {
public:
  shared_ptr<vector<string>> command{};

  ExecAction() {}

  explicit ExecAction(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (command) {
      res["command"] = boost::any(*command);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("command") != m.end() && !m["command"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["command"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["command"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      command = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ExecAction() = default;
};
class ExternalErrorSAEWeb : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ExternalErrorSAEWeb() {}

  explicit ExternalErrorSAEWeb(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["code"]));
    }
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~ExternalErrorSAEWeb() = default;
};
class GRPCAction : public Darabonba::Model {
public:
  shared_ptr<long> port{};
  shared_ptr<string> service{};

  GRPCAction() {}

  explicit GRPCAction(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (port) {
      res["port"] = boost::any(*port);
    }
    if (service) {
      res["service"] = boost::any(*service);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("port") != m.end() && !m["port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["port"]));
    }
    if (m.find("service") != m.end() && !m["service"].empty()) {
      service = make_shared<string>(boost::any_cast<string>(m["service"]));
    }
  }


  virtual ~GRPCAction() = default;
};
class GetApplicationLogsInput : public Darabonba::Model {
public:
  shared_ptr<long> backwardLine{};
  shared_ptr<long> endTime{};
  shared_ptr<long> forwardLine{};
  shared_ptr<string> instanceID{};
  shared_ptr<bool> isTail{};
  shared_ptr<string> match{};
  shared_ptr<string> message{};
  shared_ptr<long> offset{};
  shared_ptr<string> packID{};
  shared_ptr<string> packMeta{};
  shared_ptr<long> startTime{};
  shared_ptr<string> timestamp{};
  shared_ptr<string> versionID{};

  GetApplicationLogsInput() {}

  explicit GetApplicationLogsInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backwardLine) {
      res["backwardLine"] = boost::any(*backwardLine);
    }
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (forwardLine) {
      res["forwardLine"] = boost::any(*forwardLine);
    }
    if (instanceID) {
      res["instanceID"] = boost::any(*instanceID);
    }
    if (isTail) {
      res["isTail"] = boost::any(*isTail);
    }
    if (match) {
      res["match"] = boost::any(*match);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (offset) {
      res["offset"] = boost::any(*offset);
    }
    if (packID) {
      res["packID"] = boost::any(*packID);
    }
    if (packMeta) {
      res["packMeta"] = boost::any(*packMeta);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    if (timestamp) {
      res["timestamp"] = boost::any(*timestamp);
    }
    if (versionID) {
      res["versionID"] = boost::any(*versionID);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("backwardLine") != m.end() && !m["backwardLine"].empty()) {
      backwardLine = make_shared<long>(boost::any_cast<long>(m["backwardLine"]));
    }
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["endTime"]));
    }
    if (m.find("forwardLine") != m.end() && !m["forwardLine"].empty()) {
      forwardLine = make_shared<long>(boost::any_cast<long>(m["forwardLine"]));
    }
    if (m.find("instanceID") != m.end() && !m["instanceID"].empty()) {
      instanceID = make_shared<string>(boost::any_cast<string>(m["instanceID"]));
    }
    if (m.find("isTail") != m.end() && !m["isTail"].empty()) {
      isTail = make_shared<bool>(boost::any_cast<bool>(m["isTail"]));
    }
    if (m.find("match") != m.end() && !m["match"].empty()) {
      match = make_shared<string>(boost::any_cast<string>(m["match"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("offset") != m.end() && !m["offset"].empty()) {
      offset = make_shared<long>(boost::any_cast<long>(m["offset"]));
    }
    if (m.find("packID") != m.end() && !m["packID"].empty()) {
      packID = make_shared<string>(boost::any_cast<string>(m["packID"]));
    }
    if (m.find("packMeta") != m.end() && !m["packMeta"].empty()) {
      packMeta = make_shared<string>(boost::any_cast<string>(m["packMeta"]));
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["startTime"]));
    }
    if (m.find("timestamp") != m.end() && !m["timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["timestamp"]));
    }
    if (m.find("versionID") != m.end() && !m["versionID"].empty()) {
      versionID = make_shared<string>(boost::any_cast<string>(m["versionID"]));
    }
  }


  virtual ~GetApplicationLogsInput() = default;
};
class LogEntry : public Darabonba::Model {
public:
  shared_ptr<string> instanceID{};
  shared_ptr<string> message{};
  shared_ptr<long> offset{};
  shared_ptr<string> packID{};
  shared_ptr<string> packMeta{};
  shared_ptr<string> qualifier{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> versionID{};

  LogEntry() {}

  explicit LogEntry(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceID) {
      res["instanceID"] = boost::any(*instanceID);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (offset) {
      res["offset"] = boost::any(*offset);
    }
    if (packID) {
      res["packID"] = boost::any(*packID);
    }
    if (packMeta) {
      res["packMeta"] = boost::any(*packMeta);
    }
    if (qualifier) {
      res["qualifier"] = boost::any(*qualifier);
    }
    if (timestamp) {
      res["timestamp"] = boost::any(*timestamp);
    }
    if (versionID) {
      res["versionID"] = boost::any(*versionID);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("instanceID") != m.end() && !m["instanceID"].empty()) {
      instanceID = make_shared<string>(boost::any_cast<string>(m["instanceID"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("offset") != m.end() && !m["offset"].empty()) {
      offset = make_shared<long>(boost::any_cast<long>(m["offset"]));
    }
    if (m.find("packID") != m.end() && !m["packID"].empty()) {
      packID = make_shared<string>(boost::any_cast<string>(m["packID"]));
    }
    if (m.find("packMeta") != m.end() && !m["packMeta"].empty()) {
      packMeta = make_shared<string>(boost::any_cast<string>(m["packMeta"]));
    }
    if (m.find("qualifier") != m.end() && !m["qualifier"].empty()) {
      qualifier = make_shared<string>(boost::any_cast<string>(m["qualifier"]));
    }
    if (m.find("timestamp") != m.end() && !m["timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["timestamp"]));
    }
    if (m.find("versionID") != m.end() && !m["versionID"].empty()) {
      versionID = make_shared<string>(boost::any_cast<string>(m["versionID"]));
    }
  }


  virtual ~LogEntry() = default;
};
class GetApplicationLogsOutput : public Darabonba::Model {
public:
  shared_ptr<vector<LogEntry>> logEntrys{};
  shared_ptr<long> nextOffset{};
  shared_ptr<string> requestId{};

  GetApplicationLogsOutput() {}

  explicit GetApplicationLogsOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logEntrys) {
      vector<boost::any> temp1;
      for(auto item1:*logEntrys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["logEntrys"] = boost::any(temp1);
    }
    if (nextOffset) {
      res["nextOffset"] = boost::any(*nextOffset);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("logEntrys") != m.end() && !m["logEntrys"].empty()) {
      if (typeid(vector<boost::any>) == m["logEntrys"].type()) {
        vector<LogEntry> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["logEntrys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            LogEntry model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logEntrys = make_shared<vector<LogEntry>>(expect1);
      }
    }
    if (m.find("nextOffset") != m.end() && !m["nextOffset"].empty()) {
      nextOffset = make_shared<long>(boost::any_cast<long>(m["nextOffset"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~GetApplicationLogsOutput() = default;
};
class GetInstanceLogsInput : public Darabonba::Model {
public:
  shared_ptr<long> backwardLine{};
  shared_ptr<long> endTime{};
  shared_ptr<long> forwardLine{};
  shared_ptr<bool> isTail{};
  shared_ptr<string> match{};
  shared_ptr<string> message{};
  shared_ptr<long> offset{};
  shared_ptr<string> packID{};
  shared_ptr<string> packMeta{};
  shared_ptr<long> startTime{};
  shared_ptr<string> timestamp{};
  shared_ptr<string> versionID{};

  GetInstanceLogsInput() {}

  explicit GetInstanceLogsInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backwardLine) {
      res["backwardLine"] = boost::any(*backwardLine);
    }
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (forwardLine) {
      res["forwardLine"] = boost::any(*forwardLine);
    }
    if (isTail) {
      res["isTail"] = boost::any(*isTail);
    }
    if (match) {
      res["match"] = boost::any(*match);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (offset) {
      res["offset"] = boost::any(*offset);
    }
    if (packID) {
      res["packID"] = boost::any(*packID);
    }
    if (packMeta) {
      res["packMeta"] = boost::any(*packMeta);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    if (timestamp) {
      res["timestamp"] = boost::any(*timestamp);
    }
    if (versionID) {
      res["versionID"] = boost::any(*versionID);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("backwardLine") != m.end() && !m["backwardLine"].empty()) {
      backwardLine = make_shared<long>(boost::any_cast<long>(m["backwardLine"]));
    }
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["endTime"]));
    }
    if (m.find("forwardLine") != m.end() && !m["forwardLine"].empty()) {
      forwardLine = make_shared<long>(boost::any_cast<long>(m["forwardLine"]));
    }
    if (m.find("isTail") != m.end() && !m["isTail"].empty()) {
      isTail = make_shared<bool>(boost::any_cast<bool>(m["isTail"]));
    }
    if (m.find("match") != m.end() && !m["match"].empty()) {
      match = make_shared<string>(boost::any_cast<string>(m["match"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("offset") != m.end() && !m["offset"].empty()) {
      offset = make_shared<long>(boost::any_cast<long>(m["offset"]));
    }
    if (m.find("packID") != m.end() && !m["packID"].empty()) {
      packID = make_shared<string>(boost::any_cast<string>(m["packID"]));
    }
    if (m.find("packMeta") != m.end() && !m["packMeta"].empty()) {
      packMeta = make_shared<string>(boost::any_cast<string>(m["packMeta"]));
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["startTime"]));
    }
    if (m.find("timestamp") != m.end() && !m["timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["timestamp"]));
    }
    if (m.find("versionID") != m.end() && !m["versionID"].empty()) {
      versionID = make_shared<string>(boost::any_cast<string>(m["versionID"]));
    }
  }


  virtual ~GetInstanceLogsInput() = default;
};
class GetInstanceLogsOutput : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  GetInstanceLogsOutput() {}

  explicit GetInstanceLogsOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = boost::any(*data);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~GetInstanceLogsOutput() = default;
};
class GetPerRequestLogsInput : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> errorType{};
  shared_ptr<long> forwardLine{};
  shared_ptr<string> instanceID{};
  shared_ptr<bool> isColdStart{};
  shared_ptr<string> requestID{};
  shared_ptr<long> startTime{};
  shared_ptr<string> timestamp{};

  GetPerRequestLogsInput() {}

  explicit GetPerRequestLogsInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (errorType) {
      res["errorType"] = boost::any(*errorType);
    }
    if (forwardLine) {
      res["forwardLine"] = boost::any(*forwardLine);
    }
    if (instanceID) {
      res["instanceID"] = boost::any(*instanceID);
    }
    if (isColdStart) {
      res["isColdStart"] = boost::any(*isColdStart);
    }
    if (requestID) {
      res["requestID"] = boost::any(*requestID);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    if (timestamp) {
      res["timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["endTime"]));
    }
    if (m.find("errorType") != m.end() && !m["errorType"].empty()) {
      errorType = make_shared<string>(boost::any_cast<string>(m["errorType"]));
    }
    if (m.find("forwardLine") != m.end() && !m["forwardLine"].empty()) {
      forwardLine = make_shared<long>(boost::any_cast<long>(m["forwardLine"]));
    }
    if (m.find("instanceID") != m.end() && !m["instanceID"].empty()) {
      instanceID = make_shared<string>(boost::any_cast<string>(m["instanceID"]));
    }
    if (m.find("isColdStart") != m.end() && !m["isColdStart"].empty()) {
      isColdStart = make_shared<bool>(boost::any_cast<bool>(m["isColdStart"]));
    }
    if (m.find("requestID") != m.end() && !m["requestID"].empty()) {
      requestID = make_shared<string>(boost::any_cast<string>(m["requestID"]));
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["startTime"]));
    }
    if (m.find("timestamp") != m.end() && !m["timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["timestamp"]));
    }
  }


  virtual ~GetPerRequestLogsInput() = default;
};
class GetPerRequestLogsOutput : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  GetPerRequestLogsOutput() {}

  explicit GetPerRequestLogsOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = boost::any(*data);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~GetPerRequestLogsOutput() = default;
};
class GetQuotaOutput : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> instanceLimit{};
  shared_ptr<long> instanceUsed{};

  GetQuotaOutput() {}

  explicit GetQuotaOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (instanceLimit) {
      res["instanceLimit"] = boost::any(*instanceLimit);
    }
    if (instanceUsed) {
      res["instanceUsed"] = boost::any(*instanceUsed);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("instanceLimit") != m.end() && !m["instanceLimit"].empty()) {
      instanceLimit = make_shared<long>(boost::any_cast<long>(m["instanceLimit"]));
    }
    if (m.find("instanceUsed") != m.end() && !m["instanceUsed"].empty()) {
      instanceUsed = make_shared<long>(boost::any_cast<long>(m["instanceUsed"]));
    }
  }


  virtual ~GetQuotaOutput() = default;
};
class HttpApiRouteDomains : public Darabonba::Model {
public:
  shared_ptr<string> domainId{};
  shared_ptr<string> domainName{};

  HttpApiRouteDomains() {}

  explicit HttpApiRouteDomains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainId) {
      res["DomainId"] = boost::any(*domainId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainId") != m.end() && !m["DomainId"].empty()) {
      domainId = make_shared<string>(boost::any_cast<string>(m["DomainId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
  }


  virtual ~HttpApiRouteDomains() = default;
};
class HttpApiRoutePoliciesFallbackDestinations : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> serviceId{};
  shared_ptr<string> serviceName{};
  shared_ptr<long> servicePort{};
  shared_ptr<string> serviceProtocol{};

  HttpApiRoutePoliciesFallbackDestinations() {}

  explicit HttpApiRoutePoliciesFallbackDestinations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (serviceId) {
      res["ServiceId"] = boost::any(*serviceId);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (servicePort) {
      res["ServicePort"] = boost::any(*servicePort);
    }
    if (serviceProtocol) {
      res["ServiceProtocol"] = boost::any(*serviceProtocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("ServiceId") != m.end() && !m["ServiceId"].empty()) {
      serviceId = make_shared<string>(boost::any_cast<string>(m["ServiceId"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("ServicePort") != m.end() && !m["ServicePort"].empty()) {
      servicePort = make_shared<long>(boost::any_cast<long>(m["ServicePort"]));
    }
    if (m.find("ServiceProtocol") != m.end() && !m["ServiceProtocol"].empty()) {
      serviceProtocol = make_shared<string>(boost::any_cast<string>(m["ServiceProtocol"]));
    }
  }


  virtual ~HttpApiRoutePoliciesFallbackDestinations() = default;
};
class HttpApiRoutePoliciesFallback : public Darabonba::Model {
public:
  shared_ptr<vector<HttpApiRoutePoliciesFallbackDestinations>> destinations{};
  shared_ptr<bool> enable{};

  HttpApiRoutePoliciesFallback() {}

  explicit HttpApiRoutePoliciesFallback(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destinations) {
      vector<boost::any> temp1;
      for(auto item1:*destinations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Destinations"] = boost::any(temp1);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Destinations") != m.end() && !m["Destinations"].empty()) {
      if (typeid(vector<boost::any>) == m["Destinations"].type()) {
        vector<HttpApiRoutePoliciesFallbackDestinations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Destinations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HttpApiRoutePoliciesFallbackDestinations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        destinations = make_shared<vector<HttpApiRoutePoliciesFallbackDestinations>>(expect1);
      }
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
  }


  virtual ~HttpApiRoutePoliciesFallback() = default;
};
class HttpApiRoutePoliciesRetry : public Darabonba::Model {
public:
  shared_ptr<long> attempts{};
  shared_ptr<bool> enable{};
  shared_ptr<vector<string>> httpCodes{};
  shared_ptr<vector<string>> retryOn{};

  HttpApiRoutePoliciesRetry() {}

  explicit HttpApiRoutePoliciesRetry(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attempts) {
      res["Attempts"] = boost::any(*attempts);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (httpCodes) {
      res["HttpCodes"] = boost::any(*httpCodes);
    }
    if (retryOn) {
      res["RetryOn"] = boost::any(*retryOn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Attempts") != m.end() && !m["Attempts"].empty()) {
      attempts = make_shared<long>(boost::any_cast<long>(m["Attempts"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("HttpCodes") != m.end() && !m["HttpCodes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["HttpCodes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["HttpCodes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      httpCodes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RetryOn") != m.end() && !m["RetryOn"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RetryOn"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RetryOn"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      retryOn = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~HttpApiRoutePoliciesRetry() = default;
};
class HttpApiRoutePoliciesTimeout : public Darabonba::Model {
public:
  shared_ptr<bool> enable{};
  shared_ptr<string> timeUnit{};
  shared_ptr<long> unitNum{};

  HttpApiRoutePoliciesTimeout() {}

  explicit HttpApiRoutePoliciesTimeout(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (timeUnit) {
      res["TimeUnit"] = boost::any(*timeUnit);
    }
    if (unitNum) {
      res["UnitNum"] = boost::any(*unitNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("TimeUnit") != m.end() && !m["TimeUnit"].empty()) {
      timeUnit = make_shared<string>(boost::any_cast<string>(m["TimeUnit"]));
    }
    if (m.find("UnitNum") != m.end() && !m["UnitNum"].empty()) {
      unitNum = make_shared<long>(boost::any_cast<long>(m["UnitNum"]));
    }
  }


  virtual ~HttpApiRoutePoliciesTimeout() = default;
};
class HttpApiRoutePolicies : public Darabonba::Model {
public:
  shared_ptr<HttpApiRoutePoliciesFallback> fallback{};
  shared_ptr<HttpApiRoutePoliciesRetry> retry{};
  shared_ptr<HttpApiRoutePoliciesTimeout> timeout{};

  HttpApiRoutePolicies() {}

  explicit HttpApiRoutePolicies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fallback) {
      res["Fallback"] = fallback ? boost::any(fallback->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (retry) {
      res["Retry"] = retry ? boost::any(retry->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timeout) {
      res["Timeout"] = timeout ? boost::any(timeout->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Fallback") != m.end() && !m["Fallback"].empty()) {
      if (typeid(map<string, boost::any>) == m["Fallback"].type()) {
        HttpApiRoutePoliciesFallback model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Fallback"]));
        fallback = make_shared<HttpApiRoutePoliciesFallback>(model1);
      }
    }
    if (m.find("Retry") != m.end() && !m["Retry"].empty()) {
      if (typeid(map<string, boost::any>) == m["Retry"].type()) {
        HttpApiRoutePoliciesRetry model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Retry"]));
        retry = make_shared<HttpApiRoutePoliciesRetry>(model1);
      }
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      if (typeid(map<string, boost::any>) == m["Timeout"].type()) {
        HttpApiRoutePoliciesTimeout model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Timeout"]));
        timeout = make_shared<HttpApiRoutePoliciesTimeout>(model1);
      }
    }
  }


  virtual ~HttpApiRoutePolicies() = default;
};
class HttpApiRoutePredicatesHeaderPredicates : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  HttpApiRoutePredicatesHeaderPredicates() {}

  explicit HttpApiRoutePredicatesHeaderPredicates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~HttpApiRoutePredicatesHeaderPredicates() = default;
};
class HttpApiRoutePredicatesPathPredicates : public Darabonba::Model {
public:
  shared_ptr<bool> ignoreCase{};
  shared_ptr<string> path{};
  shared_ptr<string> type{};

  HttpApiRoutePredicatesPathPredicates() {}

  explicit HttpApiRoutePredicatesPathPredicates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ignoreCase) {
      res["IgnoreCase"] = boost::any(*ignoreCase);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IgnoreCase") != m.end() && !m["IgnoreCase"].empty()) {
      ignoreCase = make_shared<bool>(boost::any_cast<bool>(m["IgnoreCase"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~HttpApiRoutePredicatesPathPredicates() = default;
};
class HttpApiRoutePredicatesQueryPredicates : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  HttpApiRoutePredicatesQueryPredicates() {}

  explicit HttpApiRoutePredicatesQueryPredicates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~HttpApiRoutePredicatesQueryPredicates() = default;
};
class HttpApiRoutePredicates : public Darabonba::Model {
public:
  shared_ptr<vector<HttpApiRoutePredicatesHeaderPredicates>> headerPredicates{};
  shared_ptr<vector<string>> methodPredicates{};
  shared_ptr<HttpApiRoutePredicatesPathPredicates> pathPredicates{};
  shared_ptr<vector<HttpApiRoutePredicatesQueryPredicates>> queryPredicates{};

  HttpApiRoutePredicates() {}

  explicit HttpApiRoutePredicates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headerPredicates) {
      vector<boost::any> temp1;
      for(auto item1:*headerPredicates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HeaderPredicates"] = boost::any(temp1);
    }
    if (methodPredicates) {
      res["MethodPredicates"] = boost::any(*methodPredicates);
    }
    if (pathPredicates) {
      res["PathPredicates"] = pathPredicates ? boost::any(pathPredicates->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (queryPredicates) {
      vector<boost::any> temp1;
      for(auto item1:*queryPredicates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["QueryPredicates"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HeaderPredicates") != m.end() && !m["HeaderPredicates"].empty()) {
      if (typeid(vector<boost::any>) == m["HeaderPredicates"].type()) {
        vector<HttpApiRoutePredicatesHeaderPredicates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HeaderPredicates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HttpApiRoutePredicatesHeaderPredicates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        headerPredicates = make_shared<vector<HttpApiRoutePredicatesHeaderPredicates>>(expect1);
      }
    }
    if (m.find("MethodPredicates") != m.end() && !m["MethodPredicates"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MethodPredicates"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MethodPredicates"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      methodPredicates = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PathPredicates") != m.end() && !m["PathPredicates"].empty()) {
      if (typeid(map<string, boost::any>) == m["PathPredicates"].type()) {
        HttpApiRoutePredicatesPathPredicates model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PathPredicates"]));
        pathPredicates = make_shared<HttpApiRoutePredicatesPathPredicates>(model1);
      }
    }
    if (m.find("QueryPredicates") != m.end() && !m["QueryPredicates"].empty()) {
      if (typeid(vector<boost::any>) == m["QueryPredicates"].type()) {
        vector<HttpApiRoutePredicatesQueryPredicates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["QueryPredicates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HttpApiRoutePredicatesQueryPredicates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        queryPredicates = make_shared<vector<HttpApiRoutePredicatesQueryPredicates>>(expect1);
      }
    }
  }


  virtual ~HttpApiRoutePredicates() = default;
};
class HttpApiRouteServices : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> serviceId{};
  shared_ptr<string> serviceName{};
  shared_ptr<long> servicePort{};
  shared_ptr<string> serviceProtocol{};
  shared_ptr<long> serviceWeight{};

  HttpApiRouteServices() {}

  explicit HttpApiRouteServices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (serviceId) {
      res["ServiceId"] = boost::any(*serviceId);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (servicePort) {
      res["ServicePort"] = boost::any(*servicePort);
    }
    if (serviceProtocol) {
      res["ServiceProtocol"] = boost::any(*serviceProtocol);
    }
    if (serviceWeight) {
      res["ServiceWeight"] = boost::any(*serviceWeight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("ServiceId") != m.end() && !m["ServiceId"].empty()) {
      serviceId = make_shared<string>(boost::any_cast<string>(m["ServiceId"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("ServicePort") != m.end() && !m["ServicePort"].empty()) {
      servicePort = make_shared<long>(boost::any_cast<long>(m["ServicePort"]));
    }
    if (m.find("ServiceProtocol") != m.end() && !m["ServiceProtocol"].empty()) {
      serviceProtocol = make_shared<string>(boost::any_cast<string>(m["ServiceProtocol"]));
    }
    if (m.find("ServiceWeight") != m.end() && !m["ServiceWeight"].empty()) {
      serviceWeight = make_shared<long>(boost::any_cast<long>(m["ServiceWeight"]));
    }
  }


  virtual ~HttpApiRouteServices() = default;
};
class HttpApiRoute : public Darabonba::Model {
public:
  shared_ptr<string> addressType{};
  shared_ptr<string> deployStatus{};
  shared_ptr<string> destinationType{};
  shared_ptr<vector<HttpApiRouteDomains>> domains{};
  shared_ptr<string> environmentId{};
  shared_ptr<string> gatewayId{};
  shared_ptr<string> httpApiId{};
  shared_ptr<string> httpApiName{};
  shared_ptr<string> httpApiType{};
  shared_ptr<long> ingressId{};
  shared_ptr<string> nacosInstanceId{};
  shared_ptr<string> nacosNamespaceId{};
  shared_ptr<string> name{};
  shared_ptr<string> namespaceId{};
  shared_ptr<HttpApiRoutePolicies> policies{};
  shared_ptr<HttpApiRoutePredicates> predicates{};
  shared_ptr<string> routeId{};
  shared_ptr<vector<HttpApiRouteServices>> services{};
  shared_ptr<string> sourceType{};

  HttpApiRoute() {}

  explicit HttpApiRoute(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addressType) {
      res["AddressType"] = boost::any(*addressType);
    }
    if (deployStatus) {
      res["DeployStatus"] = boost::any(*deployStatus);
    }
    if (destinationType) {
      res["DestinationType"] = boost::any(*destinationType);
    }
    if (domains) {
      vector<boost::any> temp1;
      for(auto item1:*domains){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Domains"] = boost::any(temp1);
    }
    if (environmentId) {
      res["EnvironmentId"] = boost::any(*environmentId);
    }
    if (gatewayId) {
      res["GatewayId"] = boost::any(*gatewayId);
    }
    if (httpApiId) {
      res["HttpApiId"] = boost::any(*httpApiId);
    }
    if (httpApiName) {
      res["HttpApiName"] = boost::any(*httpApiName);
    }
    if (httpApiType) {
      res["HttpApiType"] = boost::any(*httpApiType);
    }
    if (ingressId) {
      res["IngressId"] = boost::any(*ingressId);
    }
    if (nacosInstanceId) {
      res["NacosInstanceId"] = boost::any(*nacosInstanceId);
    }
    if (nacosNamespaceId) {
      res["NacosNamespaceId"] = boost::any(*nacosNamespaceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (policies) {
      res["Policies"] = policies ? boost::any(policies->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (predicates) {
      res["Predicates"] = predicates ? boost::any(predicates->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (routeId) {
      res["RouteId"] = boost::any(*routeId);
    }
    if (services) {
      vector<boost::any> temp1;
      for(auto item1:*services){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Services"] = boost::any(temp1);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddressType") != m.end() && !m["AddressType"].empty()) {
      addressType = make_shared<string>(boost::any_cast<string>(m["AddressType"]));
    }
    if (m.find("DeployStatus") != m.end() && !m["DeployStatus"].empty()) {
      deployStatus = make_shared<string>(boost::any_cast<string>(m["DeployStatus"]));
    }
    if (m.find("DestinationType") != m.end() && !m["DestinationType"].empty()) {
      destinationType = make_shared<string>(boost::any_cast<string>(m["DestinationType"]));
    }
    if (m.find("Domains") != m.end() && !m["Domains"].empty()) {
      if (typeid(vector<boost::any>) == m["Domains"].type()) {
        vector<HttpApiRouteDomains> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Domains"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HttpApiRouteDomains model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domains = make_shared<vector<HttpApiRouteDomains>>(expect1);
      }
    }
    if (m.find("EnvironmentId") != m.end() && !m["EnvironmentId"].empty()) {
      environmentId = make_shared<string>(boost::any_cast<string>(m["EnvironmentId"]));
    }
    if (m.find("GatewayId") != m.end() && !m["GatewayId"].empty()) {
      gatewayId = make_shared<string>(boost::any_cast<string>(m["GatewayId"]));
    }
    if (m.find("HttpApiId") != m.end() && !m["HttpApiId"].empty()) {
      httpApiId = make_shared<string>(boost::any_cast<string>(m["HttpApiId"]));
    }
    if (m.find("HttpApiName") != m.end() && !m["HttpApiName"].empty()) {
      httpApiName = make_shared<string>(boost::any_cast<string>(m["HttpApiName"]));
    }
    if (m.find("HttpApiType") != m.end() && !m["HttpApiType"].empty()) {
      httpApiType = make_shared<string>(boost::any_cast<string>(m["HttpApiType"]));
    }
    if (m.find("IngressId") != m.end() && !m["IngressId"].empty()) {
      ingressId = make_shared<long>(boost::any_cast<long>(m["IngressId"]));
    }
    if (m.find("NacosInstanceId") != m.end() && !m["NacosInstanceId"].empty()) {
      nacosInstanceId = make_shared<string>(boost::any_cast<string>(m["NacosInstanceId"]));
    }
    if (m.find("NacosNamespaceId") != m.end() && !m["NacosNamespaceId"].empty()) {
      nacosNamespaceId = make_shared<string>(boost::any_cast<string>(m["NacosNamespaceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("Policies") != m.end() && !m["Policies"].empty()) {
      if (typeid(map<string, boost::any>) == m["Policies"].type()) {
        HttpApiRoutePolicies model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Policies"]));
        policies = make_shared<HttpApiRoutePolicies>(model1);
      }
    }
    if (m.find("Predicates") != m.end() && !m["Predicates"].empty()) {
      if (typeid(map<string, boost::any>) == m["Predicates"].type()) {
        HttpApiRoutePredicates model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Predicates"]));
        predicates = make_shared<HttpApiRoutePredicates>(model1);
      }
    }
    if (m.find("RouteId") != m.end() && !m["RouteId"].empty()) {
      routeId = make_shared<string>(boost::any_cast<string>(m["RouteId"]));
    }
    if (m.find("Services") != m.end() && !m["Services"].empty()) {
      if (typeid(vector<boost::any>) == m["Services"].type()) {
        vector<HttpApiRouteServices> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Services"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HttpApiRouteServices model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        services = make_shared<vector<HttpApiRouteServices>>(expect1);
      }
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
  }


  virtual ~HttpApiRoute() = default;
};
class InitContainerConfig : public Darabonba::Model {
public:
  shared_ptr<string> command{};
  shared_ptr<string> commandArgs{};
  shared_ptr<string> configMapMountDesc{};
  shared_ptr<string> envs{};
  shared_ptr<string> imageUrl{};
  shared_ptr<string> name{};

  InitContainerConfig() {}

  explicit InitContainerConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (command) {
      res["Command"] = boost::any(*command);
    }
    if (commandArgs) {
      res["CommandArgs"] = boost::any(*commandArgs);
    }
    if (configMapMountDesc) {
      res["ConfigMapMountDesc"] = boost::any(*configMapMountDesc);
    }
    if (envs) {
      res["Envs"] = boost::any(*envs);
    }
    if (imageUrl) {
      res["ImageUrl"] = boost::any(*imageUrl);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
    if (m.find("CommandArgs") != m.end() && !m["CommandArgs"].empty()) {
      commandArgs = make_shared<string>(boost::any_cast<string>(m["CommandArgs"]));
    }
    if (m.find("ConfigMapMountDesc") != m.end() && !m["ConfigMapMountDesc"].empty()) {
      configMapMountDesc = make_shared<string>(boost::any_cast<string>(m["ConfigMapMountDesc"]));
    }
    if (m.find("Envs") != m.end() && !m["Envs"].empty()) {
      envs = make_shared<string>(boost::any_cast<string>(m["Envs"]));
    }
    if (m.find("ImageUrl") != m.end() && !m["ImageUrl"].empty()) {
      imageUrl = make_shared<string>(boost::any_cast<string>(m["ImageUrl"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~InitContainerConfig() = default;
};
class InstanceExecAuthorizationInputOptions : public Darabonba::Model {
public:
  shared_ptr<vector<string>> command{};
  shared_ptr<bool> stderr{};
  shared_ptr<bool> stdin{};
  shared_ptr<bool> stdout{};
  shared_ptr<bool> tty{};

  InstanceExecAuthorizationInputOptions() {}

  explicit InstanceExecAuthorizationInputOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (command) {
      res["command"] = boost::any(*command);
    }
    if (stderr) {
      res["stderr"] = boost::any(*stderr);
    }
    if (stdin) {
      res["stdin"] = boost::any(*stdin);
    }
    if (stdout) {
      res["stdout"] = boost::any(*stdout);
    }
    if (tty) {
      res["tty"] = boost::any(*tty);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("command") != m.end() && !m["command"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["command"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["command"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      command = make_shared<vector<string>>(toVec1);
    }
    if (m.find("stderr") != m.end() && !m["stderr"].empty()) {
      stderr = make_shared<bool>(boost::any_cast<bool>(m["stderr"]));
    }
    if (m.find("stdin") != m.end() && !m["stdin"].empty()) {
      stdin = make_shared<bool>(boost::any_cast<bool>(m["stdin"]));
    }
    if (m.find("stdout") != m.end() && !m["stdout"].empty()) {
      stdout = make_shared<bool>(boost::any_cast<bool>(m["stdout"]));
    }
    if (m.find("tty") != m.end() && !m["tty"].empty()) {
      tty = make_shared<bool>(boost::any_cast<bool>(m["tty"]));
    }
  }


  virtual ~InstanceExecAuthorizationInputOptions() = default;
};
class InstanceExecAuthorizationInput : public Darabonba::Model {
public:
  shared_ptr<InstanceExecAuthorizationInputOptions> options{};

  InstanceExecAuthorizationInput() {}

  explicit InstanceExecAuthorizationInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (options) {
      res["options"] = options ? boost::any(options->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("options") != m.end() && !m["options"].empty()) {
      if (typeid(map<string, boost::any>) == m["options"].type()) {
        InstanceExecAuthorizationInputOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["options"]));
        options = make_shared<InstanceExecAuthorizationInputOptions>(model1);
      }
    }
  }


  virtual ~InstanceExecAuthorizationInput() = default;
};
class InstanceExecAuthorizationOutput : public Darabonba::Model {
public:
  shared_ptr<string> accessKeyId{};
  shared_ptr<string> accountId{};
  shared_ptr<string> authorization{};
  shared_ptr<string> date{};
  shared_ptr<string> endpoint{};
  shared_ptr<string> requestId{};

  InstanceExecAuthorizationOutput() {}

  explicit InstanceExecAuthorizationOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessKeyId) {
      res["accessKeyId"] = boost::any(*accessKeyId);
    }
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    if (authorization) {
      res["authorization"] = boost::any(*authorization);
    }
    if (date) {
      res["date"] = boost::any(*date);
    }
    if (endpoint) {
      res["endpoint"] = boost::any(*endpoint);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessKeyId") != m.end() && !m["accessKeyId"].empty()) {
      accessKeyId = make_shared<string>(boost::any_cast<string>(m["accessKeyId"]));
    }
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
    if (m.find("authorization") != m.end() && !m["authorization"].empty()) {
      authorization = make_shared<string>(boost::any_cast<string>(m["authorization"]));
    }
    if (m.find("date") != m.end() && !m["date"].empty()) {
      date = make_shared<string>(boost::any_cast<string>(m["date"]));
    }
    if (m.find("endpoint") != m.end() && !m["endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["endpoint"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~InstanceExecAuthorizationOutput() = default;
};
class InstanceInfo : public Darabonba::Model {
public:
  shared_ptr<string> imageUrl{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> status{};
  shared_ptr<string> versionId{};

  InstanceInfo() {}

  explicit InstanceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageUrl) {
      res["imageUrl"] = boost::any(*imageUrl);
    }
    if (instanceId) {
      res["instanceId"] = boost::any(*instanceId);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (versionId) {
      res["versionId"] = boost::any(*versionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("imageUrl") != m.end() && !m["imageUrl"].empty()) {
      imageUrl = make_shared<string>(boost::any_cast<string>(m["imageUrl"]));
    }
    if (m.find("instanceId") != m.end() && !m["instanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["instanceId"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("versionId") != m.end() && !m["versionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["versionId"]));
    }
  }


  virtual ~InstanceInfo() = default;
};
class InstanceMetricInfo : public Darabonba::Model {
public:
  shared_ptr<string> applicationID{};
  shared_ptr<double> cpuPercent{};
  shared_ptr<double> cpuQuotaPercent{};
  shared_ptr<string> instanceID{};
  shared_ptr<double> memoryLimitMB{};
  shared_ptr<double> memoryUsageMB{};
  shared_ptr<long> timestamp{};

  InstanceMetricInfo() {}

  explicit InstanceMetricInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationID) {
      res["applicationID"] = boost::any(*applicationID);
    }
    if (cpuPercent) {
      res["cpuPercent"] = boost::any(*cpuPercent);
    }
    if (cpuQuotaPercent) {
      res["cpuQuotaPercent"] = boost::any(*cpuQuotaPercent);
    }
    if (instanceID) {
      res["instanceID"] = boost::any(*instanceID);
    }
    if (memoryLimitMB) {
      res["memoryLimitMB"] = boost::any(*memoryLimitMB);
    }
    if (memoryUsageMB) {
      res["memoryUsageMB"] = boost::any(*memoryUsageMB);
    }
    if (timestamp) {
      res["timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("applicationID") != m.end() && !m["applicationID"].empty()) {
      applicationID = make_shared<string>(boost::any_cast<string>(m["applicationID"]));
    }
    if (m.find("cpuPercent") != m.end() && !m["cpuPercent"].empty()) {
      cpuPercent = make_shared<double>(boost::any_cast<double>(m["cpuPercent"]));
    }
    if (m.find("cpuQuotaPercent") != m.end() && !m["cpuQuotaPercent"].empty()) {
      cpuQuotaPercent = make_shared<double>(boost::any_cast<double>(m["cpuQuotaPercent"]));
    }
    if (m.find("instanceID") != m.end() && !m["instanceID"].empty()) {
      instanceID = make_shared<string>(boost::any_cast<string>(m["instanceID"]));
    }
    if (m.find("memoryLimitMB") != m.end() && !m["memoryLimitMB"].empty()) {
      memoryLimitMB = make_shared<double>(boost::any_cast<double>(m["memoryLimitMB"]));
    }
    if (m.find("memoryUsageMB") != m.end() && !m["memoryUsageMB"].empty()) {
      memoryUsageMB = make_shared<double>(boost::any_cast<double>(m["memoryUsageMB"]));
    }
    if (m.find("timestamp") != m.end() && !m["timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["timestamp"]));
    }
  }


  virtual ~InstanceMetricInfo() = default;
};
class ListApplicationVersionsOutput : public Darabonba::Model {
public:
  shared_ptr<string> direction{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<Version>> versions{};

  ListApplicationVersionsOutput() {}

  explicit ListApplicationVersionsOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (direction) {
      res["direction"] = boost::any(*direction);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (versions) {
      vector<boost::any> temp1;
      for(auto item1:*versions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["versions"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("direction") != m.end() && !m["direction"].empty()) {
      direction = make_shared<string>(boost::any_cast<string>(m["direction"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("versions") != m.end() && !m["versions"].empty()) {
      if (typeid(vector<boost::any>) == m["versions"].type()) {
        vector<Version> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["versions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Version model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        versions = make_shared<vector<Version>>(expect1);
      }
    }
  }


  virtual ~ListApplicationVersionsOutput() = default;
};
class ListApplicationsOutput : public Darabonba::Model {
public:
  shared_ptr<vector<Application>> applications{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};

  ListApplicationsOutput() {}

  explicit ListApplicationsOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applications) {
      vector<boost::any> temp1;
      for(auto item1:*applications){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["applications"] = boost::any(temp1);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("applications") != m.end() && !m["applications"].empty()) {
      if (typeid(vector<boost::any>) == m["applications"].type()) {
        vector<Application> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["applications"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Application model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        applications = make_shared<vector<Application>>(expect1);
      }
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~ListApplicationsOutput() = default;
};
class ListApplicationsWithStatusOutput : public Darabonba::Model {
public:
  shared_ptr<vector<ApplicationWithStatus>> applications{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};

  ListApplicationsWithStatusOutput() {}

  explicit ListApplicationsWithStatusOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applications) {
      vector<boost::any> temp1;
      for(auto item1:*applications){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["applications"] = boost::any(temp1);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("applications") != m.end() && !m["applications"].empty()) {
      if (typeid(vector<boost::any>) == m["applications"].type()) {
        vector<ApplicationWithStatus> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["applications"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplicationWithStatus model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        applications = make_shared<vector<ApplicationWithStatus>>(expect1);
      }
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~ListApplicationsWithStatusOutput() = default;
};
class ListCustomDomainOutput : public Darabonba::Model {
public:
  shared_ptr<vector<CustomDomain>> customDomains{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};

  ListCustomDomainOutput() {}

  explicit ListCustomDomainOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customDomains) {
      vector<boost::any> temp1;
      for(auto item1:*customDomains){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["customDomains"] = boost::any(temp1);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("customDomains") != m.end() && !m["customDomains"].empty()) {
      if (typeid(vector<boost::any>) == m["customDomains"].type()) {
        vector<CustomDomain> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["customDomains"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CustomDomain model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        customDomains = make_shared<vector<CustomDomain>>(expect1);
      }
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~ListCustomDomainOutput() = default;
};
class ListInstancesMetricsOutput : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<InstanceMetricInfo>> metricsList{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListInstancesMetricsOutput() {}

  explicit ListInstancesMetricsOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (metricsList) {
      vector<boost::any> temp1;
      for(auto item1:*metricsList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["metricsList"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["pageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("metricsList") != m.end() && !m["metricsList"].empty()) {
      if (typeid(vector<boost::any>) == m["metricsList"].type()) {
        vector<InstanceMetricInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["metricsList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InstanceMetricInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        metricsList = make_shared<vector<InstanceMetricInfo>>(expect1);
      }
    }
    if (m.find("pageNumber") != m.end() && !m["pageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["pageNumber"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
  }


  virtual ~ListInstancesMetricsOutput() = default;
};
class VersionStatus : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> status{};

  VersionStatus() {}

  explicit VersionStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
  }


  virtual ~VersionStatus() = default;
};
class ListInstancesOutput : public Darabonba::Model {
public:
  shared_ptr<string> currentError{};
  shared_ptr<vector<InstanceInfo>> instances{};
  shared_ptr<string> requestId{};
  shared_ptr<map<string, VersionStatus>> versionStatus{};

  ListInstancesOutput() {}

  explicit ListInstancesOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentError) {
      res["currentError"] = boost::any(*currentError);
    }
    if (instances) {
      vector<boost::any> temp1;
      for(auto item1:*instances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["instances"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (versionStatus) {
      map<string, boost::any> temp1;
      for(auto item1:*versionStatus){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["versionStatus"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("currentError") != m.end() && !m["currentError"].empty()) {
      currentError = make_shared<string>(boost::any_cast<string>(m["currentError"]));
    }
    if (m.find("instances") != m.end() && !m["instances"].empty()) {
      if (typeid(vector<boost::any>) == m["instances"].type()) {
        vector<InstanceInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["instances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InstanceInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instances = make_shared<vector<InstanceInfo>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("versionStatus") != m.end() && !m["versionStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["versionStatus"].type()) {
        map<string, VersionStatus> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["versionStatus"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            VersionStatus model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        versionStatus = make_shared<map<string, VersionStatus>>(expect1);
      }
    }
  }


  virtual ~ListInstancesOutput() = default;
};
class MetricInfo : public Darabonba::Model {
public:
  shared_ptr<double> average{};
  shared_ptr<double> count{};
  shared_ptr<double> maximum{};
  shared_ptr<double> minimum{};
  shared_ptr<double> sum{};
  shared_ptr<long> timestamp{};
  shared_ptr<double> value{};

  MetricInfo() {}

  explicit MetricInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (average) {
      res["Average"] = boost::any(*average);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (maximum) {
      res["Maximum"] = boost::any(*maximum);
    }
    if (minimum) {
      res["Minimum"] = boost::any(*minimum);
    }
    if (sum) {
      res["Sum"] = boost::any(*sum);
    }
    if (timestamp) {
      res["timestamp"] = boost::any(*timestamp);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Average") != m.end() && !m["Average"].empty()) {
      average = make_shared<double>(boost::any_cast<double>(m["Average"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<double>(boost::any_cast<double>(m["Count"]));
    }
    if (m.find("Maximum") != m.end() && !m["Maximum"].empty()) {
      maximum = make_shared<double>(boost::any_cast<double>(m["Maximum"]));
    }
    if (m.find("Minimum") != m.end() && !m["Minimum"].empty()) {
      minimum = make_shared<double>(boost::any_cast<double>(m["Minimum"]));
    }
    if (m.find("Sum") != m.end() && !m["Sum"].empty()) {
      sum = make_shared<double>(boost::any_cast<double>(m["Sum"]));
    }
    if (m.find("timestamp") != m.end() && !m["timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["timestamp"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["value"]));
    }
  }


  virtual ~MetricInfo() = default;
};
class ListMetricsOutput : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<map<string, vector<MetricInfo>>> metrics{};

  ListMetricsOutput() {}

  explicit ListMetricsOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (metrics) {
      map<string, boost::any> temp1;
      for(auto item1:*metrics){
        vector<boost::any> temp2;
        for(auto item2:item1.second){
          temp2.push_back(boost::any(item2.toMap()));
        }
        temp1[item1.first] = boost::any(temp2);
      }
      res["metrics"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("metrics") != m.end() && !m["metrics"].empty()) {
      if (typeid(map<string, boost::any>) == m["metrics"].type()) {
        map<string, vector<MetricInfo>> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["metrics"])){
          if (typeid(vector<boost::any>) == item1.second.type()) {
            vector<MetricInfo> expect2;
            for(auto item2:boost::any_cast<vector<boost::any>>(item1.second)){
              if (typeid(map<string, boost::any>) == item2.type()) {
                MetricInfo model3;
                model3.fromMap(boost::any_cast<map<string, boost::any>>(item2));
                expect2.push_back(model3);
              }
            }
            expect1[item1.first] = expect2;
          }
        }
        metrics = make_shared<map<string, vector<MetricInfo>>>(expect1);
      }
    }
  }


  virtual ~ListMetricsOutput() = default;
};
class StaticsInfo : public Darabonba::Model {
public:
  shared_ptr<long> activeCPUUsage{};
  shared_ptr<double> cost{};
  shared_ptr<long> diskUsage{};
  shared_ptr<string> functionName{};
  shared_ptr<long> gpuUsage{};
  shared_ptr<long> idleCPUUsage{};
  shared_ptr<long> instanceTrafficOut{};
  shared_ptr<long> invocations{};
  shared_ptr<long> invokeCDNOut{};
  shared_ptr<long> invokeInternetOut{};
  shared_ptr<long> memoryUsage{};
  shared_ptr<string> region{};
  shared_ptr<string> serviceName{};

  StaticsInfo() {}

  explicit StaticsInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activeCPUUsage) {
      res["activeCPUUsage"] = boost::any(*activeCPUUsage);
    }
    if (cost) {
      res["cost"] = boost::any(*cost);
    }
    if (diskUsage) {
      res["diskUsage"] = boost::any(*diskUsage);
    }
    if (functionName) {
      res["functionName"] = boost::any(*functionName);
    }
    if (gpuUsage) {
      res["gpuUsage"] = boost::any(*gpuUsage);
    }
    if (idleCPUUsage) {
      res["idleCPUUsage"] = boost::any(*idleCPUUsage);
    }
    if (instanceTrafficOut) {
      res["instanceTrafficOut"] = boost::any(*instanceTrafficOut);
    }
    if (invocations) {
      res["invocations"] = boost::any(*invocations);
    }
    if (invokeCDNOut) {
      res["invokeCDNOut"] = boost::any(*invokeCDNOut);
    }
    if (invokeInternetOut) {
      res["invokeInternetOut"] = boost::any(*invokeInternetOut);
    }
    if (memoryUsage) {
      res["memoryUsage"] = boost::any(*memoryUsage);
    }
    if (region) {
      res["region"] = boost::any(*region);
    }
    if (serviceName) {
      res["serviceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("activeCPUUsage") != m.end() && !m["activeCPUUsage"].empty()) {
      activeCPUUsage = make_shared<long>(boost::any_cast<long>(m["activeCPUUsage"]));
    }
    if (m.find("cost") != m.end() && !m["cost"].empty()) {
      cost = make_shared<double>(boost::any_cast<double>(m["cost"]));
    }
    if (m.find("diskUsage") != m.end() && !m["diskUsage"].empty()) {
      diskUsage = make_shared<long>(boost::any_cast<long>(m["diskUsage"]));
    }
    if (m.find("functionName") != m.end() && !m["functionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["functionName"]));
    }
    if (m.find("gpuUsage") != m.end() && !m["gpuUsage"].empty()) {
      gpuUsage = make_shared<long>(boost::any_cast<long>(m["gpuUsage"]));
    }
    if (m.find("idleCPUUsage") != m.end() && !m["idleCPUUsage"].empty()) {
      idleCPUUsage = make_shared<long>(boost::any_cast<long>(m["idleCPUUsage"]));
    }
    if (m.find("instanceTrafficOut") != m.end() && !m["instanceTrafficOut"].empty()) {
      instanceTrafficOut = make_shared<long>(boost::any_cast<long>(m["instanceTrafficOut"]));
    }
    if (m.find("invocations") != m.end() && !m["invocations"].empty()) {
      invocations = make_shared<long>(boost::any_cast<long>(m["invocations"]));
    }
    if (m.find("invokeCDNOut") != m.end() && !m["invokeCDNOut"].empty()) {
      invokeCDNOut = make_shared<long>(boost::any_cast<long>(m["invokeCDNOut"]));
    }
    if (m.find("invokeInternetOut") != m.end() && !m["invokeInternetOut"].empty()) {
      invokeInternetOut = make_shared<long>(boost::any_cast<long>(m["invokeInternetOut"]));
    }
    if (m.find("memoryUsage") != m.end() && !m["memoryUsage"].empty()) {
      memoryUsage = make_shared<long>(boost::any_cast<long>(m["memoryUsage"]));
    }
    if (m.find("region") != m.end() && !m["region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["region"]));
    }
    if (m.find("serviceName") != m.end() && !m["serviceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["serviceName"]));
    }
  }


  virtual ~StaticsInfo() = default;
};
class ListStaticsQueryResponse : public Darabonba::Model {
public:
  shared_ptr<long> length{};
  shared_ptr<string> sort{};
  shared_ptr<vector<StaticsInfo>> statics{};

  ListStaticsQueryResponse() {}

  explicit ListStaticsQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (length) {
      res["length"] = boost::any(*length);
    }
    if (sort) {
      res["sort"] = boost::any(*sort);
    }
    if (statics) {
      vector<boost::any> temp1;
      for(auto item1:*statics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["statics"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("length") != m.end() && !m["length"].empty()) {
      length = make_shared<long>(boost::any_cast<long>(m["length"]));
    }
    if (m.find("sort") != m.end() && !m["sort"].empty()) {
      sort = make_shared<string>(boost::any_cast<string>(m["sort"]));
    }
    if (m.find("statics") != m.end() && !m["statics"].empty()) {
      if (typeid(vector<boost::any>) == m["statics"].type()) {
        vector<StaticsInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["statics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            StaticsInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        statics = make_shared<vector<StaticsInfo>>(expect1);
      }
    }
  }


  virtual ~ListStaticsQueryResponse() = default;
};
class WebInstanceInfo : public Darabonba::Model {
public:
  shared_ptr<string> imageUrl{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> status{};
  shared_ptr<string> versionId{};

  WebInstanceInfo() {}

  explicit WebInstanceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageUrl) {
      res["ImageUrl"] = boost::any(*imageUrl);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageUrl") != m.end() && !m["ImageUrl"].empty()) {
      imageUrl = make_shared<string>(boost::any_cast<string>(m["ImageUrl"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
  }


  virtual ~WebInstanceInfo() = default;
};
class WebVersionStatus : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> status{};

  WebVersionStatus() {}

  explicit WebVersionStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~WebVersionStatus() = default;
};
class ListWebInstancesOutput : public Darabonba::Model {
public:
  shared_ptr<string> currentError{};
  shared_ptr<vector<WebInstanceInfo>> webInstances{};
  shared_ptr<map<string, WebVersionStatus>> webVersionStatus{};

  ListWebInstancesOutput() {}

  explicit ListWebInstancesOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentError) {
      res["CurrentError"] = boost::any(*currentError);
    }
    if (webInstances) {
      vector<boost::any> temp1;
      for(auto item1:*webInstances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WebInstances"] = boost::any(temp1);
    }
    if (webVersionStatus) {
      map<string, boost::any> temp1;
      for(auto item1:*webVersionStatus){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["WebVersionStatus"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentError") != m.end() && !m["CurrentError"].empty()) {
      currentError = make_shared<string>(boost::any_cast<string>(m["CurrentError"]));
    }
    if (m.find("WebInstances") != m.end() && !m["WebInstances"].empty()) {
      if (typeid(vector<boost::any>) == m["WebInstances"].type()) {
        vector<WebInstanceInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WebInstances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            WebInstanceInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        webInstances = make_shared<vector<WebInstanceInfo>>(expect1);
      }
    }
    if (m.find("WebVersionStatus") != m.end() && !m["WebVersionStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["WebVersionStatus"].type()) {
        map<string, WebVersionStatus> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["WebVersionStatus"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            WebVersionStatus model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        webVersionStatus = make_shared<map<string, WebVersionStatus>>(expect1);
      }
    }
  }


  virtual ~ListWebInstancesOutput() = default;
};
class ListWebApplicationInstancesBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<ListWebInstancesOutput> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListWebApplicationInstancesBody() {}

  explicit ListWebApplicationInstancesBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListWebInstancesOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListWebInstancesOutput>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListWebApplicationInstancesBody() = default;
};
class Revision : public Darabonba::Model {
public:
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<RevisionConfig> revisionConfig{};
  shared_ptr<string> revisionId{};
  shared_ptr<double> weight{};

  Revision() {}

  explicit Revision(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (revisionConfig) {
      res["RevisionConfig"] = revisionConfig ? boost::any(revisionConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (revisionId) {
      res["RevisionId"] = boost::any(*revisionId);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RevisionConfig") != m.end() && !m["RevisionConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["RevisionConfig"].type()) {
        RevisionConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RevisionConfig"]));
        revisionConfig = make_shared<RevisionConfig>(model1);
      }
    }
    if (m.find("RevisionId") != m.end() && !m["RevisionId"].empty()) {
      revisionId = make_shared<string>(boost::any_cast<string>(m["RevisionId"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<double>(boost::any_cast<double>(m["Weight"]));
    }
  }


  virtual ~Revision() = default;
};
class ListWebApplicationRevisionsOutput : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<vector<Revision>> revisions{};

  ListWebApplicationRevisionsOutput() {}

  explicit ListWebApplicationRevisionsOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (revisions) {
      vector<boost::any> temp1;
      for(auto item1:*revisions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Revisions"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Revisions") != m.end() && !m["Revisions"].empty()) {
      if (typeid(vector<boost::any>) == m["Revisions"].type()) {
        vector<Revision> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Revisions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Revision model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        revisions = make_shared<vector<Revision>>(expect1);
      }
    }
  }


  virtual ~ListWebApplicationRevisionsOutput() = default;
};
class ListWebApplicationRevisionsBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<ListWebApplicationRevisionsOutput> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListWebApplicationRevisionsBody() {}

  explicit ListWebApplicationRevisionsBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListWebApplicationRevisionsOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListWebApplicationRevisionsOutput>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListWebApplicationRevisionsBody() = default;
};
class WebApplication : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};
  shared_ptr<string> applicationName{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<string> internetURL{};
  shared_ptr<string> intranetURL{};
  shared_ptr<string> lastModifiedTime{};
  shared_ptr<string> namespaceId{};
  shared_ptr<RevisionConfig> revisionConfig{};
  shared_ptr<string> vpcId{};
  shared_ptr<WebScalingConfig> webScalingConfig{};
  shared_ptr<WebTrafficConfig> webTrafficConfig{};

  WebApplication() {}

  explicit WebApplication(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (applicationName) {
      res["ApplicationName"] = boost::any(*applicationName);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (internetURL) {
      res["InternetURL"] = boost::any(*internetURL);
    }
    if (intranetURL) {
      res["IntranetURL"] = boost::any(*intranetURL);
    }
    if (lastModifiedTime) {
      res["LastModifiedTime"] = boost::any(*lastModifiedTime);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (revisionConfig) {
      res["RevisionConfig"] = revisionConfig ? boost::any(revisionConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (webScalingConfig) {
      res["WebScalingConfig"] = webScalingConfig ? boost::any(webScalingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (webTrafficConfig) {
      res["WebTrafficConfig"] = webTrafficConfig ? boost::any(webTrafficConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("ApplicationName") != m.end() && !m["ApplicationName"].empty()) {
      applicationName = make_shared<string>(boost::any_cast<string>(m["ApplicationName"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InternetURL") != m.end() && !m["InternetURL"].empty()) {
      internetURL = make_shared<string>(boost::any_cast<string>(m["InternetURL"]));
    }
    if (m.find("IntranetURL") != m.end() && !m["IntranetURL"].empty()) {
      intranetURL = make_shared<string>(boost::any_cast<string>(m["IntranetURL"]));
    }
    if (m.find("LastModifiedTime") != m.end() && !m["LastModifiedTime"].empty()) {
      lastModifiedTime = make_shared<string>(boost::any_cast<string>(m["LastModifiedTime"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("RevisionConfig") != m.end() && !m["RevisionConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["RevisionConfig"].type()) {
        RevisionConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RevisionConfig"]));
        revisionConfig = make_shared<RevisionConfig>(model1);
      }
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("WebScalingConfig") != m.end() && !m["WebScalingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["WebScalingConfig"].type()) {
        WebScalingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WebScalingConfig"]));
        webScalingConfig = make_shared<WebScalingConfig>(model1);
      }
    }
    if (m.find("WebTrafficConfig") != m.end() && !m["WebTrafficConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["WebTrafficConfig"].type()) {
        WebTrafficConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WebTrafficConfig"]));
        webTrafficConfig = make_shared<WebTrafficConfig>(model1);
      }
    }
  }


  virtual ~WebApplication() = default;
};
class WebApplicationWithInstanceCount : public Darabonba::Model {
public:
  shared_ptr<long> instanceCount{};
  shared_ptr<WebApplication> webApplication{};

  WebApplicationWithInstanceCount() {}

  explicit WebApplicationWithInstanceCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceCount) {
      res["InstanceCount"] = boost::any(*instanceCount);
    }
    if (webApplication) {
      res["WebApplication"] = webApplication ? boost::any(webApplication->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceCount") != m.end() && !m["InstanceCount"].empty()) {
      instanceCount = make_shared<long>(boost::any_cast<long>(m["InstanceCount"]));
    }
    if (m.find("WebApplication") != m.end() && !m["WebApplication"].empty()) {
      if (typeid(map<string, boost::any>) == m["WebApplication"].type()) {
        WebApplication model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WebApplication"]));
        webApplication = make_shared<WebApplication>(model1);
      }
    }
  }


  virtual ~WebApplicationWithInstanceCount() = default;
};
class ListWebApplicationsOutput : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<vector<WebApplicationWithInstanceCount>> webApplicationWithInstanceCount{};

  ListWebApplicationsOutput() {}

  explicit ListWebApplicationsOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (webApplicationWithInstanceCount) {
      vector<boost::any> temp1;
      for(auto item1:*webApplicationWithInstanceCount){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WebApplicationWithInstanceCount"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("WebApplicationWithInstanceCount") != m.end() && !m["WebApplicationWithInstanceCount"].empty()) {
      if (typeid(vector<boost::any>) == m["WebApplicationWithInstanceCount"].type()) {
        vector<WebApplicationWithInstanceCount> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WebApplicationWithInstanceCount"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            WebApplicationWithInstanceCount model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        webApplicationWithInstanceCount = make_shared<vector<WebApplicationWithInstanceCount>>(expect1);
      }
    }
  }


  virtual ~ListWebApplicationsOutput() = default;
};
class ListWebApplicationsBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<ListWebApplicationsOutput> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListWebApplicationsBody() {}

  explicit ListWebApplicationsBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListWebApplicationsOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListWebApplicationsOutput>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListWebApplicationsBody() = default;
};
class WebCustomDomain : public Darabonba::Model {
public:
  shared_ptr<string> createdTime{};
  shared_ptr<string> defaultForwardingAppName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> lastModifiedTime{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> protocol{};
  shared_ptr<RouteConfig> routeConfig{};
  shared_ptr<WebCertConfig> webCertConfig{};
  shared_ptr<WebTLSConfig> webTLSConfig{};
  shared_ptr<WebWAFConfig> webWAFConfig{};
  shared_ptr<string> accountId{};

  WebCustomDomain() {}

  explicit WebCustomDomain(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (defaultForwardingAppName) {
      res["DefaultForwardingAppName"] = boost::any(*defaultForwardingAppName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (lastModifiedTime) {
      res["LastModifiedTime"] = boost::any(*lastModifiedTime);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (routeConfig) {
      res["RouteConfig"] = routeConfig ? boost::any(routeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (webCertConfig) {
      res["WebCertConfig"] = webCertConfig ? boost::any(webCertConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (webTLSConfig) {
      res["WebTLSConfig"] = webTLSConfig ? boost::any(webTLSConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (webWAFConfig) {
      res["WebWAFConfig"] = webWAFConfig ? boost::any(webWAFConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("DefaultForwardingAppName") != m.end() && !m["DefaultForwardingAppName"].empty()) {
      defaultForwardingAppName = make_shared<string>(boost::any_cast<string>(m["DefaultForwardingAppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("LastModifiedTime") != m.end() && !m["LastModifiedTime"].empty()) {
      lastModifiedTime = make_shared<string>(boost::any_cast<string>(m["LastModifiedTime"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("RouteConfig") != m.end() && !m["RouteConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["RouteConfig"].type()) {
        RouteConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RouteConfig"]));
        routeConfig = make_shared<RouteConfig>(model1);
      }
    }
    if (m.find("WebCertConfig") != m.end() && !m["WebCertConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["WebCertConfig"].type()) {
        WebCertConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WebCertConfig"]));
        webCertConfig = make_shared<WebCertConfig>(model1);
      }
    }
    if (m.find("WebTLSConfig") != m.end() && !m["WebTLSConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["WebTLSConfig"].type()) {
        WebTLSConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WebTLSConfig"]));
        webTLSConfig = make_shared<WebTLSConfig>(model1);
      }
    }
    if (m.find("WebWAFConfig") != m.end() && !m["WebWAFConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["WebWAFConfig"].type()) {
        WebWAFConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WebWAFConfig"]));
        webWAFConfig = make_shared<WebWAFConfig>(model1);
      }
    }
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~WebCustomDomain() = default;
};
class ListWebCustomDomainOutput : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<vector<WebCustomDomain>> webCustomDomains{};

  ListWebCustomDomainOutput() {}

  explicit ListWebCustomDomainOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (webCustomDomains) {
      vector<boost::any> temp1;
      for(auto item1:*webCustomDomains){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WebCustomDomains"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("WebCustomDomains") != m.end() && !m["WebCustomDomains"].empty()) {
      if (typeid(vector<boost::any>) == m["WebCustomDomains"].type()) {
        vector<WebCustomDomain> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WebCustomDomains"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            WebCustomDomain model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        webCustomDomains = make_shared<vector<WebCustomDomain>>(expect1);
      }
    }
  }


  virtual ~ListWebCustomDomainOutput() = default;
};
class ListWebCustomDomainBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<ListWebCustomDomainOutput> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListWebCustomDomainBody() {}

  explicit ListWebCustomDomainBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListWebCustomDomainOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListWebCustomDomainOutput>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListWebCustomDomainBody() = default;
};
class PermissionAssistantApi : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> updateTime{};

  PermissionAssistantApi() {}

  explicit PermissionAssistantApi(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (resourceType) {
      res["resourceType"] = boost::any(*resourceType);
    }
    if (updateTime) {
      res["updateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["createTime"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("resourceType") != m.end() && !m["resourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["resourceType"]));
    }
    if (m.find("updateTime") != m.end() && !m["updateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["updateTime"]));
    }
  }


  virtual ~PermissionAssistantApi() = default;
};
class PolicyItem : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> operator_{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  PolicyItem() {}

  explicit PolicyItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["key"] = boost::any(*key);
    }
    if (operator_) {
      res["operator"] = boost::any(*operator_);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("key") != m.end() && !m["key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["key"]));
    }
    if (m.find("operator") != m.end() && !m["operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["operator"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~PolicyItem() = default;
};
class PriceEstimateFeature : public Darabonba::Model {
public:
  shared_ptr<long> appCount{};
  shared_ptr<string> appType{};
  shared_ptr<double> cpuCore{};
  shared_ptr<string> cpuStrategy{};
  shared_ptr<string> cpuUtilLevel{};
  shared_ptr<vector<double>> cpuUtilMetrics{};
  shared_ptr<bool> enableCpuIdle{};
  shared_ptr<string> envType{};
  shared_ptr<long> ephemeralStorageGiB{};
  shared_ptr<long> highLoadInstanceCount{};
  shared_ptr<double> highLoadQps{};
  shared_ptr<long> highLoadSeconds{};
  shared_ptr<double> instanceQps{};
  shared_ptr<double> internetOutboundGiB{};
  shared_ptr<long> lowLoadInstanceCount{};
  shared_ptr<double> lowLoadQps{};
  shared_ptr<long> lowLoadSeconds{};
  shared_ptr<long> maxInstanceCount{};
  shared_ptr<double> memoryGiB{};
  shared_ptr<long> minInstanceCount{};
  shared_ptr<string> newSaeVersion{};
  shared_ptr<long> noneLoadInstanceCount{};
  shared_ptr<long> noneLoadSeconds{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceType{};

  PriceEstimateFeature() {}

  explicit PriceEstimateFeature(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appCount) {
      res["AppCount"] = boost::any(*appCount);
    }
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (cpuCore) {
      res["CpuCore"] = boost::any(*cpuCore);
    }
    if (cpuStrategy) {
      res["CpuStrategy"] = boost::any(*cpuStrategy);
    }
    if (cpuUtilLevel) {
      res["CpuUtilLevel"] = boost::any(*cpuUtilLevel);
    }
    if (cpuUtilMetrics) {
      res["CpuUtilMetrics"] = boost::any(*cpuUtilMetrics);
    }
    if (enableCpuIdle) {
      res["EnableCpuIdle"] = boost::any(*enableCpuIdle);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (ephemeralStorageGiB) {
      res["EphemeralStorageGiB"] = boost::any(*ephemeralStorageGiB);
    }
    if (highLoadInstanceCount) {
      res["HighLoadInstanceCount"] = boost::any(*highLoadInstanceCount);
    }
    if (highLoadQps) {
      res["HighLoadQps"] = boost::any(*highLoadQps);
    }
    if (highLoadSeconds) {
      res["HighLoadSeconds"] = boost::any(*highLoadSeconds);
    }
    if (instanceQps) {
      res["InstanceQps"] = boost::any(*instanceQps);
    }
    if (internetOutboundGiB) {
      res["InternetOutboundGiB"] = boost::any(*internetOutboundGiB);
    }
    if (lowLoadInstanceCount) {
      res["LowLoadInstanceCount"] = boost::any(*lowLoadInstanceCount);
    }
    if (lowLoadQps) {
      res["LowLoadQps"] = boost::any(*lowLoadQps);
    }
    if (lowLoadSeconds) {
      res["LowLoadSeconds"] = boost::any(*lowLoadSeconds);
    }
    if (maxInstanceCount) {
      res["MaxInstanceCount"] = boost::any(*maxInstanceCount);
    }
    if (memoryGiB) {
      res["MemoryGiB"] = boost::any(*memoryGiB);
    }
    if (minInstanceCount) {
      res["MinInstanceCount"] = boost::any(*minInstanceCount);
    }
    if (newSaeVersion) {
      res["NewSaeVersion"] = boost::any(*newSaeVersion);
    }
    if (noneLoadInstanceCount) {
      res["NoneLoadInstanceCount"] = boost::any(*noneLoadInstanceCount);
    }
    if (noneLoadSeconds) {
      res["NoneLoadSeconds"] = boost::any(*noneLoadSeconds);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppCount") != m.end() && !m["AppCount"].empty()) {
      appCount = make_shared<long>(boost::any_cast<long>(m["AppCount"]));
    }
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("CpuCore") != m.end() && !m["CpuCore"].empty()) {
      cpuCore = make_shared<double>(boost::any_cast<double>(m["CpuCore"]));
    }
    if (m.find("CpuStrategy") != m.end() && !m["CpuStrategy"].empty()) {
      cpuStrategy = make_shared<string>(boost::any_cast<string>(m["CpuStrategy"]));
    }
    if (m.find("CpuUtilLevel") != m.end() && !m["CpuUtilLevel"].empty()) {
      cpuUtilLevel = make_shared<string>(boost::any_cast<string>(m["CpuUtilLevel"]));
    }
    if (m.find("CpuUtilMetrics") != m.end() && !m["CpuUtilMetrics"].empty()) {
      vector<double> toVec1;
      if (typeid(vector<boost::any>) == m["CpuUtilMetrics"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CpuUtilMetrics"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<double>(item));
        }
      }
      cpuUtilMetrics = make_shared<vector<double>>(toVec1);
    }
    if (m.find("EnableCpuIdle") != m.end() && !m["EnableCpuIdle"].empty()) {
      enableCpuIdle = make_shared<bool>(boost::any_cast<bool>(m["EnableCpuIdle"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("EphemeralStorageGiB") != m.end() && !m["EphemeralStorageGiB"].empty()) {
      ephemeralStorageGiB = make_shared<long>(boost::any_cast<long>(m["EphemeralStorageGiB"]));
    }
    if (m.find("HighLoadInstanceCount") != m.end() && !m["HighLoadInstanceCount"].empty()) {
      highLoadInstanceCount = make_shared<long>(boost::any_cast<long>(m["HighLoadInstanceCount"]));
    }
    if (m.find("HighLoadQps") != m.end() && !m["HighLoadQps"].empty()) {
      highLoadQps = make_shared<double>(boost::any_cast<double>(m["HighLoadQps"]));
    }
    if (m.find("HighLoadSeconds") != m.end() && !m["HighLoadSeconds"].empty()) {
      highLoadSeconds = make_shared<long>(boost::any_cast<long>(m["HighLoadSeconds"]));
    }
    if (m.find("InstanceQps") != m.end() && !m["InstanceQps"].empty()) {
      instanceQps = make_shared<double>(boost::any_cast<double>(m["InstanceQps"]));
    }
    if (m.find("InternetOutboundGiB") != m.end() && !m["InternetOutboundGiB"].empty()) {
      internetOutboundGiB = make_shared<double>(boost::any_cast<double>(m["InternetOutboundGiB"]));
    }
    if (m.find("LowLoadInstanceCount") != m.end() && !m["LowLoadInstanceCount"].empty()) {
      lowLoadInstanceCount = make_shared<long>(boost::any_cast<long>(m["LowLoadInstanceCount"]));
    }
    if (m.find("LowLoadQps") != m.end() && !m["LowLoadQps"].empty()) {
      lowLoadQps = make_shared<double>(boost::any_cast<double>(m["LowLoadQps"]));
    }
    if (m.find("LowLoadSeconds") != m.end() && !m["LowLoadSeconds"].empty()) {
      lowLoadSeconds = make_shared<long>(boost::any_cast<long>(m["LowLoadSeconds"]));
    }
    if (m.find("MaxInstanceCount") != m.end() && !m["MaxInstanceCount"].empty()) {
      maxInstanceCount = make_shared<long>(boost::any_cast<long>(m["MaxInstanceCount"]));
    }
    if (m.find("MemoryGiB") != m.end() && !m["MemoryGiB"].empty()) {
      memoryGiB = make_shared<double>(boost::any_cast<double>(m["MemoryGiB"]));
    }
    if (m.find("MinInstanceCount") != m.end() && !m["MinInstanceCount"].empty()) {
      minInstanceCount = make_shared<long>(boost::any_cast<long>(m["MinInstanceCount"]));
    }
    if (m.find("NewSaeVersion") != m.end() && !m["NewSaeVersion"].empty()) {
      newSaeVersion = make_shared<string>(boost::any_cast<string>(m["NewSaeVersion"]));
    }
    if (m.find("NoneLoadInstanceCount") != m.end() && !m["NoneLoadInstanceCount"].empty()) {
      noneLoadInstanceCount = make_shared<long>(boost::any_cast<long>(m["NoneLoadInstanceCount"]));
    }
    if (m.find("NoneLoadSeconds") != m.end() && !m["NoneLoadSeconds"].empty()) {
      noneLoadSeconds = make_shared<long>(boost::any_cast<long>(m["NoneLoadSeconds"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~PriceEstimateFeature() = default;
};
class PriceEstimateOutputAppsUsages : public Darabonba::Model {
public:
  shared_ptr<double> amount{};
  shared_ptr<string> id{};
  shared_ptr<string> unit{};

  PriceEstimateOutputAppsUsages() {}

  explicit PriceEstimateOutputAppsUsages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<double>(boost::any_cast<double>(m["Amount"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
  }


  virtual ~PriceEstimateOutputAppsUsages() = default;
};
class PriceEstimateOutputApps : public Darabonba::Model {
public:
  shared_ptr<PriceEstimateFeature> feature{};
  shared_ptr<long> id{};
  shared_ptr<vector<PriceEstimateOutputAppsUsages>> usages{};

  PriceEstimateOutputApps() {}

  explicit PriceEstimateOutputApps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (feature) {
      res["Feature"] = feature ? boost::any(feature->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (usages) {
      vector<boost::any> temp1;
      for(auto item1:*usages){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Usages"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Feature") != m.end() && !m["Feature"].empty()) {
      if (typeid(map<string, boost::any>) == m["Feature"].type()) {
        PriceEstimateFeature model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Feature"]));
        feature = make_shared<PriceEstimateFeature>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Usages") != m.end() && !m["Usages"].empty()) {
      if (typeid(vector<boost::any>) == m["Usages"].type()) {
        vector<PriceEstimateOutputAppsUsages> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Usages"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PriceEstimateOutputAppsUsages model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        usages = make_shared<vector<PriceEstimateOutputAppsUsages>>(expect1);
      }
    }
  }


  virtual ~PriceEstimateOutputApps() = default;
};
class PriceEstimateOutputItemsSteps : public Darabonba::Model {
public:
  shared_ptr<long> begin{};
  shared_ptr<long> end{};
  shared_ptr<double> price{};
  shared_ptr<vector<string>> regionIds{};
  shared_ptr<string> unit{};

  PriceEstimateOutputItemsSteps() {}

  explicit PriceEstimateOutputItemsSteps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (begin) {
      res["Begin"] = boost::any(*begin);
    }
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (price) {
      res["Price"] = boost::any(*price);
    }
    if (regionIds) {
      res["RegionIds"] = boost::any(*regionIds);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Begin") != m.end() && !m["Begin"].empty()) {
      begin = make_shared<long>(boost::any_cast<long>(m["Begin"]));
    }
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<long>(boost::any_cast<long>(m["End"]));
    }
    if (m.find("Price") != m.end() && !m["Price"].empty()) {
      price = make_shared<double>(boost::any_cast<double>(m["Price"]));
    }
    if (m.find("RegionIds") != m.end() && !m["RegionIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RegionIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RegionIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      regionIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
  }


  virtual ~PriceEstimateOutputItemsSteps() = default;
};
class PriceEstimateOutputItems : public Darabonba::Model {
public:
  shared_ptr<double> amount{};
  shared_ptr<long> count{};
  shared_ptr<string> id{};
  shared_ptr<double> price{};
  shared_ptr<vector<PriceEstimateOutputItemsSteps>> steps{};
  shared_ptr<string> type{};
  shared_ptr<string> unit{};

  PriceEstimateOutputItems() {}

  explicit PriceEstimateOutputItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (price) {
      res["Price"] = boost::any(*price);
    }
    if (steps) {
      vector<boost::any> temp1;
      for(auto item1:*steps){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Steps"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<double>(boost::any_cast<double>(m["Amount"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Price") != m.end() && !m["Price"].empty()) {
      price = make_shared<double>(boost::any_cast<double>(m["Price"]));
    }
    if (m.find("Steps") != m.end() && !m["Steps"].empty()) {
      if (typeid(vector<boost::any>) == m["Steps"].type()) {
        vector<PriceEstimateOutputItemsSteps> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Steps"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PriceEstimateOutputItemsSteps model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        steps = make_shared<vector<PriceEstimateOutputItemsSteps>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
  }


  virtual ~PriceEstimateOutputItems() = default;
};
class PriceEstimateOutputPostPayItemsSteps : public Darabonba::Model {
public:
  shared_ptr<long> begin{};
  shared_ptr<long> end{};
  shared_ptr<double> price{};
  shared_ptr<vector<string>> regionIds{};
  shared_ptr<string> unit{};

  PriceEstimateOutputPostPayItemsSteps() {}

  explicit PriceEstimateOutputPostPayItemsSteps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (begin) {
      res["Begin"] = boost::any(*begin);
    }
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (price) {
      res["Price"] = boost::any(*price);
    }
    if (regionIds) {
      res["RegionIds"] = boost::any(*regionIds);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Begin") != m.end() && !m["Begin"].empty()) {
      begin = make_shared<long>(boost::any_cast<long>(m["Begin"]));
    }
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<long>(boost::any_cast<long>(m["End"]));
    }
    if (m.find("Price") != m.end() && !m["Price"].empty()) {
      price = make_shared<double>(boost::any_cast<double>(m["Price"]));
    }
    if (m.find("RegionIds") != m.end() && !m["RegionIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RegionIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RegionIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      regionIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
  }


  virtual ~PriceEstimateOutputPostPayItemsSteps() = default;
};
class PriceEstimateOutputPostPayItems : public Darabonba::Model {
public:
  shared_ptr<double> amount{};
  shared_ptr<long> count{};
  shared_ptr<string> id{};
  shared_ptr<double> price{};
  shared_ptr<vector<PriceEstimateOutputPostPayItemsSteps>> steps{};
  shared_ptr<string> type{};
  shared_ptr<string> unit{};

  PriceEstimateOutputPostPayItems() {}

  explicit PriceEstimateOutputPostPayItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (price) {
      res["Price"] = boost::any(*price);
    }
    if (steps) {
      vector<boost::any> temp1;
      for(auto item1:*steps){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Steps"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<double>(boost::any_cast<double>(m["Amount"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Price") != m.end() && !m["Price"].empty()) {
      price = make_shared<double>(boost::any_cast<double>(m["Price"]));
    }
    if (m.find("Steps") != m.end() && !m["Steps"].empty()) {
      if (typeid(vector<boost::any>) == m["Steps"].type()) {
        vector<PriceEstimateOutputPostPayItemsSteps> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Steps"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PriceEstimateOutputPostPayItemsSteps model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        steps = make_shared<vector<PriceEstimateOutputPostPayItemsSteps>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
  }


  virtual ~PriceEstimateOutputPostPayItems() = default;
};
class PriceEstimateOutput : public Darabonba::Model {
public:
  shared_ptr<vector<PriceEstimateOutputApps>> apps{};
  shared_ptr<vector<PriceEstimateOutputItems>> items{};
  shared_ptr<vector<PriceEstimateOutputPostPayItems>> postPayItems{};
  shared_ptr<double> postPayTotalPrice{};
  shared_ptr<double> totalPrice{};

  PriceEstimateOutput() {}

  explicit PriceEstimateOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apps) {
      vector<boost::any> temp1;
      for(auto item1:*apps){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Apps"] = boost::any(temp1);
    }
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Items"] = boost::any(temp1);
    }
    if (postPayItems) {
      vector<boost::any> temp1;
      for(auto item1:*postPayItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PostPayItems"] = boost::any(temp1);
    }
    if (postPayTotalPrice) {
      res["PostPayTotalPrice"] = boost::any(*postPayTotalPrice);
    }
    if (totalPrice) {
      res["TotalPrice"] = boost::any(*totalPrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Apps") != m.end() && !m["Apps"].empty()) {
      if (typeid(vector<boost::any>) == m["Apps"].type()) {
        vector<PriceEstimateOutputApps> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Apps"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PriceEstimateOutputApps model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apps = make_shared<vector<PriceEstimateOutputApps>>(expect1);
      }
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<PriceEstimateOutputItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PriceEstimateOutputItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<PriceEstimateOutputItems>>(expect1);
      }
    }
    if (m.find("PostPayItems") != m.end() && !m["PostPayItems"].empty()) {
      if (typeid(vector<boost::any>) == m["PostPayItems"].type()) {
        vector<PriceEstimateOutputPostPayItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PostPayItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PriceEstimateOutputPostPayItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        postPayItems = make_shared<vector<PriceEstimateOutputPostPayItems>>(expect1);
      }
    }
    if (m.find("PostPayTotalPrice") != m.end() && !m["PostPayTotalPrice"].empty()) {
      postPayTotalPrice = make_shared<double>(boost::any_cast<double>(m["PostPayTotalPrice"]));
    }
    if (m.find("TotalPrice") != m.end() && !m["TotalPrice"].empty()) {
      totalPrice = make_shared<double>(boost::any_cast<double>(m["TotalPrice"]));
    }
  }


  virtual ~PriceEstimateOutput() = default;
};
class PublishApplicationVersionInput : public Darabonba::Model {
public:
  shared_ptr<string> description{};

  PublishApplicationVersionInput() {}

  explicit PublishApplicationVersionInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
  }


  virtual ~PublishApplicationVersionInput() = default;
};
class PublishWebApplicationRevisionInput : public Darabonba::Model {
public:
  shared_ptr<vector<Container>> containers{};
  shared_ptr<string> description{};
  shared_ptr<bool> enableArmsMetrics{};
  shared_ptr<bool> takeEffect{};

  PublishWebApplicationRevisionInput() {}

  explicit PublishWebApplicationRevisionInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (containers) {
      vector<boost::any> temp1;
      for(auto item1:*containers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Containers"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enableArmsMetrics) {
      res["EnableArmsMetrics"] = boost::any(*enableArmsMetrics);
    }
    if (takeEffect) {
      res["TakeEffect"] = boost::any(*takeEffect);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Containers") != m.end() && !m["Containers"].empty()) {
      if (typeid(vector<boost::any>) == m["Containers"].type()) {
        vector<Container> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Containers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Container model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        containers = make_shared<vector<Container>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnableArmsMetrics") != m.end() && !m["EnableArmsMetrics"].empty()) {
      enableArmsMetrics = make_shared<bool>(boost::any_cast<bool>(m["EnableArmsMetrics"]));
    }
    if (m.find("TakeEffect") != m.end() && !m["TakeEffect"].empty()) {
      takeEffect = make_shared<bool>(boost::any_cast<bool>(m["TakeEffect"]));
    }
  }


  virtual ~PublishWebApplicationRevisionInput() = default;
};
class RoutePolicy : public Darabonba::Model {
public:
  shared_ptr<string> condition{};
  shared_ptr<vector<PolicyItem>> policyItems{};

  RoutePolicy() {}

  explicit RoutePolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (condition) {
      res["condition"] = boost::any(*condition);
    }
    if (policyItems) {
      vector<boost::any> temp1;
      for(auto item1:*policyItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["policyItems"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("condition") != m.end() && !m["condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["condition"]));
    }
    if (m.find("policyItems") != m.end() && !m["policyItems"].empty()) {
      if (typeid(vector<boost::any>) == m["policyItems"].type()) {
        vector<PolicyItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["policyItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PolicyItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        policyItems = make_shared<vector<PolicyItem>>(expect1);
      }
    }
  }


  virtual ~RoutePolicy() = default;
};
class SidecarContainerConfig : public Darabonba::Model {
public:
  shared_ptr<string> acrInstanceId{};
  shared_ptr<string> command{};
  shared_ptr<string> commandArgs{};
  shared_ptr<string> configMapMountDesc{};
  shared_ptr<long> cpu{};
  shared_ptr<string> emptyDirDesc{};
  shared_ptr<string> envs{};
  shared_ptr<string> imageUrl{};
  shared_ptr<long> memory{};
  shared_ptr<string> name{};

  SidecarContainerConfig() {}

  explicit SidecarContainerConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acrInstanceId) {
      res["AcrInstanceId"] = boost::any(*acrInstanceId);
    }
    if (command) {
      res["Command"] = boost::any(*command);
    }
    if (commandArgs) {
      res["CommandArgs"] = boost::any(*commandArgs);
    }
    if (configMapMountDesc) {
      res["ConfigMapMountDesc"] = boost::any(*configMapMountDesc);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (emptyDirDesc) {
      res["EmptyDirDesc"] = boost::any(*emptyDirDesc);
    }
    if (envs) {
      res["Envs"] = boost::any(*envs);
    }
    if (imageUrl) {
      res["ImageUrl"] = boost::any(*imageUrl);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcrInstanceId") != m.end() && !m["AcrInstanceId"].empty()) {
      acrInstanceId = make_shared<string>(boost::any_cast<string>(m["AcrInstanceId"]));
    }
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
    if (m.find("CommandArgs") != m.end() && !m["CommandArgs"].empty()) {
      commandArgs = make_shared<string>(boost::any_cast<string>(m["CommandArgs"]));
    }
    if (m.find("ConfigMapMountDesc") != m.end() && !m["ConfigMapMountDesc"].empty()) {
      configMapMountDesc = make_shared<string>(boost::any_cast<string>(m["ConfigMapMountDesc"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("EmptyDirDesc") != m.end() && !m["EmptyDirDesc"].empty()) {
      emptyDirDesc = make_shared<string>(boost::any_cast<string>(m["EmptyDirDesc"]));
    }
    if (m.find("Envs") != m.end() && !m["Envs"].empty()) {
      envs = make_shared<string>(boost::any_cast<string>(m["Envs"]));
    }
    if (m.find("ImageUrl") != m.end() && !m["ImageUrl"].empty()) {
      imageUrl = make_shared<string>(boost::any_cast<string>(m["ImageUrl"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~SidecarContainerConfig() = default;
};
class SourceCodeAccountOrganizations : public Darabonba::Model {
public:
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  SourceCodeAccountOrganizations() {}

  explicit SourceCodeAccountOrganizations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatarUrl) {
      res["AvatarUrl"] = boost::any(*avatarUrl);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvatarUrl") != m.end() && !m["AvatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["AvatarUrl"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~SourceCodeAccountOrganizations() = default;
};
class SourceCodeAccount : public Darabonba::Model {
public:
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<vector<SourceCodeAccountOrganizations>> organizations{};

  SourceCodeAccount() {}

  explicit SourceCodeAccount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatarUrl) {
      res["AvatarUrl"] = boost::any(*avatarUrl);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (organizations) {
      vector<boost::any> temp1;
      for(auto item1:*organizations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Organizations"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvatarUrl") != m.end() && !m["AvatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["AvatarUrl"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Organizations") != m.end() && !m["Organizations"].empty()) {
      if (typeid(vector<boost::any>) == m["Organizations"].type()) {
        vector<SourceCodeAccountOrganizations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Organizations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SourceCodeAccountOrganizations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        organizations = make_shared<vector<SourceCodeAccountOrganizations>>(expect1);
      }
    }
  }


  virtual ~SourceCodeAccount() = default;
};
class SourceCodeRepo : public Darabonba::Model {
public:
  shared_ptr<string> fullName{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  SourceCodeRepo() {}

  explicit SourceCodeRepo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fullName) {
      res["FullName"] = boost::any(*fullName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FullName") != m.end() && !m["FullName"].empty()) {
      fullName = make_shared<string>(boost::any_cast<string>(m["FullName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~SourceCodeRepo() = default;
};
class SourceCodeRepoBranch : public Darabonba::Model {
public:
  shared_ptr<string> commitId{};
  shared_ptr<string> name{};

  SourceCodeRepoBranch() {}

  explicit SourceCodeRepoBranch(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commitId) {
      res["CommitId"] = boost::any(*commitId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommitId") != m.end() && !m["CommitId"].empty()) {
      commitId = make_shared<string>(boost::any_cast<string>(m["CommitId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~SourceCodeRepoBranch() = default;
};
class SubmenuItems : public Darabonba::Model {
public:
  shared_ptr<bool> defaultSelected{};
  shared_ptr<string> itemDesc{};
  shared_ptr<string> itemType{};
  shared_ptr<vector<string>> relatingItems{};

  SubmenuItems() {}

  explicit SubmenuItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defaultSelected) {
      res["DefaultSelected"] = boost::any(*defaultSelected);
    }
    if (itemDesc) {
      res["ItemDesc"] = boost::any(*itemDesc);
    }
    if (itemType) {
      res["ItemType"] = boost::any(*itemType);
    }
    if (relatingItems) {
      res["RelatingItems"] = boost::any(*relatingItems);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefaultSelected") != m.end() && !m["DefaultSelected"].empty()) {
      defaultSelected = make_shared<bool>(boost::any_cast<bool>(m["DefaultSelected"]));
    }
    if (m.find("ItemDesc") != m.end() && !m["ItemDesc"].empty()) {
      itemDesc = make_shared<string>(boost::any_cast<string>(m["ItemDesc"]));
    }
    if (m.find("ItemType") != m.end() && !m["ItemType"].empty()) {
      itemType = make_shared<string>(boost::any_cast<string>(m["ItemType"]));
    }
    if (m.find("RelatingItems") != m.end() && !m["RelatingItems"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RelatingItems"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RelatingItems"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      relatingItems = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~SubmenuItems() = default;
};
class Submenu : public Darabonba::Model {
public:
  shared_ptr<vector<SubmenuItems>> items{};
  shared_ptr<string> submenuDesc{};
  shared_ptr<string> submenuType{};
  shared_ptr<vector<Submenu>> submenus{};

  Submenu() {}

  explicit Submenu(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Items"] = boost::any(temp1);
    }
    if (submenuDesc) {
      res["SubmenuDesc"] = boost::any(*submenuDesc);
    }
    if (submenuType) {
      res["SubmenuType"] = boost::any(*submenuType);
    }
    if (submenus) {
      vector<boost::any> temp1;
      for(auto item1:*submenus){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Submenus"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<SubmenuItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmenuItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<SubmenuItems>>(expect1);
      }
    }
    if (m.find("SubmenuDesc") != m.end() && !m["SubmenuDesc"].empty()) {
      submenuDesc = make_shared<string>(boost::any_cast<string>(m["SubmenuDesc"]));
    }
    if (m.find("SubmenuType") != m.end() && !m["SubmenuType"].empty()) {
      submenuType = make_shared<string>(boost::any_cast<string>(m["SubmenuType"]));
    }
    if (m.find("Submenus") != m.end() && !m["Submenus"].empty()) {
      if (typeid(vector<boost::any>) == m["Submenus"].type()) {
        vector<Submenu> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Submenus"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Submenu model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        submenus = make_shared<vector<Submenu>>(expect1);
      }
    }
  }


  virtual ~Submenu() = default;
};
class TrafficConfig : public Darabonba::Model {
public:
  shared_ptr<map<string, double>> additionalVersionWeight{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> lastModifiedTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resolvePolicy{};
  shared_ptr<RoutePolicy> routePolicy{};
  shared_ptr<string> versionId{};

  TrafficConfig() {}

  explicit TrafficConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (additionalVersionWeight) {
      res["additionalVersionWeight"] = boost::any(*additionalVersionWeight);
    }
    if (createdTime) {
      res["createdTime"] = boost::any(*createdTime);
    }
    if (lastModifiedTime) {
      res["lastModifiedTime"] = boost::any(*lastModifiedTime);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resolvePolicy) {
      res["resolvePolicy"] = boost::any(*resolvePolicy);
    }
    if (routePolicy) {
      res["routePolicy"] = routePolicy ? boost::any(routePolicy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (versionId) {
      res["versionId"] = boost::any(*versionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("additionalVersionWeight") != m.end() && !m["additionalVersionWeight"].empty()) {
      map<string, double> map1 = boost::any_cast<map<string, double>>(m["additionalVersionWeight"]);
      map<string, double> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      additionalVersionWeight = make_shared<map<string, double>>(toMap1);
    }
    if (m.find("createdTime") != m.end() && !m["createdTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["createdTime"]));
    }
    if (m.find("lastModifiedTime") != m.end() && !m["lastModifiedTime"].empty()) {
      lastModifiedTime = make_shared<string>(boost::any_cast<string>(m["lastModifiedTime"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resolvePolicy") != m.end() && !m["resolvePolicy"].empty()) {
      resolvePolicy = make_shared<string>(boost::any_cast<string>(m["resolvePolicy"]));
    }
    if (m.find("routePolicy") != m.end() && !m["routePolicy"].empty()) {
      if (typeid(map<string, boost::any>) == m["routePolicy"].type()) {
        RoutePolicy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["routePolicy"]));
        routePolicy = make_shared<RoutePolicy>(model1);
      }
    }
    if (m.find("versionId") != m.end() && !m["versionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["versionId"]));
    }
  }


  virtual ~TrafficConfig() = default;
};
class UpdateApplicationInput : public Darabonba::Model {
public:
  shared_ptr<string> args{};
  shared_ptr<long> caPort{};
  shared_ptr<InputCodeLocation> code{};
  shared_ptr<string> command{};
  shared_ptr<double> cpu{};
  shared_ptr<CustomDNS> customDNS{};
  shared_ptr<CustomHealthCheckConfig> customHealthCheckConfig{};
  shared_ptr<CustomHostAlias> customHostAlias{};
  shared_ptr<CustomRuntimeConfig> customRuntimeConfig{};
  shared_ptr<string> description{};
  shared_ptr<long> diskSize{};
  shared_ptr<bool> effectiveImmediately{};
  shared_ptr<bool> enableAppMetric{};
  shared_ptr<map<string, string>> environmentVariables{};
  shared_ptr<long> gpuMemorySize{};
  shared_ptr<string> handler{};
  shared_ptr<HTTPTriggerConfig> httpTriggerConfig{};
  shared_ptr<ImageConfig> imageConfig{};
  shared_ptr<long> initializationTimeout{};
  shared_ptr<string> initializer{};
  shared_ptr<long> instanceConcurrency{};
  shared_ptr<InstanceLifecycleConfig> instanceLifecycleConfig{};
  shared_ptr<long> instanceSoftConcurrency{};
  shared_ptr<string> instanceType{};
  shared_ptr<bool> internetAccess{};
  shared_ptr<vector<string>> layers{};
  shared_ptr<Probe> livenessProbe{};
  shared_ptr<LogConfig> logConfig{};
  shared_ptr<long> memorySize{};
  shared_ptr<string> namespaceID{};
  shared_ptr<NASConfig> nasConfig{};
  shared_ptr<OSSMountConfig> ossMountConfig{};
  shared_ptr<string> programmingLanguage{};
  shared_ptr<string> runtime{};
  shared_ptr<ScaleConfig> scaleConfig{};
  shared_ptr<SLSConfig> slsConfig{};
  shared_ptr<Probe> startupProbe{};
  shared_ptr<long> timeout{};
  shared_ptr<TracingConfig> tracingConfig{};
  shared_ptr<VPCConfig> vpcConfig{};

  UpdateApplicationInput() {}

  explicit UpdateApplicationInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (args) {
      res["args"] = boost::any(*args);
    }
    if (caPort) {
      res["caPort"] = boost::any(*caPort);
    }
    if (code) {
      res["code"] = code ? boost::any(code->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (command) {
      res["command"] = boost::any(*command);
    }
    if (cpu) {
      res["cpu"] = boost::any(*cpu);
    }
    if (customDNS) {
      res["customDNS"] = customDNS ? boost::any(customDNS->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (customHealthCheckConfig) {
      res["customHealthCheckConfig"] = customHealthCheckConfig ? boost::any(customHealthCheckConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (customHostAlias) {
      res["customHostAlias"] = customHostAlias ? boost::any(customHostAlias->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (customRuntimeConfig) {
      res["customRuntimeConfig"] = customRuntimeConfig ? boost::any(customRuntimeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (diskSize) {
      res["diskSize"] = boost::any(*diskSize);
    }
    if (effectiveImmediately) {
      res["effectiveImmediately"] = boost::any(*effectiveImmediately);
    }
    if (enableAppMetric) {
      res["enableAppMetric"] = boost::any(*enableAppMetric);
    }
    if (environmentVariables) {
      res["environmentVariables"] = boost::any(*environmentVariables);
    }
    if (gpuMemorySize) {
      res["gpuMemorySize"] = boost::any(*gpuMemorySize);
    }
    if (handler) {
      res["handler"] = boost::any(*handler);
    }
    if (httpTriggerConfig) {
      res["httpTriggerConfig"] = httpTriggerConfig ? boost::any(httpTriggerConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (imageConfig) {
      res["imageConfig"] = imageConfig ? boost::any(imageConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (initializationTimeout) {
      res["initializationTimeout"] = boost::any(*initializationTimeout);
    }
    if (initializer) {
      res["initializer"] = boost::any(*initializer);
    }
    if (instanceConcurrency) {
      res["instanceConcurrency"] = boost::any(*instanceConcurrency);
    }
    if (instanceLifecycleConfig) {
      res["instanceLifecycleConfig"] = instanceLifecycleConfig ? boost::any(instanceLifecycleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceSoftConcurrency) {
      res["instanceSoftConcurrency"] = boost::any(*instanceSoftConcurrency);
    }
    if (instanceType) {
      res["instanceType"] = boost::any(*instanceType);
    }
    if (internetAccess) {
      res["internetAccess"] = boost::any(*internetAccess);
    }
    if (layers) {
      res["layers"] = boost::any(*layers);
    }
    if (livenessProbe) {
      res["livenessProbe"] = livenessProbe ? boost::any(livenessProbe->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (logConfig) {
      res["logConfig"] = logConfig ? boost::any(logConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (memorySize) {
      res["memorySize"] = boost::any(*memorySize);
    }
    if (namespaceID) {
      res["namespaceID"] = boost::any(*namespaceID);
    }
    if (nasConfig) {
      res["nasConfig"] = nasConfig ? boost::any(nasConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ossMountConfig) {
      res["ossMountConfig"] = ossMountConfig ? boost::any(ossMountConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (programmingLanguage) {
      res["programmingLanguage"] = boost::any(*programmingLanguage);
    }
    if (runtime) {
      res["runtime"] = boost::any(*runtime);
    }
    if (scaleConfig) {
      res["scaleConfig"] = scaleConfig ? boost::any(scaleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (slsConfig) {
      res["slsConfig"] = slsConfig ? boost::any(slsConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (startupProbe) {
      res["startupProbe"] = startupProbe ? boost::any(startupProbe->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timeout) {
      res["timeout"] = boost::any(*timeout);
    }
    if (tracingConfig) {
      res["tracingConfig"] = tracingConfig ? boost::any(tracingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vpcConfig) {
      res["vpcConfig"] = vpcConfig ? boost::any(vpcConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("args") != m.end() && !m["args"].empty()) {
      args = make_shared<string>(boost::any_cast<string>(m["args"]));
    }
    if (m.find("caPort") != m.end() && !m["caPort"].empty()) {
      caPort = make_shared<long>(boost::any_cast<long>(m["caPort"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      if (typeid(map<string, boost::any>) == m["code"].type()) {
        InputCodeLocation model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["code"]));
        code = make_shared<InputCodeLocation>(model1);
      }
    }
    if (m.find("command") != m.end() && !m["command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["command"]));
    }
    if (m.find("cpu") != m.end() && !m["cpu"].empty()) {
      cpu = make_shared<double>(boost::any_cast<double>(m["cpu"]));
    }
    if (m.find("customDNS") != m.end() && !m["customDNS"].empty()) {
      if (typeid(map<string, boost::any>) == m["customDNS"].type()) {
        CustomDNS model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["customDNS"]));
        customDNS = make_shared<CustomDNS>(model1);
      }
    }
    if (m.find("customHealthCheckConfig") != m.end() && !m["customHealthCheckConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["customHealthCheckConfig"].type()) {
        CustomHealthCheckConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["customHealthCheckConfig"]));
        customHealthCheckConfig = make_shared<CustomHealthCheckConfig>(model1);
      }
    }
    if (m.find("customHostAlias") != m.end() && !m["customHostAlias"].empty()) {
      if (typeid(map<string, boost::any>) == m["customHostAlias"].type()) {
        CustomHostAlias model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["customHostAlias"]));
        customHostAlias = make_shared<CustomHostAlias>(model1);
      }
    }
    if (m.find("customRuntimeConfig") != m.end() && !m["customRuntimeConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["customRuntimeConfig"].type()) {
        CustomRuntimeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["customRuntimeConfig"]));
        customRuntimeConfig = make_shared<CustomRuntimeConfig>(model1);
      }
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("diskSize") != m.end() && !m["diskSize"].empty()) {
      diskSize = make_shared<long>(boost::any_cast<long>(m["diskSize"]));
    }
    if (m.find("effectiveImmediately") != m.end() && !m["effectiveImmediately"].empty()) {
      effectiveImmediately = make_shared<bool>(boost::any_cast<bool>(m["effectiveImmediately"]));
    }
    if (m.find("enableAppMetric") != m.end() && !m["enableAppMetric"].empty()) {
      enableAppMetric = make_shared<bool>(boost::any_cast<bool>(m["enableAppMetric"]));
    }
    if (m.find("environmentVariables") != m.end() && !m["environmentVariables"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["environmentVariables"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      environmentVariables = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("gpuMemorySize") != m.end() && !m["gpuMemorySize"].empty()) {
      gpuMemorySize = make_shared<long>(boost::any_cast<long>(m["gpuMemorySize"]));
    }
    if (m.find("handler") != m.end() && !m["handler"].empty()) {
      handler = make_shared<string>(boost::any_cast<string>(m["handler"]));
    }
    if (m.find("httpTriggerConfig") != m.end() && !m["httpTriggerConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["httpTriggerConfig"].type()) {
        HTTPTriggerConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["httpTriggerConfig"]));
        httpTriggerConfig = make_shared<HTTPTriggerConfig>(model1);
      }
    }
    if (m.find("imageConfig") != m.end() && !m["imageConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["imageConfig"].type()) {
        ImageConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["imageConfig"]));
        imageConfig = make_shared<ImageConfig>(model1);
      }
    }
    if (m.find("initializationTimeout") != m.end() && !m["initializationTimeout"].empty()) {
      initializationTimeout = make_shared<long>(boost::any_cast<long>(m["initializationTimeout"]));
    }
    if (m.find("initializer") != m.end() && !m["initializer"].empty()) {
      initializer = make_shared<string>(boost::any_cast<string>(m["initializer"]));
    }
    if (m.find("instanceConcurrency") != m.end() && !m["instanceConcurrency"].empty()) {
      instanceConcurrency = make_shared<long>(boost::any_cast<long>(m["instanceConcurrency"]));
    }
    if (m.find("instanceLifecycleConfig") != m.end() && !m["instanceLifecycleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["instanceLifecycleConfig"].type()) {
        InstanceLifecycleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["instanceLifecycleConfig"]));
        instanceLifecycleConfig = make_shared<InstanceLifecycleConfig>(model1);
      }
    }
    if (m.find("instanceSoftConcurrency") != m.end() && !m["instanceSoftConcurrency"].empty()) {
      instanceSoftConcurrency = make_shared<long>(boost::any_cast<long>(m["instanceSoftConcurrency"]));
    }
    if (m.find("instanceType") != m.end() && !m["instanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["instanceType"]));
    }
    if (m.find("internetAccess") != m.end() && !m["internetAccess"].empty()) {
      internetAccess = make_shared<bool>(boost::any_cast<bool>(m["internetAccess"]));
    }
    if (m.find("layers") != m.end() && !m["layers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["layers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["layers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      layers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("livenessProbe") != m.end() && !m["livenessProbe"].empty()) {
      if (typeid(map<string, boost::any>) == m["livenessProbe"].type()) {
        Probe model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["livenessProbe"]));
        livenessProbe = make_shared<Probe>(model1);
      }
    }
    if (m.find("logConfig") != m.end() && !m["logConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["logConfig"].type()) {
        LogConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["logConfig"]));
        logConfig = make_shared<LogConfig>(model1);
      }
    }
    if (m.find("memorySize") != m.end() && !m["memorySize"].empty()) {
      memorySize = make_shared<long>(boost::any_cast<long>(m["memorySize"]));
    }
    if (m.find("namespaceID") != m.end() && !m["namespaceID"].empty()) {
      namespaceID = make_shared<string>(boost::any_cast<string>(m["namespaceID"]));
    }
    if (m.find("nasConfig") != m.end() && !m["nasConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["nasConfig"].type()) {
        NASConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["nasConfig"]));
        nasConfig = make_shared<NASConfig>(model1);
      }
    }
    if (m.find("ossMountConfig") != m.end() && !m["ossMountConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ossMountConfig"].type()) {
        OSSMountConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ossMountConfig"]));
        ossMountConfig = make_shared<OSSMountConfig>(model1);
      }
    }
    if (m.find("programmingLanguage") != m.end() && !m["programmingLanguage"].empty()) {
      programmingLanguage = make_shared<string>(boost::any_cast<string>(m["programmingLanguage"]));
    }
    if (m.find("runtime") != m.end() && !m["runtime"].empty()) {
      runtime = make_shared<string>(boost::any_cast<string>(m["runtime"]));
    }
    if (m.find("scaleConfig") != m.end() && !m["scaleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["scaleConfig"].type()) {
        ScaleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["scaleConfig"]));
        scaleConfig = make_shared<ScaleConfig>(model1);
      }
    }
    if (m.find("slsConfig") != m.end() && !m["slsConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["slsConfig"].type()) {
        SLSConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["slsConfig"]));
        slsConfig = make_shared<SLSConfig>(model1);
      }
    }
    if (m.find("startupProbe") != m.end() && !m["startupProbe"].empty()) {
      if (typeid(map<string, boost::any>) == m["startupProbe"].type()) {
        Probe model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["startupProbe"]));
        startupProbe = make_shared<Probe>(model1);
      }
    }
    if (m.find("timeout") != m.end() && !m["timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["timeout"]));
    }
    if (m.find("tracingConfig") != m.end() && !m["tracingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["tracingConfig"].type()) {
        TracingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["tracingConfig"]));
        tracingConfig = make_shared<TracingConfig>(model1);
      }
    }
    if (m.find("vpcConfig") != m.end() && !m["vpcConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["vpcConfig"].type()) {
        VPCConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["vpcConfig"]));
        vpcConfig = make_shared<VPCConfig>(model1);
      }
    }
  }


  virtual ~UpdateApplicationInput() = default;
};
class UpdateApplicationScaleConfigInput : public Darabonba::Model {
public:
  shared_ptr<bool> alwaysAllocateCPU{};
  shared_ptr<long> maximumInstanceCount{};
  shared_ptr<long> minimumInstanceCount{};

  UpdateApplicationScaleConfigInput() {}

  explicit UpdateApplicationScaleConfigInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alwaysAllocateCPU) {
      res["alwaysAllocateCPU"] = boost::any(*alwaysAllocateCPU);
    }
    if (maximumInstanceCount) {
      res["maximumInstanceCount"] = boost::any(*maximumInstanceCount);
    }
    if (minimumInstanceCount) {
      res["minimumInstanceCount"] = boost::any(*minimumInstanceCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("alwaysAllocateCPU") != m.end() && !m["alwaysAllocateCPU"].empty()) {
      alwaysAllocateCPU = make_shared<bool>(boost::any_cast<bool>(m["alwaysAllocateCPU"]));
    }
    if (m.find("maximumInstanceCount") != m.end() && !m["maximumInstanceCount"].empty()) {
      maximumInstanceCount = make_shared<long>(boost::any_cast<long>(m["maximumInstanceCount"]));
    }
    if (m.find("minimumInstanceCount") != m.end() && !m["minimumInstanceCount"].empty()) {
      minimumInstanceCount = make_shared<long>(boost::any_cast<long>(m["minimumInstanceCount"]));
    }
  }


  virtual ~UpdateApplicationScaleConfigInput() = default;
};
class UpdateApplicationTrafficConfigInput : public Darabonba::Model {
public:
  shared_ptr<map<string, double>> additionalVersionWeight{};
  shared_ptr<string> resolvePolicy{};
  shared_ptr<RoutePolicy> routePolicy{};
  shared_ptr<string> versionId{};

  UpdateApplicationTrafficConfigInput() {}

  explicit UpdateApplicationTrafficConfigInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (additionalVersionWeight) {
      res["additionalVersionWeight"] = boost::any(*additionalVersionWeight);
    }
    if (resolvePolicy) {
      res["resolvePolicy"] = boost::any(*resolvePolicy);
    }
    if (routePolicy) {
      res["routePolicy"] = routePolicy ? boost::any(routePolicy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (versionId) {
      res["versionId"] = boost::any(*versionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("additionalVersionWeight") != m.end() && !m["additionalVersionWeight"].empty()) {
      map<string, double> map1 = boost::any_cast<map<string, double>>(m["additionalVersionWeight"]);
      map<string, double> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      additionalVersionWeight = make_shared<map<string, double>>(toMap1);
    }
    if (m.find("resolvePolicy") != m.end() && !m["resolvePolicy"].empty()) {
      resolvePolicy = make_shared<string>(boost::any_cast<string>(m["resolvePolicy"]));
    }
    if (m.find("routePolicy") != m.end() && !m["routePolicy"].empty()) {
      if (typeid(map<string, boost::any>) == m["routePolicy"].type()) {
        RoutePolicy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["routePolicy"]));
        routePolicy = make_shared<RoutePolicy>(model1);
      }
    }
    if (m.find("versionId") != m.end() && !m["versionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["versionId"]));
    }
  }


  virtual ~UpdateApplicationTrafficConfigInput() = default;
};
class UpdateAttributesInput : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<HTTPTriggerConfig> httpTriggerConfig{};
  shared_ptr<string> versionID{};

  UpdateAttributesInput() {}

  explicit UpdateAttributesInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (httpTriggerConfig) {
      res["httpTriggerConfig"] = httpTriggerConfig ? boost::any(httpTriggerConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (versionID) {
      res["versionID"] = boost::any(*versionID);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("httpTriggerConfig") != m.end() && !m["httpTriggerConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["httpTriggerConfig"].type()) {
        HTTPTriggerConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["httpTriggerConfig"]));
        httpTriggerConfig = make_shared<HTTPTriggerConfig>(model1);
      }
    }
    if (m.find("versionID") != m.end() && !m["versionID"].empty()) {
      versionID = make_shared<string>(boost::any_cast<string>(m["versionID"]));
    }
  }


  virtual ~UpdateAttributesInput() = default;
};
class UpdateCustomDomainInput : public Darabonba::Model {
public:
  shared_ptr<string> applicationID{};
  shared_ptr<string> applicationName{};
  shared_ptr<CertConfig> certConfig{};
  shared_ptr<bool> keepFullPath{};
  shared_ptr<string> namespaceID{};
  shared_ptr<string> protocol{};
  shared_ptr<TLSConfig> tlsConfig{};
  shared_ptr<WAFConfig> wafConfig{};

  UpdateCustomDomainInput() {}

  explicit UpdateCustomDomainInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationID) {
      res["applicationID"] = boost::any(*applicationID);
    }
    if (applicationName) {
      res["applicationName"] = boost::any(*applicationName);
    }
    if (certConfig) {
      res["certConfig"] = certConfig ? boost::any(certConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (keepFullPath) {
      res["keepFullPath"] = boost::any(*keepFullPath);
    }
    if (namespaceID) {
      res["namespaceID"] = boost::any(*namespaceID);
    }
    if (protocol) {
      res["protocol"] = boost::any(*protocol);
    }
    if (tlsConfig) {
      res["tlsConfig"] = tlsConfig ? boost::any(tlsConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (wafConfig) {
      res["wafConfig"] = wafConfig ? boost::any(wafConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("applicationID") != m.end() && !m["applicationID"].empty()) {
      applicationID = make_shared<string>(boost::any_cast<string>(m["applicationID"]));
    }
    if (m.find("applicationName") != m.end() && !m["applicationName"].empty()) {
      applicationName = make_shared<string>(boost::any_cast<string>(m["applicationName"]));
    }
    if (m.find("certConfig") != m.end() && !m["certConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["certConfig"].type()) {
        CertConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["certConfig"]));
        certConfig = make_shared<CertConfig>(model1);
      }
    }
    if (m.find("keepFullPath") != m.end() && !m["keepFullPath"].empty()) {
      keepFullPath = make_shared<bool>(boost::any_cast<bool>(m["keepFullPath"]));
    }
    if (m.find("namespaceID") != m.end() && !m["namespaceID"].empty()) {
      namespaceID = make_shared<string>(boost::any_cast<string>(m["namespaceID"]));
    }
    if (m.find("protocol") != m.end() && !m["protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["protocol"]));
    }
    if (m.find("tlsConfig") != m.end() && !m["tlsConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["tlsConfig"].type()) {
        TLSConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["tlsConfig"]));
        tlsConfig = make_shared<TLSConfig>(model1);
      }
    }
    if (m.find("wafConfig") != m.end() && !m["wafConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["wafConfig"].type()) {
        WAFConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["wafConfig"]));
        wafConfig = make_shared<WAFConfig>(model1);
      }
    }
  }


  virtual ~UpdateCustomDomainInput() = default;
};
class UpdateWebApplicationInput : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<WebNetworkConfig> webNetworkConfig{};

  UpdateWebApplicationInput() {}

  explicit UpdateWebApplicationInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (webNetworkConfig) {
      res["WebNetworkConfig"] = webNetworkConfig ? boost::any(webNetworkConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("WebNetworkConfig") != m.end() && !m["WebNetworkConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["WebNetworkConfig"].type()) {
        WebNetworkConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WebNetworkConfig"]));
        webNetworkConfig = make_shared<WebNetworkConfig>(model1);
      }
    }
  }


  virtual ~UpdateWebApplicationInput() = default;
};
class UpdateWebApplicationScalingConfigInput : public Darabonba::Model {
public:
  shared_ptr<long> maximumInstanceCount{};
  shared_ptr<long> minimumInstanceCount{};

  UpdateWebApplicationScalingConfigInput() {}

  explicit UpdateWebApplicationScalingConfigInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maximumInstanceCount) {
      res["MaximumInstanceCount"] = boost::any(*maximumInstanceCount);
    }
    if (minimumInstanceCount) {
      res["MinimumInstanceCount"] = boost::any(*minimumInstanceCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaximumInstanceCount") != m.end() && !m["MaximumInstanceCount"].empty()) {
      maximumInstanceCount = make_shared<long>(boost::any_cast<long>(m["MaximumInstanceCount"]));
    }
    if (m.find("MinimumInstanceCount") != m.end() && !m["MinimumInstanceCount"].empty()) {
      minimumInstanceCount = make_shared<long>(boost::any_cast<long>(m["MinimumInstanceCount"]));
    }
  }


  virtual ~UpdateWebApplicationScalingConfigInput() = default;
};
class UpdateWebApplicationTrafficConfigInput : public Darabonba::Model {
public:
  shared_ptr<string> authType{};
  shared_ptr<bool> disableURLInternet{};
  shared_ptr<map<string, double>> revisionsTrafficWeight{};
  shared_ptr<WebAclConfig> webAclConfig{};

  UpdateWebApplicationTrafficConfigInput() {}

  explicit UpdateWebApplicationTrafficConfigInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authType) {
      res["AuthType"] = boost::any(*authType);
    }
    if (disableURLInternet) {
      res["DisableURLInternet"] = boost::any(*disableURLInternet);
    }
    if (revisionsTrafficWeight) {
      res["RevisionsTrafficWeight"] = boost::any(*revisionsTrafficWeight);
    }
    if (webAclConfig) {
      res["WebAclConfig"] = webAclConfig ? boost::any(webAclConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthType") != m.end() && !m["AuthType"].empty()) {
      authType = make_shared<string>(boost::any_cast<string>(m["AuthType"]));
    }
    if (m.find("DisableURLInternet") != m.end() && !m["DisableURLInternet"].empty()) {
      disableURLInternet = make_shared<bool>(boost::any_cast<bool>(m["DisableURLInternet"]));
    }
    if (m.find("RevisionsTrafficWeight") != m.end() && !m["RevisionsTrafficWeight"].empty()) {
      map<string, double> map1 = boost::any_cast<map<string, double>>(m["RevisionsTrafficWeight"]);
      map<string, double> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      revisionsTrafficWeight = make_shared<map<string, double>>(toMap1);
    }
    if (m.find("WebAclConfig") != m.end() && !m["WebAclConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["WebAclConfig"].type()) {
        WebAclConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WebAclConfig"]));
        webAclConfig = make_shared<WebAclConfig>(model1);
      }
    }
  }


  virtual ~UpdateWebApplicationTrafficConfigInput() = default;
};
class UpdateWebCustomDomainInput : public Darabonba::Model {
public:
  shared_ptr<string> defaultForwardingAppName{};
  shared_ptr<string> protocol{};
  shared_ptr<RouteConfig> routeConfig{};
  shared_ptr<WebCertConfig> webCertConfig{};
  shared_ptr<WebTLSConfig> webTLSConfig{};
  shared_ptr<WebWAFConfig> webWAFConfig{};

  UpdateWebCustomDomainInput() {}

  explicit UpdateWebCustomDomainInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defaultForwardingAppName) {
      res["DefaultForwardingAppName"] = boost::any(*defaultForwardingAppName);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (routeConfig) {
      res["RouteConfig"] = routeConfig ? boost::any(routeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (webCertConfig) {
      res["WebCertConfig"] = webCertConfig ? boost::any(webCertConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (webTLSConfig) {
      res["WebTLSConfig"] = webTLSConfig ? boost::any(webTLSConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (webWAFConfig) {
      res["WebWAFConfig"] = webWAFConfig ? boost::any(webWAFConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefaultForwardingAppName") != m.end() && !m["DefaultForwardingAppName"].empty()) {
      defaultForwardingAppName = make_shared<string>(boost::any_cast<string>(m["DefaultForwardingAppName"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("RouteConfig") != m.end() && !m["RouteConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["RouteConfig"].type()) {
        RouteConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RouteConfig"]));
        routeConfig = make_shared<RouteConfig>(model1);
      }
    }
    if (m.find("WebCertConfig") != m.end() && !m["WebCertConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["WebCertConfig"].type()) {
        WebCertConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WebCertConfig"]));
        webCertConfig = make_shared<WebCertConfig>(model1);
      }
    }
    if (m.find("WebTLSConfig") != m.end() && !m["WebTLSConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["WebTLSConfig"].type()) {
        WebTLSConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WebTLSConfig"]));
        webTLSConfig = make_shared<WebTLSConfig>(model1);
      }
    }
    if (m.find("WebWAFConfig") != m.end() && !m["WebWAFConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["WebWAFConfig"].type()) {
        WebWAFConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WebWAFConfig"]));
        webWAFConfig = make_shared<WebWAFConfig>(model1);
      }
    }
  }


  virtual ~UpdateWebCustomDomainInput() = default;
};
class WebApplicationBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<WebApplication> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  WebApplicationBody() {}

  explicit WebApplicationBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        WebApplication model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<WebApplication>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~WebApplicationBody() = default;
};
class WebApplicationInstanceLogsBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<DescribeInstanceLogsOutput> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  WebApplicationInstanceLogsBody() {}

  explicit WebApplicationInstanceLogsBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeInstanceLogsOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeInstanceLogsOutput>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~WebApplicationInstanceLogsBody() = default;
};
class WebApplicationResourceStaticsBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<DescribeWebAppStaticsOutput> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  WebApplicationResourceStaticsBody() {}

  explicit WebApplicationResourceStaticsBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeWebAppStaticsOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeWebAppStaticsOutput>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~WebApplicationResourceStaticsBody() = default;
};
class WebApplicationRevisionBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<Revision> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  WebApplicationRevisionBody() {}

  explicit WebApplicationRevisionBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        Revision model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<Revision>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~WebApplicationRevisionBody() = default;
};
class WebApplicationScalingConfigBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<WebScalingConfig> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  WebApplicationScalingConfigBody() {}

  explicit WebApplicationScalingConfigBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        WebScalingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<WebScalingConfig>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~WebApplicationScalingConfigBody() = default;
};
class WebApplicationStatus : public Darabonba::Model {
public:
  shared_ptr<long> instanceCount{};
  shared_ptr<WebScalingConfig> webScalingConfig{};

  WebApplicationStatus() {}

  explicit WebApplicationStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceCount) {
      res["InstanceCount"] = boost::any(*instanceCount);
    }
    if (webScalingConfig) {
      res["WebScalingConfig"] = webScalingConfig ? boost::any(webScalingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceCount") != m.end() && !m["InstanceCount"].empty()) {
      instanceCount = make_shared<long>(boost::any_cast<long>(m["InstanceCount"]));
    }
    if (m.find("WebScalingConfig") != m.end() && !m["WebScalingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["WebScalingConfig"].type()) {
        WebScalingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WebScalingConfig"]));
        webScalingConfig = make_shared<WebScalingConfig>(model1);
      }
    }
  }


  virtual ~WebApplicationStatus() = default;
};
class WebApplicationTrafficConfigBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<WebTrafficConfig> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  WebApplicationTrafficConfigBody() {}

  explicit WebApplicationTrafficConfigBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        WebTrafficConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<WebTrafficConfig>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~WebApplicationTrafficConfigBody() = default;
};
class WebApplicationWithStatus : public Darabonba::Model {
public:
  shared_ptr<WebApplicationStatus> status{};
  shared_ptr<WebApplication> webApplication{};

  WebApplicationWithStatus() {}

  explicit WebApplicationWithStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = status ? boost::any(status->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (webApplication) {
      res["WebApplication"] = webApplication ? boost::any(webApplication->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      if (typeid(map<string, boost::any>) == m["Status"].type()) {
        WebApplicationStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Status"]));
        status = make_shared<WebApplicationStatus>(model1);
      }
    }
    if (m.find("WebApplication") != m.end() && !m["WebApplication"].empty()) {
      if (typeid(map<string, boost::any>) == m["WebApplication"].type()) {
        WebApplication model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WebApplication"]));
        webApplication = make_shared<WebApplication>(model1);
      }
    }
  }


  virtual ~WebApplicationWithStatus() = default;
};
class WebCustomDomainBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<WebCustomDomain> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  WebCustomDomainBody() {}

  explicit WebCustomDomainBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        WebCustomDomain model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<WebCustomDomain>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~WebCustomDomainBody() = default;
};
class AbortAndRollbackChangeOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};

  AbortAndRollbackChangeOrderRequest() {}

  explicit AbortAndRollbackChangeOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
  }


  virtual ~AbortAndRollbackChangeOrderRequest() = default;
};
class AbortAndRollbackChangeOrderResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};

  AbortAndRollbackChangeOrderResponseBodyData() {}

  explicit AbortAndRollbackChangeOrderResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
  }


  virtual ~AbortAndRollbackChangeOrderResponseBodyData() = default;
};
class AbortAndRollbackChangeOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<AbortAndRollbackChangeOrderResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  AbortAndRollbackChangeOrderResponseBody() {}

  explicit AbortAndRollbackChangeOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        AbortAndRollbackChangeOrderResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<AbortAndRollbackChangeOrderResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~AbortAndRollbackChangeOrderResponseBody() = default;
};
class AbortAndRollbackChangeOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AbortAndRollbackChangeOrderResponseBody> body{};

  AbortAndRollbackChangeOrderResponse() {}

  explicit AbortAndRollbackChangeOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AbortAndRollbackChangeOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AbortAndRollbackChangeOrderResponseBody>(model1);
      }
    }
  }


  virtual ~AbortAndRollbackChangeOrderResponse() = default;
};
class AbortChangeOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};
  shared_ptr<bool> rollback{};

  AbortChangeOrderRequest() {}

  explicit AbortChangeOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (rollback) {
      res["Rollback"] = boost::any(*rollback);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("Rollback") != m.end() && !m["Rollback"].empty()) {
      rollback = make_shared<bool>(boost::any_cast<bool>(m["Rollback"]));
    }
  }


  virtual ~AbortChangeOrderRequest() = default;
};
class AbortChangeOrderResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};

  AbortChangeOrderResponseBodyData() {}

  explicit AbortChangeOrderResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
  }


  virtual ~AbortChangeOrderResponseBodyData() = default;
};
class AbortChangeOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<AbortChangeOrderResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  AbortChangeOrderResponseBody() {}

  explicit AbortChangeOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        AbortChangeOrderResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<AbortChangeOrderResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~AbortChangeOrderResponseBody() = default;
};
class AbortChangeOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AbortChangeOrderResponseBody> body{};

  AbortChangeOrderResponse() {}

  explicit AbortChangeOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AbortChangeOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AbortChangeOrderResponseBody>(model1);
      }
    }
  }


  virtual ~AbortChangeOrderResponse() = default;
};
class BatchStartApplicationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> appIds{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> version{};

  BatchStartApplicationsRequest() {}

  explicit BatchStartApplicationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appIds) {
      res["AppIds"] = boost::any(*appIds);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppIds") != m.end() && !m["AppIds"].empty()) {
      appIds = make_shared<string>(boost::any_cast<string>(m["AppIds"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~BatchStartApplicationsRequest() = default;
};
class BatchStartApplicationsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};

  BatchStartApplicationsResponseBodyData() {}

  explicit BatchStartApplicationsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
  }


  virtual ~BatchStartApplicationsResponseBodyData() = default;
};
class BatchStartApplicationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<BatchStartApplicationsResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  BatchStartApplicationsResponseBody() {}

  explicit BatchStartApplicationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        BatchStartApplicationsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<BatchStartApplicationsResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~BatchStartApplicationsResponseBody() = default;
};
class BatchStartApplicationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchStartApplicationsResponseBody> body{};

  BatchStartApplicationsResponse() {}

  explicit BatchStartApplicationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchStartApplicationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchStartApplicationsResponseBody>(model1);
      }
    }
  }


  virtual ~BatchStartApplicationsResponse() = default;
};
class BatchStopApplicationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> appIds{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> version{};

  BatchStopApplicationsRequest() {}

  explicit BatchStopApplicationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appIds) {
      res["AppIds"] = boost::any(*appIds);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppIds") != m.end() && !m["AppIds"].empty()) {
      appIds = make_shared<string>(boost::any_cast<string>(m["AppIds"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~BatchStopApplicationsRequest() = default;
};
class BatchStopApplicationsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};

  BatchStopApplicationsResponseBodyData() {}

  explicit BatchStopApplicationsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
  }


  virtual ~BatchStopApplicationsResponseBodyData() = default;
};
class BatchStopApplicationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<BatchStopApplicationsResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  BatchStopApplicationsResponseBody() {}

  explicit BatchStopApplicationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        BatchStopApplicationsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<BatchStopApplicationsResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~BatchStopApplicationsResponseBody() = default;
};
class BatchStopApplicationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchStopApplicationsResponseBody> body{};

  BatchStopApplicationsResponse() {}

  explicit BatchStopApplicationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchStopApplicationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchStopApplicationsResponseBody>(model1);
      }
    }
  }


  virtual ~BatchStopApplicationsResponse() = default;
};
class BindSlbRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> internet{};
  shared_ptr<string> internetSlbChargeType{};
  shared_ptr<string> internetSlbId{};
  shared_ptr<string> intranet{};
  shared_ptr<string> intranetSlbChargeType{};
  shared_ptr<string> intranetSlbId{};

  BindSlbRequest() {}

  explicit BindSlbRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (internet) {
      res["Internet"] = boost::any(*internet);
    }
    if (internetSlbChargeType) {
      res["InternetSlbChargeType"] = boost::any(*internetSlbChargeType);
    }
    if (internetSlbId) {
      res["InternetSlbId"] = boost::any(*internetSlbId);
    }
    if (intranet) {
      res["Intranet"] = boost::any(*intranet);
    }
    if (intranetSlbChargeType) {
      res["IntranetSlbChargeType"] = boost::any(*intranetSlbChargeType);
    }
    if (intranetSlbId) {
      res["IntranetSlbId"] = boost::any(*intranetSlbId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Internet") != m.end() && !m["Internet"].empty()) {
      internet = make_shared<string>(boost::any_cast<string>(m["Internet"]));
    }
    if (m.find("InternetSlbChargeType") != m.end() && !m["InternetSlbChargeType"].empty()) {
      internetSlbChargeType = make_shared<string>(boost::any_cast<string>(m["InternetSlbChargeType"]));
    }
    if (m.find("InternetSlbId") != m.end() && !m["InternetSlbId"].empty()) {
      internetSlbId = make_shared<string>(boost::any_cast<string>(m["InternetSlbId"]));
    }
    if (m.find("Intranet") != m.end() && !m["Intranet"].empty()) {
      intranet = make_shared<string>(boost::any_cast<string>(m["Intranet"]));
    }
    if (m.find("IntranetSlbChargeType") != m.end() && !m["IntranetSlbChargeType"].empty()) {
      intranetSlbChargeType = make_shared<string>(boost::any_cast<string>(m["IntranetSlbChargeType"]));
    }
    if (m.find("IntranetSlbId") != m.end() && !m["IntranetSlbId"].empty()) {
      intranetSlbId = make_shared<string>(boost::any_cast<string>(m["IntranetSlbId"]));
    }
  }


  virtual ~BindSlbRequest() = default;
};
class BindSlbResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};

  BindSlbResponseBodyData() {}

  explicit BindSlbResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
  }


  virtual ~BindSlbResponseBodyData() = default;
};
class BindSlbResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<BindSlbResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  BindSlbResponseBody() {}

  explicit BindSlbResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        BindSlbResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<BindSlbResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~BindSlbResponseBody() = default;
};
class BindSlbResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BindSlbResponseBody> body{};

  BindSlbResponse() {}

  explicit BindSlbResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BindSlbResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BindSlbResponseBody>(model1);
      }
    }
  }


  virtual ~BindSlbResponse() = default;
};
class ConfirmPipelineBatchRequest : public Darabonba::Model {
public:
  shared_ptr<bool> confirm{};
  shared_ptr<string> pipelineId{};

  ConfirmPipelineBatchRequest() {}

  explicit ConfirmPipelineBatchRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (confirm) {
      res["Confirm"] = boost::any(*confirm);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Confirm") != m.end() && !m["Confirm"].empty()) {
      confirm = make_shared<bool>(boost::any_cast<bool>(m["Confirm"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
  }


  virtual ~ConfirmPipelineBatchRequest() = default;
};
class ConfirmPipelineBatchResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> pipelineId{};

  ConfirmPipelineBatchResponseBodyData() {}

  explicit ConfirmPipelineBatchResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
  }


  virtual ~ConfirmPipelineBatchResponseBodyData() = default;
};
class ConfirmPipelineBatchResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ConfirmPipelineBatchResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  ConfirmPipelineBatchResponseBody() {}

  explicit ConfirmPipelineBatchResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ConfirmPipelineBatchResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ConfirmPipelineBatchResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~ConfirmPipelineBatchResponseBody() = default;
};
class ConfirmPipelineBatchResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ConfirmPipelineBatchResponseBody> body{};

  ConfirmPipelineBatchResponse() {}

  explicit ConfirmPipelineBatchResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ConfirmPipelineBatchResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ConfirmPipelineBatchResponseBody>(model1);
      }
    }
  }


  virtual ~ConfirmPipelineBatchResponse() = default;
};
class CreateApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> acrAssumeRoleArn{};
  shared_ptr<string> acrInstanceId{};
  shared_ptr<string> appDescription{};
  shared_ptr<string> appName{};
  shared_ptr<string> appSource{};
  shared_ptr<bool> associateEip{};
  shared_ptr<bool> autoConfig{};
  shared_ptr<string> baseAppId{};
  shared_ptr<string> command{};
  shared_ptr<string> commandArgs{};
  shared_ptr<string> configMapMountDesc{};
  shared_ptr<long> cpu{};
  shared_ptr<string> customHostAlias{};
  shared_ptr<string> customImageNetworkType{};
  shared_ptr<bool> deploy{};
  shared_ptr<long> diskSize{};
  shared_ptr<string> dotnet{};
  shared_ptr<string> edasContainerVersion{};
  shared_ptr<bool> enableCpuBurst{};
  shared_ptr<string> enableEbpf{};
  shared_ptr<bool> enableNewArms{};
  shared_ptr<bool> enableSidecarResourceIsolated{};
  shared_ptr<string> envs{};
  shared_ptr<string> gpuConfig{};
  shared_ptr<string> imagePullSecrets{};
  shared_ptr<string> imageUrl{};
  shared_ptr<vector<InitContainerConfig>> initContainersConfig{};
  shared_ptr<string> jarStartArgs{};
  shared_ptr<string> jarStartOptions{};
  shared_ptr<string> jdk{};
  shared_ptr<string> kafkaConfigs{};
  shared_ptr<string> liveness{};
  shared_ptr<long> memory{};
  shared_ptr<string> microRegistration{};
  shared_ptr<string> microRegistrationConfig{};
  shared_ptr<string> microserviceEngineConfig{};
  shared_ptr<string> mountDesc{};
  shared_ptr<string> mountHost{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> nasConfigs{};
  shared_ptr<string> nasId{};
  shared_ptr<string> newSaeVersion{};
  shared_ptr<string> oidcRoleName{};
  shared_ptr<string> ossAkId{};
  shared_ptr<string> ossAkSecret{};
  shared_ptr<string> ossMountDescs{};
  shared_ptr<string> packageType{};
  shared_ptr<string> packageUrl{};
  shared_ptr<string> packageVersion{};
  shared_ptr<string> php{};
  shared_ptr<string> phpArmsConfigLocation{};
  shared_ptr<string> phpConfig{};
  shared_ptr<string> phpConfigLocation{};
  shared_ptr<string> postStart{};
  shared_ptr<string> preStop{};
  shared_ptr<string> programmingLanguage{};
  shared_ptr<string> pvtzDiscoverySvc{};
  shared_ptr<string> python{};
  shared_ptr<string> pythonModules{};
  shared_ptr<string> readiness{};
  shared_ptr<long> replicas{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> saeVersion{};
  shared_ptr<string> secretMountDesc{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> serviceTags{};
  shared_ptr<vector<SidecarContainerConfig>> sidecarContainersConfig{};
  shared_ptr<string> slsConfigs{};
  shared_ptr<string> startupProbe{};
  shared_ptr<long> terminationGracePeriodSeconds{};
  shared_ptr<string> timezone{};
  shared_ptr<string> tomcatConfig{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> warStartOptions{};
  shared_ptr<string> webContainer{};

  CreateApplicationRequest() {}

  explicit CreateApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acrAssumeRoleArn) {
      res["AcrAssumeRoleArn"] = boost::any(*acrAssumeRoleArn);
    }
    if (acrInstanceId) {
      res["AcrInstanceId"] = boost::any(*acrInstanceId);
    }
    if (appDescription) {
      res["AppDescription"] = boost::any(*appDescription);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (appSource) {
      res["AppSource"] = boost::any(*appSource);
    }
    if (associateEip) {
      res["AssociateEip"] = boost::any(*associateEip);
    }
    if (autoConfig) {
      res["AutoConfig"] = boost::any(*autoConfig);
    }
    if (baseAppId) {
      res["BaseAppId"] = boost::any(*baseAppId);
    }
    if (command) {
      res["Command"] = boost::any(*command);
    }
    if (commandArgs) {
      res["CommandArgs"] = boost::any(*commandArgs);
    }
    if (configMapMountDesc) {
      res["ConfigMapMountDesc"] = boost::any(*configMapMountDesc);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (customHostAlias) {
      res["CustomHostAlias"] = boost::any(*customHostAlias);
    }
    if (customImageNetworkType) {
      res["CustomImageNetworkType"] = boost::any(*customImageNetworkType);
    }
    if (deploy) {
      res["Deploy"] = boost::any(*deploy);
    }
    if (diskSize) {
      res["DiskSize"] = boost::any(*diskSize);
    }
    if (dotnet) {
      res["Dotnet"] = boost::any(*dotnet);
    }
    if (edasContainerVersion) {
      res["EdasContainerVersion"] = boost::any(*edasContainerVersion);
    }
    if (enableCpuBurst) {
      res["EnableCpuBurst"] = boost::any(*enableCpuBurst);
    }
    if (enableEbpf) {
      res["EnableEbpf"] = boost::any(*enableEbpf);
    }
    if (enableNewArms) {
      res["EnableNewArms"] = boost::any(*enableNewArms);
    }
    if (enableSidecarResourceIsolated) {
      res["EnableSidecarResourceIsolated"] = boost::any(*enableSidecarResourceIsolated);
    }
    if (envs) {
      res["Envs"] = boost::any(*envs);
    }
    if (gpuConfig) {
      res["GpuConfig"] = boost::any(*gpuConfig);
    }
    if (imagePullSecrets) {
      res["ImagePullSecrets"] = boost::any(*imagePullSecrets);
    }
    if (imageUrl) {
      res["ImageUrl"] = boost::any(*imageUrl);
    }
    if (initContainersConfig) {
      vector<boost::any> temp1;
      for(auto item1:*initContainersConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InitContainersConfig"] = boost::any(temp1);
    }
    if (jarStartArgs) {
      res["JarStartArgs"] = boost::any(*jarStartArgs);
    }
    if (jarStartOptions) {
      res["JarStartOptions"] = boost::any(*jarStartOptions);
    }
    if (jdk) {
      res["Jdk"] = boost::any(*jdk);
    }
    if (kafkaConfigs) {
      res["KafkaConfigs"] = boost::any(*kafkaConfigs);
    }
    if (liveness) {
      res["Liveness"] = boost::any(*liveness);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (microRegistration) {
      res["MicroRegistration"] = boost::any(*microRegistration);
    }
    if (microRegistrationConfig) {
      res["MicroRegistrationConfig"] = boost::any(*microRegistrationConfig);
    }
    if (microserviceEngineConfig) {
      res["MicroserviceEngineConfig"] = boost::any(*microserviceEngineConfig);
    }
    if (mountDesc) {
      res["MountDesc"] = boost::any(*mountDesc);
    }
    if (mountHost) {
      res["MountHost"] = boost::any(*mountHost);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (nasConfigs) {
      res["NasConfigs"] = boost::any(*nasConfigs);
    }
    if (nasId) {
      res["NasId"] = boost::any(*nasId);
    }
    if (newSaeVersion) {
      res["NewSaeVersion"] = boost::any(*newSaeVersion);
    }
    if (oidcRoleName) {
      res["OidcRoleName"] = boost::any(*oidcRoleName);
    }
    if (ossAkId) {
      res["OssAkId"] = boost::any(*ossAkId);
    }
    if (ossAkSecret) {
      res["OssAkSecret"] = boost::any(*ossAkSecret);
    }
    if (ossMountDescs) {
      res["OssMountDescs"] = boost::any(*ossMountDescs);
    }
    if (packageType) {
      res["PackageType"] = boost::any(*packageType);
    }
    if (packageUrl) {
      res["PackageUrl"] = boost::any(*packageUrl);
    }
    if (packageVersion) {
      res["PackageVersion"] = boost::any(*packageVersion);
    }
    if (php) {
      res["Php"] = boost::any(*php);
    }
    if (phpArmsConfigLocation) {
      res["PhpArmsConfigLocation"] = boost::any(*phpArmsConfigLocation);
    }
    if (phpConfig) {
      res["PhpConfig"] = boost::any(*phpConfig);
    }
    if (phpConfigLocation) {
      res["PhpConfigLocation"] = boost::any(*phpConfigLocation);
    }
    if (postStart) {
      res["PostStart"] = boost::any(*postStart);
    }
    if (preStop) {
      res["PreStop"] = boost::any(*preStop);
    }
    if (programmingLanguage) {
      res["ProgrammingLanguage"] = boost::any(*programmingLanguage);
    }
    if (pvtzDiscoverySvc) {
      res["PvtzDiscoverySvc"] = boost::any(*pvtzDiscoverySvc);
    }
    if (python) {
      res["Python"] = boost::any(*python);
    }
    if (pythonModules) {
      res["PythonModules"] = boost::any(*pythonModules);
    }
    if (readiness) {
      res["Readiness"] = boost::any(*readiness);
    }
    if (replicas) {
      res["Replicas"] = boost::any(*replicas);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (saeVersion) {
      res["SaeVersion"] = boost::any(*saeVersion);
    }
    if (secretMountDesc) {
      res["SecretMountDesc"] = boost::any(*secretMountDesc);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (serviceTags) {
      res["ServiceTags"] = boost::any(*serviceTags);
    }
    if (sidecarContainersConfig) {
      vector<boost::any> temp1;
      for(auto item1:*sidecarContainersConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SidecarContainersConfig"] = boost::any(temp1);
    }
    if (slsConfigs) {
      res["SlsConfigs"] = boost::any(*slsConfigs);
    }
    if (startupProbe) {
      res["StartupProbe"] = boost::any(*startupProbe);
    }
    if (terminationGracePeriodSeconds) {
      res["TerminationGracePeriodSeconds"] = boost::any(*terminationGracePeriodSeconds);
    }
    if (timezone) {
      res["Timezone"] = boost::any(*timezone);
    }
    if (tomcatConfig) {
      res["TomcatConfig"] = boost::any(*tomcatConfig);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (warStartOptions) {
      res["WarStartOptions"] = boost::any(*warStartOptions);
    }
    if (webContainer) {
      res["WebContainer"] = boost::any(*webContainer);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcrAssumeRoleArn") != m.end() && !m["AcrAssumeRoleArn"].empty()) {
      acrAssumeRoleArn = make_shared<string>(boost::any_cast<string>(m["AcrAssumeRoleArn"]));
    }
    if (m.find("AcrInstanceId") != m.end() && !m["AcrInstanceId"].empty()) {
      acrInstanceId = make_shared<string>(boost::any_cast<string>(m["AcrInstanceId"]));
    }
    if (m.find("AppDescription") != m.end() && !m["AppDescription"].empty()) {
      appDescription = make_shared<string>(boost::any_cast<string>(m["AppDescription"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AppSource") != m.end() && !m["AppSource"].empty()) {
      appSource = make_shared<string>(boost::any_cast<string>(m["AppSource"]));
    }
    if (m.find("AssociateEip") != m.end() && !m["AssociateEip"].empty()) {
      associateEip = make_shared<bool>(boost::any_cast<bool>(m["AssociateEip"]));
    }
    if (m.find("AutoConfig") != m.end() && !m["AutoConfig"].empty()) {
      autoConfig = make_shared<bool>(boost::any_cast<bool>(m["AutoConfig"]));
    }
    if (m.find("BaseAppId") != m.end() && !m["BaseAppId"].empty()) {
      baseAppId = make_shared<string>(boost::any_cast<string>(m["BaseAppId"]));
    }
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
    if (m.find("CommandArgs") != m.end() && !m["CommandArgs"].empty()) {
      commandArgs = make_shared<string>(boost::any_cast<string>(m["CommandArgs"]));
    }
    if (m.find("ConfigMapMountDesc") != m.end() && !m["ConfigMapMountDesc"].empty()) {
      configMapMountDesc = make_shared<string>(boost::any_cast<string>(m["ConfigMapMountDesc"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("CustomHostAlias") != m.end() && !m["CustomHostAlias"].empty()) {
      customHostAlias = make_shared<string>(boost::any_cast<string>(m["CustomHostAlias"]));
    }
    if (m.find("CustomImageNetworkType") != m.end() && !m["CustomImageNetworkType"].empty()) {
      customImageNetworkType = make_shared<string>(boost::any_cast<string>(m["CustomImageNetworkType"]));
    }
    if (m.find("Deploy") != m.end() && !m["Deploy"].empty()) {
      deploy = make_shared<bool>(boost::any_cast<bool>(m["Deploy"]));
    }
    if (m.find("DiskSize") != m.end() && !m["DiskSize"].empty()) {
      diskSize = make_shared<long>(boost::any_cast<long>(m["DiskSize"]));
    }
    if (m.find("Dotnet") != m.end() && !m["Dotnet"].empty()) {
      dotnet = make_shared<string>(boost::any_cast<string>(m["Dotnet"]));
    }
    if (m.find("EdasContainerVersion") != m.end() && !m["EdasContainerVersion"].empty()) {
      edasContainerVersion = make_shared<string>(boost::any_cast<string>(m["EdasContainerVersion"]));
    }
    if (m.find("EnableCpuBurst") != m.end() && !m["EnableCpuBurst"].empty()) {
      enableCpuBurst = make_shared<bool>(boost::any_cast<bool>(m["EnableCpuBurst"]));
    }
    if (m.find("EnableEbpf") != m.end() && !m["EnableEbpf"].empty()) {
      enableEbpf = make_shared<string>(boost::any_cast<string>(m["EnableEbpf"]));
    }
    if (m.find("EnableNewArms") != m.end() && !m["EnableNewArms"].empty()) {
      enableNewArms = make_shared<bool>(boost::any_cast<bool>(m["EnableNewArms"]));
    }
    if (m.find("EnableSidecarResourceIsolated") != m.end() && !m["EnableSidecarResourceIsolated"].empty()) {
      enableSidecarResourceIsolated = make_shared<bool>(boost::any_cast<bool>(m["EnableSidecarResourceIsolated"]));
    }
    if (m.find("Envs") != m.end() && !m["Envs"].empty()) {
      envs = make_shared<string>(boost::any_cast<string>(m["Envs"]));
    }
    if (m.find("GpuConfig") != m.end() && !m["GpuConfig"].empty()) {
      gpuConfig = make_shared<string>(boost::any_cast<string>(m["GpuConfig"]));
    }
    if (m.find("ImagePullSecrets") != m.end() && !m["ImagePullSecrets"].empty()) {
      imagePullSecrets = make_shared<string>(boost::any_cast<string>(m["ImagePullSecrets"]));
    }
    if (m.find("ImageUrl") != m.end() && !m["ImageUrl"].empty()) {
      imageUrl = make_shared<string>(boost::any_cast<string>(m["ImageUrl"]));
    }
    if (m.find("InitContainersConfig") != m.end() && !m["InitContainersConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["InitContainersConfig"].type()) {
        vector<InitContainerConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InitContainersConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InitContainerConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        initContainersConfig = make_shared<vector<InitContainerConfig>>(expect1);
      }
    }
    if (m.find("JarStartArgs") != m.end() && !m["JarStartArgs"].empty()) {
      jarStartArgs = make_shared<string>(boost::any_cast<string>(m["JarStartArgs"]));
    }
    if (m.find("JarStartOptions") != m.end() && !m["JarStartOptions"].empty()) {
      jarStartOptions = make_shared<string>(boost::any_cast<string>(m["JarStartOptions"]));
    }
    if (m.find("Jdk") != m.end() && !m["Jdk"].empty()) {
      jdk = make_shared<string>(boost::any_cast<string>(m["Jdk"]));
    }
    if (m.find("KafkaConfigs") != m.end() && !m["KafkaConfigs"].empty()) {
      kafkaConfigs = make_shared<string>(boost::any_cast<string>(m["KafkaConfigs"]));
    }
    if (m.find("Liveness") != m.end() && !m["Liveness"].empty()) {
      liveness = make_shared<string>(boost::any_cast<string>(m["Liveness"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
    if (m.find("MicroRegistration") != m.end() && !m["MicroRegistration"].empty()) {
      microRegistration = make_shared<string>(boost::any_cast<string>(m["MicroRegistration"]));
    }
    if (m.find("MicroRegistrationConfig") != m.end() && !m["MicroRegistrationConfig"].empty()) {
      microRegistrationConfig = make_shared<string>(boost::any_cast<string>(m["MicroRegistrationConfig"]));
    }
    if (m.find("MicroserviceEngineConfig") != m.end() && !m["MicroserviceEngineConfig"].empty()) {
      microserviceEngineConfig = make_shared<string>(boost::any_cast<string>(m["MicroserviceEngineConfig"]));
    }
    if (m.find("MountDesc") != m.end() && !m["MountDesc"].empty()) {
      mountDesc = make_shared<string>(boost::any_cast<string>(m["MountDesc"]));
    }
    if (m.find("MountHost") != m.end() && !m["MountHost"].empty()) {
      mountHost = make_shared<string>(boost::any_cast<string>(m["MountHost"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("NasConfigs") != m.end() && !m["NasConfigs"].empty()) {
      nasConfigs = make_shared<string>(boost::any_cast<string>(m["NasConfigs"]));
    }
    if (m.find("NasId") != m.end() && !m["NasId"].empty()) {
      nasId = make_shared<string>(boost::any_cast<string>(m["NasId"]));
    }
    if (m.find("NewSaeVersion") != m.end() && !m["NewSaeVersion"].empty()) {
      newSaeVersion = make_shared<string>(boost::any_cast<string>(m["NewSaeVersion"]));
    }
    if (m.find("OidcRoleName") != m.end() && !m["OidcRoleName"].empty()) {
      oidcRoleName = make_shared<string>(boost::any_cast<string>(m["OidcRoleName"]));
    }
    if (m.find("OssAkId") != m.end() && !m["OssAkId"].empty()) {
      ossAkId = make_shared<string>(boost::any_cast<string>(m["OssAkId"]));
    }
    if (m.find("OssAkSecret") != m.end() && !m["OssAkSecret"].empty()) {
      ossAkSecret = make_shared<string>(boost::any_cast<string>(m["OssAkSecret"]));
    }
    if (m.find("OssMountDescs") != m.end() && !m["OssMountDescs"].empty()) {
      ossMountDescs = make_shared<string>(boost::any_cast<string>(m["OssMountDescs"]));
    }
    if (m.find("PackageType") != m.end() && !m["PackageType"].empty()) {
      packageType = make_shared<string>(boost::any_cast<string>(m["PackageType"]));
    }
    if (m.find("PackageUrl") != m.end() && !m["PackageUrl"].empty()) {
      packageUrl = make_shared<string>(boost::any_cast<string>(m["PackageUrl"]));
    }
    if (m.find("PackageVersion") != m.end() && !m["PackageVersion"].empty()) {
      packageVersion = make_shared<string>(boost::any_cast<string>(m["PackageVersion"]));
    }
    if (m.find("Php") != m.end() && !m["Php"].empty()) {
      php = make_shared<string>(boost::any_cast<string>(m["Php"]));
    }
    if (m.find("PhpArmsConfigLocation") != m.end() && !m["PhpArmsConfigLocation"].empty()) {
      phpArmsConfigLocation = make_shared<string>(boost::any_cast<string>(m["PhpArmsConfigLocation"]));
    }
    if (m.find("PhpConfig") != m.end() && !m["PhpConfig"].empty()) {
      phpConfig = make_shared<string>(boost::any_cast<string>(m["PhpConfig"]));
    }
    if (m.find("PhpConfigLocation") != m.end() && !m["PhpConfigLocation"].empty()) {
      phpConfigLocation = make_shared<string>(boost::any_cast<string>(m["PhpConfigLocation"]));
    }
    if (m.find("PostStart") != m.end() && !m["PostStart"].empty()) {
      postStart = make_shared<string>(boost::any_cast<string>(m["PostStart"]));
    }
    if (m.find("PreStop") != m.end() && !m["PreStop"].empty()) {
      preStop = make_shared<string>(boost::any_cast<string>(m["PreStop"]));
    }
    if (m.find("ProgrammingLanguage") != m.end() && !m["ProgrammingLanguage"].empty()) {
      programmingLanguage = make_shared<string>(boost::any_cast<string>(m["ProgrammingLanguage"]));
    }
    if (m.find("PvtzDiscoverySvc") != m.end() && !m["PvtzDiscoverySvc"].empty()) {
      pvtzDiscoverySvc = make_shared<string>(boost::any_cast<string>(m["PvtzDiscoverySvc"]));
    }
    if (m.find("Python") != m.end() && !m["Python"].empty()) {
      python = make_shared<string>(boost::any_cast<string>(m["Python"]));
    }
    if (m.find("PythonModules") != m.end() && !m["PythonModules"].empty()) {
      pythonModules = make_shared<string>(boost::any_cast<string>(m["PythonModules"]));
    }
    if (m.find("Readiness") != m.end() && !m["Readiness"].empty()) {
      readiness = make_shared<string>(boost::any_cast<string>(m["Readiness"]));
    }
    if (m.find("Replicas") != m.end() && !m["Replicas"].empty()) {
      replicas = make_shared<long>(boost::any_cast<long>(m["Replicas"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("SaeVersion") != m.end() && !m["SaeVersion"].empty()) {
      saeVersion = make_shared<string>(boost::any_cast<string>(m["SaeVersion"]));
    }
    if (m.find("SecretMountDesc") != m.end() && !m["SecretMountDesc"].empty()) {
      secretMountDesc = make_shared<string>(boost::any_cast<string>(m["SecretMountDesc"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("ServiceTags") != m.end() && !m["ServiceTags"].empty()) {
      serviceTags = make_shared<string>(boost::any_cast<string>(m["ServiceTags"]));
    }
    if (m.find("SidecarContainersConfig") != m.end() && !m["SidecarContainersConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["SidecarContainersConfig"].type()) {
        vector<SidecarContainerConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SidecarContainersConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SidecarContainerConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sidecarContainersConfig = make_shared<vector<SidecarContainerConfig>>(expect1);
      }
    }
    if (m.find("SlsConfigs") != m.end() && !m["SlsConfigs"].empty()) {
      slsConfigs = make_shared<string>(boost::any_cast<string>(m["SlsConfigs"]));
    }
    if (m.find("StartupProbe") != m.end() && !m["StartupProbe"].empty()) {
      startupProbe = make_shared<string>(boost::any_cast<string>(m["StartupProbe"]));
    }
    if (m.find("TerminationGracePeriodSeconds") != m.end() && !m["TerminationGracePeriodSeconds"].empty()) {
      terminationGracePeriodSeconds = make_shared<long>(boost::any_cast<long>(m["TerminationGracePeriodSeconds"]));
    }
    if (m.find("Timezone") != m.end() && !m["Timezone"].empty()) {
      timezone = make_shared<string>(boost::any_cast<string>(m["Timezone"]));
    }
    if (m.find("TomcatConfig") != m.end() && !m["TomcatConfig"].empty()) {
      tomcatConfig = make_shared<string>(boost::any_cast<string>(m["TomcatConfig"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("WarStartOptions") != m.end() && !m["WarStartOptions"].empty()) {
      warStartOptions = make_shared<string>(boost::any_cast<string>(m["WarStartOptions"]));
    }
    if (m.find("WebContainer") != m.end() && !m["WebContainer"].empty()) {
      webContainer = make_shared<string>(boost::any_cast<string>(m["WebContainer"]));
    }
  }


  virtual ~CreateApplicationRequest() = default;
};
class CreateApplicationShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> acrAssumeRoleArn{};
  shared_ptr<string> acrInstanceId{};
  shared_ptr<string> appDescription{};
  shared_ptr<string> appName{};
  shared_ptr<string> appSource{};
  shared_ptr<bool> associateEip{};
  shared_ptr<bool> autoConfig{};
  shared_ptr<string> baseAppId{};
  shared_ptr<string> command{};
  shared_ptr<string> commandArgs{};
  shared_ptr<string> configMapMountDesc{};
  shared_ptr<long> cpu{};
  shared_ptr<string> customHostAlias{};
  shared_ptr<string> customImageNetworkType{};
  shared_ptr<bool> deploy{};
  shared_ptr<long> diskSize{};
  shared_ptr<string> dotnet{};
  shared_ptr<string> edasContainerVersion{};
  shared_ptr<bool> enableCpuBurst{};
  shared_ptr<string> enableEbpf{};
  shared_ptr<bool> enableNewArms{};
  shared_ptr<bool> enableSidecarResourceIsolated{};
  shared_ptr<string> envs{};
  shared_ptr<string> gpuConfig{};
  shared_ptr<string> imagePullSecrets{};
  shared_ptr<string> imageUrl{};
  shared_ptr<string> initContainersConfigShrink{};
  shared_ptr<string> jarStartArgs{};
  shared_ptr<string> jarStartOptions{};
  shared_ptr<string> jdk{};
  shared_ptr<string> kafkaConfigs{};
  shared_ptr<string> liveness{};
  shared_ptr<long> memory{};
  shared_ptr<string> microRegistration{};
  shared_ptr<string> microRegistrationConfig{};
  shared_ptr<string> microserviceEngineConfig{};
  shared_ptr<string> mountDesc{};
  shared_ptr<string> mountHost{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> nasConfigs{};
  shared_ptr<string> nasId{};
  shared_ptr<string> newSaeVersion{};
  shared_ptr<string> oidcRoleName{};
  shared_ptr<string> ossAkId{};
  shared_ptr<string> ossAkSecret{};
  shared_ptr<string> ossMountDescs{};
  shared_ptr<string> packageType{};
  shared_ptr<string> packageUrl{};
  shared_ptr<string> packageVersion{};
  shared_ptr<string> php{};
  shared_ptr<string> phpArmsConfigLocation{};
  shared_ptr<string> phpConfig{};
  shared_ptr<string> phpConfigLocation{};
  shared_ptr<string> postStart{};
  shared_ptr<string> preStop{};
  shared_ptr<string> programmingLanguage{};
  shared_ptr<string> pvtzDiscoverySvc{};
  shared_ptr<string> python{};
  shared_ptr<string> pythonModules{};
  shared_ptr<string> readiness{};
  shared_ptr<long> replicas{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> saeVersion{};
  shared_ptr<string> secretMountDesc{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> serviceTags{};
  shared_ptr<string> sidecarContainersConfigShrink{};
  shared_ptr<string> slsConfigs{};
  shared_ptr<string> startupProbe{};
  shared_ptr<long> terminationGracePeriodSeconds{};
  shared_ptr<string> timezone{};
  shared_ptr<string> tomcatConfig{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> warStartOptions{};
  shared_ptr<string> webContainer{};

  CreateApplicationShrinkRequest() {}

  explicit CreateApplicationShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acrAssumeRoleArn) {
      res["AcrAssumeRoleArn"] = boost::any(*acrAssumeRoleArn);
    }
    if (acrInstanceId) {
      res["AcrInstanceId"] = boost::any(*acrInstanceId);
    }
    if (appDescription) {
      res["AppDescription"] = boost::any(*appDescription);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (appSource) {
      res["AppSource"] = boost::any(*appSource);
    }
    if (associateEip) {
      res["AssociateEip"] = boost::any(*associateEip);
    }
    if (autoConfig) {
      res["AutoConfig"] = boost::any(*autoConfig);
    }
    if (baseAppId) {
      res["BaseAppId"] = boost::any(*baseAppId);
    }
    if (command) {
      res["Command"] = boost::any(*command);
    }
    if (commandArgs) {
      res["CommandArgs"] = boost::any(*commandArgs);
    }
    if (configMapMountDesc) {
      res["ConfigMapMountDesc"] = boost::any(*configMapMountDesc);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (customHostAlias) {
      res["CustomHostAlias"] = boost::any(*customHostAlias);
    }
    if (customImageNetworkType) {
      res["CustomImageNetworkType"] = boost::any(*customImageNetworkType);
    }
    if (deploy) {
      res["Deploy"] = boost::any(*deploy);
    }
    if (diskSize) {
      res["DiskSize"] = boost::any(*diskSize);
    }
    if (dotnet) {
      res["Dotnet"] = boost::any(*dotnet);
    }
    if (edasContainerVersion) {
      res["EdasContainerVersion"] = boost::any(*edasContainerVersion);
    }
    if (enableCpuBurst) {
      res["EnableCpuBurst"] = boost::any(*enableCpuBurst);
    }
    if (enableEbpf) {
      res["EnableEbpf"] = boost::any(*enableEbpf);
    }
    if (enableNewArms) {
      res["EnableNewArms"] = boost::any(*enableNewArms);
    }
    if (enableSidecarResourceIsolated) {
      res["EnableSidecarResourceIsolated"] = boost::any(*enableSidecarResourceIsolated);
    }
    if (envs) {
      res["Envs"] = boost::any(*envs);
    }
    if (gpuConfig) {
      res["GpuConfig"] = boost::any(*gpuConfig);
    }
    if (imagePullSecrets) {
      res["ImagePullSecrets"] = boost::any(*imagePullSecrets);
    }
    if (imageUrl) {
      res["ImageUrl"] = boost::any(*imageUrl);
    }
    if (initContainersConfigShrink) {
      res["InitContainersConfig"] = boost::any(*initContainersConfigShrink);
    }
    if (jarStartArgs) {
      res["JarStartArgs"] = boost::any(*jarStartArgs);
    }
    if (jarStartOptions) {
      res["JarStartOptions"] = boost::any(*jarStartOptions);
    }
    if (jdk) {
      res["Jdk"] = boost::any(*jdk);
    }
    if (kafkaConfigs) {
      res["KafkaConfigs"] = boost::any(*kafkaConfigs);
    }
    if (liveness) {
      res["Liveness"] = boost::any(*liveness);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (microRegistration) {
      res["MicroRegistration"] = boost::any(*microRegistration);
    }
    if (microRegistrationConfig) {
      res["MicroRegistrationConfig"] = boost::any(*microRegistrationConfig);
    }
    if (microserviceEngineConfig) {
      res["MicroserviceEngineConfig"] = boost::any(*microserviceEngineConfig);
    }
    if (mountDesc) {
      res["MountDesc"] = boost::any(*mountDesc);
    }
    if (mountHost) {
      res["MountHost"] = boost::any(*mountHost);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (nasConfigs) {
      res["NasConfigs"] = boost::any(*nasConfigs);
    }
    if (nasId) {
      res["NasId"] = boost::any(*nasId);
    }
    if (newSaeVersion) {
      res["NewSaeVersion"] = boost::any(*newSaeVersion);
    }
    if (oidcRoleName) {
      res["OidcRoleName"] = boost::any(*oidcRoleName);
    }
    if (ossAkId) {
      res["OssAkId"] = boost::any(*ossAkId);
    }
    if (ossAkSecret) {
      res["OssAkSecret"] = boost::any(*ossAkSecret);
    }
    if (ossMountDescs) {
      res["OssMountDescs"] = boost::any(*ossMountDescs);
    }
    if (packageType) {
      res["PackageType"] = boost::any(*packageType);
    }
    if (packageUrl) {
      res["PackageUrl"] = boost::any(*packageUrl);
    }
    if (packageVersion) {
      res["PackageVersion"] = boost::any(*packageVersion);
    }
    if (php) {
      res["Php"] = boost::any(*php);
    }
    if (phpArmsConfigLocation) {
      res["PhpArmsConfigLocation"] = boost::any(*phpArmsConfigLocation);
    }
    if (phpConfig) {
      res["PhpConfig"] = boost::any(*phpConfig);
    }
    if (phpConfigLocation) {
      res["PhpConfigLocation"] = boost::any(*phpConfigLocation);
    }
    if (postStart) {
      res["PostStart"] = boost::any(*postStart);
    }
    if (preStop) {
      res["PreStop"] = boost::any(*preStop);
    }
    if (programmingLanguage) {
      res["ProgrammingLanguage"] = boost::any(*programmingLanguage);
    }
    if (pvtzDiscoverySvc) {
      res["PvtzDiscoverySvc"] = boost::any(*pvtzDiscoverySvc);
    }
    if (python) {
      res["Python"] = boost::any(*python);
    }
    if (pythonModules) {
      res["PythonModules"] = boost::any(*pythonModules);
    }
    if (readiness) {
      res["Readiness"] = boost::any(*readiness);
    }
    if (replicas) {
      res["Replicas"] = boost::any(*replicas);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (saeVersion) {
      res["SaeVersion"] = boost::any(*saeVersion);
    }
    if (secretMountDesc) {
      res["SecretMountDesc"] = boost::any(*secretMountDesc);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (serviceTags) {
      res["ServiceTags"] = boost::any(*serviceTags);
    }
    if (sidecarContainersConfigShrink) {
      res["SidecarContainersConfig"] = boost::any(*sidecarContainersConfigShrink);
    }
    if (slsConfigs) {
      res["SlsConfigs"] = boost::any(*slsConfigs);
    }
    if (startupProbe) {
      res["StartupProbe"] = boost::any(*startupProbe);
    }
    if (terminationGracePeriodSeconds) {
      res["TerminationGracePeriodSeconds"] = boost::any(*terminationGracePeriodSeconds);
    }
    if (timezone) {
      res["Timezone"] = boost::any(*timezone);
    }
    if (tomcatConfig) {
      res["TomcatConfig"] = boost::any(*tomcatConfig);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (warStartOptions) {
      res["WarStartOptions"] = boost::any(*warStartOptions);
    }
    if (webContainer) {
      res["WebContainer"] = boost::any(*webContainer);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcrAssumeRoleArn") != m.end() && !m["AcrAssumeRoleArn"].empty()) {
      acrAssumeRoleArn = make_shared<string>(boost::any_cast<string>(m["AcrAssumeRoleArn"]));
    }
    if (m.find("AcrInstanceId") != m.end() && !m["AcrInstanceId"].empty()) {
      acrInstanceId = make_shared<string>(boost::any_cast<string>(m["AcrInstanceId"]));
    }
    if (m.find("AppDescription") != m.end() && !m["AppDescription"].empty()) {
      appDescription = make_shared<string>(boost::any_cast<string>(m["AppDescription"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AppSource") != m.end() && !m["AppSource"].empty()) {
      appSource = make_shared<string>(boost::any_cast<string>(m["AppSource"]));
    }
    if (m.find("AssociateEip") != m.end() && !m["AssociateEip"].empty()) {
      associateEip = make_shared<bool>(boost::any_cast<bool>(m["AssociateEip"]));
    }
    if (m.find("AutoConfig") != m.end() && !m["AutoConfig"].empty()) {
      autoConfig = make_shared<bool>(boost::any_cast<bool>(m["AutoConfig"]));
    }
    if (m.find("BaseAppId") != m.end() && !m["BaseAppId"].empty()) {
      baseAppId = make_shared<string>(boost::any_cast<string>(m["BaseAppId"]));
    }
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
    if (m.find("CommandArgs") != m.end() && !m["CommandArgs"].empty()) {
      commandArgs = make_shared<string>(boost::any_cast<string>(m["CommandArgs"]));
    }
    if (m.find("ConfigMapMountDesc") != m.end() && !m["ConfigMapMountDesc"].empty()) {
      configMapMountDesc = make_shared<string>(boost::any_cast<string>(m["ConfigMapMountDesc"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("CustomHostAlias") != m.end() && !m["CustomHostAlias"].empty()) {
      customHostAlias = make_shared<string>(boost::any_cast<string>(m["CustomHostAlias"]));
    }
    if (m.find("CustomImageNetworkType") != m.end() && !m["CustomImageNetworkType"].empty()) {
      customImageNetworkType = make_shared<string>(boost::any_cast<string>(m["CustomImageNetworkType"]));
    }
    if (m.find("Deploy") != m.end() && !m["Deploy"].empty()) {
      deploy = make_shared<bool>(boost::any_cast<bool>(m["Deploy"]));
    }
    if (m.find("DiskSize") != m.end() && !m["DiskSize"].empty()) {
      diskSize = make_shared<long>(boost::any_cast<long>(m["DiskSize"]));
    }
    if (m.find("Dotnet") != m.end() && !m["Dotnet"].empty()) {
      dotnet = make_shared<string>(boost::any_cast<string>(m["Dotnet"]));
    }
    if (m.find("EdasContainerVersion") != m.end() && !m["EdasContainerVersion"].empty()) {
      edasContainerVersion = make_shared<string>(boost::any_cast<string>(m["EdasContainerVersion"]));
    }
    if (m.find("EnableCpuBurst") != m.end() && !m["EnableCpuBurst"].empty()) {
      enableCpuBurst = make_shared<bool>(boost::any_cast<bool>(m["EnableCpuBurst"]));
    }
    if (m.find("EnableEbpf") != m.end() && !m["EnableEbpf"].empty()) {
      enableEbpf = make_shared<string>(boost::any_cast<string>(m["EnableEbpf"]));
    }
    if (m.find("EnableNewArms") != m.end() && !m["EnableNewArms"].empty()) {
      enableNewArms = make_shared<bool>(boost::any_cast<bool>(m["EnableNewArms"]));
    }
    if (m.find("EnableSidecarResourceIsolated") != m.end() && !m["EnableSidecarResourceIsolated"].empty()) {
      enableSidecarResourceIsolated = make_shared<bool>(boost::any_cast<bool>(m["EnableSidecarResourceIsolated"]));
    }
    if (m.find("Envs") != m.end() && !m["Envs"].empty()) {
      envs = make_shared<string>(boost::any_cast<string>(m["Envs"]));
    }
    if (m.find("GpuConfig") != m.end() && !m["GpuConfig"].empty()) {
      gpuConfig = make_shared<string>(boost::any_cast<string>(m["GpuConfig"]));
    }
    if (m.find("ImagePullSecrets") != m.end() && !m["ImagePullSecrets"].empty()) {
      imagePullSecrets = make_shared<string>(boost::any_cast<string>(m["ImagePullSecrets"]));
    }
    if (m.find("ImageUrl") != m.end() && !m["ImageUrl"].empty()) {
      imageUrl = make_shared<string>(boost::any_cast<string>(m["ImageUrl"]));
    }
    if (m.find("InitContainersConfig") != m.end() && !m["InitContainersConfig"].empty()) {
      initContainersConfigShrink = make_shared<string>(boost::any_cast<string>(m["InitContainersConfig"]));
    }
    if (m.find("JarStartArgs") != m.end() && !m["JarStartArgs"].empty()) {
      jarStartArgs = make_shared<string>(boost::any_cast<string>(m["JarStartArgs"]));
    }
    if (m.find("JarStartOptions") != m.end() && !m["JarStartOptions"].empty()) {
      jarStartOptions = make_shared<string>(boost::any_cast<string>(m["JarStartOptions"]));
    }
    if (m.find("Jdk") != m.end() && !m["Jdk"].empty()) {
      jdk = make_shared<string>(boost::any_cast<string>(m["Jdk"]));
    }
    if (m.find("KafkaConfigs") != m.end() && !m["KafkaConfigs"].empty()) {
      kafkaConfigs = make_shared<string>(boost::any_cast<string>(m["KafkaConfigs"]));
    }
    if (m.find("Liveness") != m.end() && !m["Liveness"].empty()) {
      liveness = make_shared<string>(boost::any_cast<string>(m["Liveness"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
    if (m.find("MicroRegistration") != m.end() && !m["MicroRegistration"].empty()) {
      microRegistration = make_shared<string>(boost::any_cast<string>(m["MicroRegistration"]));
    }
    if (m.find("MicroRegistrationConfig") != m.end() && !m["MicroRegistrationConfig"].empty()) {
      microRegistrationConfig = make_shared<string>(boost::any_cast<string>(m["MicroRegistrationConfig"]));
    }
    if (m.find("MicroserviceEngineConfig") != m.end() && !m["MicroserviceEngineConfig"].empty()) {
      microserviceEngineConfig = make_shared<string>(boost::any_cast<string>(m["MicroserviceEngineConfig"]));
    }
    if (m.find("MountDesc") != m.end() && !m["MountDesc"].empty()) {
      mountDesc = make_shared<string>(boost::any_cast<string>(m["MountDesc"]));
    }
    if (m.find("MountHost") != m.end() && !m["MountHost"].empty()) {
      mountHost = make_shared<string>(boost::any_cast<string>(m["MountHost"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("NasConfigs") != m.end() && !m["NasConfigs"].empty()) {
      nasConfigs = make_shared<string>(boost::any_cast<string>(m["NasConfigs"]));
    }
    if (m.find("NasId") != m.end() && !m["NasId"].empty()) {
      nasId = make_shared<string>(boost::any_cast<string>(m["NasId"]));
    }
    if (m.find("NewSaeVersion") != m.end() && !m["NewSaeVersion"].empty()) {
      newSaeVersion = make_shared<string>(boost::any_cast<string>(m["NewSaeVersion"]));
    }
    if (m.find("OidcRoleName") != m.end() && !m["OidcRoleName"].empty()) {
      oidcRoleName = make_shared<string>(boost::any_cast<string>(m["OidcRoleName"]));
    }
    if (m.find("OssAkId") != m.end() && !m["OssAkId"].empty()) {
      ossAkId = make_shared<string>(boost::any_cast<string>(m["OssAkId"]));
    }
    if (m.find("OssAkSecret") != m.end() && !m["OssAkSecret"].empty()) {
      ossAkSecret = make_shared<string>(boost::any_cast<string>(m["OssAkSecret"]));
    }
    if (m.find("OssMountDescs") != m.end() && !m["OssMountDescs"].empty()) {
      ossMountDescs = make_shared<string>(boost::any_cast<string>(m["OssMountDescs"]));
    }
    if (m.find("PackageType") != m.end() && !m["PackageType"].empty()) {
      packageType = make_shared<string>(boost::any_cast<string>(m["PackageType"]));
    }
    if (m.find("PackageUrl") != m.end() && !m["PackageUrl"].empty()) {
      packageUrl = make_shared<string>(boost::any_cast<string>(m["PackageUrl"]));
    }
    if (m.find("PackageVersion") != m.end() && !m["PackageVersion"].empty()) {
      packageVersion = make_shared<string>(boost::any_cast<string>(m["PackageVersion"]));
    }
    if (m.find("Php") != m.end() && !m["Php"].empty()) {
      php = make_shared<string>(boost::any_cast<string>(m["Php"]));
    }
    if (m.find("PhpArmsConfigLocation") != m.end() && !m["PhpArmsConfigLocation"].empty()) {
      phpArmsConfigLocation = make_shared<string>(boost::any_cast<string>(m["PhpArmsConfigLocation"]));
    }
    if (m.find("PhpConfig") != m.end() && !m["PhpConfig"].empty()) {
      phpConfig = make_shared<string>(boost::any_cast<string>(m["PhpConfig"]));
    }
    if (m.find("PhpConfigLocation") != m.end() && !m["PhpConfigLocation"].empty()) {
      phpConfigLocation = make_shared<string>(boost::any_cast<string>(m["PhpConfigLocation"]));
    }
    if (m.find("PostStart") != m.end() && !m["PostStart"].empty()) {
      postStart = make_shared<string>(boost::any_cast<string>(m["PostStart"]));
    }
    if (m.find("PreStop") != m.end() && !m["PreStop"].empty()) {
      preStop = make_shared<string>(boost::any_cast<string>(m["PreStop"]));
    }
    if (m.find("ProgrammingLanguage") != m.end() && !m["ProgrammingLanguage"].empty()) {
      programmingLanguage = make_shared<string>(boost::any_cast<string>(m["ProgrammingLanguage"]));
    }
    if (m.find("PvtzDiscoverySvc") != m.end() && !m["PvtzDiscoverySvc"].empty()) {
      pvtzDiscoverySvc = make_shared<string>(boost::any_cast<string>(m["PvtzDiscoverySvc"]));
    }
    if (m.find("Python") != m.end() && !m["Python"].empty()) {
      python = make_shared<string>(boost::any_cast<string>(m["Python"]));
    }
    if (m.find("PythonModules") != m.end() && !m["PythonModules"].empty()) {
      pythonModules = make_shared<string>(boost::any_cast<string>(m["PythonModules"]));
    }
    if (m.find("Readiness") != m.end() && !m["Readiness"].empty()) {
      readiness = make_shared<string>(boost::any_cast<string>(m["Readiness"]));
    }
    if (m.find("Replicas") != m.end() && !m["Replicas"].empty()) {
      replicas = make_shared<long>(boost::any_cast<long>(m["Replicas"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("SaeVersion") != m.end() && !m["SaeVersion"].empty()) {
      saeVersion = make_shared<string>(boost::any_cast<string>(m["SaeVersion"]));
    }
    if (m.find("SecretMountDesc") != m.end() && !m["SecretMountDesc"].empty()) {
      secretMountDesc = make_shared<string>(boost::any_cast<string>(m["SecretMountDesc"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("ServiceTags") != m.end() && !m["ServiceTags"].empty()) {
      serviceTags = make_shared<string>(boost::any_cast<string>(m["ServiceTags"]));
    }
    if (m.find("SidecarContainersConfig") != m.end() && !m["SidecarContainersConfig"].empty()) {
      sidecarContainersConfigShrink = make_shared<string>(boost::any_cast<string>(m["SidecarContainersConfig"]));
    }
    if (m.find("SlsConfigs") != m.end() && !m["SlsConfigs"].empty()) {
      slsConfigs = make_shared<string>(boost::any_cast<string>(m["SlsConfigs"]));
    }
    if (m.find("StartupProbe") != m.end() && !m["StartupProbe"].empty()) {
      startupProbe = make_shared<string>(boost::any_cast<string>(m["StartupProbe"]));
    }
    if (m.find("TerminationGracePeriodSeconds") != m.end() && !m["TerminationGracePeriodSeconds"].empty()) {
      terminationGracePeriodSeconds = make_shared<long>(boost::any_cast<long>(m["TerminationGracePeriodSeconds"]));
    }
    if (m.find("Timezone") != m.end() && !m["Timezone"].empty()) {
      timezone = make_shared<string>(boost::any_cast<string>(m["Timezone"]));
    }
    if (m.find("TomcatConfig") != m.end() && !m["TomcatConfig"].empty()) {
      tomcatConfig = make_shared<string>(boost::any_cast<string>(m["TomcatConfig"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("WarStartOptions") != m.end() && !m["WarStartOptions"].empty()) {
      warStartOptions = make_shared<string>(boost::any_cast<string>(m["WarStartOptions"]));
    }
    if (m.find("WebContainer") != m.end() && !m["WebContainer"].empty()) {
      webContainer = make_shared<string>(boost::any_cast<string>(m["WebContainer"]));
    }
  }


  virtual ~CreateApplicationShrinkRequest() = default;
};
class CreateApplicationResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> changeOrderId{};

  CreateApplicationResponseBodyData() {}

  explicit CreateApplicationResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
  }


  virtual ~CreateApplicationResponseBodyData() = default;
};
class CreateApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CreateApplicationResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  CreateApplicationResponseBody() {}

  explicit CreateApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateApplicationResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateApplicationResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~CreateApplicationResponseBody() = default;
};
class CreateApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateApplicationResponseBody> body{};

  CreateApplicationResponse() {}

  explicit CreateApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~CreateApplicationResponse() = default;
};
class CreateApplicationScalingRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<bool> enableIdle{};
  shared_ptr<long> minReadyInstanceRatio{};
  shared_ptr<long> minReadyInstances{};
  shared_ptr<bool> scalingRuleEnable{};
  shared_ptr<string> scalingRuleMetric{};
  shared_ptr<string> scalingRuleName{};
  shared_ptr<string> scalingRuleTimer{};
  shared_ptr<string> scalingRuleType{};

  CreateApplicationScalingRuleRequest() {}

  explicit CreateApplicationScalingRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (enableIdle) {
      res["EnableIdle"] = boost::any(*enableIdle);
    }
    if (minReadyInstanceRatio) {
      res["MinReadyInstanceRatio"] = boost::any(*minReadyInstanceRatio);
    }
    if (minReadyInstances) {
      res["MinReadyInstances"] = boost::any(*minReadyInstances);
    }
    if (scalingRuleEnable) {
      res["ScalingRuleEnable"] = boost::any(*scalingRuleEnable);
    }
    if (scalingRuleMetric) {
      res["ScalingRuleMetric"] = boost::any(*scalingRuleMetric);
    }
    if (scalingRuleName) {
      res["ScalingRuleName"] = boost::any(*scalingRuleName);
    }
    if (scalingRuleTimer) {
      res["ScalingRuleTimer"] = boost::any(*scalingRuleTimer);
    }
    if (scalingRuleType) {
      res["ScalingRuleType"] = boost::any(*scalingRuleType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("EnableIdle") != m.end() && !m["EnableIdle"].empty()) {
      enableIdle = make_shared<bool>(boost::any_cast<bool>(m["EnableIdle"]));
    }
    if (m.find("MinReadyInstanceRatio") != m.end() && !m["MinReadyInstanceRatio"].empty()) {
      minReadyInstanceRatio = make_shared<long>(boost::any_cast<long>(m["MinReadyInstanceRatio"]));
    }
    if (m.find("MinReadyInstances") != m.end() && !m["MinReadyInstances"].empty()) {
      minReadyInstances = make_shared<long>(boost::any_cast<long>(m["MinReadyInstances"]));
    }
    if (m.find("ScalingRuleEnable") != m.end() && !m["ScalingRuleEnable"].empty()) {
      scalingRuleEnable = make_shared<bool>(boost::any_cast<bool>(m["ScalingRuleEnable"]));
    }
    if (m.find("ScalingRuleMetric") != m.end() && !m["ScalingRuleMetric"].empty()) {
      scalingRuleMetric = make_shared<string>(boost::any_cast<string>(m["ScalingRuleMetric"]));
    }
    if (m.find("ScalingRuleName") != m.end() && !m["ScalingRuleName"].empty()) {
      scalingRuleName = make_shared<string>(boost::any_cast<string>(m["ScalingRuleName"]));
    }
    if (m.find("ScalingRuleTimer") != m.end() && !m["ScalingRuleTimer"].empty()) {
      scalingRuleTimer = make_shared<string>(boost::any_cast<string>(m["ScalingRuleTimer"]));
    }
    if (m.find("ScalingRuleType") != m.end() && !m["ScalingRuleType"].empty()) {
      scalingRuleType = make_shared<string>(boost::any_cast<string>(m["ScalingRuleType"]));
    }
  }


  virtual ~CreateApplicationScalingRuleRequest() = default;
};
class CreateApplicationScalingRuleResponseBodyDataMetricMetrics : public Darabonba::Model {
public:
  shared_ptr<long> metricTargetAverageUtilization{};
  shared_ptr<string> metricType{};
  shared_ptr<string> slbId{};
  shared_ptr<string> slbLogstore{};
  shared_ptr<string> slbProject{};
  shared_ptr<string> vport{};

  CreateApplicationScalingRuleResponseBodyDataMetricMetrics() {}

  explicit CreateApplicationScalingRuleResponseBodyDataMetricMetrics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metricTargetAverageUtilization) {
      res["MetricTargetAverageUtilization"] = boost::any(*metricTargetAverageUtilization);
    }
    if (metricType) {
      res["MetricType"] = boost::any(*metricType);
    }
    if (slbId) {
      res["SlbId"] = boost::any(*slbId);
    }
    if (slbLogstore) {
      res["SlbLogstore"] = boost::any(*slbLogstore);
    }
    if (slbProject) {
      res["SlbProject"] = boost::any(*slbProject);
    }
    if (vport) {
      res["Vport"] = boost::any(*vport);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MetricTargetAverageUtilization") != m.end() && !m["MetricTargetAverageUtilization"].empty()) {
      metricTargetAverageUtilization = make_shared<long>(boost::any_cast<long>(m["MetricTargetAverageUtilization"]));
    }
    if (m.find("MetricType") != m.end() && !m["MetricType"].empty()) {
      metricType = make_shared<string>(boost::any_cast<string>(m["MetricType"]));
    }
    if (m.find("SlbId") != m.end() && !m["SlbId"].empty()) {
      slbId = make_shared<string>(boost::any_cast<string>(m["SlbId"]));
    }
    if (m.find("SlbLogstore") != m.end() && !m["SlbLogstore"].empty()) {
      slbLogstore = make_shared<string>(boost::any_cast<string>(m["SlbLogstore"]));
    }
    if (m.find("SlbProject") != m.end() && !m["SlbProject"].empty()) {
      slbProject = make_shared<string>(boost::any_cast<string>(m["SlbProject"]));
    }
    if (m.find("Vport") != m.end() && !m["Vport"].empty()) {
      vport = make_shared<string>(boost::any_cast<string>(m["Vport"]));
    }
  }


  virtual ~CreateApplicationScalingRuleResponseBodyDataMetricMetrics() = default;
};
class CreateApplicationScalingRuleResponseBodyDataMetric : public Darabonba::Model {
public:
  shared_ptr<long> maxReplicas{};
  shared_ptr<vector<CreateApplicationScalingRuleResponseBodyDataMetricMetrics>> metrics{};
  shared_ptr<long> minReplicas{};

  CreateApplicationScalingRuleResponseBodyDataMetric() {}

  explicit CreateApplicationScalingRuleResponseBodyDataMetric(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxReplicas) {
      res["MaxReplicas"] = boost::any(*maxReplicas);
    }
    if (metrics) {
      vector<boost::any> temp1;
      for(auto item1:*metrics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Metrics"] = boost::any(temp1);
    }
    if (minReplicas) {
      res["MinReplicas"] = boost::any(*minReplicas);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxReplicas") != m.end() && !m["MaxReplicas"].empty()) {
      maxReplicas = make_shared<long>(boost::any_cast<long>(m["MaxReplicas"]));
    }
    if (m.find("Metrics") != m.end() && !m["Metrics"].empty()) {
      if (typeid(vector<boost::any>) == m["Metrics"].type()) {
        vector<CreateApplicationScalingRuleResponseBodyDataMetricMetrics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Metrics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateApplicationScalingRuleResponseBodyDataMetricMetrics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        metrics = make_shared<vector<CreateApplicationScalingRuleResponseBodyDataMetricMetrics>>(expect1);
      }
    }
    if (m.find("MinReplicas") != m.end() && !m["MinReplicas"].empty()) {
      minReplicas = make_shared<long>(boost::any_cast<long>(m["MinReplicas"]));
    }
  }


  virtual ~CreateApplicationScalingRuleResponseBodyDataMetric() = default;
};
class CreateApplicationScalingRuleResponseBodyDataTimerSchedules : public Darabonba::Model {
public:
  shared_ptr<string> atTime{};
  shared_ptr<long> maxReplicas{};
  shared_ptr<long> minReplicas{};
  shared_ptr<long> targetReplicas{};

  CreateApplicationScalingRuleResponseBodyDataTimerSchedules() {}

  explicit CreateApplicationScalingRuleResponseBodyDataTimerSchedules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (atTime) {
      res["AtTime"] = boost::any(*atTime);
    }
    if (maxReplicas) {
      res["MaxReplicas"] = boost::any(*maxReplicas);
    }
    if (minReplicas) {
      res["MinReplicas"] = boost::any(*minReplicas);
    }
    if (targetReplicas) {
      res["TargetReplicas"] = boost::any(*targetReplicas);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AtTime") != m.end() && !m["AtTime"].empty()) {
      atTime = make_shared<string>(boost::any_cast<string>(m["AtTime"]));
    }
    if (m.find("MaxReplicas") != m.end() && !m["MaxReplicas"].empty()) {
      maxReplicas = make_shared<long>(boost::any_cast<long>(m["MaxReplicas"]));
    }
    if (m.find("MinReplicas") != m.end() && !m["MinReplicas"].empty()) {
      minReplicas = make_shared<long>(boost::any_cast<long>(m["MinReplicas"]));
    }
    if (m.find("TargetReplicas") != m.end() && !m["TargetReplicas"].empty()) {
      targetReplicas = make_shared<long>(boost::any_cast<long>(m["TargetReplicas"]));
    }
  }


  virtual ~CreateApplicationScalingRuleResponseBodyDataTimerSchedules() = default;
};
class CreateApplicationScalingRuleResponseBodyDataTimer : public Darabonba::Model {
public:
  shared_ptr<string> beginDate{};
  shared_ptr<string> endDate{};
  shared_ptr<string> period{};
  shared_ptr<vector<CreateApplicationScalingRuleResponseBodyDataTimerSchedules>> schedules{};

  CreateApplicationScalingRuleResponseBodyDataTimer() {}

  explicit CreateApplicationScalingRuleResponseBodyDataTimer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beginDate) {
      res["BeginDate"] = boost::any(*beginDate);
    }
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (schedules) {
      vector<boost::any> temp1;
      for(auto item1:*schedules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Schedules"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BeginDate") != m.end() && !m["BeginDate"].empty()) {
      beginDate = make_shared<string>(boost::any_cast<string>(m["BeginDate"]));
    }
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("Schedules") != m.end() && !m["Schedules"].empty()) {
      if (typeid(vector<boost::any>) == m["Schedules"].type()) {
        vector<CreateApplicationScalingRuleResponseBodyDataTimerSchedules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Schedules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateApplicationScalingRuleResponseBodyDataTimerSchedules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        schedules = make_shared<vector<CreateApplicationScalingRuleResponseBodyDataTimerSchedules>>(expect1);
      }
    }
  }


  virtual ~CreateApplicationScalingRuleResponseBodyDataTimer() = default;
};
class CreateApplicationScalingRuleResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> createTime{};
  shared_ptr<bool> enableIdle{};
  shared_ptr<long> lastDisableTime{};
  shared_ptr<CreateApplicationScalingRuleResponseBodyDataMetric> metric{};
  shared_ptr<bool> scaleRuleEnabled{};
  shared_ptr<string> scaleRuleName{};
  shared_ptr<string> scaleRuleType{};
  shared_ptr<CreateApplicationScalingRuleResponseBodyDataTimer> timer{};
  shared_ptr<long> updateTime{};

  CreateApplicationScalingRuleResponseBodyData() {}

  explicit CreateApplicationScalingRuleResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (enableIdle) {
      res["EnableIdle"] = boost::any(*enableIdle);
    }
    if (lastDisableTime) {
      res["LastDisableTime"] = boost::any(*lastDisableTime);
    }
    if (metric) {
      res["Metric"] = metric ? boost::any(metric->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scaleRuleEnabled) {
      res["ScaleRuleEnabled"] = boost::any(*scaleRuleEnabled);
    }
    if (scaleRuleName) {
      res["ScaleRuleName"] = boost::any(*scaleRuleName);
    }
    if (scaleRuleType) {
      res["ScaleRuleType"] = boost::any(*scaleRuleType);
    }
    if (timer) {
      res["Timer"] = timer ? boost::any(timer->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("EnableIdle") != m.end() && !m["EnableIdle"].empty()) {
      enableIdle = make_shared<bool>(boost::any_cast<bool>(m["EnableIdle"]));
    }
    if (m.find("LastDisableTime") != m.end() && !m["LastDisableTime"].empty()) {
      lastDisableTime = make_shared<long>(boost::any_cast<long>(m["LastDisableTime"]));
    }
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      if (typeid(map<string, boost::any>) == m["Metric"].type()) {
        CreateApplicationScalingRuleResponseBodyDataMetric model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Metric"]));
        metric = make_shared<CreateApplicationScalingRuleResponseBodyDataMetric>(model1);
      }
    }
    if (m.find("ScaleRuleEnabled") != m.end() && !m["ScaleRuleEnabled"].empty()) {
      scaleRuleEnabled = make_shared<bool>(boost::any_cast<bool>(m["ScaleRuleEnabled"]));
    }
    if (m.find("ScaleRuleName") != m.end() && !m["ScaleRuleName"].empty()) {
      scaleRuleName = make_shared<string>(boost::any_cast<string>(m["ScaleRuleName"]));
    }
    if (m.find("ScaleRuleType") != m.end() && !m["ScaleRuleType"].empty()) {
      scaleRuleType = make_shared<string>(boost::any_cast<string>(m["ScaleRuleType"]));
    }
    if (m.find("Timer") != m.end() && !m["Timer"].empty()) {
      if (typeid(map<string, boost::any>) == m["Timer"].type()) {
        CreateApplicationScalingRuleResponseBodyDataTimer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Timer"]));
        timer = make_shared<CreateApplicationScalingRuleResponseBodyDataTimer>(model1);
      }
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~CreateApplicationScalingRuleResponseBodyData() = default;
};
class CreateApplicationScalingRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CreateApplicationScalingRuleResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  CreateApplicationScalingRuleResponseBody() {}

  explicit CreateApplicationScalingRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateApplicationScalingRuleResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateApplicationScalingRuleResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~CreateApplicationScalingRuleResponseBody() = default;
};
class CreateApplicationScalingRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateApplicationScalingRuleResponseBody> body{};

  CreateApplicationScalingRuleResponse() {}

  explicit CreateApplicationScalingRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateApplicationScalingRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateApplicationScalingRuleResponseBody>(model1);
      }
    }
  }


  virtual ~CreateApplicationScalingRuleResponse() = default;
};
class CreateConfigMapRequest : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> namespaceId{};

  CreateConfigMapRequest() {}

  explicit CreateConfigMapRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
  }


  virtual ~CreateConfigMapRequest() = default;
};
class CreateConfigMapResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> configMapId{};

  CreateConfigMapResponseBodyData() {}

  explicit CreateConfigMapResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configMapId) {
      res["ConfigMapId"] = boost::any(*configMapId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigMapId") != m.end() && !m["ConfigMapId"].empty()) {
      configMapId = make_shared<long>(boost::any_cast<long>(m["ConfigMapId"]));
    }
  }


  virtual ~CreateConfigMapResponseBodyData() = default;
};
class CreateConfigMapResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CreateConfigMapResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  CreateConfigMapResponseBody() {}

  explicit CreateConfigMapResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateConfigMapResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateConfigMapResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~CreateConfigMapResponseBody() = default;
};
class CreateConfigMapResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateConfigMapResponseBody> body{};

  CreateConfigMapResponse() {}

  explicit CreateConfigMapResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateConfigMapResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateConfigMapResponseBody>(model1);
      }
    }
  }


  virtual ~CreateConfigMapResponse() = default;
};
class CreateGreyTagRouteRequest : public Darabonba::Model {
public:
  shared_ptr<string> albRules{};
  shared_ptr<string> appId{};
  shared_ptr<string> description{};
  shared_ptr<string> dubboRules{};
  shared_ptr<string> name{};
  shared_ptr<string> scRules{};

  CreateGreyTagRouteRequest() {}

  explicit CreateGreyTagRouteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (albRules) {
      res["AlbRules"] = boost::any(*albRules);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dubboRules) {
      res["DubboRules"] = boost::any(*dubboRules);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (scRules) {
      res["ScRules"] = boost::any(*scRules);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlbRules") != m.end() && !m["AlbRules"].empty()) {
      albRules = make_shared<string>(boost::any_cast<string>(m["AlbRules"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DubboRules") != m.end() && !m["DubboRules"].empty()) {
      dubboRules = make_shared<string>(boost::any_cast<string>(m["DubboRules"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ScRules") != m.end() && !m["ScRules"].empty()) {
      scRules = make_shared<string>(boost::any_cast<string>(m["ScRules"]));
    }
  }


  virtual ~CreateGreyTagRouteRequest() = default;
};
class CreateGreyTagRouteResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> greyTagRouteId{};

  CreateGreyTagRouteResponseBodyData() {}

  explicit CreateGreyTagRouteResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (greyTagRouteId) {
      res["GreyTagRouteId"] = boost::any(*greyTagRouteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GreyTagRouteId") != m.end() && !m["GreyTagRouteId"].empty()) {
      greyTagRouteId = make_shared<long>(boost::any_cast<long>(m["GreyTagRouteId"]));
    }
  }


  virtual ~CreateGreyTagRouteResponseBodyData() = default;
};
class CreateGreyTagRouteResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CreateGreyTagRouteResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  CreateGreyTagRouteResponseBody() {}

  explicit CreateGreyTagRouteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateGreyTagRouteResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateGreyTagRouteResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~CreateGreyTagRouteResponseBody() = default;
};
class CreateGreyTagRouteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateGreyTagRouteResponseBody> body{};

  CreateGreyTagRouteResponse() {}

  explicit CreateGreyTagRouteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateGreyTagRouteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateGreyTagRouteResponseBody>(model1);
      }
    }
  }


  virtual ~CreateGreyTagRouteResponse() = default;
};
class CreateIngressRequest : public Darabonba::Model {
public:
  shared_ptr<string> addressType{};
  shared_ptr<string> certId{};
  shared_ptr<string> certIds{};
  shared_ptr<string> corsConfig{};
  shared_ptr<string> defaultRule{};
  shared_ptr<string> description{};
  shared_ptr<bool> enableXForwardedFor{};
  shared_ptr<bool> enableXForwardedForClientSrcPort{};
  shared_ptr<bool> enableXForwardedForProto{};
  shared_ptr<bool> enableXForwardedForSlbId{};
  shared_ptr<bool> enableXForwardedForSlbPort{};
  shared_ptr<long> idleTimeout{};
  shared_ptr<long> listenerPort{};
  shared_ptr<string> listenerProtocol{};
  shared_ptr<string> loadBalanceType{};
  shared_ptr<string> loadBalancerEdition{};
  shared_ptr<string> namespaceId{};
  shared_ptr<long> requestTimeout{};
  shared_ptr<string> rules{};
  shared_ptr<string> securityPolicyId{};
  shared_ptr<string> slbId{};
  shared_ptr<string> zoneMappings{};

  CreateIngressRequest() {}

  explicit CreateIngressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addressType) {
      res["AddressType"] = boost::any(*addressType);
    }
    if (certId) {
      res["CertId"] = boost::any(*certId);
    }
    if (certIds) {
      res["CertIds"] = boost::any(*certIds);
    }
    if (corsConfig) {
      res["CorsConfig"] = boost::any(*corsConfig);
    }
    if (defaultRule) {
      res["DefaultRule"] = boost::any(*defaultRule);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enableXForwardedFor) {
      res["EnableXForwardedFor"] = boost::any(*enableXForwardedFor);
    }
    if (enableXForwardedForClientSrcPort) {
      res["EnableXForwardedForClientSrcPort"] = boost::any(*enableXForwardedForClientSrcPort);
    }
    if (enableXForwardedForProto) {
      res["EnableXForwardedForProto"] = boost::any(*enableXForwardedForProto);
    }
    if (enableXForwardedForSlbId) {
      res["EnableXForwardedForSlbId"] = boost::any(*enableXForwardedForSlbId);
    }
    if (enableXForwardedForSlbPort) {
      res["EnableXForwardedForSlbPort"] = boost::any(*enableXForwardedForSlbPort);
    }
    if (idleTimeout) {
      res["IdleTimeout"] = boost::any(*idleTimeout);
    }
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    if (listenerProtocol) {
      res["ListenerProtocol"] = boost::any(*listenerProtocol);
    }
    if (loadBalanceType) {
      res["LoadBalanceType"] = boost::any(*loadBalanceType);
    }
    if (loadBalancerEdition) {
      res["LoadBalancerEdition"] = boost::any(*loadBalancerEdition);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (requestTimeout) {
      res["RequestTimeout"] = boost::any(*requestTimeout);
    }
    if (rules) {
      res["Rules"] = boost::any(*rules);
    }
    if (securityPolicyId) {
      res["SecurityPolicyId"] = boost::any(*securityPolicyId);
    }
    if (slbId) {
      res["SlbId"] = boost::any(*slbId);
    }
    if (zoneMappings) {
      res["ZoneMappings"] = boost::any(*zoneMappings);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddressType") != m.end() && !m["AddressType"].empty()) {
      addressType = make_shared<string>(boost::any_cast<string>(m["AddressType"]));
    }
    if (m.find("CertId") != m.end() && !m["CertId"].empty()) {
      certId = make_shared<string>(boost::any_cast<string>(m["CertId"]));
    }
    if (m.find("CertIds") != m.end() && !m["CertIds"].empty()) {
      certIds = make_shared<string>(boost::any_cast<string>(m["CertIds"]));
    }
    if (m.find("CorsConfig") != m.end() && !m["CorsConfig"].empty()) {
      corsConfig = make_shared<string>(boost::any_cast<string>(m["CorsConfig"]));
    }
    if (m.find("DefaultRule") != m.end() && !m["DefaultRule"].empty()) {
      defaultRule = make_shared<string>(boost::any_cast<string>(m["DefaultRule"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnableXForwardedFor") != m.end() && !m["EnableXForwardedFor"].empty()) {
      enableXForwardedFor = make_shared<bool>(boost::any_cast<bool>(m["EnableXForwardedFor"]));
    }
    if (m.find("EnableXForwardedForClientSrcPort") != m.end() && !m["EnableXForwardedForClientSrcPort"].empty()) {
      enableXForwardedForClientSrcPort = make_shared<bool>(boost::any_cast<bool>(m["EnableXForwardedForClientSrcPort"]));
    }
    if (m.find("EnableXForwardedForProto") != m.end() && !m["EnableXForwardedForProto"].empty()) {
      enableXForwardedForProto = make_shared<bool>(boost::any_cast<bool>(m["EnableXForwardedForProto"]));
    }
    if (m.find("EnableXForwardedForSlbId") != m.end() && !m["EnableXForwardedForSlbId"].empty()) {
      enableXForwardedForSlbId = make_shared<bool>(boost::any_cast<bool>(m["EnableXForwardedForSlbId"]));
    }
    if (m.find("EnableXForwardedForSlbPort") != m.end() && !m["EnableXForwardedForSlbPort"].empty()) {
      enableXForwardedForSlbPort = make_shared<bool>(boost::any_cast<bool>(m["EnableXForwardedForSlbPort"]));
    }
    if (m.find("IdleTimeout") != m.end() && !m["IdleTimeout"].empty()) {
      idleTimeout = make_shared<long>(boost::any_cast<long>(m["IdleTimeout"]));
    }
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<long>(boost::any_cast<long>(m["ListenerPort"]));
    }
    if (m.find("ListenerProtocol") != m.end() && !m["ListenerProtocol"].empty()) {
      listenerProtocol = make_shared<string>(boost::any_cast<string>(m["ListenerProtocol"]));
    }
    if (m.find("LoadBalanceType") != m.end() && !m["LoadBalanceType"].empty()) {
      loadBalanceType = make_shared<string>(boost::any_cast<string>(m["LoadBalanceType"]));
    }
    if (m.find("LoadBalancerEdition") != m.end() && !m["LoadBalancerEdition"].empty()) {
      loadBalancerEdition = make_shared<string>(boost::any_cast<string>(m["LoadBalancerEdition"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("RequestTimeout") != m.end() && !m["RequestTimeout"].empty()) {
      requestTimeout = make_shared<long>(boost::any_cast<long>(m["RequestTimeout"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      rules = make_shared<string>(boost::any_cast<string>(m["Rules"]));
    }
    if (m.find("SecurityPolicyId") != m.end() && !m["SecurityPolicyId"].empty()) {
      securityPolicyId = make_shared<string>(boost::any_cast<string>(m["SecurityPolicyId"]));
    }
    if (m.find("SlbId") != m.end() && !m["SlbId"].empty()) {
      slbId = make_shared<string>(boost::any_cast<string>(m["SlbId"]));
    }
    if (m.find("ZoneMappings") != m.end() && !m["ZoneMappings"].empty()) {
      zoneMappings = make_shared<string>(boost::any_cast<string>(m["ZoneMappings"]));
    }
  }


  virtual ~CreateIngressRequest() = default;
};
class CreateIngressResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> ingressId{};

  CreateIngressResponseBodyData() {}

  explicit CreateIngressResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ingressId) {
      res["IngressId"] = boost::any(*ingressId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IngressId") != m.end() && !m["IngressId"].empty()) {
      ingressId = make_shared<long>(boost::any_cast<long>(m["IngressId"]));
    }
  }


  virtual ~CreateIngressResponseBodyData() = default;
};
class CreateIngressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CreateIngressResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  CreateIngressResponseBody() {}

  explicit CreateIngressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateIngressResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateIngressResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~CreateIngressResponseBody() = default;
};
class CreateIngressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateIngressResponseBody> body{};

  CreateIngressResponse() {}

  explicit CreateIngressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateIngressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateIngressResponseBody>(model1);
      }
    }
  }


  virtual ~CreateIngressResponse() = default;
};
class CreateJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> acrAssumeRoleArn{};
  shared_ptr<string> acrInstanceId{};
  shared_ptr<string> appDescription{};
  shared_ptr<string> appName{};
  shared_ptr<bool> autoConfig{};
  shared_ptr<long> backoffLimit{};
  shared_ptr<string> command{};
  shared_ptr<string> commandArgs{};
  shared_ptr<string> concurrencyPolicy{};
  shared_ptr<string> configMapMountDesc{};
  shared_ptr<long> cpu{};
  shared_ptr<string> customHostAlias{};
  shared_ptr<string> edasContainerVersion{};
  shared_ptr<bool> enableImageAccl{};
  shared_ptr<string> envs{};
  shared_ptr<string> imagePullSecrets{};
  shared_ptr<string> imageUrl{};
  shared_ptr<string> jarStartArgs{};
  shared_ptr<string> jarStartOptions{};
  shared_ptr<string> jdk{};
  shared_ptr<long> memory{};
  shared_ptr<string> mountDesc{};
  shared_ptr<string> mountHost{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> nasId{};
  shared_ptr<string> ossAkId{};
  shared_ptr<string> ossAkSecret{};
  shared_ptr<string> ossMountDescs{};
  shared_ptr<string> packageType{};
  shared_ptr<string> packageUrl{};
  shared_ptr<string> packageVersion{};
  shared_ptr<string> phpConfig{};
  shared_ptr<string> phpConfigLocation{};
  shared_ptr<string> postStart{};
  shared_ptr<string> preStop{};
  shared_ptr<string> programmingLanguage{};
  shared_ptr<string> python{};
  shared_ptr<string> pythonModules{};
  shared_ptr<string> refAppId{};
  shared_ptr<long> replicas{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<bool> slice{};
  shared_ptr<string> sliceEnvs{};
  shared_ptr<string> slsConfigs{};
  shared_ptr<long> terminationGracePeriodSeconds{};
  shared_ptr<long> timeout{};
  shared_ptr<string> timezone{};
  shared_ptr<string> tomcatConfig{};
  shared_ptr<string> triggerConfig{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> warStartOptions{};
  shared_ptr<string> webContainer{};
  shared_ptr<string> workload{};

  CreateJobRequest() {}

  explicit CreateJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acrAssumeRoleArn) {
      res["AcrAssumeRoleArn"] = boost::any(*acrAssumeRoleArn);
    }
    if (acrInstanceId) {
      res["AcrInstanceId"] = boost::any(*acrInstanceId);
    }
    if (appDescription) {
      res["AppDescription"] = boost::any(*appDescription);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (autoConfig) {
      res["AutoConfig"] = boost::any(*autoConfig);
    }
    if (backoffLimit) {
      res["BackoffLimit"] = boost::any(*backoffLimit);
    }
    if (command) {
      res["Command"] = boost::any(*command);
    }
    if (commandArgs) {
      res["CommandArgs"] = boost::any(*commandArgs);
    }
    if (concurrencyPolicy) {
      res["ConcurrencyPolicy"] = boost::any(*concurrencyPolicy);
    }
    if (configMapMountDesc) {
      res["ConfigMapMountDesc"] = boost::any(*configMapMountDesc);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (customHostAlias) {
      res["CustomHostAlias"] = boost::any(*customHostAlias);
    }
    if (edasContainerVersion) {
      res["EdasContainerVersion"] = boost::any(*edasContainerVersion);
    }
    if (enableImageAccl) {
      res["EnableImageAccl"] = boost::any(*enableImageAccl);
    }
    if (envs) {
      res["Envs"] = boost::any(*envs);
    }
    if (imagePullSecrets) {
      res["ImagePullSecrets"] = boost::any(*imagePullSecrets);
    }
    if (imageUrl) {
      res["ImageUrl"] = boost::any(*imageUrl);
    }
    if (jarStartArgs) {
      res["JarStartArgs"] = boost::any(*jarStartArgs);
    }
    if (jarStartOptions) {
      res["JarStartOptions"] = boost::any(*jarStartOptions);
    }
    if (jdk) {
      res["Jdk"] = boost::any(*jdk);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (mountDesc) {
      res["MountDesc"] = boost::any(*mountDesc);
    }
    if (mountHost) {
      res["MountHost"] = boost::any(*mountHost);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (nasId) {
      res["NasId"] = boost::any(*nasId);
    }
    if (ossAkId) {
      res["OssAkId"] = boost::any(*ossAkId);
    }
    if (ossAkSecret) {
      res["OssAkSecret"] = boost::any(*ossAkSecret);
    }
    if (ossMountDescs) {
      res["OssMountDescs"] = boost::any(*ossMountDescs);
    }
    if (packageType) {
      res["PackageType"] = boost::any(*packageType);
    }
    if (packageUrl) {
      res["PackageUrl"] = boost::any(*packageUrl);
    }
    if (packageVersion) {
      res["PackageVersion"] = boost::any(*packageVersion);
    }
    if (phpConfig) {
      res["PhpConfig"] = boost::any(*phpConfig);
    }
    if (phpConfigLocation) {
      res["PhpConfigLocation"] = boost::any(*phpConfigLocation);
    }
    if (postStart) {
      res["PostStart"] = boost::any(*postStart);
    }
    if (preStop) {
      res["PreStop"] = boost::any(*preStop);
    }
    if (programmingLanguage) {
      res["ProgrammingLanguage"] = boost::any(*programmingLanguage);
    }
    if (python) {
      res["Python"] = boost::any(*python);
    }
    if (pythonModules) {
      res["PythonModules"] = boost::any(*pythonModules);
    }
    if (refAppId) {
      res["RefAppId"] = boost::any(*refAppId);
    }
    if (replicas) {
      res["Replicas"] = boost::any(*replicas);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (slice) {
      res["Slice"] = boost::any(*slice);
    }
    if (sliceEnvs) {
      res["SliceEnvs"] = boost::any(*sliceEnvs);
    }
    if (slsConfigs) {
      res["SlsConfigs"] = boost::any(*slsConfigs);
    }
    if (terminationGracePeriodSeconds) {
      res["TerminationGracePeriodSeconds"] = boost::any(*terminationGracePeriodSeconds);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (timezone) {
      res["Timezone"] = boost::any(*timezone);
    }
    if (tomcatConfig) {
      res["TomcatConfig"] = boost::any(*tomcatConfig);
    }
    if (triggerConfig) {
      res["TriggerConfig"] = boost::any(*triggerConfig);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (warStartOptions) {
      res["WarStartOptions"] = boost::any(*warStartOptions);
    }
    if (webContainer) {
      res["WebContainer"] = boost::any(*webContainer);
    }
    if (workload) {
      res["Workload"] = boost::any(*workload);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcrAssumeRoleArn") != m.end() && !m["AcrAssumeRoleArn"].empty()) {
      acrAssumeRoleArn = make_shared<string>(boost::any_cast<string>(m["AcrAssumeRoleArn"]));
    }
    if (m.find("AcrInstanceId") != m.end() && !m["AcrInstanceId"].empty()) {
      acrInstanceId = make_shared<string>(boost::any_cast<string>(m["AcrInstanceId"]));
    }
    if (m.find("AppDescription") != m.end() && !m["AppDescription"].empty()) {
      appDescription = make_shared<string>(boost::any_cast<string>(m["AppDescription"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AutoConfig") != m.end() && !m["AutoConfig"].empty()) {
      autoConfig = make_shared<bool>(boost::any_cast<bool>(m["AutoConfig"]));
    }
    if (m.find("BackoffLimit") != m.end() && !m["BackoffLimit"].empty()) {
      backoffLimit = make_shared<long>(boost::any_cast<long>(m["BackoffLimit"]));
    }
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
    if (m.find("CommandArgs") != m.end() && !m["CommandArgs"].empty()) {
      commandArgs = make_shared<string>(boost::any_cast<string>(m["CommandArgs"]));
    }
    if (m.find("ConcurrencyPolicy") != m.end() && !m["ConcurrencyPolicy"].empty()) {
      concurrencyPolicy = make_shared<string>(boost::any_cast<string>(m["ConcurrencyPolicy"]));
    }
    if (m.find("ConfigMapMountDesc") != m.end() && !m["ConfigMapMountDesc"].empty()) {
      configMapMountDesc = make_shared<string>(boost::any_cast<string>(m["ConfigMapMountDesc"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("CustomHostAlias") != m.end() && !m["CustomHostAlias"].empty()) {
      customHostAlias = make_shared<string>(boost::any_cast<string>(m["CustomHostAlias"]));
    }
    if (m.find("EdasContainerVersion") != m.end() && !m["EdasContainerVersion"].empty()) {
      edasContainerVersion = make_shared<string>(boost::any_cast<string>(m["EdasContainerVersion"]));
    }
    if (m.find("EnableImageAccl") != m.end() && !m["EnableImageAccl"].empty()) {
      enableImageAccl = make_shared<bool>(boost::any_cast<bool>(m["EnableImageAccl"]));
    }
    if (m.find("Envs") != m.end() && !m["Envs"].empty()) {
      envs = make_shared<string>(boost::any_cast<string>(m["Envs"]));
    }
    if (m.find("ImagePullSecrets") != m.end() && !m["ImagePullSecrets"].empty()) {
      imagePullSecrets = make_shared<string>(boost::any_cast<string>(m["ImagePullSecrets"]));
    }
    if (m.find("ImageUrl") != m.end() && !m["ImageUrl"].empty()) {
      imageUrl = make_shared<string>(boost::any_cast<string>(m["ImageUrl"]));
    }
    if (m.find("JarStartArgs") != m.end() && !m["JarStartArgs"].empty()) {
      jarStartArgs = make_shared<string>(boost::any_cast<string>(m["JarStartArgs"]));
    }
    if (m.find("JarStartOptions") != m.end() && !m["JarStartOptions"].empty()) {
      jarStartOptions = make_shared<string>(boost::any_cast<string>(m["JarStartOptions"]));
    }
    if (m.find("Jdk") != m.end() && !m["Jdk"].empty()) {
      jdk = make_shared<string>(boost::any_cast<string>(m["Jdk"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
    if (m.find("MountDesc") != m.end() && !m["MountDesc"].empty()) {
      mountDesc = make_shared<string>(boost::any_cast<string>(m["MountDesc"]));
    }
    if (m.find("MountHost") != m.end() && !m["MountHost"].empty()) {
      mountHost = make_shared<string>(boost::any_cast<string>(m["MountHost"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("NasId") != m.end() && !m["NasId"].empty()) {
      nasId = make_shared<string>(boost::any_cast<string>(m["NasId"]));
    }
    if (m.find("OssAkId") != m.end() && !m["OssAkId"].empty()) {
      ossAkId = make_shared<string>(boost::any_cast<string>(m["OssAkId"]));
    }
    if (m.find("OssAkSecret") != m.end() && !m["OssAkSecret"].empty()) {
      ossAkSecret = make_shared<string>(boost::any_cast<string>(m["OssAkSecret"]));
    }
    if (m.find("OssMountDescs") != m.end() && !m["OssMountDescs"].empty()) {
      ossMountDescs = make_shared<string>(boost::any_cast<string>(m["OssMountDescs"]));
    }
    if (m.find("PackageType") != m.end() && !m["PackageType"].empty()) {
      packageType = make_shared<string>(boost::any_cast<string>(m["PackageType"]));
    }
    if (m.find("PackageUrl") != m.end() && !m["PackageUrl"].empty()) {
      packageUrl = make_shared<string>(boost::any_cast<string>(m["PackageUrl"]));
    }
    if (m.find("PackageVersion") != m.end() && !m["PackageVersion"].empty()) {
      packageVersion = make_shared<string>(boost::any_cast<string>(m["PackageVersion"]));
    }
    if (m.find("PhpConfig") != m.end() && !m["PhpConfig"].empty()) {
      phpConfig = make_shared<string>(boost::any_cast<string>(m["PhpConfig"]));
    }
    if (m.find("PhpConfigLocation") != m.end() && !m["PhpConfigLocation"].empty()) {
      phpConfigLocation = make_shared<string>(boost::any_cast<string>(m["PhpConfigLocation"]));
    }
    if (m.find("PostStart") != m.end() && !m["PostStart"].empty()) {
      postStart = make_shared<string>(boost::any_cast<string>(m["PostStart"]));
    }
    if (m.find("PreStop") != m.end() && !m["PreStop"].empty()) {
      preStop = make_shared<string>(boost::any_cast<string>(m["PreStop"]));
    }
    if (m.find("ProgrammingLanguage") != m.end() && !m["ProgrammingLanguage"].empty()) {
      programmingLanguage = make_shared<string>(boost::any_cast<string>(m["ProgrammingLanguage"]));
    }
    if (m.find("Python") != m.end() && !m["Python"].empty()) {
      python = make_shared<string>(boost::any_cast<string>(m["Python"]));
    }
    if (m.find("PythonModules") != m.end() && !m["PythonModules"].empty()) {
      pythonModules = make_shared<string>(boost::any_cast<string>(m["PythonModules"]));
    }
    if (m.find("RefAppId") != m.end() && !m["RefAppId"].empty()) {
      refAppId = make_shared<string>(boost::any_cast<string>(m["RefAppId"]));
    }
    if (m.find("Replicas") != m.end() && !m["Replicas"].empty()) {
      replicas = make_shared<long>(boost::any_cast<long>(m["Replicas"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("Slice") != m.end() && !m["Slice"].empty()) {
      slice = make_shared<bool>(boost::any_cast<bool>(m["Slice"]));
    }
    if (m.find("SliceEnvs") != m.end() && !m["SliceEnvs"].empty()) {
      sliceEnvs = make_shared<string>(boost::any_cast<string>(m["SliceEnvs"]));
    }
    if (m.find("SlsConfigs") != m.end() && !m["SlsConfigs"].empty()) {
      slsConfigs = make_shared<string>(boost::any_cast<string>(m["SlsConfigs"]));
    }
    if (m.find("TerminationGracePeriodSeconds") != m.end() && !m["TerminationGracePeriodSeconds"].empty()) {
      terminationGracePeriodSeconds = make_shared<long>(boost::any_cast<long>(m["TerminationGracePeriodSeconds"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("Timezone") != m.end() && !m["Timezone"].empty()) {
      timezone = make_shared<string>(boost::any_cast<string>(m["Timezone"]));
    }
    if (m.find("TomcatConfig") != m.end() && !m["TomcatConfig"].empty()) {
      tomcatConfig = make_shared<string>(boost::any_cast<string>(m["TomcatConfig"]));
    }
    if (m.find("TriggerConfig") != m.end() && !m["TriggerConfig"].empty()) {
      triggerConfig = make_shared<string>(boost::any_cast<string>(m["TriggerConfig"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("WarStartOptions") != m.end() && !m["WarStartOptions"].empty()) {
      warStartOptions = make_shared<string>(boost::any_cast<string>(m["WarStartOptions"]));
    }
    if (m.find("WebContainer") != m.end() && !m["WebContainer"].empty()) {
      webContainer = make_shared<string>(boost::any_cast<string>(m["WebContainer"]));
    }
    if (m.find("Workload") != m.end() && !m["Workload"].empty()) {
      workload = make_shared<string>(boost::any_cast<string>(m["Workload"]));
    }
  }


  virtual ~CreateJobRequest() = default;
};
class CreateJobResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> changeOrderId{};

  CreateJobResponseBodyData() {}

  explicit CreateJobResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
  }


  virtual ~CreateJobResponseBodyData() = default;
};
class CreateJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CreateJobResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  CreateJobResponseBody() {}

  explicit CreateJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateJobResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateJobResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~CreateJobResponseBody() = default;
};
class CreateJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateJobResponseBody> body{};

  CreateJobResponse() {}

  explicit CreateJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateJobResponseBody>(model1);
      }
    }
  }


  virtual ~CreateJobResponse() = default;
};
class CreateNamespaceRequest : public Darabonba::Model {
public:
  shared_ptr<bool> enableMicroRegistration{};
  shared_ptr<string> nameSpaceShortId{};
  shared_ptr<string> namespaceDescription{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> namespaceName{};

  CreateNamespaceRequest() {}

  explicit CreateNamespaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableMicroRegistration) {
      res["EnableMicroRegistration"] = boost::any(*enableMicroRegistration);
    }
    if (nameSpaceShortId) {
      res["NameSpaceShortId"] = boost::any(*nameSpaceShortId);
    }
    if (namespaceDescription) {
      res["NamespaceDescription"] = boost::any(*namespaceDescription);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (namespaceName) {
      res["NamespaceName"] = boost::any(*namespaceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableMicroRegistration") != m.end() && !m["EnableMicroRegistration"].empty()) {
      enableMicroRegistration = make_shared<bool>(boost::any_cast<bool>(m["EnableMicroRegistration"]));
    }
    if (m.find("NameSpaceShortId") != m.end() && !m["NameSpaceShortId"].empty()) {
      nameSpaceShortId = make_shared<string>(boost::any_cast<string>(m["NameSpaceShortId"]));
    }
    if (m.find("NamespaceDescription") != m.end() && !m["NamespaceDescription"].empty()) {
      namespaceDescription = make_shared<string>(boost::any_cast<string>(m["NamespaceDescription"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("NamespaceName") != m.end() && !m["NamespaceName"].empty()) {
      namespaceName = make_shared<string>(boost::any_cast<string>(m["NamespaceName"]));
    }
  }


  virtual ~CreateNamespaceRequest() = default;
};
class CreateNamespaceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> enableMicroRegistration{};
  shared_ptr<string> nameSpaceShortId{};
  shared_ptr<string> namespaceDescription{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> namespaceName{};
  shared_ptr<string> regionId{};

  CreateNamespaceResponseBodyData() {}

  explicit CreateNamespaceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableMicroRegistration) {
      res["EnableMicroRegistration"] = boost::any(*enableMicroRegistration);
    }
    if (nameSpaceShortId) {
      res["NameSpaceShortId"] = boost::any(*nameSpaceShortId);
    }
    if (namespaceDescription) {
      res["NamespaceDescription"] = boost::any(*namespaceDescription);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (namespaceName) {
      res["NamespaceName"] = boost::any(*namespaceName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableMicroRegistration") != m.end() && !m["EnableMicroRegistration"].empty()) {
      enableMicroRegistration = make_shared<bool>(boost::any_cast<bool>(m["EnableMicroRegistration"]));
    }
    if (m.find("NameSpaceShortId") != m.end() && !m["NameSpaceShortId"].empty()) {
      nameSpaceShortId = make_shared<string>(boost::any_cast<string>(m["NameSpaceShortId"]));
    }
    if (m.find("NamespaceDescription") != m.end() && !m["NamespaceDescription"].empty()) {
      namespaceDescription = make_shared<string>(boost::any_cast<string>(m["NamespaceDescription"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("NamespaceName") != m.end() && !m["NamespaceName"].empty()) {
      namespaceName = make_shared<string>(boost::any_cast<string>(m["NamespaceName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreateNamespaceResponseBodyData() = default;
};
class CreateNamespaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CreateNamespaceResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  CreateNamespaceResponseBody() {}

  explicit CreateNamespaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateNamespaceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateNamespaceResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~CreateNamespaceResponseBody() = default;
};
class CreateNamespaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateNamespaceResponseBody> body{};

  CreateNamespaceResponse() {}

  explicit CreateNamespaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateNamespaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateNamespaceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateNamespaceResponse() = default;
};
class CreateOrUpdateSwimmingLaneRequestAppEntryRuleConditions : public Darabonba::Model {
public:
  shared_ptr<string> condition{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  CreateOrUpdateSwimmingLaneRequestAppEntryRuleConditions() {}

  explicit CreateOrUpdateSwimmingLaneRequestAppEntryRuleConditions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (condition) {
      res["Condition"] = boost::any(*condition);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Condition") != m.end() && !m["Condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["Condition"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateOrUpdateSwimmingLaneRequestAppEntryRuleConditions() = default;
};
class CreateOrUpdateSwimmingLaneRequestAppEntryRule : public Darabonba::Model {
public:
  shared_ptr<string> conditionJoiner{};
  shared_ptr<vector<CreateOrUpdateSwimmingLaneRequestAppEntryRuleConditions>> conditions{};
  shared_ptr<bool> independentPercentageEnable{};
  shared_ptr<vector<string>> paths{};
  shared_ptr<long> percentage{};
  shared_ptr<map<string, long>> percentageByPath{};

  CreateOrUpdateSwimmingLaneRequestAppEntryRule() {}

  explicit CreateOrUpdateSwimmingLaneRequestAppEntryRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conditionJoiner) {
      res["ConditionJoiner"] = boost::any(*conditionJoiner);
    }
    if (conditions) {
      vector<boost::any> temp1;
      for(auto item1:*conditions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Conditions"] = boost::any(temp1);
    }
    if (independentPercentageEnable) {
      res["IndependentPercentageEnable"] = boost::any(*independentPercentageEnable);
    }
    if (paths) {
      res["Paths"] = boost::any(*paths);
    }
    if (percentage) {
      res["Percentage"] = boost::any(*percentage);
    }
    if (percentageByPath) {
      res["PercentageByPath"] = boost::any(*percentageByPath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConditionJoiner") != m.end() && !m["ConditionJoiner"].empty()) {
      conditionJoiner = make_shared<string>(boost::any_cast<string>(m["ConditionJoiner"]));
    }
    if (m.find("Conditions") != m.end() && !m["Conditions"].empty()) {
      if (typeid(vector<boost::any>) == m["Conditions"].type()) {
        vector<CreateOrUpdateSwimmingLaneRequestAppEntryRuleConditions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Conditions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateOrUpdateSwimmingLaneRequestAppEntryRuleConditions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        conditions = make_shared<vector<CreateOrUpdateSwimmingLaneRequestAppEntryRuleConditions>>(expect1);
      }
    }
    if (m.find("IndependentPercentageEnable") != m.end() && !m["IndependentPercentageEnable"].empty()) {
      independentPercentageEnable = make_shared<bool>(boost::any_cast<bool>(m["IndependentPercentageEnable"]));
    }
    if (m.find("Paths") != m.end() && !m["Paths"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Paths"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Paths"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      paths = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Percentage") != m.end() && !m["Percentage"].empty()) {
      percentage = make_shared<long>(boost::any_cast<long>(m["Percentage"]));
    }
    if (m.find("PercentageByPath") != m.end() && !m["PercentageByPath"].empty()) {
      map<string, long> map1 = boost::any_cast<map<string, long>>(m["PercentageByPath"]);
      map<string, long> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      percentageByPath = make_shared<map<string, long>>(toMap1);
    }
  }


  virtual ~CreateOrUpdateSwimmingLaneRequestAppEntryRule() = default;
};
class CreateOrUpdateSwimmingLaneRequestMseGatewayEntryRuleConditions : public Darabonba::Model {
public:
  shared_ptr<string> condition{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  CreateOrUpdateSwimmingLaneRequestMseGatewayEntryRuleConditions() {}

  explicit CreateOrUpdateSwimmingLaneRequestMseGatewayEntryRuleConditions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (condition) {
      res["Condition"] = boost::any(*condition);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Condition") != m.end() && !m["Condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["Condition"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateOrUpdateSwimmingLaneRequestMseGatewayEntryRuleConditions() = default;
};
class CreateOrUpdateSwimmingLaneRequestMseGatewayEntryRule : public Darabonba::Model {
public:
  shared_ptr<string> conditionJoiner{};
  shared_ptr<vector<CreateOrUpdateSwimmingLaneRequestMseGatewayEntryRuleConditions>> conditions{};
  shared_ptr<bool> independentPercentageEnable{};
  shared_ptr<long> percentage{};
  shared_ptr<map<string, long>> percentageByRoute{};
  shared_ptr<vector<long>> routeIds{};

  CreateOrUpdateSwimmingLaneRequestMseGatewayEntryRule() {}

  explicit CreateOrUpdateSwimmingLaneRequestMseGatewayEntryRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conditionJoiner) {
      res["ConditionJoiner"] = boost::any(*conditionJoiner);
    }
    if (conditions) {
      vector<boost::any> temp1;
      for(auto item1:*conditions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Conditions"] = boost::any(temp1);
    }
    if (independentPercentageEnable) {
      res["IndependentPercentageEnable"] = boost::any(*independentPercentageEnable);
    }
    if (percentage) {
      res["Percentage"] = boost::any(*percentage);
    }
    if (percentageByRoute) {
      res["PercentageByRoute"] = boost::any(*percentageByRoute);
    }
    if (routeIds) {
      res["RouteIds"] = boost::any(*routeIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConditionJoiner") != m.end() && !m["ConditionJoiner"].empty()) {
      conditionJoiner = make_shared<string>(boost::any_cast<string>(m["ConditionJoiner"]));
    }
    if (m.find("Conditions") != m.end() && !m["Conditions"].empty()) {
      if (typeid(vector<boost::any>) == m["Conditions"].type()) {
        vector<CreateOrUpdateSwimmingLaneRequestMseGatewayEntryRuleConditions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Conditions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateOrUpdateSwimmingLaneRequestMseGatewayEntryRuleConditions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        conditions = make_shared<vector<CreateOrUpdateSwimmingLaneRequestMseGatewayEntryRuleConditions>>(expect1);
      }
    }
    if (m.find("IndependentPercentageEnable") != m.end() && !m["IndependentPercentageEnable"].empty()) {
      independentPercentageEnable = make_shared<bool>(boost::any_cast<bool>(m["IndependentPercentageEnable"]));
    }
    if (m.find("Percentage") != m.end() && !m["Percentage"].empty()) {
      percentage = make_shared<long>(boost::any_cast<long>(m["Percentage"]));
    }
    if (m.find("PercentageByRoute") != m.end() && !m["PercentageByRoute"].empty()) {
      map<string, long> map1 = boost::any_cast<map<string, long>>(m["PercentageByRoute"]);
      map<string, long> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      percentageByRoute = make_shared<map<string, long>>(toMap1);
    }
    if (m.find("RouteIds") != m.end() && !m["RouteIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["RouteIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RouteIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      routeIds = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~CreateOrUpdateSwimmingLaneRequestMseGatewayEntryRule() = default;
};
class CreateOrUpdateSwimmingLaneRequest : public Darabonba::Model {
public:
  shared_ptr<CreateOrUpdateSwimmingLaneRequestAppEntryRule> appEntryRule{};
  shared_ptr<long> canaryModel{};
  shared_ptr<bool> enable{};
  shared_ptr<long> groupId{};
  shared_ptr<long> laneId{};
  shared_ptr<string> laneName{};
  shared_ptr<string> laneTag{};
  shared_ptr<CreateOrUpdateSwimmingLaneRequestMseGatewayEntryRule> mseGatewayEntryRule{};
  shared_ptr<string> namespaceId{};

  CreateOrUpdateSwimmingLaneRequest() {}

  explicit CreateOrUpdateSwimmingLaneRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appEntryRule) {
      res["AppEntryRule"] = appEntryRule ? boost::any(appEntryRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (canaryModel) {
      res["CanaryModel"] = boost::any(*canaryModel);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (laneId) {
      res["LaneId"] = boost::any(*laneId);
    }
    if (laneName) {
      res["LaneName"] = boost::any(*laneName);
    }
    if (laneTag) {
      res["LaneTag"] = boost::any(*laneTag);
    }
    if (mseGatewayEntryRule) {
      res["MseGatewayEntryRule"] = mseGatewayEntryRule ? boost::any(mseGatewayEntryRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppEntryRule") != m.end() && !m["AppEntryRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["AppEntryRule"].type()) {
        CreateOrUpdateSwimmingLaneRequestAppEntryRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AppEntryRule"]));
        appEntryRule = make_shared<CreateOrUpdateSwimmingLaneRequestAppEntryRule>(model1);
      }
    }
    if (m.find("CanaryModel") != m.end() && !m["CanaryModel"].empty()) {
      canaryModel = make_shared<long>(boost::any_cast<long>(m["CanaryModel"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("LaneId") != m.end() && !m["LaneId"].empty()) {
      laneId = make_shared<long>(boost::any_cast<long>(m["LaneId"]));
    }
    if (m.find("LaneName") != m.end() && !m["LaneName"].empty()) {
      laneName = make_shared<string>(boost::any_cast<string>(m["LaneName"]));
    }
    if (m.find("LaneTag") != m.end() && !m["LaneTag"].empty()) {
      laneTag = make_shared<string>(boost::any_cast<string>(m["LaneTag"]));
    }
    if (m.find("MseGatewayEntryRule") != m.end() && !m["MseGatewayEntryRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["MseGatewayEntryRule"].type()) {
        CreateOrUpdateSwimmingLaneRequestMseGatewayEntryRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MseGatewayEntryRule"]));
        mseGatewayEntryRule = make_shared<CreateOrUpdateSwimmingLaneRequestMseGatewayEntryRule>(model1);
      }
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
  }


  virtual ~CreateOrUpdateSwimmingLaneRequest() = default;
};
class CreateOrUpdateSwimmingLaneShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> appEntryRuleShrink{};
  shared_ptr<long> canaryModel{};
  shared_ptr<bool> enable{};
  shared_ptr<long> groupId{};
  shared_ptr<long> laneId{};
  shared_ptr<string> laneName{};
  shared_ptr<string> laneTag{};
  shared_ptr<string> mseGatewayEntryRuleShrink{};
  shared_ptr<string> namespaceId{};

  CreateOrUpdateSwimmingLaneShrinkRequest() {}

  explicit CreateOrUpdateSwimmingLaneShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appEntryRuleShrink) {
      res["AppEntryRule"] = boost::any(*appEntryRuleShrink);
    }
    if (canaryModel) {
      res["CanaryModel"] = boost::any(*canaryModel);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (laneId) {
      res["LaneId"] = boost::any(*laneId);
    }
    if (laneName) {
      res["LaneName"] = boost::any(*laneName);
    }
    if (laneTag) {
      res["LaneTag"] = boost::any(*laneTag);
    }
    if (mseGatewayEntryRuleShrink) {
      res["MseGatewayEntryRule"] = boost::any(*mseGatewayEntryRuleShrink);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppEntryRule") != m.end() && !m["AppEntryRule"].empty()) {
      appEntryRuleShrink = make_shared<string>(boost::any_cast<string>(m["AppEntryRule"]));
    }
    if (m.find("CanaryModel") != m.end() && !m["CanaryModel"].empty()) {
      canaryModel = make_shared<long>(boost::any_cast<long>(m["CanaryModel"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("LaneId") != m.end() && !m["LaneId"].empty()) {
      laneId = make_shared<long>(boost::any_cast<long>(m["LaneId"]));
    }
    if (m.find("LaneName") != m.end() && !m["LaneName"].empty()) {
      laneName = make_shared<string>(boost::any_cast<string>(m["LaneName"]));
    }
    if (m.find("LaneTag") != m.end() && !m["LaneTag"].empty()) {
      laneTag = make_shared<string>(boost::any_cast<string>(m["LaneTag"]));
    }
    if (m.find("MseGatewayEntryRule") != m.end() && !m["MseGatewayEntryRule"].empty()) {
      mseGatewayEntryRuleShrink = make_shared<string>(boost::any_cast<string>(m["MseGatewayEntryRule"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
  }


  virtual ~CreateOrUpdateSwimmingLaneShrinkRequest() = default;
};
class CreateOrUpdateSwimmingLaneResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> laneId{};

  CreateOrUpdateSwimmingLaneResponseBodyData() {}

  explicit CreateOrUpdateSwimmingLaneResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (laneId) {
      res["LaneId"] = boost::any(*laneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LaneId") != m.end() && !m["LaneId"].empty()) {
      laneId = make_shared<long>(boost::any_cast<long>(m["LaneId"]));
    }
  }


  virtual ~CreateOrUpdateSwimmingLaneResponseBodyData() = default;
};
class CreateOrUpdateSwimmingLaneResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CreateOrUpdateSwimmingLaneResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  CreateOrUpdateSwimmingLaneResponseBody() {}

  explicit CreateOrUpdateSwimmingLaneResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateOrUpdateSwimmingLaneResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateOrUpdateSwimmingLaneResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~CreateOrUpdateSwimmingLaneResponseBody() = default;
};
class CreateOrUpdateSwimmingLaneResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateOrUpdateSwimmingLaneResponseBody> body{};

  CreateOrUpdateSwimmingLaneResponse() {}

  explicit CreateOrUpdateSwimmingLaneResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOrUpdateSwimmingLaneResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOrUpdateSwimmingLaneResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOrUpdateSwimmingLaneResponse() = default;
};
class CreateOrUpdateSwimmingLaneGroupRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> appIds{};
  shared_ptr<string> entryAppId{};
  shared_ptr<string> entryAppType{};
  shared_ptr<long> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> swimVersion{};

  CreateOrUpdateSwimmingLaneGroupRequest() {}

  explicit CreateOrUpdateSwimmingLaneGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appIds) {
      res["AppIds"] = boost::any(*appIds);
    }
    if (entryAppId) {
      res["EntryAppId"] = boost::any(*entryAppId);
    }
    if (entryAppType) {
      res["EntryAppType"] = boost::any(*entryAppType);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (swimVersion) {
      res["SwimVersion"] = boost::any(*swimVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppIds") != m.end() && !m["AppIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AppIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AppIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      appIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EntryAppId") != m.end() && !m["EntryAppId"].empty()) {
      entryAppId = make_shared<string>(boost::any_cast<string>(m["EntryAppId"]));
    }
    if (m.find("EntryAppType") != m.end() && !m["EntryAppType"].empty()) {
      entryAppType = make_shared<string>(boost::any_cast<string>(m["EntryAppType"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("SwimVersion") != m.end() && !m["SwimVersion"].empty()) {
      swimVersion = make_shared<string>(boost::any_cast<string>(m["SwimVersion"]));
    }
  }


  virtual ~CreateOrUpdateSwimmingLaneGroupRequest() = default;
};
class CreateOrUpdateSwimmingLaneGroupShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> appIdsShrink{};
  shared_ptr<string> entryAppId{};
  shared_ptr<string> entryAppType{};
  shared_ptr<long> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> swimVersion{};

  CreateOrUpdateSwimmingLaneGroupShrinkRequest() {}

  explicit CreateOrUpdateSwimmingLaneGroupShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appIdsShrink) {
      res["AppIds"] = boost::any(*appIdsShrink);
    }
    if (entryAppId) {
      res["EntryAppId"] = boost::any(*entryAppId);
    }
    if (entryAppType) {
      res["EntryAppType"] = boost::any(*entryAppType);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (swimVersion) {
      res["SwimVersion"] = boost::any(*swimVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppIds") != m.end() && !m["AppIds"].empty()) {
      appIdsShrink = make_shared<string>(boost::any_cast<string>(m["AppIds"]));
    }
    if (m.find("EntryAppId") != m.end() && !m["EntryAppId"].empty()) {
      entryAppId = make_shared<string>(boost::any_cast<string>(m["EntryAppId"]));
    }
    if (m.find("EntryAppType") != m.end() && !m["EntryAppType"].empty()) {
      entryAppType = make_shared<string>(boost::any_cast<string>(m["EntryAppType"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("SwimVersion") != m.end() && !m["SwimVersion"].empty()) {
      swimVersion = make_shared<string>(boost::any_cast<string>(m["SwimVersion"]));
    }
  }


  virtual ~CreateOrUpdateSwimmingLaneGroupShrinkRequest() = default;
};
class CreateOrUpdateSwimmingLaneGroupResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> groupId{};

  CreateOrUpdateSwimmingLaneGroupResponseBodyData() {}

  explicit CreateOrUpdateSwimmingLaneGroupResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
  }


  virtual ~CreateOrUpdateSwimmingLaneGroupResponseBodyData() = default;
};
class CreateOrUpdateSwimmingLaneGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CreateOrUpdateSwimmingLaneGroupResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  CreateOrUpdateSwimmingLaneGroupResponseBody() {}

  explicit CreateOrUpdateSwimmingLaneGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateOrUpdateSwimmingLaneGroupResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateOrUpdateSwimmingLaneGroupResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~CreateOrUpdateSwimmingLaneGroupResponseBody() = default;
};
class CreateOrUpdateSwimmingLaneGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateOrUpdateSwimmingLaneGroupResponseBody> body{};

  CreateOrUpdateSwimmingLaneGroupResponse() {}

  explicit CreateOrUpdateSwimmingLaneGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOrUpdateSwimmingLaneGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOrUpdateSwimmingLaneGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOrUpdateSwimmingLaneGroupResponse() = default;
};
class CreateSecretRequestSecretData : public Darabonba::Model {
public:
  shared_ptr<string> secretData{};

  CreateSecretRequestSecretData() {}

  explicit CreateSecretRequestSecretData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (secretData) {
      res["SecretData"] = boost::any(*secretData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecretData") != m.end() && !m["SecretData"].empty()) {
      secretData = make_shared<string>(boost::any_cast<string>(m["SecretData"]));
    }
  }


  virtual ~CreateSecretRequestSecretData() = default;
};
class CreateSecretRequest : public Darabonba::Model {
public:
  shared_ptr<string> namespaceId{};
  shared_ptr<CreateSecretRequestSecretData> secretData{};
  shared_ptr<string> secretName{};
  shared_ptr<string> secretType{};

  CreateSecretRequest() {}

  explicit CreateSecretRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (secretData) {
      res["SecretData"] = secretData ? boost::any(secretData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (secretName) {
      res["SecretName"] = boost::any(*secretName);
    }
    if (secretType) {
      res["SecretType"] = boost::any(*secretType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("SecretData") != m.end() && !m["SecretData"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecretData"].type()) {
        CreateSecretRequestSecretData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecretData"]));
        secretData = make_shared<CreateSecretRequestSecretData>(model1);
      }
    }
    if (m.find("SecretName") != m.end() && !m["SecretName"].empty()) {
      secretName = make_shared<string>(boost::any_cast<string>(m["SecretName"]));
    }
    if (m.find("SecretType") != m.end() && !m["SecretType"].empty()) {
      secretType = make_shared<string>(boost::any_cast<string>(m["SecretType"]));
    }
  }


  virtual ~CreateSecretRequest() = default;
};
class CreateSecretShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> namespaceId{};
  shared_ptr<string> secretDataShrink{};
  shared_ptr<string> secretName{};
  shared_ptr<string> secretType{};

  CreateSecretShrinkRequest() {}

  explicit CreateSecretShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (secretDataShrink) {
      res["SecretData"] = boost::any(*secretDataShrink);
    }
    if (secretName) {
      res["SecretName"] = boost::any(*secretName);
    }
    if (secretType) {
      res["SecretType"] = boost::any(*secretType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("SecretData") != m.end() && !m["SecretData"].empty()) {
      secretDataShrink = make_shared<string>(boost::any_cast<string>(m["SecretData"]));
    }
    if (m.find("SecretName") != m.end() && !m["SecretName"].empty()) {
      secretName = make_shared<string>(boost::any_cast<string>(m["SecretName"]));
    }
    if (m.find("SecretType") != m.end() && !m["SecretType"].empty()) {
      secretType = make_shared<string>(boost::any_cast<string>(m["SecretType"]));
    }
  }


  virtual ~CreateSecretShrinkRequest() = default;
};
class CreateSecretResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> secretId{};

  CreateSecretResponseBodyData() {}

  explicit CreateSecretResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (secretId) {
      res["SecretId"] = boost::any(*secretId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecretId") != m.end() && !m["SecretId"].empty()) {
      secretId = make_shared<long>(boost::any_cast<long>(m["SecretId"]));
    }
  }


  virtual ~CreateSecretResponseBodyData() = default;
};
class CreateSecretResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CreateSecretResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  CreateSecretResponseBody() {}

  explicit CreateSecretResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateSecretResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateSecretResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~CreateSecretResponseBody() = default;
};
class CreateSecretResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSecretResponseBody> body{};

  CreateSecretResponse() {}

  explicit CreateSecretResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSecretResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSecretResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSecretResponse() = default;
};
class CreateWebApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> namespaceId{};
  shared_ptr<CreateWebApplicationInput> body{};

  CreateWebApplicationRequest() {}

  explicit CreateWebApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateWebApplicationInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateWebApplicationInput>(model1);
      }
    }
  }


  virtual ~CreateWebApplicationRequest() = default;
};
class CreateWebApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<WebApplicationBody> body{};

  CreateWebApplicationResponse() {}

  explicit CreateWebApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        WebApplicationBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<WebApplicationBody>(model1);
      }
    }
  }


  virtual ~CreateWebApplicationResponse() = default;
};
class CreateWebCustomDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> namespaceId{};
  shared_ptr<CreateWebCustomDomainInput> body{};

  CreateWebCustomDomainRequest() {}

  explicit CreateWebCustomDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateWebCustomDomainInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateWebCustomDomainInput>(model1);
      }
    }
  }


  virtual ~CreateWebCustomDomainRequest() = default;
};
class CreateWebCustomDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<WebCustomDomainBody> body{};

  CreateWebCustomDomainResponse() {}

  explicit CreateWebCustomDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        WebCustomDomainBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<WebCustomDomainBody>(model1);
      }
    }
  }


  virtual ~CreateWebCustomDomainResponse() = default;
};
class DeleteApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  DeleteApplicationRequest() {}

  explicit DeleteApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~DeleteApplicationRequest() = default;
};
class DeleteApplicationResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};

  DeleteApplicationResponseBodyData() {}

  explicit DeleteApplicationResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
  }


  virtual ~DeleteApplicationResponseBodyData() = default;
};
class DeleteApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DeleteApplicationResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  DeleteApplicationResponseBody() {}

  explicit DeleteApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DeleteApplicationResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DeleteApplicationResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~DeleteApplicationResponseBody() = default;
};
class DeleteApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteApplicationResponseBody> body{};

  DeleteApplicationResponse() {}

  explicit DeleteApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteApplicationResponse() = default;
};
class DeleteApplicationScalingRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> scalingRuleName{};

  DeleteApplicationScalingRuleRequest() {}

  explicit DeleteApplicationScalingRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (scalingRuleName) {
      res["ScalingRuleName"] = boost::any(*scalingRuleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ScalingRuleName") != m.end() && !m["ScalingRuleName"].empty()) {
      scalingRuleName = make_shared<string>(boost::any_cast<string>(m["ScalingRuleName"]));
    }
  }


  virtual ~DeleteApplicationScalingRuleRequest() = default;
};
class DeleteApplicationScalingRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  DeleteApplicationScalingRuleResponseBody() {}

  explicit DeleteApplicationScalingRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~DeleteApplicationScalingRuleResponseBody() = default;
};
class DeleteApplicationScalingRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteApplicationScalingRuleResponseBody> body{};

  DeleteApplicationScalingRuleResponse() {}

  explicit DeleteApplicationScalingRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteApplicationScalingRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteApplicationScalingRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteApplicationScalingRuleResponse() = default;
};
class DeleteConfigMapRequest : public Darabonba::Model {
public:
  shared_ptr<long> configMapId{};

  DeleteConfigMapRequest() {}

  explicit DeleteConfigMapRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configMapId) {
      res["ConfigMapId"] = boost::any(*configMapId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigMapId") != m.end() && !m["ConfigMapId"].empty()) {
      configMapId = make_shared<long>(boost::any_cast<long>(m["ConfigMapId"]));
    }
  }


  virtual ~DeleteConfigMapRequest() = default;
};
class DeleteConfigMapResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> configMapId{};

  DeleteConfigMapResponseBodyData() {}

  explicit DeleteConfigMapResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configMapId) {
      res["ConfigMapId"] = boost::any(*configMapId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigMapId") != m.end() && !m["ConfigMapId"].empty()) {
      configMapId = make_shared<long>(boost::any_cast<long>(m["ConfigMapId"]));
    }
  }


  virtual ~DeleteConfigMapResponseBodyData() = default;
};
class DeleteConfigMapResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DeleteConfigMapResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  DeleteConfigMapResponseBody() {}

  explicit DeleteConfigMapResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DeleteConfigMapResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DeleteConfigMapResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~DeleteConfigMapResponseBody() = default;
};
class DeleteConfigMapResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteConfigMapResponseBody> body{};

  DeleteConfigMapResponse() {}

  explicit DeleteConfigMapResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteConfigMapResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteConfigMapResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteConfigMapResponse() = default;
};
class DeleteGreyTagRouteRequest : public Darabonba::Model {
public:
  shared_ptr<long> greyTagRouteId{};

  DeleteGreyTagRouteRequest() {}

  explicit DeleteGreyTagRouteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (greyTagRouteId) {
      res["GreyTagRouteId"] = boost::any(*greyTagRouteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GreyTagRouteId") != m.end() && !m["GreyTagRouteId"].empty()) {
      greyTagRouteId = make_shared<long>(boost::any_cast<long>(m["GreyTagRouteId"]));
    }
  }


  virtual ~DeleteGreyTagRouteRequest() = default;
};
class DeleteGreyTagRouteResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> greyTagRouteId{};

  DeleteGreyTagRouteResponseBodyData() {}

  explicit DeleteGreyTagRouteResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (greyTagRouteId) {
      res["GreyTagRouteId"] = boost::any(*greyTagRouteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GreyTagRouteId") != m.end() && !m["GreyTagRouteId"].empty()) {
      greyTagRouteId = make_shared<long>(boost::any_cast<long>(m["GreyTagRouteId"]));
    }
  }


  virtual ~DeleteGreyTagRouteResponseBodyData() = default;
};
class DeleteGreyTagRouteResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DeleteGreyTagRouteResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  DeleteGreyTagRouteResponseBody() {}

  explicit DeleteGreyTagRouteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DeleteGreyTagRouteResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DeleteGreyTagRouteResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~DeleteGreyTagRouteResponseBody() = default;
};
class DeleteGreyTagRouteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteGreyTagRouteResponseBody> body{};

  DeleteGreyTagRouteResponse() {}

  explicit DeleteGreyTagRouteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteGreyTagRouteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteGreyTagRouteResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteGreyTagRouteResponse() = default;
};
class DeleteHistoryJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> jobId{};

  DeleteHistoryJobRequest() {}

  explicit DeleteHistoryJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~DeleteHistoryJobRequest() = default;
};
class DeleteHistoryJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  DeleteHistoryJobResponseBody() {}

  explicit DeleteHistoryJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~DeleteHistoryJobResponseBody() = default;
};
class DeleteHistoryJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteHistoryJobResponseBody> body{};

  DeleteHistoryJobResponse() {}

  explicit DeleteHistoryJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteHistoryJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteHistoryJobResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteHistoryJobResponse() = default;
};
class DeleteIngressRequest : public Darabonba::Model {
public:
  shared_ptr<long> ingressId{};

  DeleteIngressRequest() {}

  explicit DeleteIngressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ingressId) {
      res["IngressId"] = boost::any(*ingressId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IngressId") != m.end() && !m["IngressId"].empty()) {
      ingressId = make_shared<long>(boost::any_cast<long>(m["IngressId"]));
    }
  }


  virtual ~DeleteIngressRequest() = default;
};
class DeleteIngressResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> ingressId{};

  DeleteIngressResponseBodyData() {}

  explicit DeleteIngressResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ingressId) {
      res["IngressId"] = boost::any(*ingressId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IngressId") != m.end() && !m["IngressId"].empty()) {
      ingressId = make_shared<long>(boost::any_cast<long>(m["IngressId"]));
    }
  }


  virtual ~DeleteIngressResponseBodyData() = default;
};
class DeleteIngressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DeleteIngressResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  DeleteIngressResponseBody() {}

  explicit DeleteIngressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DeleteIngressResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DeleteIngressResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~DeleteIngressResponseBody() = default;
};
class DeleteIngressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteIngressResponseBody> body{};

  DeleteIngressResponse() {}

  explicit DeleteIngressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteIngressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteIngressResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteIngressResponse() = default;
};
class DeleteInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> instanceIds{};

  DeleteInstancesRequest() {}

  explicit DeleteInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
  }


  virtual ~DeleteInstancesRequest() = default;
};
class DeleteInstancesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};

  DeleteInstancesResponseBodyData() {}

  explicit DeleteInstancesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
  }


  virtual ~DeleteInstancesResponseBodyData() = default;
};
class DeleteInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DeleteInstancesResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  DeleteInstancesResponseBody() {}

  explicit DeleteInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DeleteInstancesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DeleteInstancesResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~DeleteInstancesResponseBody() = default;
};
class DeleteInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteInstancesResponseBody> body{};

  DeleteInstancesResponse() {}

  explicit DeleteInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteInstancesResponse() = default;
};
class DeleteJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  DeleteJobRequest() {}

  explicit DeleteJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~DeleteJobRequest() = default;
};
class DeleteJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  DeleteJobResponseBody() {}

  explicit DeleteJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~DeleteJobResponseBody() = default;
};
class DeleteJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteJobResponseBody> body{};

  DeleteJobResponse() {}

  explicit DeleteJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteJobResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteJobResponse() = default;
};
class DeleteNamespaceRequest : public Darabonba::Model {
public:
  shared_ptr<string> nameSpaceShortId{};
  shared_ptr<string> namespaceId{};

  DeleteNamespaceRequest() {}

  explicit DeleteNamespaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nameSpaceShortId) {
      res["NameSpaceShortId"] = boost::any(*nameSpaceShortId);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NameSpaceShortId") != m.end() && !m["NameSpaceShortId"].empty()) {
      nameSpaceShortId = make_shared<string>(boost::any_cast<string>(m["NameSpaceShortId"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
  }


  virtual ~DeleteNamespaceRequest() = default;
};
class DeleteNamespaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  DeleteNamespaceResponseBody() {}

  explicit DeleteNamespaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~DeleteNamespaceResponseBody() = default;
};
class DeleteNamespaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteNamespaceResponseBody> body{};

  DeleteNamespaceResponse() {}

  explicit DeleteNamespaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteNamespaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteNamespaceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteNamespaceResponse() = default;
};
class DeleteSecretRequest : public Darabonba::Model {
public:
  shared_ptr<string> namespaceId{};
  shared_ptr<long> secretId{};

  DeleteSecretRequest() {}

  explicit DeleteSecretRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (secretId) {
      res["SecretId"] = boost::any(*secretId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("SecretId") != m.end() && !m["SecretId"].empty()) {
      secretId = make_shared<long>(boost::any_cast<long>(m["SecretId"]));
    }
  }


  virtual ~DeleteSecretRequest() = default;
};
class DeleteSecretResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> secretId{};

  DeleteSecretResponseBodyData() {}

  explicit DeleteSecretResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (secretId) {
      res["SecretId"] = boost::any(*secretId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecretId") != m.end() && !m["SecretId"].empty()) {
      secretId = make_shared<long>(boost::any_cast<long>(m["SecretId"]));
    }
  }


  virtual ~DeleteSecretResponseBodyData() = default;
};
class DeleteSecretResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DeleteSecretResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  DeleteSecretResponseBody() {}

  explicit DeleteSecretResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DeleteSecretResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DeleteSecretResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~DeleteSecretResponseBody() = default;
};
class DeleteSecretResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSecretResponseBody> body{};

  DeleteSecretResponse() {}

  explicit DeleteSecretResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSecretResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSecretResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSecretResponse() = default;
};
class DeleteSwimmingLaneGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> groupId{};
  shared_ptr<string> namespaceId{};

  DeleteSwimmingLaneGroupRequest() {}

  explicit DeleteSwimmingLaneGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
  }


  virtual ~DeleteSwimmingLaneGroupRequest() = default;
};
class DeleteSwimmingLaneGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  DeleteSwimmingLaneGroupResponseBody() {}

  explicit DeleteSwimmingLaneGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~DeleteSwimmingLaneGroupResponseBody() = default;
};
class DeleteSwimmingLaneGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSwimmingLaneGroupResponseBody> body{};

  DeleteSwimmingLaneGroupResponse() {}

  explicit DeleteSwimmingLaneGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSwimmingLaneGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSwimmingLaneGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSwimmingLaneGroupResponse() = default;
};
class DeleteWebApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> namespaceId{};

  DeleteWebApplicationRequest() {}

  explicit DeleteWebApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
  }


  virtual ~DeleteWebApplicationRequest() = default;
};
class DeleteWebApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<WebApplicationBody> body{};

  DeleteWebApplicationResponse() {}

  explicit DeleteWebApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        WebApplicationBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<WebApplicationBody>(model1);
      }
    }
  }


  virtual ~DeleteWebApplicationResponse() = default;
};
class DeleteWebApplicationRevisionRequest : public Darabonba::Model {
public:
  shared_ptr<string> namespaceId{};

  DeleteWebApplicationRevisionRequest() {}

  explicit DeleteWebApplicationRevisionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
  }


  virtual ~DeleteWebApplicationRevisionRequest() = default;
};
class DeleteWebApplicationRevisionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<WebApplicationRevisionBody> body{};

  DeleteWebApplicationRevisionResponse() {}

  explicit DeleteWebApplicationRevisionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        WebApplicationRevisionBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<WebApplicationRevisionBody>(model1);
      }
    }
  }


  virtual ~DeleteWebApplicationRevisionResponse() = default;
};
class DeleteWebCustomDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> namespaceId{};

  DeleteWebCustomDomainRequest() {}

  explicit DeleteWebCustomDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
  }


  virtual ~DeleteWebCustomDomainRequest() = default;
};
class DeleteWebCustomDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<WebCustomDomainBody> body{};

  DeleteWebCustomDomainResponse() {}

  explicit DeleteWebCustomDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        WebCustomDomainBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<WebCustomDomainBody>(model1);
      }
    }
  }


  virtual ~DeleteWebCustomDomainResponse() = default;
};
class DeployApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> acrAssumeRoleArn{};
  shared_ptr<string> acrInstanceId{};
  shared_ptr<string> appId{};
  shared_ptr<bool> associateEip{};
  shared_ptr<bool> autoEnableApplicationScalingRule{};
  shared_ptr<long> batchWaitTime{};
  shared_ptr<string> changeOrderDesc{};
  shared_ptr<string> command{};
  shared_ptr<string> commandArgs{};
  shared_ptr<string> configMapMountDesc{};
  shared_ptr<long> cpu{};
  shared_ptr<string> customHostAlias{};
  shared_ptr<string> customImageNetworkType{};
  shared_ptr<string> deploy{};
  shared_ptr<string> dotnet{};
  shared_ptr<string> edasContainerVersion{};
  shared_ptr<string> enableAhas{};
  shared_ptr<bool> enableCpuBurst{};
  shared_ptr<bool> enableGreyTagRoute{};
  shared_ptr<bool> enableNewArms{};
  shared_ptr<bool> enableSidecarResourceIsolated{};
  shared_ptr<string> envs{};
  shared_ptr<string> gpuConfig{};
  shared_ptr<string> imagePullSecrets{};
  shared_ptr<string> imageUrl{};
  shared_ptr<vector<InitContainerConfig>> initContainersConfig{};
  shared_ptr<string> jarStartArgs{};
  shared_ptr<string> jarStartOptions{};
  shared_ptr<string> jdk{};
  shared_ptr<string> kafkaConfigs{};
  shared_ptr<string> liveness{};
  shared_ptr<long> memory{};
  shared_ptr<string> microRegistration{};
  shared_ptr<string> microRegistrationConfig{};
  shared_ptr<string> microserviceEngineConfig{};
  shared_ptr<long> minReadyInstanceRatio{};
  shared_ptr<long> minReadyInstances{};
  shared_ptr<string> mountDesc{};
  shared_ptr<string> mountHost{};
  shared_ptr<string> nasConfigs{};
  shared_ptr<string> nasId{};
  shared_ptr<string> newSaeVersion{};
  shared_ptr<string> oidcRoleName{};
  shared_ptr<string> ossAkId{};
  shared_ptr<string> ossAkSecret{};
  shared_ptr<string> ossMountDescs{};
  shared_ptr<string> packageType{};
  shared_ptr<string> packageUrl{};
  shared_ptr<string> packageVersion{};
  shared_ptr<string> php{};
  shared_ptr<string> phpArmsConfigLocation{};
  shared_ptr<string> phpConfig{};
  shared_ptr<string> phpConfigLocation{};
  shared_ptr<string> postStart{};
  shared_ptr<string> preStop{};
  shared_ptr<string> pvtzDiscoverySvc{};
  shared_ptr<string> python{};
  shared_ptr<string> pythonModules{};
  shared_ptr<string> readiness{};
  shared_ptr<long> replicas{};
  shared_ptr<string> secretMountDesc{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> serviceTags{};
  shared_ptr<vector<SidecarContainerConfig>> sidecarContainersConfig{};
  shared_ptr<string> slsConfigs{};
  shared_ptr<string> startupProbe{};
  shared_ptr<string> swimlanePvtzDiscoverySvc{};
  shared_ptr<long> terminationGracePeriodSeconds{};
  shared_ptr<string> timezone{};
  shared_ptr<string> tomcatConfig{};
  shared_ptr<string> updateStrategy{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> warStartOptions{};
  shared_ptr<string> webContainer{};

  DeployApplicationRequest() {}

  explicit DeployApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acrAssumeRoleArn) {
      res["AcrAssumeRoleArn"] = boost::any(*acrAssumeRoleArn);
    }
    if (acrInstanceId) {
      res["AcrInstanceId"] = boost::any(*acrInstanceId);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (associateEip) {
      res["AssociateEip"] = boost::any(*associateEip);
    }
    if (autoEnableApplicationScalingRule) {
      res["AutoEnableApplicationScalingRule"] = boost::any(*autoEnableApplicationScalingRule);
    }
    if (batchWaitTime) {
      res["BatchWaitTime"] = boost::any(*batchWaitTime);
    }
    if (changeOrderDesc) {
      res["ChangeOrderDesc"] = boost::any(*changeOrderDesc);
    }
    if (command) {
      res["Command"] = boost::any(*command);
    }
    if (commandArgs) {
      res["CommandArgs"] = boost::any(*commandArgs);
    }
    if (configMapMountDesc) {
      res["ConfigMapMountDesc"] = boost::any(*configMapMountDesc);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (customHostAlias) {
      res["CustomHostAlias"] = boost::any(*customHostAlias);
    }
    if (customImageNetworkType) {
      res["CustomImageNetworkType"] = boost::any(*customImageNetworkType);
    }
    if (deploy) {
      res["Deploy"] = boost::any(*deploy);
    }
    if (dotnet) {
      res["Dotnet"] = boost::any(*dotnet);
    }
    if (edasContainerVersion) {
      res["EdasContainerVersion"] = boost::any(*edasContainerVersion);
    }
    if (enableAhas) {
      res["EnableAhas"] = boost::any(*enableAhas);
    }
    if (enableCpuBurst) {
      res["EnableCpuBurst"] = boost::any(*enableCpuBurst);
    }
    if (enableGreyTagRoute) {
      res["EnableGreyTagRoute"] = boost::any(*enableGreyTagRoute);
    }
    if (enableNewArms) {
      res["EnableNewArms"] = boost::any(*enableNewArms);
    }
    if (enableSidecarResourceIsolated) {
      res["EnableSidecarResourceIsolated"] = boost::any(*enableSidecarResourceIsolated);
    }
    if (envs) {
      res["Envs"] = boost::any(*envs);
    }
    if (gpuConfig) {
      res["GpuConfig"] = boost::any(*gpuConfig);
    }
    if (imagePullSecrets) {
      res["ImagePullSecrets"] = boost::any(*imagePullSecrets);
    }
    if (imageUrl) {
      res["ImageUrl"] = boost::any(*imageUrl);
    }
    if (initContainersConfig) {
      vector<boost::any> temp1;
      for(auto item1:*initContainersConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InitContainersConfig"] = boost::any(temp1);
    }
    if (jarStartArgs) {
      res["JarStartArgs"] = boost::any(*jarStartArgs);
    }
    if (jarStartOptions) {
      res["JarStartOptions"] = boost::any(*jarStartOptions);
    }
    if (jdk) {
      res["Jdk"] = boost::any(*jdk);
    }
    if (kafkaConfigs) {
      res["KafkaConfigs"] = boost::any(*kafkaConfigs);
    }
    if (liveness) {
      res["Liveness"] = boost::any(*liveness);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (microRegistration) {
      res["MicroRegistration"] = boost::any(*microRegistration);
    }
    if (microRegistrationConfig) {
      res["MicroRegistrationConfig"] = boost::any(*microRegistrationConfig);
    }
    if (microserviceEngineConfig) {
      res["MicroserviceEngineConfig"] = boost::any(*microserviceEngineConfig);
    }
    if (minReadyInstanceRatio) {
      res["MinReadyInstanceRatio"] = boost::any(*minReadyInstanceRatio);
    }
    if (minReadyInstances) {
      res["MinReadyInstances"] = boost::any(*minReadyInstances);
    }
    if (mountDesc) {
      res["MountDesc"] = boost::any(*mountDesc);
    }
    if (mountHost) {
      res["MountHost"] = boost::any(*mountHost);
    }
    if (nasConfigs) {
      res["NasConfigs"] = boost::any(*nasConfigs);
    }
    if (nasId) {
      res["NasId"] = boost::any(*nasId);
    }
    if (newSaeVersion) {
      res["NewSaeVersion"] = boost::any(*newSaeVersion);
    }
    if (oidcRoleName) {
      res["OidcRoleName"] = boost::any(*oidcRoleName);
    }
    if (ossAkId) {
      res["OssAkId"] = boost::any(*ossAkId);
    }
    if (ossAkSecret) {
      res["OssAkSecret"] = boost::any(*ossAkSecret);
    }
    if (ossMountDescs) {
      res["OssMountDescs"] = boost::any(*ossMountDescs);
    }
    if (packageType) {
      res["PackageType"] = boost::any(*packageType);
    }
    if (packageUrl) {
      res["PackageUrl"] = boost::any(*packageUrl);
    }
    if (packageVersion) {
      res["PackageVersion"] = boost::any(*packageVersion);
    }
    if (php) {
      res["Php"] = boost::any(*php);
    }
    if (phpArmsConfigLocation) {
      res["PhpArmsConfigLocation"] = boost::any(*phpArmsConfigLocation);
    }
    if (phpConfig) {
      res["PhpConfig"] = boost::any(*phpConfig);
    }
    if (phpConfigLocation) {
      res["PhpConfigLocation"] = boost::any(*phpConfigLocation);
    }
    if (postStart) {
      res["PostStart"] = boost::any(*postStart);
    }
    if (preStop) {
      res["PreStop"] = boost::any(*preStop);
    }
    if (pvtzDiscoverySvc) {
      res["PvtzDiscoverySvc"] = boost::any(*pvtzDiscoverySvc);
    }
    if (python) {
      res["Python"] = boost::any(*python);
    }
    if (pythonModules) {
      res["PythonModules"] = boost::any(*pythonModules);
    }
    if (readiness) {
      res["Readiness"] = boost::any(*readiness);
    }
    if (replicas) {
      res["Replicas"] = boost::any(*replicas);
    }
    if (secretMountDesc) {
      res["SecretMountDesc"] = boost::any(*secretMountDesc);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (serviceTags) {
      res["ServiceTags"] = boost::any(*serviceTags);
    }
    if (sidecarContainersConfig) {
      vector<boost::any> temp1;
      for(auto item1:*sidecarContainersConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SidecarContainersConfig"] = boost::any(temp1);
    }
    if (slsConfigs) {
      res["SlsConfigs"] = boost::any(*slsConfigs);
    }
    if (startupProbe) {
      res["StartupProbe"] = boost::any(*startupProbe);
    }
    if (swimlanePvtzDiscoverySvc) {
      res["SwimlanePvtzDiscoverySvc"] = boost::any(*swimlanePvtzDiscoverySvc);
    }
    if (terminationGracePeriodSeconds) {
      res["TerminationGracePeriodSeconds"] = boost::any(*terminationGracePeriodSeconds);
    }
    if (timezone) {
      res["Timezone"] = boost::any(*timezone);
    }
    if (tomcatConfig) {
      res["TomcatConfig"] = boost::any(*tomcatConfig);
    }
    if (updateStrategy) {
      res["UpdateStrategy"] = boost::any(*updateStrategy);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (warStartOptions) {
      res["WarStartOptions"] = boost::any(*warStartOptions);
    }
    if (webContainer) {
      res["WebContainer"] = boost::any(*webContainer);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcrAssumeRoleArn") != m.end() && !m["AcrAssumeRoleArn"].empty()) {
      acrAssumeRoleArn = make_shared<string>(boost::any_cast<string>(m["AcrAssumeRoleArn"]));
    }
    if (m.find("AcrInstanceId") != m.end() && !m["AcrInstanceId"].empty()) {
      acrInstanceId = make_shared<string>(boost::any_cast<string>(m["AcrInstanceId"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AssociateEip") != m.end() && !m["AssociateEip"].empty()) {
      associateEip = make_shared<bool>(boost::any_cast<bool>(m["AssociateEip"]));
    }
    if (m.find("AutoEnableApplicationScalingRule") != m.end() && !m["AutoEnableApplicationScalingRule"].empty()) {
      autoEnableApplicationScalingRule = make_shared<bool>(boost::any_cast<bool>(m["AutoEnableApplicationScalingRule"]));
    }
    if (m.find("BatchWaitTime") != m.end() && !m["BatchWaitTime"].empty()) {
      batchWaitTime = make_shared<long>(boost::any_cast<long>(m["BatchWaitTime"]));
    }
    if (m.find("ChangeOrderDesc") != m.end() && !m["ChangeOrderDesc"].empty()) {
      changeOrderDesc = make_shared<string>(boost::any_cast<string>(m["ChangeOrderDesc"]));
    }
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
    if (m.find("CommandArgs") != m.end() && !m["CommandArgs"].empty()) {
      commandArgs = make_shared<string>(boost::any_cast<string>(m["CommandArgs"]));
    }
    if (m.find("ConfigMapMountDesc") != m.end() && !m["ConfigMapMountDesc"].empty()) {
      configMapMountDesc = make_shared<string>(boost::any_cast<string>(m["ConfigMapMountDesc"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("CustomHostAlias") != m.end() && !m["CustomHostAlias"].empty()) {
      customHostAlias = make_shared<string>(boost::any_cast<string>(m["CustomHostAlias"]));
    }
    if (m.find("CustomImageNetworkType") != m.end() && !m["CustomImageNetworkType"].empty()) {
      customImageNetworkType = make_shared<string>(boost::any_cast<string>(m["CustomImageNetworkType"]));
    }
    if (m.find("Deploy") != m.end() && !m["Deploy"].empty()) {
      deploy = make_shared<string>(boost::any_cast<string>(m["Deploy"]));
    }
    if (m.find("Dotnet") != m.end() && !m["Dotnet"].empty()) {
      dotnet = make_shared<string>(boost::any_cast<string>(m["Dotnet"]));
    }
    if (m.find("EdasContainerVersion") != m.end() && !m["EdasContainerVersion"].empty()) {
      edasContainerVersion = make_shared<string>(boost::any_cast<string>(m["EdasContainerVersion"]));
    }
    if (m.find("EnableAhas") != m.end() && !m["EnableAhas"].empty()) {
      enableAhas = make_shared<string>(boost::any_cast<string>(m["EnableAhas"]));
    }
    if (m.find("EnableCpuBurst") != m.end() && !m["EnableCpuBurst"].empty()) {
      enableCpuBurst = make_shared<bool>(boost::any_cast<bool>(m["EnableCpuBurst"]));
    }
    if (m.find("EnableGreyTagRoute") != m.end() && !m["EnableGreyTagRoute"].empty()) {
      enableGreyTagRoute = make_shared<bool>(boost::any_cast<bool>(m["EnableGreyTagRoute"]));
    }
    if (m.find("EnableNewArms") != m.end() && !m["EnableNewArms"].empty()) {
      enableNewArms = make_shared<bool>(boost::any_cast<bool>(m["EnableNewArms"]));
    }
    if (m.find("EnableSidecarResourceIsolated") != m.end() && !m["EnableSidecarResourceIsolated"].empty()) {
      enableSidecarResourceIsolated = make_shared<bool>(boost::any_cast<bool>(m["EnableSidecarResourceIsolated"]));
    }
    if (m.find("Envs") != m.end() && !m["Envs"].empty()) {
      envs = make_shared<string>(boost::any_cast<string>(m["Envs"]));
    }
    if (m.find("GpuConfig") != m.end() && !m["GpuConfig"].empty()) {
      gpuConfig = make_shared<string>(boost::any_cast<string>(m["GpuConfig"]));
    }
    if (m.find("ImagePullSecrets") != m.end() && !m["ImagePullSecrets"].empty()) {
      imagePullSecrets = make_shared<string>(boost::any_cast<string>(m["ImagePullSecrets"]));
    }
    if (m.find("ImageUrl") != m.end() && !m["ImageUrl"].empty()) {
      imageUrl = make_shared<string>(boost::any_cast<string>(m["ImageUrl"]));
    }
    if (m.find("InitContainersConfig") != m.end() && !m["InitContainersConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["InitContainersConfig"].type()) {
        vector<InitContainerConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InitContainersConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InitContainerConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        initContainersConfig = make_shared<vector<InitContainerConfig>>(expect1);
      }
    }
    if (m.find("JarStartArgs") != m.end() && !m["JarStartArgs"].empty()) {
      jarStartArgs = make_shared<string>(boost::any_cast<string>(m["JarStartArgs"]));
    }
    if (m.find("JarStartOptions") != m.end() && !m["JarStartOptions"].empty()) {
      jarStartOptions = make_shared<string>(boost::any_cast<string>(m["JarStartOptions"]));
    }
    if (m.find("Jdk") != m.end() && !m["Jdk"].empty()) {
      jdk = make_shared<string>(boost::any_cast<string>(m["Jdk"]));
    }
    if (m.find("KafkaConfigs") != m.end() && !m["KafkaConfigs"].empty()) {
      kafkaConfigs = make_shared<string>(boost::any_cast<string>(m["KafkaConfigs"]));
    }
    if (m.find("Liveness") != m.end() && !m["Liveness"].empty()) {
      liveness = make_shared<string>(boost::any_cast<string>(m["Liveness"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
    if (m.find("MicroRegistration") != m.end() && !m["MicroRegistration"].empty()) {
      microRegistration = make_shared<string>(boost::any_cast<string>(m["MicroRegistration"]));
    }
    if (m.find("MicroRegistrationConfig") != m.end() && !m["MicroRegistrationConfig"].empty()) {
      microRegistrationConfig = make_shared<string>(boost::any_cast<string>(m["MicroRegistrationConfig"]));
    }
    if (m.find("MicroserviceEngineConfig") != m.end() && !m["MicroserviceEngineConfig"].empty()) {
      microserviceEngineConfig = make_shared<string>(boost::any_cast<string>(m["MicroserviceEngineConfig"]));
    }
    if (m.find("MinReadyInstanceRatio") != m.end() && !m["MinReadyInstanceRatio"].empty()) {
      minReadyInstanceRatio = make_shared<long>(boost::any_cast<long>(m["MinReadyInstanceRatio"]));
    }
    if (m.find("MinReadyInstances") != m.end() && !m["MinReadyInstances"].empty()) {
      minReadyInstances = make_shared<long>(boost::any_cast<long>(m["MinReadyInstances"]));
    }
    if (m.find("MountDesc") != m.end() && !m["MountDesc"].empty()) {
      mountDesc = make_shared<string>(boost::any_cast<string>(m["MountDesc"]));
    }
    if (m.find("MountHost") != m.end() && !m["MountHost"].empty()) {
      mountHost = make_shared<string>(boost::any_cast<string>(m["MountHost"]));
    }
    if (m.find("NasConfigs") != m.end() && !m["NasConfigs"].empty()) {
      nasConfigs = make_shared<string>(boost::any_cast<string>(m["NasConfigs"]));
    }
    if (m.find("NasId") != m.end() && !m["NasId"].empty()) {
      nasId = make_shared<string>(boost::any_cast<string>(m["NasId"]));
    }
    if (m.find("NewSaeVersion") != m.end() && !m["NewSaeVersion"].empty()) {
      newSaeVersion = make_shared<string>(boost::any_cast<string>(m["NewSaeVersion"]));
    }
    if (m.find("OidcRoleName") != m.end() && !m["OidcRoleName"].empty()) {
      oidcRoleName = make_shared<string>(boost::any_cast<string>(m["OidcRoleName"]));
    }
    if (m.find("OssAkId") != m.end() && !m["OssAkId"].empty()) {
      ossAkId = make_shared<string>(boost::any_cast<string>(m["OssAkId"]));
    }
    if (m.find("OssAkSecret") != m.end() && !m["OssAkSecret"].empty()) {
      ossAkSecret = make_shared<string>(boost::any_cast<string>(m["OssAkSecret"]));
    }
    if (m.find("OssMountDescs") != m.end() && !m["OssMountDescs"].empty()) {
      ossMountDescs = make_shared<string>(boost::any_cast<string>(m["OssMountDescs"]));
    }
    if (m.find("PackageType") != m.end() && !m["PackageType"].empty()) {
      packageType = make_shared<string>(boost::any_cast<string>(m["PackageType"]));
    }
    if (m.find("PackageUrl") != m.end() && !m["PackageUrl"].empty()) {
      packageUrl = make_shared<string>(boost::any_cast<string>(m["PackageUrl"]));
    }
    if (m.find("PackageVersion") != m.end() && !m["PackageVersion"].empty()) {
      packageVersion = make_shared<string>(boost::any_cast<string>(m["PackageVersion"]));
    }
    if (m.find("Php") != m.end() && !m["Php"].empty()) {
      php = make_shared<string>(boost::any_cast<string>(m["Php"]));
    }
    if (m.find("PhpArmsConfigLocation") != m.end() && !m["PhpArmsConfigLocation"].empty()) {
      phpArmsConfigLocation = make_shared<string>(boost::any_cast<string>(m["PhpArmsConfigLocation"]));
    }
    if (m.find("PhpConfig") != m.end() && !m["PhpConfig"].empty()) {
      phpConfig = make_shared<string>(boost::any_cast<string>(m["PhpConfig"]));
    }
    if (m.find("PhpConfigLocation") != m.end() && !m["PhpConfigLocation"].empty()) {
      phpConfigLocation = make_shared<string>(boost::any_cast<string>(m["PhpConfigLocation"]));
    }
    if (m.find("PostStart") != m.end() && !m["PostStart"].empty()) {
      postStart = make_shared<string>(boost::any_cast<string>(m["PostStart"]));
    }
    if (m.find("PreStop") != m.end() && !m["PreStop"].empty()) {
      preStop = make_shared<string>(boost::any_cast<string>(m["PreStop"]));
    }
    if (m.find("PvtzDiscoverySvc") != m.end() && !m["PvtzDiscoverySvc"].empty()) {
      pvtzDiscoverySvc = make_shared<string>(boost::any_cast<string>(m["PvtzDiscoverySvc"]));
    }
    if (m.find("Python") != m.end() && !m["Python"].empty()) {
      python = make_shared<string>(boost::any_cast<string>(m["Python"]));
    }
    if (m.find("PythonModules") != m.end() && !m["PythonModules"].empty()) {
      pythonModules = make_shared<string>(boost::any_cast<string>(m["PythonModules"]));
    }
    if (m.find("Readiness") != m.end() && !m["Readiness"].empty()) {
      readiness = make_shared<string>(boost::any_cast<string>(m["Readiness"]));
    }
    if (m.find("Replicas") != m.end() && !m["Replicas"].empty()) {
      replicas = make_shared<long>(boost::any_cast<long>(m["Replicas"]));
    }
    if (m.find("SecretMountDesc") != m.end() && !m["SecretMountDesc"].empty()) {
      secretMountDesc = make_shared<string>(boost::any_cast<string>(m["SecretMountDesc"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("ServiceTags") != m.end() && !m["ServiceTags"].empty()) {
      serviceTags = make_shared<string>(boost::any_cast<string>(m["ServiceTags"]));
    }
    if (m.find("SidecarContainersConfig") != m.end() && !m["SidecarContainersConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["SidecarContainersConfig"].type()) {
        vector<SidecarContainerConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SidecarContainersConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SidecarContainerConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sidecarContainersConfig = make_shared<vector<SidecarContainerConfig>>(expect1);
      }
    }
    if (m.find("SlsConfigs") != m.end() && !m["SlsConfigs"].empty()) {
      slsConfigs = make_shared<string>(boost::any_cast<string>(m["SlsConfigs"]));
    }
    if (m.find("StartupProbe") != m.end() && !m["StartupProbe"].empty()) {
      startupProbe = make_shared<string>(boost::any_cast<string>(m["StartupProbe"]));
    }
    if (m.find("SwimlanePvtzDiscoverySvc") != m.end() && !m["SwimlanePvtzDiscoverySvc"].empty()) {
      swimlanePvtzDiscoverySvc = make_shared<string>(boost::any_cast<string>(m["SwimlanePvtzDiscoverySvc"]));
    }
    if (m.find("TerminationGracePeriodSeconds") != m.end() && !m["TerminationGracePeriodSeconds"].empty()) {
      terminationGracePeriodSeconds = make_shared<long>(boost::any_cast<long>(m["TerminationGracePeriodSeconds"]));
    }
    if (m.find("Timezone") != m.end() && !m["Timezone"].empty()) {
      timezone = make_shared<string>(boost::any_cast<string>(m["Timezone"]));
    }
    if (m.find("TomcatConfig") != m.end() && !m["TomcatConfig"].empty()) {
      tomcatConfig = make_shared<string>(boost::any_cast<string>(m["TomcatConfig"]));
    }
    if (m.find("UpdateStrategy") != m.end() && !m["UpdateStrategy"].empty()) {
      updateStrategy = make_shared<string>(boost::any_cast<string>(m["UpdateStrategy"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("WarStartOptions") != m.end() && !m["WarStartOptions"].empty()) {
      warStartOptions = make_shared<string>(boost::any_cast<string>(m["WarStartOptions"]));
    }
    if (m.find("WebContainer") != m.end() && !m["WebContainer"].empty()) {
      webContainer = make_shared<string>(boost::any_cast<string>(m["WebContainer"]));
    }
  }


  virtual ~DeployApplicationRequest() = default;
};
class DeployApplicationShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> acrAssumeRoleArn{};
  shared_ptr<string> acrInstanceId{};
  shared_ptr<string> appId{};
  shared_ptr<bool> associateEip{};
  shared_ptr<bool> autoEnableApplicationScalingRule{};
  shared_ptr<long> batchWaitTime{};
  shared_ptr<string> changeOrderDesc{};
  shared_ptr<string> command{};
  shared_ptr<string> commandArgs{};
  shared_ptr<string> configMapMountDesc{};
  shared_ptr<long> cpu{};
  shared_ptr<string> customHostAlias{};
  shared_ptr<string> customImageNetworkType{};
  shared_ptr<string> deploy{};
  shared_ptr<string> dotnet{};
  shared_ptr<string> edasContainerVersion{};
  shared_ptr<string> enableAhas{};
  shared_ptr<bool> enableCpuBurst{};
  shared_ptr<bool> enableGreyTagRoute{};
  shared_ptr<bool> enableNewArms{};
  shared_ptr<bool> enableSidecarResourceIsolated{};
  shared_ptr<string> envs{};
  shared_ptr<string> gpuConfig{};
  shared_ptr<string> imagePullSecrets{};
  shared_ptr<string> imageUrl{};
  shared_ptr<string> initContainersConfigShrink{};
  shared_ptr<string> jarStartArgs{};
  shared_ptr<string> jarStartOptions{};
  shared_ptr<string> jdk{};
  shared_ptr<string> kafkaConfigs{};
  shared_ptr<string> liveness{};
  shared_ptr<long> memory{};
  shared_ptr<string> microRegistration{};
  shared_ptr<string> microRegistrationConfig{};
  shared_ptr<string> microserviceEngineConfig{};
  shared_ptr<long> minReadyInstanceRatio{};
  shared_ptr<long> minReadyInstances{};
  shared_ptr<string> mountDesc{};
  shared_ptr<string> mountHost{};
  shared_ptr<string> nasConfigs{};
  shared_ptr<string> nasId{};
  shared_ptr<string> newSaeVersion{};
  shared_ptr<string> oidcRoleName{};
  shared_ptr<string> ossAkId{};
  shared_ptr<string> ossAkSecret{};
  shared_ptr<string> ossMountDescs{};
  shared_ptr<string> packageType{};
  shared_ptr<string> packageUrl{};
  shared_ptr<string> packageVersion{};
  shared_ptr<string> php{};
  shared_ptr<string> phpArmsConfigLocation{};
  shared_ptr<string> phpConfig{};
  shared_ptr<string> phpConfigLocation{};
  shared_ptr<string> postStart{};
  shared_ptr<string> preStop{};
  shared_ptr<string> pvtzDiscoverySvc{};
  shared_ptr<string> python{};
  shared_ptr<string> pythonModules{};
  shared_ptr<string> readiness{};
  shared_ptr<long> replicas{};
  shared_ptr<string> secretMountDesc{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> serviceTags{};
  shared_ptr<string> sidecarContainersConfigShrink{};
  shared_ptr<string> slsConfigs{};
  shared_ptr<string> startupProbe{};
  shared_ptr<string> swimlanePvtzDiscoverySvc{};
  shared_ptr<long> terminationGracePeriodSeconds{};
  shared_ptr<string> timezone{};
  shared_ptr<string> tomcatConfig{};
  shared_ptr<string> updateStrategy{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> warStartOptions{};
  shared_ptr<string> webContainer{};

  DeployApplicationShrinkRequest() {}

  explicit DeployApplicationShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acrAssumeRoleArn) {
      res["AcrAssumeRoleArn"] = boost::any(*acrAssumeRoleArn);
    }
    if (acrInstanceId) {
      res["AcrInstanceId"] = boost::any(*acrInstanceId);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (associateEip) {
      res["AssociateEip"] = boost::any(*associateEip);
    }
    if (autoEnableApplicationScalingRule) {
      res["AutoEnableApplicationScalingRule"] = boost::any(*autoEnableApplicationScalingRule);
    }
    if (batchWaitTime) {
      res["BatchWaitTime"] = boost::any(*batchWaitTime);
    }
    if (changeOrderDesc) {
      res["ChangeOrderDesc"] = boost::any(*changeOrderDesc);
    }
    if (command) {
      res["Command"] = boost::any(*command);
    }
    if (commandArgs) {
      res["CommandArgs"] = boost::any(*commandArgs);
    }
    if (configMapMountDesc) {
      res["ConfigMapMountDesc"] = boost::any(*configMapMountDesc);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (customHostAlias) {
      res["CustomHostAlias"] = boost::any(*customHostAlias);
    }
    if (customImageNetworkType) {
      res["CustomImageNetworkType"] = boost::any(*customImageNetworkType);
    }
    if (deploy) {
      res["Deploy"] = boost::any(*deploy);
    }
    if (dotnet) {
      res["Dotnet"] = boost::any(*dotnet);
    }
    if (edasContainerVersion) {
      res["EdasContainerVersion"] = boost::any(*edasContainerVersion);
    }
    if (enableAhas) {
      res["EnableAhas"] = boost::any(*enableAhas);
    }
    if (enableCpuBurst) {
      res["EnableCpuBurst"] = boost::any(*enableCpuBurst);
    }
    if (enableGreyTagRoute) {
      res["EnableGreyTagRoute"] = boost::any(*enableGreyTagRoute);
    }
    if (enableNewArms) {
      res["EnableNewArms"] = boost::any(*enableNewArms);
    }
    if (enableSidecarResourceIsolated) {
      res["EnableSidecarResourceIsolated"] = boost::any(*enableSidecarResourceIsolated);
    }
    if (envs) {
      res["Envs"] = boost::any(*envs);
    }
    if (gpuConfig) {
      res["GpuConfig"] = boost::any(*gpuConfig);
    }
    if (imagePullSecrets) {
      res["ImagePullSecrets"] = boost::any(*imagePullSecrets);
    }
    if (imageUrl) {
      res["ImageUrl"] = boost::any(*imageUrl);
    }
    if (initContainersConfigShrink) {
      res["InitContainersConfig"] = boost::any(*initContainersConfigShrink);
    }
    if (jarStartArgs) {
      res["JarStartArgs"] = boost::any(*jarStartArgs);
    }
    if (jarStartOptions) {
      res["JarStartOptions"] = boost::any(*jarStartOptions);
    }
    if (jdk) {
      res["Jdk"] = boost::any(*jdk);
    }
    if (kafkaConfigs) {
      res["KafkaConfigs"] = boost::any(*kafkaConfigs);
    }
    if (liveness) {
      res["Liveness"] = boost::any(*liveness);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (microRegistration) {
      res["MicroRegistration"] = boost::any(*microRegistration);
    }
    if (microRegistrationConfig) {
      res["MicroRegistrationConfig"] = boost::any(*microRegistrationConfig);
    }
    if (microserviceEngineConfig) {
      res["MicroserviceEngineConfig"] = boost::any(*microserviceEngineConfig);
    }
    if (minReadyInstanceRatio) {
      res["MinReadyInstanceRatio"] = boost::any(*minReadyInstanceRatio);
    }
    if (minReadyInstances) {
      res["MinReadyInstances"] = boost::any(*minReadyInstances);
    }
    if (mountDesc) {
      res["MountDesc"] = boost::any(*mountDesc);
    }
    if (mountHost) {
      res["MountHost"] = boost::any(*mountHost);
    }
    if (nasConfigs) {
      res["NasConfigs"] = boost::any(*nasConfigs);
    }
    if (nasId) {
      res["NasId"] = boost::any(*nasId);
    }
    if (newSaeVersion) {
      res["NewSaeVersion"] = boost::any(*newSaeVersion);
    }
    if (oidcRoleName) {
      res["OidcRoleName"] = boost::any(*oidcRoleName);
    }
    if (ossAkId) {
      res["OssAkId"] = boost::any(*ossAkId);
    }
    if (ossAkSecret) {
      res["OssAkSecret"] = boost::any(*ossAkSecret);
    }
    if (ossMountDescs) {
      res["OssMountDescs"] = boost::any(*ossMountDescs);
    }
    if (packageType) {
      res["PackageType"] = boost::any(*packageType);
    }
    if (packageUrl) {
      res["PackageUrl"] = boost::any(*packageUrl);
    }
    if (packageVersion) {
      res["PackageVersion"] = boost::any(*packageVersion);
    }
    if (php) {
      res["Php"] = boost::any(*php);
    }
    if (phpArmsConfigLocation) {
      res["PhpArmsConfigLocation"] = boost::any(*phpArmsConfigLocation);
    }
    if (phpConfig) {
      res["PhpConfig"] = boost::any(*phpConfig);
    }
    if (phpConfigLocation) {
      res["PhpConfigLocation"] = boost::any(*phpConfigLocation);
    }
    if (postStart) {
      res["PostStart"] = boost::any(*postStart);
    }
    if (preStop) {
      res["PreStop"] = boost::any(*preStop);
    }
    if (pvtzDiscoverySvc) {
      res["PvtzDiscoverySvc"] = boost::any(*pvtzDiscoverySvc);
    }
    if (python) {
      res["Python"] = boost::any(*python);
    }
    if (pythonModules) {
      res["PythonModules"] = boost::any(*pythonModules);
    }
    if (readiness) {
      res["Readiness"] = boost::any(*readiness);
    }
    if (replicas) {
      res["Replicas"] = boost::any(*replicas);
    }
    if (secretMountDesc) {
      res["SecretMountDesc"] = boost::any(*secretMountDesc);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (serviceTags) {
      res["ServiceTags"] = boost::any(*serviceTags);
    }
    if (sidecarContainersConfigShrink) {
      res["SidecarContainersConfig"] = boost::any(*sidecarContainersConfigShrink);
    }
    if (slsConfigs) {
      res["SlsConfigs"] = boost::any(*slsConfigs);
    }
    if (startupProbe) {
      res["StartupProbe"] = boost::any(*startupProbe);
    }
    if (swimlanePvtzDiscoverySvc) {
      res["SwimlanePvtzDiscoverySvc"] = boost::any(*swimlanePvtzDiscoverySvc);
    }
    if (terminationGracePeriodSeconds) {
      res["TerminationGracePeriodSeconds"] = boost::any(*terminationGracePeriodSeconds);
    }
    if (timezone) {
      res["Timezone"] = boost::any(*timezone);
    }
    if (tomcatConfig) {
      res["TomcatConfig"] = boost::any(*tomcatConfig);
    }
    if (updateStrategy) {
      res["UpdateStrategy"] = boost::any(*updateStrategy);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (warStartOptions) {
      res["WarStartOptions"] = boost::any(*warStartOptions);
    }
    if (webContainer) {
      res["WebContainer"] = boost::any(*webContainer);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcrAssumeRoleArn") != m.end() && !m["AcrAssumeRoleArn"].empty()) {
      acrAssumeRoleArn = make_shared<string>(boost::any_cast<string>(m["AcrAssumeRoleArn"]));
    }
    if (m.find("AcrInstanceId") != m.end() && !m["AcrInstanceId"].empty()) {
      acrInstanceId = make_shared<string>(boost::any_cast<string>(m["AcrInstanceId"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AssociateEip") != m.end() && !m["AssociateEip"].empty()) {
      associateEip = make_shared<bool>(boost::any_cast<bool>(m["AssociateEip"]));
    }
    if (m.find("AutoEnableApplicationScalingRule") != m.end() && !m["AutoEnableApplicationScalingRule"].empty()) {
      autoEnableApplicationScalingRule = make_shared<bool>(boost::any_cast<bool>(m["AutoEnableApplicationScalingRule"]));
    }
    if (m.find("BatchWaitTime") != m.end() && !m["BatchWaitTime"].empty()) {
      batchWaitTime = make_shared<long>(boost::any_cast<long>(m["BatchWaitTime"]));
    }
    if (m.find("ChangeOrderDesc") != m.end() && !m["ChangeOrderDesc"].empty()) {
      changeOrderDesc = make_shared<string>(boost::any_cast<string>(m["ChangeOrderDesc"]));
    }
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
    if (m.find("CommandArgs") != m.end() && !m["CommandArgs"].empty()) {
      commandArgs = make_shared<string>(boost::any_cast<string>(m["CommandArgs"]));
    }
    if (m.find("ConfigMapMountDesc") != m.end() && !m["ConfigMapMountDesc"].empty()) {
      configMapMountDesc = make_shared<string>(boost::any_cast<string>(m["ConfigMapMountDesc"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("CustomHostAlias") != m.end() && !m["CustomHostAlias"].empty()) {
      customHostAlias = make_shared<string>(boost::any_cast<string>(m["CustomHostAlias"]));
    }
    if (m.find("CustomImageNetworkType") != m.end() && !m["CustomImageNetworkType"].empty()) {
      customImageNetworkType = make_shared<string>(boost::any_cast<string>(m["CustomImageNetworkType"]));
    }
    if (m.find("Deploy") != m.end() && !m["Deploy"].empty()) {
      deploy = make_shared<string>(boost::any_cast<string>(m["Deploy"]));
    }
    if (m.find("Dotnet") != m.end() && !m["Dotnet"].empty()) {
      dotnet = make_shared<string>(boost::any_cast<string>(m["Dotnet"]));
    }
    if (m.find("EdasContainerVersion") != m.end() && !m["EdasContainerVersion"].empty()) {
      edasContainerVersion = make_shared<string>(boost::any_cast<string>(m["EdasContainerVersion"]));
    }
    if (m.find("EnableAhas") != m.end() && !m["EnableAhas"].empty()) {
      enableAhas = make_shared<string>(boost::any_cast<string>(m["EnableAhas"]));
    }
    if (m.find("EnableCpuBurst") != m.end() && !m["EnableCpuBurst"].empty()) {
      enableCpuBurst = make_shared<bool>(boost::any_cast<bool>(m["EnableCpuBurst"]));
    }
    if (m.find("EnableGreyTagRoute") != m.end() && !m["EnableGreyTagRoute"].empty()) {
      enableGreyTagRoute = make_shared<bool>(boost::any_cast<bool>(m["EnableGreyTagRoute"]));
    }
    if (m.find("EnableNewArms") != m.end() && !m["EnableNewArms"].empty()) {
      enableNewArms = make_shared<bool>(boost::any_cast<bool>(m["EnableNewArms"]));
    }
    if (m.find("EnableSidecarResourceIsolated") != m.end() && !m["EnableSidecarResourceIsolated"].empty()) {
      enableSidecarResourceIsolated = make_shared<bool>(boost::any_cast<bool>(m["EnableSidecarResourceIsolated"]));
    }
    if (m.find("Envs") != m.end() && !m["Envs"].empty()) {
      envs = make_shared<string>(boost::any_cast<string>(m["Envs"]));
    }
    if (m.find("GpuConfig") != m.end() && !m["GpuConfig"].empty()) {
      gpuConfig = make_shared<string>(boost::any_cast<string>(m["GpuConfig"]));
    }
    if (m.find("ImagePullSecrets") != m.end() && !m["ImagePullSecrets"].empty()) {
      imagePullSecrets = make_shared<string>(boost::any_cast<string>(m["ImagePullSecrets"]));
    }
    if (m.find("ImageUrl") != m.end() && !m["ImageUrl"].empty()) {
      imageUrl = make_shared<string>(boost::any_cast<string>(m["ImageUrl"]));
    }
    if (m.find("InitContainersConfig") != m.end() && !m["InitContainersConfig"].empty()) {
      initContainersConfigShrink = make_shared<string>(boost::any_cast<string>(m["InitContainersConfig"]));
    }
    if (m.find("JarStartArgs") != m.end() && !m["JarStartArgs"].empty()) {
      jarStartArgs = make_shared<string>(boost::any_cast<string>(m["JarStartArgs"]));
    }
    if (m.find("JarStartOptions") != m.end() && !m["JarStartOptions"].empty()) {
      jarStartOptions = make_shared<string>(boost::any_cast<string>(m["JarStartOptions"]));
    }
    if (m.find("Jdk") != m.end() && !m["Jdk"].empty()) {
      jdk = make_shared<string>(boost::any_cast<string>(m["Jdk"]));
    }
    if (m.find("KafkaConfigs") != m.end() && !m["KafkaConfigs"].empty()) {
      kafkaConfigs = make_shared<string>(boost::any_cast<string>(m["KafkaConfigs"]));
    }
    if (m.find("Liveness") != m.end() && !m["Liveness"].empty()) {
      liveness = make_shared<string>(boost::any_cast<string>(m["Liveness"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
    if (m.find("MicroRegistration") != m.end() && !m["MicroRegistration"].empty()) {
      microRegistration = make_shared<string>(boost::any_cast<string>(m["MicroRegistration"]));
    }
    if (m.find("MicroRegistrationConfig") != m.end() && !m["MicroRegistrationConfig"].empty()) {
      microRegistrationConfig = make_shared<string>(boost::any_cast<string>(m["MicroRegistrationConfig"]));
    }
    if (m.find("MicroserviceEngineConfig") != m.end() && !m["MicroserviceEngineConfig"].empty()) {
      microserviceEngineConfig = make_shared<string>(boost::any_cast<string>(m["MicroserviceEngineConfig"]));
    }
    if (m.find("MinReadyInstanceRatio") != m.end() && !m["MinReadyInstanceRatio"].empty()) {
      minReadyInstanceRatio = make_shared<long>(boost::any_cast<long>(m["MinReadyInstanceRatio"]));
    }
    if (m.find("MinReadyInstances") != m.end() && !m["MinReadyInstances"].empty()) {
      minReadyInstances = make_shared<long>(boost::any_cast<long>(m["MinReadyInstances"]));
    }
    if (m.find("MountDesc") != m.end() && !m["MountDesc"].empty()) {
      mountDesc = make_shared<string>(boost::any_cast<string>(m["MountDesc"]));
    }
    if (m.find("MountHost") != m.end() && !m["MountHost"].empty()) {
      mountHost = make_shared<string>(boost::any_cast<string>(m["MountHost"]));
    }
    if (m.find("NasConfigs") != m.end() && !m["NasConfigs"].empty()) {
      nasConfigs = make_shared<string>(boost::any_cast<string>(m["NasConfigs"]));
    }
    if (m.find("NasId") != m.end() && !m["NasId"].empty()) {
      nasId = make_shared<string>(boost::any_cast<string>(m["NasId"]));
    }
    if (m.find("NewSaeVersion") != m.end() && !m["NewSaeVersion"].empty()) {
      newSaeVersion = make_shared<string>(boost::any_cast<string>(m["NewSaeVersion"]));
    }
    if (m.find("OidcRoleName") != m.end() && !m["OidcRoleName"].empty()) {
      oidcRoleName = make_shared<string>(boost::any_cast<string>(m["OidcRoleName"]));
    }
    if (m.find("OssAkId") != m.end() && !m["OssAkId"].empty()) {
      ossAkId = make_shared<string>(boost::any_cast<string>(m["OssAkId"]));
    }
    if (m.find("OssAkSecret") != m.end() && !m["OssAkSecret"].empty()) {
      ossAkSecret = make_shared<string>(boost::any_cast<string>(m["OssAkSecret"]));
    }
    if (m.find("OssMountDescs") != m.end() && !m["OssMountDescs"].empty()) {
      ossMountDescs = make_shared<string>(boost::any_cast<string>(m["OssMountDescs"]));
    }
    if (m.find("PackageType") != m.end() && !m["PackageType"].empty()) {
      packageType = make_shared<string>(boost::any_cast<string>(m["PackageType"]));
    }
    if (m.find("PackageUrl") != m.end() && !m["PackageUrl"].empty()) {
      packageUrl = make_shared<string>(boost::any_cast<string>(m["PackageUrl"]));
    }
    if (m.find("PackageVersion") != m.end() && !m["PackageVersion"].empty()) {
      packageVersion = make_shared<string>(boost::any_cast<string>(m["PackageVersion"]));
    }
    if (m.find("Php") != m.end() && !m["Php"].empty()) {
      php = make_shared<string>(boost::any_cast<string>(m["Php"]));
    }
    if (m.find("PhpArmsConfigLocation") != m.end() && !m["PhpArmsConfigLocation"].empty()) {
      phpArmsConfigLocation = make_shared<string>(boost::any_cast<string>(m["PhpArmsConfigLocation"]));
    }
    if (m.find("PhpConfig") != m.end() && !m["PhpConfig"].empty()) {
      phpConfig = make_shared<string>(boost::any_cast<string>(m["PhpConfig"]));
    }
    if (m.find("PhpConfigLocation") != m.end() && !m["PhpConfigLocation"].empty()) {
      phpConfigLocation = make_shared<string>(boost::any_cast<string>(m["PhpConfigLocation"]));
    }
    if (m.find("PostStart") != m.end() && !m["PostStart"].empty()) {
      postStart = make_shared<string>(boost::any_cast<string>(m["PostStart"]));
    }
    if (m.find("PreStop") != m.end() && !m["PreStop"].empty()) {
      preStop = make_shared<string>(boost::any_cast<string>(m["PreStop"]));
    }
    if (m.find("PvtzDiscoverySvc") != m.end() && !m["PvtzDiscoverySvc"].empty()) {
      pvtzDiscoverySvc = make_shared<string>(boost::any_cast<string>(m["PvtzDiscoverySvc"]));
    }
    if (m.find("Python") != m.end() && !m["Python"].empty()) {
      python = make_shared<string>(boost::any_cast<string>(m["Python"]));
    }
    if (m.find("PythonModules") != m.end() && !m["PythonModules"].empty()) {
      pythonModules = make_shared<string>(boost::any_cast<string>(m["PythonModules"]));
    }
    if (m.find("Readiness") != m.end() && !m["Readiness"].empty()) {
      readiness = make_shared<string>(boost::any_cast<string>(m["Readiness"]));
    }
    if (m.find("Replicas") != m.end() && !m["Replicas"].empty()) {
      replicas = make_shared<long>(boost::any_cast<long>(m["Replicas"]));
    }
    if (m.find("SecretMountDesc") != m.end() && !m["SecretMountDesc"].empty()) {
      secretMountDesc = make_shared<string>(boost::any_cast<string>(m["SecretMountDesc"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("ServiceTags") != m.end() && !m["ServiceTags"].empty()) {
      serviceTags = make_shared<string>(boost::any_cast<string>(m["ServiceTags"]));
    }
    if (m.find("SidecarContainersConfig") != m.end() && !m["SidecarContainersConfig"].empty()) {
      sidecarContainersConfigShrink = make_shared<string>(boost::any_cast<string>(m["SidecarContainersConfig"]));
    }
    if (m.find("SlsConfigs") != m.end() && !m["SlsConfigs"].empty()) {
      slsConfigs = make_shared<string>(boost::any_cast<string>(m["SlsConfigs"]));
    }
    if (m.find("StartupProbe") != m.end() && !m["StartupProbe"].empty()) {
      startupProbe = make_shared<string>(boost::any_cast<string>(m["StartupProbe"]));
    }
    if (m.find("SwimlanePvtzDiscoverySvc") != m.end() && !m["SwimlanePvtzDiscoverySvc"].empty()) {
      swimlanePvtzDiscoverySvc = make_shared<string>(boost::any_cast<string>(m["SwimlanePvtzDiscoverySvc"]));
    }
    if (m.find("TerminationGracePeriodSeconds") != m.end() && !m["TerminationGracePeriodSeconds"].empty()) {
      terminationGracePeriodSeconds = make_shared<long>(boost::any_cast<long>(m["TerminationGracePeriodSeconds"]));
    }
    if (m.find("Timezone") != m.end() && !m["Timezone"].empty()) {
      timezone = make_shared<string>(boost::any_cast<string>(m["Timezone"]));
    }
    if (m.find("TomcatConfig") != m.end() && !m["TomcatConfig"].empty()) {
      tomcatConfig = make_shared<string>(boost::any_cast<string>(m["TomcatConfig"]));
    }
    if (m.find("UpdateStrategy") != m.end() && !m["UpdateStrategy"].empty()) {
      updateStrategy = make_shared<string>(boost::any_cast<string>(m["UpdateStrategy"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("WarStartOptions") != m.end() && !m["WarStartOptions"].empty()) {
      warStartOptions = make_shared<string>(boost::any_cast<string>(m["WarStartOptions"]));
    }
    if (m.find("WebContainer") != m.end() && !m["WebContainer"].empty()) {
      webContainer = make_shared<string>(boost::any_cast<string>(m["WebContainer"]));
    }
  }


  virtual ~DeployApplicationShrinkRequest() = default;
};
class DeployApplicationResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> changeOrderId{};
  shared_ptr<bool> isNeedApproval{};

  DeployApplicationResponseBodyData() {}

  explicit DeployApplicationResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (isNeedApproval) {
      res["IsNeedApproval"] = boost::any(*isNeedApproval);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("IsNeedApproval") != m.end() && !m["IsNeedApproval"].empty()) {
      isNeedApproval = make_shared<bool>(boost::any_cast<bool>(m["IsNeedApproval"]));
    }
  }


  virtual ~DeployApplicationResponseBodyData() = default;
};
class DeployApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DeployApplicationResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  DeployApplicationResponseBody() {}

  explicit DeployApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DeployApplicationResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DeployApplicationResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~DeployApplicationResponseBody() = default;
};
class DeployApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeployApplicationResponseBody> body{};

  DeployApplicationResponse() {}

  explicit DeployApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeployApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeployApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~DeployApplicationResponse() = default;
};
class DescribeAppServiceDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> nacosInstanceId{};
  shared_ptr<string> nacosNamespaceId{};
  shared_ptr<string> serviceGroup{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> serviceType{};
  shared_ptr<string> serviceVersion{};

  DescribeAppServiceDetailRequest() {}

  explicit DescribeAppServiceDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (nacosInstanceId) {
      res["NacosInstanceId"] = boost::any(*nacosInstanceId);
    }
    if (nacosNamespaceId) {
      res["NacosNamespaceId"] = boost::any(*nacosNamespaceId);
    }
    if (serviceGroup) {
      res["ServiceGroup"] = boost::any(*serviceGroup);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (serviceType) {
      res["ServiceType"] = boost::any(*serviceType);
    }
    if (serviceVersion) {
      res["ServiceVersion"] = boost::any(*serviceVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("NacosInstanceId") != m.end() && !m["NacosInstanceId"].empty()) {
      nacosInstanceId = make_shared<string>(boost::any_cast<string>(m["NacosInstanceId"]));
    }
    if (m.find("NacosNamespaceId") != m.end() && !m["NacosNamespaceId"].empty()) {
      nacosNamespaceId = make_shared<string>(boost::any_cast<string>(m["NacosNamespaceId"]));
    }
    if (m.find("ServiceGroup") != m.end() && !m["ServiceGroup"].empty()) {
      serviceGroup = make_shared<string>(boost::any_cast<string>(m["ServiceGroup"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("ServiceType") != m.end() && !m["ServiceType"].empty()) {
      serviceType = make_shared<string>(boost::any_cast<string>(m["ServiceType"]));
    }
    if (m.find("ServiceVersion") != m.end() && !m["ServiceVersion"].empty()) {
      serviceVersion = make_shared<string>(boost::any_cast<string>(m["ServiceVersion"]));
    }
  }


  virtual ~DescribeAppServiceDetailRequest() = default;
};
class DescribeAppServiceDetailResponseBodyDataMethodsParameterDefinitions : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};

  DescribeAppServiceDetailResponseBodyDataMethodsParameterDefinitions() {}

  explicit DescribeAppServiceDetailResponseBodyDataMethodsParameterDefinitions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeAppServiceDetailResponseBodyDataMethodsParameterDefinitions() = default;
};
class DescribeAppServiceDetailResponseBodyDataMethods : public Darabonba::Model {
public:
  shared_ptr<string> methodController{};
  shared_ptr<string> name{};
  shared_ptr<string> nameDetail{};
  shared_ptr<vector<DescribeAppServiceDetailResponseBodyDataMethodsParameterDefinitions>> parameterDefinitions{};
  shared_ptr<vector<string>> parameterDetails{};
  shared_ptr<vector<string>> parameterTypes{};
  shared_ptr<vector<string>> paths{};
  shared_ptr<vector<string>> requestMethods{};
  shared_ptr<string> returnDetails{};
  shared_ptr<string> returnType{};

  DescribeAppServiceDetailResponseBodyDataMethods() {}

  explicit DescribeAppServiceDetailResponseBodyDataMethods(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (methodController) {
      res["MethodController"] = boost::any(*methodController);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nameDetail) {
      res["NameDetail"] = boost::any(*nameDetail);
    }
    if (parameterDefinitions) {
      vector<boost::any> temp1;
      for(auto item1:*parameterDefinitions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ParameterDefinitions"] = boost::any(temp1);
    }
    if (parameterDetails) {
      res["ParameterDetails"] = boost::any(*parameterDetails);
    }
    if (parameterTypes) {
      res["ParameterTypes"] = boost::any(*parameterTypes);
    }
    if (paths) {
      res["Paths"] = boost::any(*paths);
    }
    if (requestMethods) {
      res["RequestMethods"] = boost::any(*requestMethods);
    }
    if (returnDetails) {
      res["ReturnDetails"] = boost::any(*returnDetails);
    }
    if (returnType) {
      res["ReturnType"] = boost::any(*returnType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MethodController") != m.end() && !m["MethodController"].empty()) {
      methodController = make_shared<string>(boost::any_cast<string>(m["MethodController"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NameDetail") != m.end() && !m["NameDetail"].empty()) {
      nameDetail = make_shared<string>(boost::any_cast<string>(m["NameDetail"]));
    }
    if (m.find("ParameterDefinitions") != m.end() && !m["ParameterDefinitions"].empty()) {
      if (typeid(vector<boost::any>) == m["ParameterDefinitions"].type()) {
        vector<DescribeAppServiceDetailResponseBodyDataMethodsParameterDefinitions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ParameterDefinitions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAppServiceDetailResponseBodyDataMethodsParameterDefinitions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        parameterDefinitions = make_shared<vector<DescribeAppServiceDetailResponseBodyDataMethodsParameterDefinitions>>(expect1);
      }
    }
    if (m.find("ParameterDetails") != m.end() && !m["ParameterDetails"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ParameterDetails"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ParameterDetails"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      parameterDetails = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ParameterTypes") != m.end() && !m["ParameterTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ParameterTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ParameterTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      parameterTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Paths") != m.end() && !m["Paths"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Paths"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Paths"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      paths = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestMethods") != m.end() && !m["RequestMethods"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RequestMethods"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RequestMethods"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      requestMethods = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ReturnDetails") != m.end() && !m["ReturnDetails"].empty()) {
      returnDetails = make_shared<string>(boost::any_cast<string>(m["ReturnDetails"]));
    }
    if (m.find("ReturnType") != m.end() && !m["ReturnType"].empty()) {
      returnType = make_shared<string>(boost::any_cast<string>(m["ReturnType"]));
    }
  }


  virtual ~DescribeAppServiceDetailResponseBodyDataMethods() = default;
};
class DescribeAppServiceDetailResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> dubboApplicationName{};
  shared_ptr<string> edasAppName{};
  shared_ptr<string> group{};
  shared_ptr<map<string, boost::any>> metadata{};
  shared_ptr<vector<DescribeAppServiceDetailResponseBodyDataMethods>> methods{};
  shared_ptr<string> serviceName{};
  shared_ptr<vector<long>> servicePorts{};
  shared_ptr<string> serviceProtocol{};
  shared_ptr<vector<string>> serviceTags{};
  shared_ptr<string> serviceType{};
  shared_ptr<string> springApplicationName{};
  shared_ptr<string> version{};

  DescribeAppServiceDetailResponseBodyData() {}

  explicit DescribeAppServiceDetailResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dubboApplicationName) {
      res["DubboApplicationName"] = boost::any(*dubboApplicationName);
    }
    if (edasAppName) {
      res["EdasAppName"] = boost::any(*edasAppName);
    }
    if (group) {
      res["Group"] = boost::any(*group);
    }
    if (metadata) {
      res["Metadata"] = boost::any(*metadata);
    }
    if (methods) {
      vector<boost::any> temp1;
      for(auto item1:*methods){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Methods"] = boost::any(temp1);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (servicePorts) {
      res["ServicePorts"] = boost::any(*servicePorts);
    }
    if (serviceProtocol) {
      res["ServiceProtocol"] = boost::any(*serviceProtocol);
    }
    if (serviceTags) {
      res["ServiceTags"] = boost::any(*serviceTags);
    }
    if (serviceType) {
      res["ServiceType"] = boost::any(*serviceType);
    }
    if (springApplicationName) {
      res["SpringApplicationName"] = boost::any(*springApplicationName);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DubboApplicationName") != m.end() && !m["DubboApplicationName"].empty()) {
      dubboApplicationName = make_shared<string>(boost::any_cast<string>(m["DubboApplicationName"]));
    }
    if (m.find("EdasAppName") != m.end() && !m["EdasAppName"].empty()) {
      edasAppName = make_shared<string>(boost::any_cast<string>(m["EdasAppName"]));
    }
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["Group"]));
    }
    if (m.find("Metadata") != m.end() && !m["Metadata"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Metadata"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      metadata = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Methods") != m.end() && !m["Methods"].empty()) {
      if (typeid(vector<boost::any>) == m["Methods"].type()) {
        vector<DescribeAppServiceDetailResponseBodyDataMethods> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Methods"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAppServiceDetailResponseBodyDataMethods model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        methods = make_shared<vector<DescribeAppServiceDetailResponseBodyDataMethods>>(expect1);
      }
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("ServicePorts") != m.end() && !m["ServicePorts"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["ServicePorts"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ServicePorts"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      servicePorts = make_shared<vector<long>>(toVec1);
    }
    if (m.find("ServiceProtocol") != m.end() && !m["ServiceProtocol"].empty()) {
      serviceProtocol = make_shared<string>(boost::any_cast<string>(m["ServiceProtocol"]));
    }
    if (m.find("ServiceTags") != m.end() && !m["ServiceTags"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ServiceTags"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ServiceTags"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      serviceTags = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ServiceType") != m.end() && !m["ServiceType"].empty()) {
      serviceType = make_shared<string>(boost::any_cast<string>(m["ServiceType"]));
    }
    if (m.find("SpringApplicationName") != m.end() && !m["SpringApplicationName"].empty()) {
      springApplicationName = make_shared<string>(boost::any_cast<string>(m["SpringApplicationName"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeAppServiceDetailResponseBodyData() = default;
};
class DescribeAppServiceDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeAppServiceDetailResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  DescribeAppServiceDetailResponseBody() {}

  explicit DescribeAppServiceDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeAppServiceDetailResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeAppServiceDetailResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~DescribeAppServiceDetailResponseBody() = default;
};
class DescribeAppServiceDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAppServiceDetailResponseBody> body{};

  DescribeAppServiceDetailResponse() {}

  explicit DescribeAppServiceDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAppServiceDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAppServiceDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAppServiceDetailResponse() = default;
};
class DescribeApplicationConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> versionId{};

  DescribeApplicationConfigRequest() {}

  explicit DescribeApplicationConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
  }


  virtual ~DescribeApplicationConfigRequest() = default;
};
class DescribeApplicationConfigResponseBodyDataConfigMapMountDesc : public Darabonba::Model {
public:
  shared_ptr<long> configMapId{};
  shared_ptr<string> configMapName{};
  shared_ptr<string> key{};
  shared_ptr<string> mountPath{};

  DescribeApplicationConfigResponseBodyDataConfigMapMountDesc() {}

  explicit DescribeApplicationConfigResponseBodyDataConfigMapMountDesc(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configMapId) {
      res["ConfigMapId"] = boost::any(*configMapId);
    }
    if (configMapName) {
      res["ConfigMapName"] = boost::any(*configMapName);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (mountPath) {
      res["MountPath"] = boost::any(*mountPath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigMapId") != m.end() && !m["ConfigMapId"].empty()) {
      configMapId = make_shared<long>(boost::any_cast<long>(m["ConfigMapId"]));
    }
    if (m.find("ConfigMapName") != m.end() && !m["ConfigMapName"].empty()) {
      configMapName = make_shared<string>(boost::any_cast<string>(m["ConfigMapName"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("MountPath") != m.end() && !m["MountPath"].empty()) {
      mountPath = make_shared<string>(boost::any_cast<string>(m["MountPath"]));
    }
  }


  virtual ~DescribeApplicationConfigResponseBodyDataConfigMapMountDesc() = default;
};
class DescribeApplicationConfigResponseBodyDataInitContainersConfigConfigMapMountDesc : public Darabonba::Model {
public:
  shared_ptr<long> configMapId{};
  shared_ptr<string> configMapName{};
  shared_ptr<string> key{};
  shared_ptr<string> mountPath{};

  DescribeApplicationConfigResponseBodyDataInitContainersConfigConfigMapMountDesc() {}

  explicit DescribeApplicationConfigResponseBodyDataInitContainersConfigConfigMapMountDesc(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configMapId) {
      res["ConfigMapId"] = boost::any(*configMapId);
    }
    if (configMapName) {
      res["ConfigMapName"] = boost::any(*configMapName);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (mountPath) {
      res["MountPath"] = boost::any(*mountPath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigMapId") != m.end() && !m["ConfigMapId"].empty()) {
      configMapId = make_shared<long>(boost::any_cast<long>(m["ConfigMapId"]));
    }
    if (m.find("ConfigMapName") != m.end() && !m["ConfigMapName"].empty()) {
      configMapName = make_shared<string>(boost::any_cast<string>(m["ConfigMapName"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("MountPath") != m.end() && !m["MountPath"].empty()) {
      mountPath = make_shared<string>(boost::any_cast<string>(m["MountPath"]));
    }
  }


  virtual ~DescribeApplicationConfigResponseBodyDataInitContainersConfigConfigMapMountDesc() = default;
};
class DescribeApplicationConfigResponseBodyDataInitContainersConfig : public Darabonba::Model {
public:
  shared_ptr<string> command{};
  shared_ptr<string> commandArgs{};
  shared_ptr<vector<DescribeApplicationConfigResponseBodyDataInitContainersConfigConfigMapMountDesc>> configMapMountDesc{};
  shared_ptr<string> envs{};
  shared_ptr<string> imageUrl{};
  shared_ptr<string> name{};

  DescribeApplicationConfigResponseBodyDataInitContainersConfig() {}

  explicit DescribeApplicationConfigResponseBodyDataInitContainersConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (command) {
      res["Command"] = boost::any(*command);
    }
    if (commandArgs) {
      res["CommandArgs"] = boost::any(*commandArgs);
    }
    if (configMapMountDesc) {
      vector<boost::any> temp1;
      for(auto item1:*configMapMountDesc){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigMapMountDesc"] = boost::any(temp1);
    }
    if (envs) {
      res["Envs"] = boost::any(*envs);
    }
    if (imageUrl) {
      res["ImageUrl"] = boost::any(*imageUrl);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
    if (m.find("CommandArgs") != m.end() && !m["CommandArgs"].empty()) {
      commandArgs = make_shared<string>(boost::any_cast<string>(m["CommandArgs"]));
    }
    if (m.find("ConfigMapMountDesc") != m.end() && !m["ConfigMapMountDesc"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigMapMountDesc"].type()) {
        vector<DescribeApplicationConfigResponseBodyDataInitContainersConfigConfigMapMountDesc> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigMapMountDesc"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApplicationConfigResponseBodyDataInitContainersConfigConfigMapMountDesc model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configMapMountDesc = make_shared<vector<DescribeApplicationConfigResponseBodyDataInitContainersConfigConfigMapMountDesc>>(expect1);
      }
    }
    if (m.find("Envs") != m.end() && !m["Envs"].empty()) {
      envs = make_shared<string>(boost::any_cast<string>(m["Envs"]));
    }
    if (m.find("ImageUrl") != m.end() && !m["ImageUrl"].empty()) {
      imageUrl = make_shared<string>(boost::any_cast<string>(m["ImageUrl"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DescribeApplicationConfigResponseBodyDataInitContainersConfig() = default;
};
class DescribeApplicationConfigResponseBodyDataMountDesc : public Darabonba::Model {
public:
  shared_ptr<string> mountPath{};
  shared_ptr<string> nasPath{};

  DescribeApplicationConfigResponseBodyDataMountDesc() {}

  explicit DescribeApplicationConfigResponseBodyDataMountDesc(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mountPath) {
      res["MountPath"] = boost::any(*mountPath);
    }
    if (nasPath) {
      res["NasPath"] = boost::any(*nasPath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MountPath") != m.end() && !m["MountPath"].empty()) {
      mountPath = make_shared<string>(boost::any_cast<string>(m["MountPath"]));
    }
    if (m.find("NasPath") != m.end() && !m["NasPath"].empty()) {
      nasPath = make_shared<string>(boost::any_cast<string>(m["NasPath"]));
    }
  }


  virtual ~DescribeApplicationConfigResponseBodyDataMountDesc() = default;
};
class DescribeApplicationConfigResponseBodyDataOssMountDescs : public Darabonba::Model {
public:
  shared_ptr<string> bucketName{};
  shared_ptr<string> bucketPath{};
  shared_ptr<string> mountPath{};
  shared_ptr<bool> readOnly{};

  DescribeApplicationConfigResponseBodyDataOssMountDescs() {}

  explicit DescribeApplicationConfigResponseBodyDataOssMountDescs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucketName) {
      res["bucketName"] = boost::any(*bucketName);
    }
    if (bucketPath) {
      res["bucketPath"] = boost::any(*bucketPath);
    }
    if (mountPath) {
      res["mountPath"] = boost::any(*mountPath);
    }
    if (readOnly) {
      res["readOnly"] = boost::any(*readOnly);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("bucketName") != m.end() && !m["bucketName"].empty()) {
      bucketName = make_shared<string>(boost::any_cast<string>(m["bucketName"]));
    }
    if (m.find("bucketPath") != m.end() && !m["bucketPath"].empty()) {
      bucketPath = make_shared<string>(boost::any_cast<string>(m["bucketPath"]));
    }
    if (m.find("mountPath") != m.end() && !m["mountPath"].empty()) {
      mountPath = make_shared<string>(boost::any_cast<string>(m["mountPath"]));
    }
    if (m.find("readOnly") != m.end() && !m["readOnly"].empty()) {
      readOnly = make_shared<bool>(boost::any_cast<bool>(m["readOnly"]));
    }
  }


  virtual ~DescribeApplicationConfigResponseBodyDataOssMountDescs() = default;
};
class DescribeApplicationConfigResponseBodyDataSecretMountDesc : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> mountPath{};
  shared_ptr<long> secretId{};
  shared_ptr<string> secretName{};

  DescribeApplicationConfigResponseBodyDataSecretMountDesc() {}

  explicit DescribeApplicationConfigResponseBodyDataSecretMountDesc(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (mountPath) {
      res["MountPath"] = boost::any(*mountPath);
    }
    if (secretId) {
      res["SecretId"] = boost::any(*secretId);
    }
    if (secretName) {
      res["SecretName"] = boost::any(*secretName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("MountPath") != m.end() && !m["MountPath"].empty()) {
      mountPath = make_shared<string>(boost::any_cast<string>(m["MountPath"]));
    }
    if (m.find("SecretId") != m.end() && !m["SecretId"].empty()) {
      secretId = make_shared<long>(boost::any_cast<long>(m["SecretId"]));
    }
    if (m.find("SecretName") != m.end() && !m["SecretName"].empty()) {
      secretName = make_shared<string>(boost::any_cast<string>(m["SecretName"]));
    }
  }


  virtual ~DescribeApplicationConfigResponseBodyDataSecretMountDesc() = default;
};
class DescribeApplicationConfigResponseBodyDataSidecarContainersConfigConfigMapMountDesc : public Darabonba::Model {
public:
  shared_ptr<long> configMapId{};
  shared_ptr<string> configMapName{};
  shared_ptr<string> key{};
  shared_ptr<string> mountPath{};

  DescribeApplicationConfigResponseBodyDataSidecarContainersConfigConfigMapMountDesc() {}

  explicit DescribeApplicationConfigResponseBodyDataSidecarContainersConfigConfigMapMountDesc(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configMapId) {
      res["ConfigMapId"] = boost::any(*configMapId);
    }
    if (configMapName) {
      res["ConfigMapName"] = boost::any(*configMapName);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (mountPath) {
      res["MountPath"] = boost::any(*mountPath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigMapId") != m.end() && !m["ConfigMapId"].empty()) {
      configMapId = make_shared<long>(boost::any_cast<long>(m["ConfigMapId"]));
    }
    if (m.find("ConfigMapName") != m.end() && !m["ConfigMapName"].empty()) {
      configMapName = make_shared<string>(boost::any_cast<string>(m["ConfigMapName"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("MountPath") != m.end() && !m["MountPath"].empty()) {
      mountPath = make_shared<string>(boost::any_cast<string>(m["MountPath"]));
    }
  }


  virtual ~DescribeApplicationConfigResponseBodyDataSidecarContainersConfigConfigMapMountDesc() = default;
};
class DescribeApplicationConfigResponseBodyDataSidecarContainersConfigEmptyDirDesc : public Darabonba::Model {
public:
  shared_ptr<string> mountPath{};
  shared_ptr<string> name{};

  DescribeApplicationConfigResponseBodyDataSidecarContainersConfigEmptyDirDesc() {}

  explicit DescribeApplicationConfigResponseBodyDataSidecarContainersConfigEmptyDirDesc(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mountPath) {
      res["MountPath"] = boost::any(*mountPath);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MountPath") != m.end() && !m["MountPath"].empty()) {
      mountPath = make_shared<string>(boost::any_cast<string>(m["MountPath"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DescribeApplicationConfigResponseBodyDataSidecarContainersConfigEmptyDirDesc() = default;
};
class DescribeApplicationConfigResponseBodyDataSidecarContainersConfig : public Darabonba::Model {
public:
  shared_ptr<string> acrInstanceId{};
  shared_ptr<string> command{};
  shared_ptr<string> commandArgs{};
  shared_ptr<vector<DescribeApplicationConfigResponseBodyDataSidecarContainersConfigConfigMapMountDesc>> configMapMountDesc{};
  shared_ptr<long> cpu{};
  shared_ptr<vector<DescribeApplicationConfigResponseBodyDataSidecarContainersConfigEmptyDirDesc>> emptyDirDesc{};
  shared_ptr<string> envs{};
  shared_ptr<string> imageUrl{};
  shared_ptr<long> memory{};
  shared_ptr<string> name{};

  DescribeApplicationConfigResponseBodyDataSidecarContainersConfig() {}

  explicit DescribeApplicationConfigResponseBodyDataSidecarContainersConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acrInstanceId) {
      res["AcrInstanceId"] = boost::any(*acrInstanceId);
    }
    if (command) {
      res["Command"] = boost::any(*command);
    }
    if (commandArgs) {
      res["CommandArgs"] = boost::any(*commandArgs);
    }
    if (configMapMountDesc) {
      vector<boost::any> temp1;
      for(auto item1:*configMapMountDesc){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigMapMountDesc"] = boost::any(temp1);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (emptyDirDesc) {
      vector<boost::any> temp1;
      for(auto item1:*emptyDirDesc){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EmptyDirDesc"] = boost::any(temp1);
    }
    if (envs) {
      res["Envs"] = boost::any(*envs);
    }
    if (imageUrl) {
      res["ImageUrl"] = boost::any(*imageUrl);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcrInstanceId") != m.end() && !m["AcrInstanceId"].empty()) {
      acrInstanceId = make_shared<string>(boost::any_cast<string>(m["AcrInstanceId"]));
    }
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
    if (m.find("CommandArgs") != m.end() && !m["CommandArgs"].empty()) {
      commandArgs = make_shared<string>(boost::any_cast<string>(m["CommandArgs"]));
    }
    if (m.find("ConfigMapMountDesc") != m.end() && !m["ConfigMapMountDesc"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigMapMountDesc"].type()) {
        vector<DescribeApplicationConfigResponseBodyDataSidecarContainersConfigConfigMapMountDesc> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigMapMountDesc"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApplicationConfigResponseBodyDataSidecarContainersConfigConfigMapMountDesc model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configMapMountDesc = make_shared<vector<DescribeApplicationConfigResponseBodyDataSidecarContainersConfigConfigMapMountDesc>>(expect1);
      }
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("EmptyDirDesc") != m.end() && !m["EmptyDirDesc"].empty()) {
      if (typeid(vector<boost::any>) == m["EmptyDirDesc"].type()) {
        vector<DescribeApplicationConfigResponseBodyDataSidecarContainersConfigEmptyDirDesc> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EmptyDirDesc"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApplicationConfigResponseBodyDataSidecarContainersConfigEmptyDirDesc model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        emptyDirDesc = make_shared<vector<DescribeApplicationConfigResponseBodyDataSidecarContainersConfigEmptyDirDesc>>(expect1);
      }
    }
    if (m.find("Envs") != m.end() && !m["Envs"].empty()) {
      envs = make_shared<string>(boost::any_cast<string>(m["Envs"]));
    }
    if (m.find("ImageUrl") != m.end() && !m["ImageUrl"].empty()) {
      imageUrl = make_shared<string>(boost::any_cast<string>(m["ImageUrl"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DescribeApplicationConfigResponseBodyDataSidecarContainersConfig() = default;
};
class DescribeApplicationConfigResponseBodyDataTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeApplicationConfigResponseBodyDataTags() {}

  explicit DescribeApplicationConfigResponseBodyDataTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeApplicationConfigResponseBodyDataTags() = default;
};
class DescribeApplicationConfigResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> acrAssumeRoleArn{};
  shared_ptr<string> acrInstanceId{};
  shared_ptr<string> appDescription{};
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> appSource{};
  shared_ptr<bool> associateEip{};
  shared_ptr<string> baseAppId{};
  shared_ptr<long> batchWaitTime{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> command{};
  shared_ptr<string> commandArgs{};
  shared_ptr<vector<DescribeApplicationConfigResponseBodyDataConfigMapMountDesc>> configMapMountDesc{};
  shared_ptr<long> cpu{};
  shared_ptr<string> customHostAlias{};
  shared_ptr<string> customImageNetworkType{};
  shared_ptr<long> diskSize{};
  shared_ptr<string> dotnet{};
  shared_ptr<string> edasContainerVersion{};
  shared_ptr<string> enableAhas{};
  shared_ptr<string> enableCpuBurst{};
  shared_ptr<bool> enableGreyTagRoute{};
  shared_ptr<bool> enableIdle{};
  shared_ptr<bool> enableNewArms{};
  shared_ptr<string> envs{};
  shared_ptr<string> gpuCount{};
  shared_ptr<string> gpuType{};
  shared_ptr<string> imagePullSecrets{};
  shared_ptr<string> imageUrl{};
  shared_ptr<vector<DescribeApplicationConfigResponseBodyDataInitContainersConfig>> initContainersConfig{};
  shared_ptr<string> jarStartArgs{};
  shared_ptr<string> jarStartOptions{};
  shared_ptr<string> jdk{};
  shared_ptr<string> kafkaConfigs{};
  shared_ptr<string> liveness{};
  shared_ptr<long> memory{};
  shared_ptr<string> microRegistration{};
  shared_ptr<string> microRegistrationConfig{};
  shared_ptr<string> microserviceEngineConfig{};
  shared_ptr<long> minReadyInstanceRatio{};
  shared_ptr<long> minReadyInstances{};
  shared_ptr<vector<DescribeApplicationConfigResponseBodyDataMountDesc>> mountDesc{};
  shared_ptr<string> mountHost{};
  shared_ptr<string> mseApplicationId{};
  shared_ptr<string> mseApplicationName{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> nasConfigs{};
  shared_ptr<string> nasId{};
  shared_ptr<string> newSaeVersion{};
  shared_ptr<string> oidcRoleName{};
  shared_ptr<string> ossAkId{};
  shared_ptr<string> ossAkSecret{};
  shared_ptr<vector<DescribeApplicationConfigResponseBodyDataOssMountDescs>> ossMountDescs{};
  shared_ptr<string> packageType{};
  shared_ptr<string> packageUrl{};
  shared_ptr<string> packageVersion{};
  shared_ptr<string> php{};
  shared_ptr<string> phpArmsConfigLocation{};
  shared_ptr<string> phpConfig{};
  shared_ptr<string> phpConfigLocation{};
  shared_ptr<string> postStart{};
  shared_ptr<string> preStop{};
  shared_ptr<string> programmingLanguage{};
  shared_ptr<string> pvtzDiscovery{};
  shared_ptr<string> python{};
  shared_ptr<string> pythonModules{};
  shared_ptr<string> readiness{};
  shared_ptr<string> regionId{};
  shared_ptr<long> replicas{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<DescribeApplicationConfigResponseBodyDataSecretMountDesc>> secretMountDesc{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<map<string, string>> serviceTags{};
  shared_ptr<vector<DescribeApplicationConfigResponseBodyDataSidecarContainersConfig>> sidecarContainersConfig{};
  shared_ptr<string> slsConfigs{};
  shared_ptr<string> startupProbe{};
  shared_ptr<string> swimlanePvtzDiscovery{};
  shared_ptr<vector<DescribeApplicationConfigResponseBodyDataTags>> tags{};
  shared_ptr<long> terminationGracePeriodSeconds{};
  shared_ptr<string> timezone{};
  shared_ptr<string> tomcatConfig{};
  shared_ptr<string> updateStrategy{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> warStartOptions{};
  shared_ptr<string> webContainer{};

  DescribeApplicationConfigResponseBodyData() {}

  explicit DescribeApplicationConfigResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acrAssumeRoleArn) {
      res["AcrAssumeRoleArn"] = boost::any(*acrAssumeRoleArn);
    }
    if (acrInstanceId) {
      res["AcrInstanceId"] = boost::any(*acrInstanceId);
    }
    if (appDescription) {
      res["AppDescription"] = boost::any(*appDescription);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (appSource) {
      res["AppSource"] = boost::any(*appSource);
    }
    if (associateEip) {
      res["AssociateEip"] = boost::any(*associateEip);
    }
    if (baseAppId) {
      res["BaseAppId"] = boost::any(*baseAppId);
    }
    if (batchWaitTime) {
      res["BatchWaitTime"] = boost::any(*batchWaitTime);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (command) {
      res["Command"] = boost::any(*command);
    }
    if (commandArgs) {
      res["CommandArgs"] = boost::any(*commandArgs);
    }
    if (configMapMountDesc) {
      vector<boost::any> temp1;
      for(auto item1:*configMapMountDesc){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigMapMountDesc"] = boost::any(temp1);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (customHostAlias) {
      res["CustomHostAlias"] = boost::any(*customHostAlias);
    }
    if (customImageNetworkType) {
      res["CustomImageNetworkType"] = boost::any(*customImageNetworkType);
    }
    if (diskSize) {
      res["DiskSize"] = boost::any(*diskSize);
    }
    if (dotnet) {
      res["Dotnet"] = boost::any(*dotnet);
    }
    if (edasContainerVersion) {
      res["EdasContainerVersion"] = boost::any(*edasContainerVersion);
    }
    if (enableAhas) {
      res["EnableAhas"] = boost::any(*enableAhas);
    }
    if (enableCpuBurst) {
      res["EnableCpuBurst"] = boost::any(*enableCpuBurst);
    }
    if (enableGreyTagRoute) {
      res["EnableGreyTagRoute"] = boost::any(*enableGreyTagRoute);
    }
    if (enableIdle) {
      res["EnableIdle"] = boost::any(*enableIdle);
    }
    if (enableNewArms) {
      res["EnableNewArms"] = boost::any(*enableNewArms);
    }
    if (envs) {
      res["Envs"] = boost::any(*envs);
    }
    if (gpuCount) {
      res["GpuCount"] = boost::any(*gpuCount);
    }
    if (gpuType) {
      res["GpuType"] = boost::any(*gpuType);
    }
    if (imagePullSecrets) {
      res["ImagePullSecrets"] = boost::any(*imagePullSecrets);
    }
    if (imageUrl) {
      res["ImageUrl"] = boost::any(*imageUrl);
    }
    if (initContainersConfig) {
      vector<boost::any> temp1;
      for(auto item1:*initContainersConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InitContainersConfig"] = boost::any(temp1);
    }
    if (jarStartArgs) {
      res["JarStartArgs"] = boost::any(*jarStartArgs);
    }
    if (jarStartOptions) {
      res["JarStartOptions"] = boost::any(*jarStartOptions);
    }
    if (jdk) {
      res["Jdk"] = boost::any(*jdk);
    }
    if (kafkaConfigs) {
      res["KafkaConfigs"] = boost::any(*kafkaConfigs);
    }
    if (liveness) {
      res["Liveness"] = boost::any(*liveness);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (microRegistration) {
      res["MicroRegistration"] = boost::any(*microRegistration);
    }
    if (microRegistrationConfig) {
      res["MicroRegistrationConfig"] = boost::any(*microRegistrationConfig);
    }
    if (microserviceEngineConfig) {
      res["MicroserviceEngineConfig"] = boost::any(*microserviceEngineConfig);
    }
    if (minReadyInstanceRatio) {
      res["MinReadyInstanceRatio"] = boost::any(*minReadyInstanceRatio);
    }
    if (minReadyInstances) {
      res["MinReadyInstances"] = boost::any(*minReadyInstances);
    }
    if (mountDesc) {
      vector<boost::any> temp1;
      for(auto item1:*mountDesc){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MountDesc"] = boost::any(temp1);
    }
    if (mountHost) {
      res["MountHost"] = boost::any(*mountHost);
    }
    if (mseApplicationId) {
      res["MseApplicationId"] = boost::any(*mseApplicationId);
    }
    if (mseApplicationName) {
      res["MseApplicationName"] = boost::any(*mseApplicationName);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (nasConfigs) {
      res["NasConfigs"] = boost::any(*nasConfigs);
    }
    if (nasId) {
      res["NasId"] = boost::any(*nasId);
    }
    if (newSaeVersion) {
      res["NewSaeVersion"] = boost::any(*newSaeVersion);
    }
    if (oidcRoleName) {
      res["OidcRoleName"] = boost::any(*oidcRoleName);
    }
    if (ossAkId) {
      res["OssAkId"] = boost::any(*ossAkId);
    }
    if (ossAkSecret) {
      res["OssAkSecret"] = boost::any(*ossAkSecret);
    }
    if (ossMountDescs) {
      vector<boost::any> temp1;
      for(auto item1:*ossMountDescs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OssMountDescs"] = boost::any(temp1);
    }
    if (packageType) {
      res["PackageType"] = boost::any(*packageType);
    }
    if (packageUrl) {
      res["PackageUrl"] = boost::any(*packageUrl);
    }
    if (packageVersion) {
      res["PackageVersion"] = boost::any(*packageVersion);
    }
    if (php) {
      res["Php"] = boost::any(*php);
    }
    if (phpArmsConfigLocation) {
      res["PhpArmsConfigLocation"] = boost::any(*phpArmsConfigLocation);
    }
    if (phpConfig) {
      res["PhpConfig"] = boost::any(*phpConfig);
    }
    if (phpConfigLocation) {
      res["PhpConfigLocation"] = boost::any(*phpConfigLocation);
    }
    if (postStart) {
      res["PostStart"] = boost::any(*postStart);
    }
    if (preStop) {
      res["PreStop"] = boost::any(*preStop);
    }
    if (programmingLanguage) {
      res["ProgrammingLanguage"] = boost::any(*programmingLanguage);
    }
    if (pvtzDiscovery) {
      res["PvtzDiscovery"] = boost::any(*pvtzDiscovery);
    }
    if (python) {
      res["Python"] = boost::any(*python);
    }
    if (pythonModules) {
      res["PythonModules"] = boost::any(*pythonModules);
    }
    if (readiness) {
      res["Readiness"] = boost::any(*readiness);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (replicas) {
      res["Replicas"] = boost::any(*replicas);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (secretMountDesc) {
      vector<boost::any> temp1;
      for(auto item1:*secretMountDesc){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SecretMountDesc"] = boost::any(temp1);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (serviceTags) {
      res["ServiceTags"] = boost::any(*serviceTags);
    }
    if (sidecarContainersConfig) {
      vector<boost::any> temp1;
      for(auto item1:*sidecarContainersConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SidecarContainersConfig"] = boost::any(temp1);
    }
    if (slsConfigs) {
      res["SlsConfigs"] = boost::any(*slsConfigs);
    }
    if (startupProbe) {
      res["StartupProbe"] = boost::any(*startupProbe);
    }
    if (swimlanePvtzDiscovery) {
      res["SwimlanePvtzDiscovery"] = boost::any(*swimlanePvtzDiscovery);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (terminationGracePeriodSeconds) {
      res["TerminationGracePeriodSeconds"] = boost::any(*terminationGracePeriodSeconds);
    }
    if (timezone) {
      res["Timezone"] = boost::any(*timezone);
    }
    if (tomcatConfig) {
      res["TomcatConfig"] = boost::any(*tomcatConfig);
    }
    if (updateStrategy) {
      res["UpdateStrategy"] = boost::any(*updateStrategy);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (warStartOptions) {
      res["WarStartOptions"] = boost::any(*warStartOptions);
    }
    if (webContainer) {
      res["WebContainer"] = boost::any(*webContainer);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcrAssumeRoleArn") != m.end() && !m["AcrAssumeRoleArn"].empty()) {
      acrAssumeRoleArn = make_shared<string>(boost::any_cast<string>(m["AcrAssumeRoleArn"]));
    }
    if (m.find("AcrInstanceId") != m.end() && !m["AcrInstanceId"].empty()) {
      acrInstanceId = make_shared<string>(boost::any_cast<string>(m["AcrInstanceId"]));
    }
    if (m.find("AppDescription") != m.end() && !m["AppDescription"].empty()) {
      appDescription = make_shared<string>(boost::any_cast<string>(m["AppDescription"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AppSource") != m.end() && !m["AppSource"].empty()) {
      appSource = make_shared<string>(boost::any_cast<string>(m["AppSource"]));
    }
    if (m.find("AssociateEip") != m.end() && !m["AssociateEip"].empty()) {
      associateEip = make_shared<bool>(boost::any_cast<bool>(m["AssociateEip"]));
    }
    if (m.find("BaseAppId") != m.end() && !m["BaseAppId"].empty()) {
      baseAppId = make_shared<string>(boost::any_cast<string>(m["BaseAppId"]));
    }
    if (m.find("BatchWaitTime") != m.end() && !m["BatchWaitTime"].empty()) {
      batchWaitTime = make_shared<long>(boost::any_cast<long>(m["BatchWaitTime"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
    if (m.find("CommandArgs") != m.end() && !m["CommandArgs"].empty()) {
      commandArgs = make_shared<string>(boost::any_cast<string>(m["CommandArgs"]));
    }
    if (m.find("ConfigMapMountDesc") != m.end() && !m["ConfigMapMountDesc"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigMapMountDesc"].type()) {
        vector<DescribeApplicationConfigResponseBodyDataConfigMapMountDesc> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigMapMountDesc"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApplicationConfigResponseBodyDataConfigMapMountDesc model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configMapMountDesc = make_shared<vector<DescribeApplicationConfigResponseBodyDataConfigMapMountDesc>>(expect1);
      }
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("CustomHostAlias") != m.end() && !m["CustomHostAlias"].empty()) {
      customHostAlias = make_shared<string>(boost::any_cast<string>(m["CustomHostAlias"]));
    }
    if (m.find("CustomImageNetworkType") != m.end() && !m["CustomImageNetworkType"].empty()) {
      customImageNetworkType = make_shared<string>(boost::any_cast<string>(m["CustomImageNetworkType"]));
    }
    if (m.find("DiskSize") != m.end() && !m["DiskSize"].empty()) {
      diskSize = make_shared<long>(boost::any_cast<long>(m["DiskSize"]));
    }
    if (m.find("Dotnet") != m.end() && !m["Dotnet"].empty()) {
      dotnet = make_shared<string>(boost::any_cast<string>(m["Dotnet"]));
    }
    if (m.find("EdasContainerVersion") != m.end() && !m["EdasContainerVersion"].empty()) {
      edasContainerVersion = make_shared<string>(boost::any_cast<string>(m["EdasContainerVersion"]));
    }
    if (m.find("EnableAhas") != m.end() && !m["EnableAhas"].empty()) {
      enableAhas = make_shared<string>(boost::any_cast<string>(m["EnableAhas"]));
    }
    if (m.find("EnableCpuBurst") != m.end() && !m["EnableCpuBurst"].empty()) {
      enableCpuBurst = make_shared<string>(boost::any_cast<string>(m["EnableCpuBurst"]));
    }
    if (m.find("EnableGreyTagRoute") != m.end() && !m["EnableGreyTagRoute"].empty()) {
      enableGreyTagRoute = make_shared<bool>(boost::any_cast<bool>(m["EnableGreyTagRoute"]));
    }
    if (m.find("EnableIdle") != m.end() && !m["EnableIdle"].empty()) {
      enableIdle = make_shared<bool>(boost::any_cast<bool>(m["EnableIdle"]));
    }
    if (m.find("EnableNewArms") != m.end() && !m["EnableNewArms"].empty()) {
      enableNewArms = make_shared<bool>(boost::any_cast<bool>(m["EnableNewArms"]));
    }
    if (m.find("Envs") != m.end() && !m["Envs"].empty()) {
      envs = make_shared<string>(boost::any_cast<string>(m["Envs"]));
    }
    if (m.find("GpuCount") != m.end() && !m["GpuCount"].empty()) {
      gpuCount = make_shared<string>(boost::any_cast<string>(m["GpuCount"]));
    }
    if (m.find("GpuType") != m.end() && !m["GpuType"].empty()) {
      gpuType = make_shared<string>(boost::any_cast<string>(m["GpuType"]));
    }
    if (m.find("ImagePullSecrets") != m.end() && !m["ImagePullSecrets"].empty()) {
      imagePullSecrets = make_shared<string>(boost::any_cast<string>(m["ImagePullSecrets"]));
    }
    if (m.find("ImageUrl") != m.end() && !m["ImageUrl"].empty()) {
      imageUrl = make_shared<string>(boost::any_cast<string>(m["ImageUrl"]));
    }
    if (m.find("InitContainersConfig") != m.end() && !m["InitContainersConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["InitContainersConfig"].type()) {
        vector<DescribeApplicationConfigResponseBodyDataInitContainersConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InitContainersConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApplicationConfigResponseBodyDataInitContainersConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        initContainersConfig = make_shared<vector<DescribeApplicationConfigResponseBodyDataInitContainersConfig>>(expect1);
      }
    }
    if (m.find("JarStartArgs") != m.end() && !m["JarStartArgs"].empty()) {
      jarStartArgs = make_shared<string>(boost::any_cast<string>(m["JarStartArgs"]));
    }
    if (m.find("JarStartOptions") != m.end() && !m["JarStartOptions"].empty()) {
      jarStartOptions = make_shared<string>(boost::any_cast<string>(m["JarStartOptions"]));
    }
    if (m.find("Jdk") != m.end() && !m["Jdk"].empty()) {
      jdk = make_shared<string>(boost::any_cast<string>(m["Jdk"]));
    }
    if (m.find("KafkaConfigs") != m.end() && !m["KafkaConfigs"].empty()) {
      kafkaConfigs = make_shared<string>(boost::any_cast<string>(m["KafkaConfigs"]));
    }
    if (m.find("Liveness") != m.end() && !m["Liveness"].empty()) {
      liveness = make_shared<string>(boost::any_cast<string>(m["Liveness"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
    if (m.find("MicroRegistration") != m.end() && !m["MicroRegistration"].empty()) {
      microRegistration = make_shared<string>(boost::any_cast<string>(m["MicroRegistration"]));
    }
    if (m.find("MicroRegistrationConfig") != m.end() && !m["MicroRegistrationConfig"].empty()) {
      microRegistrationConfig = make_shared<string>(boost::any_cast<string>(m["MicroRegistrationConfig"]));
    }
    if (m.find("MicroserviceEngineConfig") != m.end() && !m["MicroserviceEngineConfig"].empty()) {
      microserviceEngineConfig = make_shared<string>(boost::any_cast<string>(m["MicroserviceEngineConfig"]));
    }
    if (m.find("MinReadyInstanceRatio") != m.end() && !m["MinReadyInstanceRatio"].empty()) {
      minReadyInstanceRatio = make_shared<long>(boost::any_cast<long>(m["MinReadyInstanceRatio"]));
    }
    if (m.find("MinReadyInstances") != m.end() && !m["MinReadyInstances"].empty()) {
      minReadyInstances = make_shared<long>(boost::any_cast<long>(m["MinReadyInstances"]));
    }
    if (m.find("MountDesc") != m.end() && !m["MountDesc"].empty()) {
      if (typeid(vector<boost::any>) == m["MountDesc"].type()) {
        vector<DescribeApplicationConfigResponseBodyDataMountDesc> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MountDesc"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApplicationConfigResponseBodyDataMountDesc model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mountDesc = make_shared<vector<DescribeApplicationConfigResponseBodyDataMountDesc>>(expect1);
      }
    }
    if (m.find("MountHost") != m.end() && !m["MountHost"].empty()) {
      mountHost = make_shared<string>(boost::any_cast<string>(m["MountHost"]));
    }
    if (m.find("MseApplicationId") != m.end() && !m["MseApplicationId"].empty()) {
      mseApplicationId = make_shared<string>(boost::any_cast<string>(m["MseApplicationId"]));
    }
    if (m.find("MseApplicationName") != m.end() && !m["MseApplicationName"].empty()) {
      mseApplicationName = make_shared<string>(boost::any_cast<string>(m["MseApplicationName"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("NasConfigs") != m.end() && !m["NasConfigs"].empty()) {
      nasConfigs = make_shared<string>(boost::any_cast<string>(m["NasConfigs"]));
    }
    if (m.find("NasId") != m.end() && !m["NasId"].empty()) {
      nasId = make_shared<string>(boost::any_cast<string>(m["NasId"]));
    }
    if (m.find("NewSaeVersion") != m.end() && !m["NewSaeVersion"].empty()) {
      newSaeVersion = make_shared<string>(boost::any_cast<string>(m["NewSaeVersion"]));
    }
    if (m.find("OidcRoleName") != m.end() && !m["OidcRoleName"].empty()) {
      oidcRoleName = make_shared<string>(boost::any_cast<string>(m["OidcRoleName"]));
    }
    if (m.find("OssAkId") != m.end() && !m["OssAkId"].empty()) {
      ossAkId = make_shared<string>(boost::any_cast<string>(m["OssAkId"]));
    }
    if (m.find("OssAkSecret") != m.end() && !m["OssAkSecret"].empty()) {
      ossAkSecret = make_shared<string>(boost::any_cast<string>(m["OssAkSecret"]));
    }
    if (m.find("OssMountDescs") != m.end() && !m["OssMountDescs"].empty()) {
      if (typeid(vector<boost::any>) == m["OssMountDescs"].type()) {
        vector<DescribeApplicationConfigResponseBodyDataOssMountDescs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OssMountDescs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApplicationConfigResponseBodyDataOssMountDescs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ossMountDescs = make_shared<vector<DescribeApplicationConfigResponseBodyDataOssMountDescs>>(expect1);
      }
    }
    if (m.find("PackageType") != m.end() && !m["PackageType"].empty()) {
      packageType = make_shared<string>(boost::any_cast<string>(m["PackageType"]));
    }
    if (m.find("PackageUrl") != m.end() && !m["PackageUrl"].empty()) {
      packageUrl = make_shared<string>(boost::any_cast<string>(m["PackageUrl"]));
    }
    if (m.find("PackageVersion") != m.end() && !m["PackageVersion"].empty()) {
      packageVersion = make_shared<string>(boost::any_cast<string>(m["PackageVersion"]));
    }
    if (m.find("Php") != m.end() && !m["Php"].empty()) {
      php = make_shared<string>(boost::any_cast<string>(m["Php"]));
    }
    if (m.find("PhpArmsConfigLocation") != m.end() && !m["PhpArmsConfigLocation"].empty()) {
      phpArmsConfigLocation = make_shared<string>(boost::any_cast<string>(m["PhpArmsConfigLocation"]));
    }
    if (m.find("PhpConfig") != m.end() && !m["PhpConfig"].empty()) {
      phpConfig = make_shared<string>(boost::any_cast<string>(m["PhpConfig"]));
    }
    if (m.find("PhpConfigLocation") != m.end() && !m["PhpConfigLocation"].empty()) {
      phpConfigLocation = make_shared<string>(boost::any_cast<string>(m["PhpConfigLocation"]));
    }
    if (m.find("PostStart") != m.end() && !m["PostStart"].empty()) {
      postStart = make_shared<string>(boost::any_cast<string>(m["PostStart"]));
    }
    if (m.find("PreStop") != m.end() && !m["PreStop"].empty()) {
      preStop = make_shared<string>(boost::any_cast<string>(m["PreStop"]));
    }
    if (m.find("ProgrammingLanguage") != m.end() && !m["ProgrammingLanguage"].empty()) {
      programmingLanguage = make_shared<string>(boost::any_cast<string>(m["ProgrammingLanguage"]));
    }
    if (m.find("PvtzDiscovery") != m.end() && !m["PvtzDiscovery"].empty()) {
      pvtzDiscovery = make_shared<string>(boost::any_cast<string>(m["PvtzDiscovery"]));
    }
    if (m.find("Python") != m.end() && !m["Python"].empty()) {
      python = make_shared<string>(boost::any_cast<string>(m["Python"]));
    }
    if (m.find("PythonModules") != m.end() && !m["PythonModules"].empty()) {
      pythonModules = make_shared<string>(boost::any_cast<string>(m["PythonModules"]));
    }
    if (m.find("Readiness") != m.end() && !m["Readiness"].empty()) {
      readiness = make_shared<string>(boost::any_cast<string>(m["Readiness"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Replicas") != m.end() && !m["Replicas"].empty()) {
      replicas = make_shared<long>(boost::any_cast<long>(m["Replicas"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("SecretMountDesc") != m.end() && !m["SecretMountDesc"].empty()) {
      if (typeid(vector<boost::any>) == m["SecretMountDesc"].type()) {
        vector<DescribeApplicationConfigResponseBodyDataSecretMountDesc> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SecretMountDesc"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApplicationConfigResponseBodyDataSecretMountDesc model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        secretMountDesc = make_shared<vector<DescribeApplicationConfigResponseBodyDataSecretMountDesc>>(expect1);
      }
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("ServiceTags") != m.end() && !m["ServiceTags"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ServiceTags"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      serviceTags = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("SidecarContainersConfig") != m.end() && !m["SidecarContainersConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["SidecarContainersConfig"].type()) {
        vector<DescribeApplicationConfigResponseBodyDataSidecarContainersConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SidecarContainersConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApplicationConfigResponseBodyDataSidecarContainersConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sidecarContainersConfig = make_shared<vector<DescribeApplicationConfigResponseBodyDataSidecarContainersConfig>>(expect1);
      }
    }
    if (m.find("SlsConfigs") != m.end() && !m["SlsConfigs"].empty()) {
      slsConfigs = make_shared<string>(boost::any_cast<string>(m["SlsConfigs"]));
    }
    if (m.find("StartupProbe") != m.end() && !m["StartupProbe"].empty()) {
      startupProbe = make_shared<string>(boost::any_cast<string>(m["StartupProbe"]));
    }
    if (m.find("SwimlanePvtzDiscovery") != m.end() && !m["SwimlanePvtzDiscovery"].empty()) {
      swimlanePvtzDiscovery = make_shared<string>(boost::any_cast<string>(m["SwimlanePvtzDiscovery"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<DescribeApplicationConfigResponseBodyDataTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApplicationConfigResponseBodyDataTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<DescribeApplicationConfigResponseBodyDataTags>>(expect1);
      }
    }
    if (m.find("TerminationGracePeriodSeconds") != m.end() && !m["TerminationGracePeriodSeconds"].empty()) {
      terminationGracePeriodSeconds = make_shared<long>(boost::any_cast<long>(m["TerminationGracePeriodSeconds"]));
    }
    if (m.find("Timezone") != m.end() && !m["Timezone"].empty()) {
      timezone = make_shared<string>(boost::any_cast<string>(m["Timezone"]));
    }
    if (m.find("TomcatConfig") != m.end() && !m["TomcatConfig"].empty()) {
      tomcatConfig = make_shared<string>(boost::any_cast<string>(m["TomcatConfig"]));
    }
    if (m.find("UpdateStrategy") != m.end() && !m["UpdateStrategy"].empty()) {
      updateStrategy = make_shared<string>(boost::any_cast<string>(m["UpdateStrategy"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("WarStartOptions") != m.end() && !m["WarStartOptions"].empty()) {
      warStartOptions = make_shared<string>(boost::any_cast<string>(m["WarStartOptions"]));
    }
    if (m.find("WebContainer") != m.end() && !m["WebContainer"].empty()) {
      webContainer = make_shared<string>(boost::any_cast<string>(m["WebContainer"]));
    }
  }


  virtual ~DescribeApplicationConfigResponseBodyData() = default;
};
class DescribeApplicationConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeApplicationConfigResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  DescribeApplicationConfigResponseBody() {}

  explicit DescribeApplicationConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeApplicationConfigResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeApplicationConfigResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~DescribeApplicationConfigResponseBody() = default;
};
class DescribeApplicationConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApplicationConfigResponseBody> body{};

  DescribeApplicationConfigResponse() {}

  explicit DescribeApplicationConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApplicationConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApplicationConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApplicationConfigResponse() = default;
};
class DescribeApplicationGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};

  DescribeApplicationGroupsRequest() {}

  explicit DescribeApplicationGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeApplicationGroupsRequest() = default;
};
class DescribeApplicationGroupsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> edasContainerVersion{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<long> groupType{};
  shared_ptr<string> imageUrl{};
  shared_ptr<string> jdk{};
  shared_ptr<string> packageType{};
  shared_ptr<string> packageUrl{};
  shared_ptr<string> packageVersion{};
  shared_ptr<string> packageVersionId{};
  shared_ptr<long> replicas{};
  shared_ptr<long> runningInstances{};
  shared_ptr<string> webContainer{};

  DescribeApplicationGroupsResponseBodyData() {}

  explicit DescribeApplicationGroupsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (edasContainerVersion) {
      res["EdasContainerVersion"] = boost::any(*edasContainerVersion);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (groupType) {
      res["GroupType"] = boost::any(*groupType);
    }
    if (imageUrl) {
      res["ImageUrl"] = boost::any(*imageUrl);
    }
    if (jdk) {
      res["Jdk"] = boost::any(*jdk);
    }
    if (packageType) {
      res["PackageType"] = boost::any(*packageType);
    }
    if (packageUrl) {
      res["PackageUrl"] = boost::any(*packageUrl);
    }
    if (packageVersion) {
      res["PackageVersion"] = boost::any(*packageVersion);
    }
    if (packageVersionId) {
      res["PackageVersionId"] = boost::any(*packageVersionId);
    }
    if (replicas) {
      res["Replicas"] = boost::any(*replicas);
    }
    if (runningInstances) {
      res["RunningInstances"] = boost::any(*runningInstances);
    }
    if (webContainer) {
      res["WebContainer"] = boost::any(*webContainer);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EdasContainerVersion") != m.end() && !m["EdasContainerVersion"].empty()) {
      edasContainerVersion = make_shared<string>(boost::any_cast<string>(m["EdasContainerVersion"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("GroupType") != m.end() && !m["GroupType"].empty()) {
      groupType = make_shared<long>(boost::any_cast<long>(m["GroupType"]));
    }
    if (m.find("ImageUrl") != m.end() && !m["ImageUrl"].empty()) {
      imageUrl = make_shared<string>(boost::any_cast<string>(m["ImageUrl"]));
    }
    if (m.find("Jdk") != m.end() && !m["Jdk"].empty()) {
      jdk = make_shared<string>(boost::any_cast<string>(m["Jdk"]));
    }
    if (m.find("PackageType") != m.end() && !m["PackageType"].empty()) {
      packageType = make_shared<string>(boost::any_cast<string>(m["PackageType"]));
    }
    if (m.find("PackageUrl") != m.end() && !m["PackageUrl"].empty()) {
      packageUrl = make_shared<string>(boost::any_cast<string>(m["PackageUrl"]));
    }
    if (m.find("PackageVersion") != m.end() && !m["PackageVersion"].empty()) {
      packageVersion = make_shared<string>(boost::any_cast<string>(m["PackageVersion"]));
    }
    if (m.find("PackageVersionId") != m.end() && !m["PackageVersionId"].empty()) {
      packageVersionId = make_shared<string>(boost::any_cast<string>(m["PackageVersionId"]));
    }
    if (m.find("Replicas") != m.end() && !m["Replicas"].empty()) {
      replicas = make_shared<long>(boost::any_cast<long>(m["Replicas"]));
    }
    if (m.find("RunningInstances") != m.end() && !m["RunningInstances"].empty()) {
      runningInstances = make_shared<long>(boost::any_cast<long>(m["RunningInstances"]));
    }
    if (m.find("WebContainer") != m.end() && !m["WebContainer"].empty()) {
      webContainer = make_shared<string>(boost::any_cast<string>(m["WebContainer"]));
    }
  }


  virtual ~DescribeApplicationGroupsResponseBodyData() = default;
};
class DescribeApplicationGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<DescribeApplicationGroupsResponseBodyData>> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  DescribeApplicationGroupsResponseBody() {}

  explicit DescribeApplicationGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeApplicationGroupsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApplicationGroupsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeApplicationGroupsResponseBodyData>>(expect1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~DescribeApplicationGroupsResponseBody() = default;
};
class DescribeApplicationGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApplicationGroupsResponseBody> body{};

  DescribeApplicationGroupsResponse() {}

  explicit DescribeApplicationGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApplicationGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApplicationGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApplicationGroupsResponse() = default;
};
class DescribeApplicationImageRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> imageUrl{};

  DescribeApplicationImageRequest() {}

  explicit DescribeApplicationImageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (imageUrl) {
      res["ImageUrl"] = boost::any(*imageUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ImageUrl") != m.end() && !m["ImageUrl"].empty()) {
      imageUrl = make_shared<string>(boost::any_cast<string>(m["ImageUrl"]));
    }
  }


  virtual ~DescribeApplicationImageRequest() = default;
};
class DescribeApplicationImageResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> crUrl{};
  shared_ptr<string> logo{};
  shared_ptr<string> regionId{};
  shared_ptr<string> repoName{};
  shared_ptr<string> repoNamespace{};
  shared_ptr<string> repoOriginType{};
  shared_ptr<string> repoTag{};
  shared_ptr<string> repoType{};

  DescribeApplicationImageResponseBodyData() {}

  explicit DescribeApplicationImageResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (crUrl) {
      res["CrUrl"] = boost::any(*crUrl);
    }
    if (logo) {
      res["Logo"] = boost::any(*logo);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (repoName) {
      res["RepoName"] = boost::any(*repoName);
    }
    if (repoNamespace) {
      res["RepoNamespace"] = boost::any(*repoNamespace);
    }
    if (repoOriginType) {
      res["RepoOriginType"] = boost::any(*repoOriginType);
    }
    if (repoTag) {
      res["RepoTag"] = boost::any(*repoTag);
    }
    if (repoType) {
      res["RepoType"] = boost::any(*repoType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CrUrl") != m.end() && !m["CrUrl"].empty()) {
      crUrl = make_shared<string>(boost::any_cast<string>(m["CrUrl"]));
    }
    if (m.find("Logo") != m.end() && !m["Logo"].empty()) {
      logo = make_shared<string>(boost::any_cast<string>(m["Logo"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RepoName") != m.end() && !m["RepoName"].empty()) {
      repoName = make_shared<string>(boost::any_cast<string>(m["RepoName"]));
    }
    if (m.find("RepoNamespace") != m.end() && !m["RepoNamespace"].empty()) {
      repoNamespace = make_shared<string>(boost::any_cast<string>(m["RepoNamespace"]));
    }
    if (m.find("RepoOriginType") != m.end() && !m["RepoOriginType"].empty()) {
      repoOriginType = make_shared<string>(boost::any_cast<string>(m["RepoOriginType"]));
    }
    if (m.find("RepoTag") != m.end() && !m["RepoTag"].empty()) {
      repoTag = make_shared<string>(boost::any_cast<string>(m["RepoTag"]));
    }
    if (m.find("RepoType") != m.end() && !m["RepoType"].empty()) {
      repoType = make_shared<string>(boost::any_cast<string>(m["RepoType"]));
    }
  }


  virtual ~DescribeApplicationImageResponseBodyData() = default;
};
class DescribeApplicationImageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeApplicationImageResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  DescribeApplicationImageResponseBody() {}

  explicit DescribeApplicationImageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeApplicationImageResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeApplicationImageResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~DescribeApplicationImageResponseBody() = default;
};
class DescribeApplicationImageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApplicationImageResponseBody> body{};

  DescribeApplicationImageResponse() {}

  explicit DescribeApplicationImageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApplicationImageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApplicationImageResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApplicationImageResponse() = default;
};
class DescribeApplicationInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> groupId{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> pipelineId{};
  shared_ptr<bool> reverse{};

  DescribeApplicationInstancesRequest() {}

  explicit DescribeApplicationInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (reverse) {
      res["Reverse"] = boost::any(*reverse);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Reverse") != m.end() && !m["Reverse"].empty()) {
      reverse = make_shared<bool>(boost::any_cast<bool>(m["Reverse"]));
    }
  }


  virtual ~DescribeApplicationInstancesRequest() = default;
};
class DescribeApplicationInstancesResponseBodyDataInstancesSidecarContainersStatus : public Darabonba::Model {
public:
  shared_ptr<string> containerId{};
  shared_ptr<string> containerStatus{};
  shared_ptr<string> imageUrl{};

  DescribeApplicationInstancesResponseBodyDataInstancesSidecarContainersStatus() {}

  explicit DescribeApplicationInstancesResponseBodyDataInstancesSidecarContainersStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (containerId) {
      res["ContainerId"] = boost::any(*containerId);
    }
    if (containerStatus) {
      res["ContainerStatus"] = boost::any(*containerStatus);
    }
    if (imageUrl) {
      res["ImageUrl"] = boost::any(*imageUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContainerId") != m.end() && !m["ContainerId"].empty()) {
      containerId = make_shared<string>(boost::any_cast<string>(m["ContainerId"]));
    }
    if (m.find("ContainerStatus") != m.end() && !m["ContainerStatus"].empty()) {
      containerStatus = make_shared<string>(boost::any_cast<string>(m["ContainerStatus"]));
    }
    if (m.find("ImageUrl") != m.end() && !m["ImageUrl"].empty()) {
      imageUrl = make_shared<string>(boost::any_cast<string>(m["ImageUrl"]));
    }
  }


  virtual ~DescribeApplicationInstancesResponseBodyDataInstancesSidecarContainersStatus() = default;
};
class DescribeApplicationInstancesResponseBodyDataInstances : public Darabonba::Model {
public:
  shared_ptr<long> createTimeStamp{};
  shared_ptr<bool> debugStatus{};
  shared_ptr<string> eip{};
  shared_ptr<long> finishTimeStamp{};
  shared_ptr<string> groupId{};
  shared_ptr<string> imageUrl{};
  shared_ptr<string> instanceContainerIp{};
  shared_ptr<long> instanceContainerRestarts{};
  shared_ptr<string> instanceContainerStatus{};
  shared_ptr<string> instanceHealthStatus{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> mainContainerStatus{};
  shared_ptr<string> packageVersion{};
  shared_ptr<vector<DescribeApplicationInstancesResponseBodyDataInstancesSidecarContainersStatus>> sidecarContainersStatus{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> unhealthyMessage{};
  shared_ptr<string> vSwitchId{};

  DescribeApplicationInstancesResponseBodyDataInstances() {}

  explicit DescribeApplicationInstancesResponseBodyDataInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTimeStamp) {
      res["CreateTimeStamp"] = boost::any(*createTimeStamp);
    }
    if (debugStatus) {
      res["DebugStatus"] = boost::any(*debugStatus);
    }
    if (eip) {
      res["Eip"] = boost::any(*eip);
    }
    if (finishTimeStamp) {
      res["FinishTimeStamp"] = boost::any(*finishTimeStamp);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (imageUrl) {
      res["ImageUrl"] = boost::any(*imageUrl);
    }
    if (instanceContainerIp) {
      res["InstanceContainerIp"] = boost::any(*instanceContainerIp);
    }
    if (instanceContainerRestarts) {
      res["InstanceContainerRestarts"] = boost::any(*instanceContainerRestarts);
    }
    if (instanceContainerStatus) {
      res["InstanceContainerStatus"] = boost::any(*instanceContainerStatus);
    }
    if (instanceHealthStatus) {
      res["InstanceHealthStatus"] = boost::any(*instanceHealthStatus);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (mainContainerStatus) {
      res["MainContainerStatus"] = boost::any(*mainContainerStatus);
    }
    if (packageVersion) {
      res["PackageVersion"] = boost::any(*packageVersion);
    }
    if (sidecarContainersStatus) {
      vector<boost::any> temp1;
      for(auto item1:*sidecarContainersStatus){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SidecarContainersStatus"] = boost::any(temp1);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (unhealthyMessage) {
      res["UnhealthyMessage"] = boost::any(*unhealthyMessage);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTimeStamp") != m.end() && !m["CreateTimeStamp"].empty()) {
      createTimeStamp = make_shared<long>(boost::any_cast<long>(m["CreateTimeStamp"]));
    }
    if (m.find("DebugStatus") != m.end() && !m["DebugStatus"].empty()) {
      debugStatus = make_shared<bool>(boost::any_cast<bool>(m["DebugStatus"]));
    }
    if (m.find("Eip") != m.end() && !m["Eip"].empty()) {
      eip = make_shared<string>(boost::any_cast<string>(m["Eip"]));
    }
    if (m.find("FinishTimeStamp") != m.end() && !m["FinishTimeStamp"].empty()) {
      finishTimeStamp = make_shared<long>(boost::any_cast<long>(m["FinishTimeStamp"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("ImageUrl") != m.end() && !m["ImageUrl"].empty()) {
      imageUrl = make_shared<string>(boost::any_cast<string>(m["ImageUrl"]));
    }
    if (m.find("InstanceContainerIp") != m.end() && !m["InstanceContainerIp"].empty()) {
      instanceContainerIp = make_shared<string>(boost::any_cast<string>(m["InstanceContainerIp"]));
    }
    if (m.find("InstanceContainerRestarts") != m.end() && !m["InstanceContainerRestarts"].empty()) {
      instanceContainerRestarts = make_shared<long>(boost::any_cast<long>(m["InstanceContainerRestarts"]));
    }
    if (m.find("InstanceContainerStatus") != m.end() && !m["InstanceContainerStatus"].empty()) {
      instanceContainerStatus = make_shared<string>(boost::any_cast<string>(m["InstanceContainerStatus"]));
    }
    if (m.find("InstanceHealthStatus") != m.end() && !m["InstanceHealthStatus"].empty()) {
      instanceHealthStatus = make_shared<string>(boost::any_cast<string>(m["InstanceHealthStatus"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MainContainerStatus") != m.end() && !m["MainContainerStatus"].empty()) {
      mainContainerStatus = make_shared<string>(boost::any_cast<string>(m["MainContainerStatus"]));
    }
    if (m.find("PackageVersion") != m.end() && !m["PackageVersion"].empty()) {
      packageVersion = make_shared<string>(boost::any_cast<string>(m["PackageVersion"]));
    }
    if (m.find("SidecarContainersStatus") != m.end() && !m["SidecarContainersStatus"].empty()) {
      if (typeid(vector<boost::any>) == m["SidecarContainersStatus"].type()) {
        vector<DescribeApplicationInstancesResponseBodyDataInstancesSidecarContainersStatus> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SidecarContainersStatus"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApplicationInstancesResponseBodyDataInstancesSidecarContainersStatus model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sidecarContainersStatus = make_shared<vector<DescribeApplicationInstancesResponseBodyDataInstancesSidecarContainersStatus>>(expect1);
      }
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("UnhealthyMessage") != m.end() && !m["UnhealthyMessage"].empty()) {
      unhealthyMessage = make_shared<string>(boost::any_cast<string>(m["UnhealthyMessage"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~DescribeApplicationInstancesResponseBodyDataInstances() = default;
};
class DescribeApplicationInstancesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<vector<DescribeApplicationInstancesResponseBodyDataInstances>> instances{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalSize{};

  DescribeApplicationInstancesResponseBodyData() {}

  explicit DescribeApplicationInstancesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (instances) {
      vector<boost::any> temp1;
      for(auto item1:*instances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Instances"] = boost::any(temp1);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      if (typeid(vector<boost::any>) == m["Instances"].type()) {
        vector<DescribeApplicationInstancesResponseBodyDataInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Instances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApplicationInstancesResponseBodyDataInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instances = make_shared<vector<DescribeApplicationInstancesResponseBodyDataInstances>>(expect1);
      }
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
  }


  virtual ~DescribeApplicationInstancesResponseBodyData() = default;
};
class DescribeApplicationInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeApplicationInstancesResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  DescribeApplicationInstancesResponseBody() {}

  explicit DescribeApplicationInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeApplicationInstancesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeApplicationInstancesResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~DescribeApplicationInstancesResponseBody() = default;
};
class DescribeApplicationInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApplicationInstancesResponseBody> body{};

  DescribeApplicationInstancesResponse() {}

  explicit DescribeApplicationInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApplicationInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApplicationInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApplicationInstancesResponse() = default;
};
class DescribeApplicationScalingRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> scalingRuleName{};

  DescribeApplicationScalingRuleRequest() {}

  explicit DescribeApplicationScalingRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (scalingRuleName) {
      res["ScalingRuleName"] = boost::any(*scalingRuleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ScalingRuleName") != m.end() && !m["ScalingRuleName"].empty()) {
      scalingRuleName = make_shared<string>(boost::any_cast<string>(m["ScalingRuleName"]));
    }
  }


  virtual ~DescribeApplicationScalingRuleRequest() = default;
};
class DescribeApplicationScalingRuleResponseBodyDataMetricMetrics : public Darabonba::Model {
public:
  shared_ptr<long> metricTargetAverageUtilization{};
  shared_ptr<string> metricType{};
  shared_ptr<string> slbId{};
  shared_ptr<string> slbLogstore{};
  shared_ptr<string> slbProject{};
  shared_ptr<string> vport{};

  DescribeApplicationScalingRuleResponseBodyDataMetricMetrics() {}

  explicit DescribeApplicationScalingRuleResponseBodyDataMetricMetrics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metricTargetAverageUtilization) {
      res["MetricTargetAverageUtilization"] = boost::any(*metricTargetAverageUtilization);
    }
    if (metricType) {
      res["MetricType"] = boost::any(*metricType);
    }
    if (slbId) {
      res["SlbId"] = boost::any(*slbId);
    }
    if (slbLogstore) {
      res["SlbLogstore"] = boost::any(*slbLogstore);
    }
    if (slbProject) {
      res["SlbProject"] = boost::any(*slbProject);
    }
    if (vport) {
      res["Vport"] = boost::any(*vport);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MetricTargetAverageUtilization") != m.end() && !m["MetricTargetAverageUtilization"].empty()) {
      metricTargetAverageUtilization = make_shared<long>(boost::any_cast<long>(m["MetricTargetAverageUtilization"]));
    }
    if (m.find("MetricType") != m.end() && !m["MetricType"].empty()) {
      metricType = make_shared<string>(boost::any_cast<string>(m["MetricType"]));
    }
    if (m.find("SlbId") != m.end() && !m["SlbId"].empty()) {
      slbId = make_shared<string>(boost::any_cast<string>(m["SlbId"]));
    }
    if (m.find("SlbLogstore") != m.end() && !m["SlbLogstore"].empty()) {
      slbLogstore = make_shared<string>(boost::any_cast<string>(m["SlbLogstore"]));
    }
    if (m.find("SlbProject") != m.end() && !m["SlbProject"].empty()) {
      slbProject = make_shared<string>(boost::any_cast<string>(m["SlbProject"]));
    }
    if (m.find("Vport") != m.end() && !m["Vport"].empty()) {
      vport = make_shared<string>(boost::any_cast<string>(m["Vport"]));
    }
  }


  virtual ~DescribeApplicationScalingRuleResponseBodyDataMetricMetrics() = default;
};
class DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatusCurrentMetrics : public Darabonba::Model {
public:
  shared_ptr<long> currentValue{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};

  DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatusCurrentMetrics() {}

  explicit DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatusCurrentMetrics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentValue) {
      res["CurrentValue"] = boost::any(*currentValue);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentValue") != m.end() && !m["CurrentValue"].empty()) {
      currentValue = make_shared<long>(boost::any_cast<long>(m["CurrentValue"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatusCurrentMetrics() = default;
};
class DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatusNextScaleMetrics : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> nextScaleInAverageUtilization{};
  shared_ptr<long> nextScaleOutAverageUtilization{};

  DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatusNextScaleMetrics() {}

  explicit DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatusNextScaleMetrics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nextScaleInAverageUtilization) {
      res["NextScaleInAverageUtilization"] = boost::any(*nextScaleInAverageUtilization);
    }
    if (nextScaleOutAverageUtilization) {
      res["NextScaleOutAverageUtilization"] = boost::any(*nextScaleOutAverageUtilization);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NextScaleInAverageUtilization") != m.end() && !m["NextScaleInAverageUtilization"].empty()) {
      nextScaleInAverageUtilization = make_shared<long>(boost::any_cast<long>(m["NextScaleInAverageUtilization"]));
    }
    if (m.find("NextScaleOutAverageUtilization") != m.end() && !m["NextScaleOutAverageUtilization"].empty()) {
      nextScaleOutAverageUtilization = make_shared<long>(boost::any_cast<long>(m["NextScaleOutAverageUtilization"]));
    }
  }


  virtual ~DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatusNextScaleMetrics() = default;
};
class DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatus : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatusCurrentMetrics>> currentMetrics{};
  shared_ptr<long> currentReplicas{};
  shared_ptr<long> desiredReplicas{};
  shared_ptr<string> lastScaleTime{};
  shared_ptr<vector<DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatusNextScaleMetrics>> nextScaleMetrics{};
  shared_ptr<long> nextScaleTimePeriod{};

  DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatus() {}

  explicit DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentMetrics) {
      vector<boost::any> temp1;
      for(auto item1:*currentMetrics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CurrentMetrics"] = boost::any(temp1);
    }
    if (currentReplicas) {
      res["CurrentReplicas"] = boost::any(*currentReplicas);
    }
    if (desiredReplicas) {
      res["DesiredReplicas"] = boost::any(*desiredReplicas);
    }
    if (lastScaleTime) {
      res["LastScaleTime"] = boost::any(*lastScaleTime);
    }
    if (nextScaleMetrics) {
      vector<boost::any> temp1;
      for(auto item1:*nextScaleMetrics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NextScaleMetrics"] = boost::any(temp1);
    }
    if (nextScaleTimePeriod) {
      res["NextScaleTimePeriod"] = boost::any(*nextScaleTimePeriod);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentMetrics") != m.end() && !m["CurrentMetrics"].empty()) {
      if (typeid(vector<boost::any>) == m["CurrentMetrics"].type()) {
        vector<DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatusCurrentMetrics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CurrentMetrics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatusCurrentMetrics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        currentMetrics = make_shared<vector<DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatusCurrentMetrics>>(expect1);
      }
    }
    if (m.find("CurrentReplicas") != m.end() && !m["CurrentReplicas"].empty()) {
      currentReplicas = make_shared<long>(boost::any_cast<long>(m["CurrentReplicas"]));
    }
    if (m.find("DesiredReplicas") != m.end() && !m["DesiredReplicas"].empty()) {
      desiredReplicas = make_shared<long>(boost::any_cast<long>(m["DesiredReplicas"]));
    }
    if (m.find("LastScaleTime") != m.end() && !m["LastScaleTime"].empty()) {
      lastScaleTime = make_shared<string>(boost::any_cast<string>(m["LastScaleTime"]));
    }
    if (m.find("NextScaleMetrics") != m.end() && !m["NextScaleMetrics"].empty()) {
      if (typeid(vector<boost::any>) == m["NextScaleMetrics"].type()) {
        vector<DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatusNextScaleMetrics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NextScaleMetrics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatusNextScaleMetrics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nextScaleMetrics = make_shared<vector<DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatusNextScaleMetrics>>(expect1);
      }
    }
    if (m.find("NextScaleTimePeriod") != m.end() && !m["NextScaleTimePeriod"].empty()) {
      nextScaleTimePeriod = make_shared<long>(boost::any_cast<long>(m["NextScaleTimePeriod"]));
    }
  }


  virtual ~DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatus() = default;
};
class DescribeApplicationScalingRuleResponseBodyDataMetricScaleDownRules : public Darabonba::Model {
public:
  shared_ptr<bool> disabled{};
  shared_ptr<long> stabilizationWindowSeconds{};
  shared_ptr<long> step{};

  DescribeApplicationScalingRuleResponseBodyDataMetricScaleDownRules() {}

  explicit DescribeApplicationScalingRuleResponseBodyDataMetricScaleDownRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disabled) {
      res["Disabled"] = boost::any(*disabled);
    }
    if (stabilizationWindowSeconds) {
      res["StabilizationWindowSeconds"] = boost::any(*stabilizationWindowSeconds);
    }
    if (step) {
      res["Step"] = boost::any(*step);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Disabled") != m.end() && !m["Disabled"].empty()) {
      disabled = make_shared<bool>(boost::any_cast<bool>(m["Disabled"]));
    }
    if (m.find("StabilizationWindowSeconds") != m.end() && !m["StabilizationWindowSeconds"].empty()) {
      stabilizationWindowSeconds = make_shared<long>(boost::any_cast<long>(m["StabilizationWindowSeconds"]));
    }
    if (m.find("Step") != m.end() && !m["Step"].empty()) {
      step = make_shared<long>(boost::any_cast<long>(m["Step"]));
    }
  }


  virtual ~DescribeApplicationScalingRuleResponseBodyDataMetricScaleDownRules() = default;
};
class DescribeApplicationScalingRuleResponseBodyDataMetricScaleUpRules : public Darabonba::Model {
public:
  shared_ptr<bool> disabled{};
  shared_ptr<long> stabilizationWindowSeconds{};
  shared_ptr<long> step{};

  DescribeApplicationScalingRuleResponseBodyDataMetricScaleUpRules() {}

  explicit DescribeApplicationScalingRuleResponseBodyDataMetricScaleUpRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disabled) {
      res["Disabled"] = boost::any(*disabled);
    }
    if (stabilizationWindowSeconds) {
      res["StabilizationWindowSeconds"] = boost::any(*stabilizationWindowSeconds);
    }
    if (step) {
      res["Step"] = boost::any(*step);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Disabled") != m.end() && !m["Disabled"].empty()) {
      disabled = make_shared<bool>(boost::any_cast<bool>(m["Disabled"]));
    }
    if (m.find("StabilizationWindowSeconds") != m.end() && !m["StabilizationWindowSeconds"].empty()) {
      stabilizationWindowSeconds = make_shared<long>(boost::any_cast<long>(m["StabilizationWindowSeconds"]));
    }
    if (m.find("Step") != m.end() && !m["Step"].empty()) {
      step = make_shared<long>(boost::any_cast<long>(m["Step"]));
    }
  }


  virtual ~DescribeApplicationScalingRuleResponseBodyDataMetricScaleUpRules() = default;
};
class DescribeApplicationScalingRuleResponseBodyDataMetric : public Darabonba::Model {
public:
  shared_ptr<long> maxReplicas{};
  shared_ptr<vector<DescribeApplicationScalingRuleResponseBodyDataMetricMetrics>> metrics{};
  shared_ptr<DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatus> metricsStatus{};
  shared_ptr<long> minReplicas{};
  shared_ptr<DescribeApplicationScalingRuleResponseBodyDataMetricScaleDownRules> scaleDownRules{};
  shared_ptr<DescribeApplicationScalingRuleResponseBodyDataMetricScaleUpRules> scaleUpRules{};

  DescribeApplicationScalingRuleResponseBodyDataMetric() {}

  explicit DescribeApplicationScalingRuleResponseBodyDataMetric(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxReplicas) {
      res["MaxReplicas"] = boost::any(*maxReplicas);
    }
    if (metrics) {
      vector<boost::any> temp1;
      for(auto item1:*metrics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Metrics"] = boost::any(temp1);
    }
    if (metricsStatus) {
      res["MetricsStatus"] = metricsStatus ? boost::any(metricsStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (minReplicas) {
      res["MinReplicas"] = boost::any(*minReplicas);
    }
    if (scaleDownRules) {
      res["ScaleDownRules"] = scaleDownRules ? boost::any(scaleDownRules->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scaleUpRules) {
      res["ScaleUpRules"] = scaleUpRules ? boost::any(scaleUpRules->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxReplicas") != m.end() && !m["MaxReplicas"].empty()) {
      maxReplicas = make_shared<long>(boost::any_cast<long>(m["MaxReplicas"]));
    }
    if (m.find("Metrics") != m.end() && !m["Metrics"].empty()) {
      if (typeid(vector<boost::any>) == m["Metrics"].type()) {
        vector<DescribeApplicationScalingRuleResponseBodyDataMetricMetrics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Metrics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApplicationScalingRuleResponseBodyDataMetricMetrics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        metrics = make_shared<vector<DescribeApplicationScalingRuleResponseBodyDataMetricMetrics>>(expect1);
      }
    }
    if (m.find("MetricsStatus") != m.end() && !m["MetricsStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["MetricsStatus"].type()) {
        DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MetricsStatus"]));
        metricsStatus = make_shared<DescribeApplicationScalingRuleResponseBodyDataMetricMetricsStatus>(model1);
      }
    }
    if (m.find("MinReplicas") != m.end() && !m["MinReplicas"].empty()) {
      minReplicas = make_shared<long>(boost::any_cast<long>(m["MinReplicas"]));
    }
    if (m.find("ScaleDownRules") != m.end() && !m["ScaleDownRules"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScaleDownRules"].type()) {
        DescribeApplicationScalingRuleResponseBodyDataMetricScaleDownRules model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScaleDownRules"]));
        scaleDownRules = make_shared<DescribeApplicationScalingRuleResponseBodyDataMetricScaleDownRules>(model1);
      }
    }
    if (m.find("ScaleUpRules") != m.end() && !m["ScaleUpRules"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScaleUpRules"].type()) {
        DescribeApplicationScalingRuleResponseBodyDataMetricScaleUpRules model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScaleUpRules"]));
        scaleUpRules = make_shared<DescribeApplicationScalingRuleResponseBodyDataMetricScaleUpRules>(model1);
      }
    }
  }


  virtual ~DescribeApplicationScalingRuleResponseBodyDataMetric() = default;
};
class DescribeApplicationScalingRuleResponseBodyDataTimerSchedules : public Darabonba::Model {
public:
  shared_ptr<string> atTime{};
  shared_ptr<long> maxReplicas{};
  shared_ptr<long> minReplicas{};
  shared_ptr<long> targetReplicas{};

  DescribeApplicationScalingRuleResponseBodyDataTimerSchedules() {}

  explicit DescribeApplicationScalingRuleResponseBodyDataTimerSchedules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (atTime) {
      res["AtTime"] = boost::any(*atTime);
    }
    if (maxReplicas) {
      res["MaxReplicas"] = boost::any(*maxReplicas);
    }
    if (minReplicas) {
      res["MinReplicas"] = boost::any(*minReplicas);
    }
    if (targetReplicas) {
      res["TargetReplicas"] = boost::any(*targetReplicas);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AtTime") != m.end() && !m["AtTime"].empty()) {
      atTime = make_shared<string>(boost::any_cast<string>(m["AtTime"]));
    }
    if (m.find("MaxReplicas") != m.end() && !m["MaxReplicas"].empty()) {
      maxReplicas = make_shared<long>(boost::any_cast<long>(m["MaxReplicas"]));
    }
    if (m.find("MinReplicas") != m.end() && !m["MinReplicas"].empty()) {
      minReplicas = make_shared<long>(boost::any_cast<long>(m["MinReplicas"]));
    }
    if (m.find("TargetReplicas") != m.end() && !m["TargetReplicas"].empty()) {
      targetReplicas = make_shared<long>(boost::any_cast<long>(m["TargetReplicas"]));
    }
  }


  virtual ~DescribeApplicationScalingRuleResponseBodyDataTimerSchedules() = default;
};
class DescribeApplicationScalingRuleResponseBodyDataTimer : public Darabonba::Model {
public:
  shared_ptr<string> beginDate{};
  shared_ptr<string> endDate{};
  shared_ptr<string> period{};
  shared_ptr<vector<DescribeApplicationScalingRuleResponseBodyDataTimerSchedules>> schedules{};

  DescribeApplicationScalingRuleResponseBodyDataTimer() {}

  explicit DescribeApplicationScalingRuleResponseBodyDataTimer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beginDate) {
      res["BeginDate"] = boost::any(*beginDate);
    }
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (schedules) {
      vector<boost::any> temp1;
      for(auto item1:*schedules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Schedules"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BeginDate") != m.end() && !m["BeginDate"].empty()) {
      beginDate = make_shared<string>(boost::any_cast<string>(m["BeginDate"]));
    }
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("Schedules") != m.end() && !m["Schedules"].empty()) {
      if (typeid(vector<boost::any>) == m["Schedules"].type()) {
        vector<DescribeApplicationScalingRuleResponseBodyDataTimerSchedules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Schedules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApplicationScalingRuleResponseBodyDataTimerSchedules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        schedules = make_shared<vector<DescribeApplicationScalingRuleResponseBodyDataTimerSchedules>>(expect1);
      }
    }
  }


  virtual ~DescribeApplicationScalingRuleResponseBodyDataTimer() = default;
};
class DescribeApplicationScalingRuleResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> createTime{};
  shared_ptr<long> lastDisableTime{};
  shared_ptr<DescribeApplicationScalingRuleResponseBodyDataMetric> metric{};
  shared_ptr<long> minReadyInstanceRatio{};
  shared_ptr<long> minReadyInstances{};
  shared_ptr<bool> scaleRuleEnabled{};
  shared_ptr<string> scaleRuleName{};
  shared_ptr<string> scaleRuleType{};
  shared_ptr<DescribeApplicationScalingRuleResponseBodyDataTimer> timer{};
  shared_ptr<long> updateTime{};

  DescribeApplicationScalingRuleResponseBodyData() {}

  explicit DescribeApplicationScalingRuleResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (lastDisableTime) {
      res["LastDisableTime"] = boost::any(*lastDisableTime);
    }
    if (metric) {
      res["Metric"] = metric ? boost::any(metric->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (minReadyInstanceRatio) {
      res["MinReadyInstanceRatio"] = boost::any(*minReadyInstanceRatio);
    }
    if (minReadyInstances) {
      res["MinReadyInstances"] = boost::any(*minReadyInstances);
    }
    if (scaleRuleEnabled) {
      res["ScaleRuleEnabled"] = boost::any(*scaleRuleEnabled);
    }
    if (scaleRuleName) {
      res["ScaleRuleName"] = boost::any(*scaleRuleName);
    }
    if (scaleRuleType) {
      res["ScaleRuleType"] = boost::any(*scaleRuleType);
    }
    if (timer) {
      res["Timer"] = timer ? boost::any(timer->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("LastDisableTime") != m.end() && !m["LastDisableTime"].empty()) {
      lastDisableTime = make_shared<long>(boost::any_cast<long>(m["LastDisableTime"]));
    }
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      if (typeid(map<string, boost::any>) == m["Metric"].type()) {
        DescribeApplicationScalingRuleResponseBodyDataMetric model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Metric"]));
        metric = make_shared<DescribeApplicationScalingRuleResponseBodyDataMetric>(model1);
      }
    }
    if (m.find("MinReadyInstanceRatio") != m.end() && !m["MinReadyInstanceRatio"].empty()) {
      minReadyInstanceRatio = make_shared<long>(boost::any_cast<long>(m["MinReadyInstanceRatio"]));
    }
    if (m.find("MinReadyInstances") != m.end() && !m["MinReadyInstances"].empty()) {
      minReadyInstances = make_shared<long>(boost::any_cast<long>(m["MinReadyInstances"]));
    }
    if (m.find("ScaleRuleEnabled") != m.end() && !m["ScaleRuleEnabled"].empty()) {
      scaleRuleEnabled = make_shared<bool>(boost::any_cast<bool>(m["ScaleRuleEnabled"]));
    }
    if (m.find("ScaleRuleName") != m.end() && !m["ScaleRuleName"].empty()) {
      scaleRuleName = make_shared<string>(boost::any_cast<string>(m["ScaleRuleName"]));
    }
    if (m.find("ScaleRuleType") != m.end() && !m["ScaleRuleType"].empty()) {
      scaleRuleType = make_shared<string>(boost::any_cast<string>(m["ScaleRuleType"]));
    }
    if (m.find("Timer") != m.end() && !m["Timer"].empty()) {
      if (typeid(map<string, boost::any>) == m["Timer"].type()) {
        DescribeApplicationScalingRuleResponseBodyDataTimer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Timer"]));
        timer = make_shared<DescribeApplicationScalingRuleResponseBodyDataTimer>(model1);
      }
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~DescribeApplicationScalingRuleResponseBodyData() = default;
};
class DescribeApplicationScalingRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeApplicationScalingRuleResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  DescribeApplicationScalingRuleResponseBody() {}

  explicit DescribeApplicationScalingRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeApplicationScalingRuleResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeApplicationScalingRuleResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~DescribeApplicationScalingRuleResponseBody() = default;
};
class DescribeApplicationScalingRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApplicationScalingRuleResponseBody> body{};

  DescribeApplicationScalingRuleResponse() {}

  explicit DescribeApplicationScalingRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApplicationScalingRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApplicationScalingRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApplicationScalingRuleResponse() = default;
};
class DescribeApplicationScalingRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  DescribeApplicationScalingRulesRequest() {}

  explicit DescribeApplicationScalingRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~DescribeApplicationScalingRulesRequest() = default;
};
class DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetrics : public Darabonba::Model {
public:
  shared_ptr<long> metricTargetAverageUtilization{};
  shared_ptr<string> metricType{};
  shared_ptr<string> slbId{};
  shared_ptr<string> slbLogstore{};
  shared_ptr<string> slbProject{};
  shared_ptr<string> vport{};

  DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetrics() {}

  explicit DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetrics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metricTargetAverageUtilization) {
      res["MetricTargetAverageUtilization"] = boost::any(*metricTargetAverageUtilization);
    }
    if (metricType) {
      res["MetricType"] = boost::any(*metricType);
    }
    if (slbId) {
      res["SlbId"] = boost::any(*slbId);
    }
    if (slbLogstore) {
      res["SlbLogstore"] = boost::any(*slbLogstore);
    }
    if (slbProject) {
      res["SlbProject"] = boost::any(*slbProject);
    }
    if (vport) {
      res["Vport"] = boost::any(*vport);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MetricTargetAverageUtilization") != m.end() && !m["MetricTargetAverageUtilization"].empty()) {
      metricTargetAverageUtilization = make_shared<long>(boost::any_cast<long>(m["MetricTargetAverageUtilization"]));
    }
    if (m.find("MetricType") != m.end() && !m["MetricType"].empty()) {
      metricType = make_shared<string>(boost::any_cast<string>(m["MetricType"]));
    }
    if (m.find("SlbId") != m.end() && !m["SlbId"].empty()) {
      slbId = make_shared<string>(boost::any_cast<string>(m["SlbId"]));
    }
    if (m.find("SlbLogstore") != m.end() && !m["SlbLogstore"].empty()) {
      slbLogstore = make_shared<string>(boost::any_cast<string>(m["SlbLogstore"]));
    }
    if (m.find("SlbProject") != m.end() && !m["SlbProject"].empty()) {
      slbProject = make_shared<string>(boost::any_cast<string>(m["SlbProject"]));
    }
    if (m.find("Vport") != m.end() && !m["Vport"].empty()) {
      vport = make_shared<string>(boost::any_cast<string>(m["Vport"]));
    }
  }


  virtual ~DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetrics() = default;
};
class DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatusCurrentMetrics : public Darabonba::Model {
public:
  shared_ptr<long> currentValue{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};

  DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatusCurrentMetrics() {}

  explicit DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatusCurrentMetrics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentValue) {
      res["CurrentValue"] = boost::any(*currentValue);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentValue") != m.end() && !m["CurrentValue"].empty()) {
      currentValue = make_shared<long>(boost::any_cast<long>(m["CurrentValue"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatusCurrentMetrics() = default;
};
class DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatusNextScaleMetrics : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> nextScaleInAverageUtilization{};
  shared_ptr<long> nextScaleOutAverageUtilization{};

  DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatusNextScaleMetrics() {}

  explicit DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatusNextScaleMetrics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nextScaleInAverageUtilization) {
      res["NextScaleInAverageUtilization"] = boost::any(*nextScaleInAverageUtilization);
    }
    if (nextScaleOutAverageUtilization) {
      res["NextScaleOutAverageUtilization"] = boost::any(*nextScaleOutAverageUtilization);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NextScaleInAverageUtilization") != m.end() && !m["NextScaleInAverageUtilization"].empty()) {
      nextScaleInAverageUtilization = make_shared<long>(boost::any_cast<long>(m["NextScaleInAverageUtilization"]));
    }
    if (m.find("NextScaleOutAverageUtilization") != m.end() && !m["NextScaleOutAverageUtilization"].empty()) {
      nextScaleOutAverageUtilization = make_shared<long>(boost::any_cast<long>(m["NextScaleOutAverageUtilization"]));
    }
  }


  virtual ~DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatusNextScaleMetrics() = default;
};
class DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatus : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatusCurrentMetrics>> currentMetrics{};
  shared_ptr<long> currentReplicas{};
  shared_ptr<long> desiredReplicas{};
  shared_ptr<string> lastScaleTime{};
  shared_ptr<long> maxReplicas{};
  shared_ptr<long> minReplicas{};
  shared_ptr<vector<DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatusNextScaleMetrics>> nextScaleMetrics{};
  shared_ptr<long> nextScaleTimePeriod{};

  DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatus() {}

  explicit DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentMetrics) {
      vector<boost::any> temp1;
      for(auto item1:*currentMetrics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CurrentMetrics"] = boost::any(temp1);
    }
    if (currentReplicas) {
      res["CurrentReplicas"] = boost::any(*currentReplicas);
    }
    if (desiredReplicas) {
      res["DesiredReplicas"] = boost::any(*desiredReplicas);
    }
    if (lastScaleTime) {
      res["LastScaleTime"] = boost::any(*lastScaleTime);
    }
    if (maxReplicas) {
      res["MaxReplicas"] = boost::any(*maxReplicas);
    }
    if (minReplicas) {
      res["MinReplicas"] = boost::any(*minReplicas);
    }
    if (nextScaleMetrics) {
      vector<boost::any> temp1;
      for(auto item1:*nextScaleMetrics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NextScaleMetrics"] = boost::any(temp1);
    }
    if (nextScaleTimePeriod) {
      res["NextScaleTimePeriod"] = boost::any(*nextScaleTimePeriod);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentMetrics") != m.end() && !m["CurrentMetrics"].empty()) {
      if (typeid(vector<boost::any>) == m["CurrentMetrics"].type()) {
        vector<DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatusCurrentMetrics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CurrentMetrics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatusCurrentMetrics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        currentMetrics = make_shared<vector<DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatusCurrentMetrics>>(expect1);
      }
    }
    if (m.find("CurrentReplicas") != m.end() && !m["CurrentReplicas"].empty()) {
      currentReplicas = make_shared<long>(boost::any_cast<long>(m["CurrentReplicas"]));
    }
    if (m.find("DesiredReplicas") != m.end() && !m["DesiredReplicas"].empty()) {
      desiredReplicas = make_shared<long>(boost::any_cast<long>(m["DesiredReplicas"]));
    }
    if (m.find("LastScaleTime") != m.end() && !m["LastScaleTime"].empty()) {
      lastScaleTime = make_shared<string>(boost::any_cast<string>(m["LastScaleTime"]));
    }
    if (m.find("MaxReplicas") != m.end() && !m["MaxReplicas"].empty()) {
      maxReplicas = make_shared<long>(boost::any_cast<long>(m["MaxReplicas"]));
    }
    if (m.find("MinReplicas") != m.end() && !m["MinReplicas"].empty()) {
      minReplicas = make_shared<long>(boost::any_cast<long>(m["MinReplicas"]));
    }
    if (m.find("NextScaleMetrics") != m.end() && !m["NextScaleMetrics"].empty()) {
      if (typeid(vector<boost::any>) == m["NextScaleMetrics"].type()) {
        vector<DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatusNextScaleMetrics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NextScaleMetrics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatusNextScaleMetrics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nextScaleMetrics = make_shared<vector<DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatusNextScaleMetrics>>(expect1);
      }
    }
    if (m.find("NextScaleTimePeriod") != m.end() && !m["NextScaleTimePeriod"].empty()) {
      nextScaleTimePeriod = make_shared<long>(boost::any_cast<long>(m["NextScaleTimePeriod"]));
    }
  }


  virtual ~DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatus() = default;
};
class DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricScaleDownRules : public Darabonba::Model {
public:
  shared_ptr<bool> disabled{};
  shared_ptr<long> stabilizationWindowSeconds{};
  shared_ptr<long> step{};

  DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricScaleDownRules() {}

  explicit DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricScaleDownRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disabled) {
      res["Disabled"] = boost::any(*disabled);
    }
    if (stabilizationWindowSeconds) {
      res["StabilizationWindowSeconds"] = boost::any(*stabilizationWindowSeconds);
    }
    if (step) {
      res["Step"] = boost::any(*step);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Disabled") != m.end() && !m["Disabled"].empty()) {
      disabled = make_shared<bool>(boost::any_cast<bool>(m["Disabled"]));
    }
    if (m.find("StabilizationWindowSeconds") != m.end() && !m["StabilizationWindowSeconds"].empty()) {
      stabilizationWindowSeconds = make_shared<long>(boost::any_cast<long>(m["StabilizationWindowSeconds"]));
    }
    if (m.find("Step") != m.end() && !m["Step"].empty()) {
      step = make_shared<long>(boost::any_cast<long>(m["Step"]));
    }
  }


  virtual ~DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricScaleDownRules() = default;
};
class DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricScaleUpRules : public Darabonba::Model {
public:
  shared_ptr<bool> disabled{};
  shared_ptr<long> stabilizationWindowSeconds{};
  shared_ptr<long> step{};

  DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricScaleUpRules() {}

  explicit DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricScaleUpRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disabled) {
      res["Disabled"] = boost::any(*disabled);
    }
    if (stabilizationWindowSeconds) {
      res["StabilizationWindowSeconds"] = boost::any(*stabilizationWindowSeconds);
    }
    if (step) {
      res["Step"] = boost::any(*step);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Disabled") != m.end() && !m["Disabled"].empty()) {
      disabled = make_shared<bool>(boost::any_cast<bool>(m["Disabled"]));
    }
    if (m.find("StabilizationWindowSeconds") != m.end() && !m["StabilizationWindowSeconds"].empty()) {
      stabilizationWindowSeconds = make_shared<long>(boost::any_cast<long>(m["StabilizationWindowSeconds"]));
    }
    if (m.find("Step") != m.end() && !m["Step"].empty()) {
      step = make_shared<long>(boost::any_cast<long>(m["Step"]));
    }
  }


  virtual ~DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricScaleUpRules() = default;
};
class DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetric : public Darabonba::Model {
public:
  shared_ptr<long> maxReplicas{};
  shared_ptr<vector<DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetrics>> metrics{};
  shared_ptr<DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatus> metricsStatus{};
  shared_ptr<long> minReplicas{};
  shared_ptr<DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricScaleDownRules> scaleDownRules{};
  shared_ptr<DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricScaleUpRules> scaleUpRules{};

  DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetric() {}

  explicit DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetric(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxReplicas) {
      res["MaxReplicas"] = boost::any(*maxReplicas);
    }
    if (metrics) {
      vector<boost::any> temp1;
      for(auto item1:*metrics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Metrics"] = boost::any(temp1);
    }
    if (metricsStatus) {
      res["MetricsStatus"] = metricsStatus ? boost::any(metricsStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (minReplicas) {
      res["MinReplicas"] = boost::any(*minReplicas);
    }
    if (scaleDownRules) {
      res["ScaleDownRules"] = scaleDownRules ? boost::any(scaleDownRules->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scaleUpRules) {
      res["ScaleUpRules"] = scaleUpRules ? boost::any(scaleUpRules->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxReplicas") != m.end() && !m["MaxReplicas"].empty()) {
      maxReplicas = make_shared<long>(boost::any_cast<long>(m["MaxReplicas"]));
    }
    if (m.find("Metrics") != m.end() && !m["Metrics"].empty()) {
      if (typeid(vector<boost::any>) == m["Metrics"].type()) {
        vector<DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetrics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Metrics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetrics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        metrics = make_shared<vector<DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetrics>>(expect1);
      }
    }
    if (m.find("MetricsStatus") != m.end() && !m["MetricsStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["MetricsStatus"].type()) {
        DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MetricsStatus"]));
        metricsStatus = make_shared<DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricMetricsStatus>(model1);
      }
    }
    if (m.find("MinReplicas") != m.end() && !m["MinReplicas"].empty()) {
      minReplicas = make_shared<long>(boost::any_cast<long>(m["MinReplicas"]));
    }
    if (m.find("ScaleDownRules") != m.end() && !m["ScaleDownRules"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScaleDownRules"].type()) {
        DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricScaleDownRules model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScaleDownRules"]));
        scaleDownRules = make_shared<DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricScaleDownRules>(model1);
      }
    }
    if (m.find("ScaleUpRules") != m.end() && !m["ScaleUpRules"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScaleUpRules"].type()) {
        DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricScaleUpRules model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScaleUpRules"]));
        scaleUpRules = make_shared<DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetricScaleUpRules>(model1);
      }
    }
  }


  virtual ~DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetric() = default;
};
class DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesTimerSchedules : public Darabonba::Model {
public:
  shared_ptr<string> atTime{};
  shared_ptr<long> maxReplicas{};
  shared_ptr<long> minReplicas{};
  shared_ptr<long> targetReplicas{};

  DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesTimerSchedules() {}

  explicit DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesTimerSchedules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (atTime) {
      res["AtTime"] = boost::any(*atTime);
    }
    if (maxReplicas) {
      res["MaxReplicas"] = boost::any(*maxReplicas);
    }
    if (minReplicas) {
      res["MinReplicas"] = boost::any(*minReplicas);
    }
    if (targetReplicas) {
      res["TargetReplicas"] = boost::any(*targetReplicas);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AtTime") != m.end() && !m["AtTime"].empty()) {
      atTime = make_shared<string>(boost::any_cast<string>(m["AtTime"]));
    }
    if (m.find("MaxReplicas") != m.end() && !m["MaxReplicas"].empty()) {
      maxReplicas = make_shared<long>(boost::any_cast<long>(m["MaxReplicas"]));
    }
    if (m.find("MinReplicas") != m.end() && !m["MinReplicas"].empty()) {
      minReplicas = make_shared<long>(boost::any_cast<long>(m["MinReplicas"]));
    }
    if (m.find("TargetReplicas") != m.end() && !m["TargetReplicas"].empty()) {
      targetReplicas = make_shared<long>(boost::any_cast<long>(m["TargetReplicas"]));
    }
  }


  virtual ~DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesTimerSchedules() = default;
};
class DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesTimer : public Darabonba::Model {
public:
  shared_ptr<string> beginDate{};
  shared_ptr<string> endDate{};
  shared_ptr<string> period{};
  shared_ptr<vector<DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesTimerSchedules>> schedules{};

  DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesTimer() {}

  explicit DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesTimer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beginDate) {
      res["BeginDate"] = boost::any(*beginDate);
    }
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (schedules) {
      vector<boost::any> temp1;
      for(auto item1:*schedules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Schedules"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BeginDate") != m.end() && !m["BeginDate"].empty()) {
      beginDate = make_shared<string>(boost::any_cast<string>(m["BeginDate"]));
    }
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("Schedules") != m.end() && !m["Schedules"].empty()) {
      if (typeid(vector<boost::any>) == m["Schedules"].type()) {
        vector<DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesTimerSchedules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Schedules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesTimerSchedules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        schedules = make_shared<vector<DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesTimerSchedules>>(expect1);
      }
    }
  }


  virtual ~DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesTimer() = default;
};
class DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRules : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> createTime{};
  shared_ptr<long> lastDisableTime{};
  shared_ptr<DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetric> metric{};
  shared_ptr<long> minReadyInstanceRatio{};
  shared_ptr<long> minReadyInstances{};
  shared_ptr<bool> scaleRuleEnabled{};
  shared_ptr<string> scaleRuleName{};
  shared_ptr<string> scaleRuleType{};
  shared_ptr<DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesTimer> timer{};
  shared_ptr<long> updateTime{};

  DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRules() {}

  explicit DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (lastDisableTime) {
      res["LastDisableTime"] = boost::any(*lastDisableTime);
    }
    if (metric) {
      res["Metric"] = metric ? boost::any(metric->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (minReadyInstanceRatio) {
      res["MinReadyInstanceRatio"] = boost::any(*minReadyInstanceRatio);
    }
    if (minReadyInstances) {
      res["MinReadyInstances"] = boost::any(*minReadyInstances);
    }
    if (scaleRuleEnabled) {
      res["ScaleRuleEnabled"] = boost::any(*scaleRuleEnabled);
    }
    if (scaleRuleName) {
      res["ScaleRuleName"] = boost::any(*scaleRuleName);
    }
    if (scaleRuleType) {
      res["ScaleRuleType"] = boost::any(*scaleRuleType);
    }
    if (timer) {
      res["Timer"] = timer ? boost::any(timer->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("LastDisableTime") != m.end() && !m["LastDisableTime"].empty()) {
      lastDisableTime = make_shared<long>(boost::any_cast<long>(m["LastDisableTime"]));
    }
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      if (typeid(map<string, boost::any>) == m["Metric"].type()) {
        DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetric model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Metric"]));
        metric = make_shared<DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesMetric>(model1);
      }
    }
    if (m.find("MinReadyInstanceRatio") != m.end() && !m["MinReadyInstanceRatio"].empty()) {
      minReadyInstanceRatio = make_shared<long>(boost::any_cast<long>(m["MinReadyInstanceRatio"]));
    }
    if (m.find("MinReadyInstances") != m.end() && !m["MinReadyInstances"].empty()) {
      minReadyInstances = make_shared<long>(boost::any_cast<long>(m["MinReadyInstances"]));
    }
    if (m.find("ScaleRuleEnabled") != m.end() && !m["ScaleRuleEnabled"].empty()) {
      scaleRuleEnabled = make_shared<bool>(boost::any_cast<bool>(m["ScaleRuleEnabled"]));
    }
    if (m.find("ScaleRuleName") != m.end() && !m["ScaleRuleName"].empty()) {
      scaleRuleName = make_shared<string>(boost::any_cast<string>(m["ScaleRuleName"]));
    }
    if (m.find("ScaleRuleType") != m.end() && !m["ScaleRuleType"].empty()) {
      scaleRuleType = make_shared<string>(boost::any_cast<string>(m["ScaleRuleType"]));
    }
    if (m.find("Timer") != m.end() && !m["Timer"].empty()) {
      if (typeid(map<string, boost::any>) == m["Timer"].type()) {
        DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesTimer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Timer"]));
        timer = make_shared<DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRulesTimer>(model1);
      }
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRules() = default;
};
class DescribeApplicationScalingRulesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRules>> applicationScalingRules{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalSize{};

  DescribeApplicationScalingRulesResponseBodyData() {}

  explicit DescribeApplicationScalingRulesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationScalingRules) {
      vector<boost::any> temp1;
      for(auto item1:*applicationScalingRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApplicationScalingRules"] = boost::any(temp1);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationScalingRules") != m.end() && !m["ApplicationScalingRules"].empty()) {
      if (typeid(vector<boost::any>) == m["ApplicationScalingRules"].type()) {
        vector<DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApplicationScalingRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        applicationScalingRules = make_shared<vector<DescribeApplicationScalingRulesResponseBodyDataApplicationScalingRules>>(expect1);
      }
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
  }


  virtual ~DescribeApplicationScalingRulesResponseBodyData() = default;
};
class DescribeApplicationScalingRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeApplicationScalingRulesResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  DescribeApplicationScalingRulesResponseBody() {}

  explicit DescribeApplicationScalingRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeApplicationScalingRulesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeApplicationScalingRulesResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~DescribeApplicationScalingRulesResponseBody() = default;
};
class DescribeApplicationScalingRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApplicationScalingRulesResponseBody> body{};

  DescribeApplicationScalingRulesResponse() {}

  explicit DescribeApplicationScalingRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApplicationScalingRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApplicationScalingRulesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApplicationScalingRulesResponse() = default;
};
class DescribeApplicationSlbsRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  DescribeApplicationSlbsRequest() {}

  explicit DescribeApplicationSlbsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~DescribeApplicationSlbsRequest() = default;
};
class DescribeApplicationSlbsResponseBodyDataInternet : public Darabonba::Model {
public:
  shared_ptr<string> cookie{};
  shared_ptr<long> cookieTimeout{};
  shared_ptr<long> createTime{};
  shared_ptr<string> httpsCaCertId{};
  shared_ptr<string> httpsCertId{};
  shared_ptr<long> port{};
  shared_ptr<string> protocol{};
  shared_ptr<bool> stickySession{};
  shared_ptr<string> stickySessionType{};
  shared_ptr<long> targetPort{};

  DescribeApplicationSlbsResponseBodyDataInternet() {}

  explicit DescribeApplicationSlbsResponseBodyDataInternet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cookie) {
      res["Cookie"] = boost::any(*cookie);
    }
    if (cookieTimeout) {
      res["CookieTimeout"] = boost::any(*cookieTimeout);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (httpsCaCertId) {
      res["HttpsCaCertId"] = boost::any(*httpsCaCertId);
    }
    if (httpsCertId) {
      res["HttpsCertId"] = boost::any(*httpsCertId);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (stickySession) {
      res["StickySession"] = boost::any(*stickySession);
    }
    if (stickySessionType) {
      res["StickySessionType"] = boost::any(*stickySessionType);
    }
    if (targetPort) {
      res["TargetPort"] = boost::any(*targetPort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cookie") != m.end() && !m["Cookie"].empty()) {
      cookie = make_shared<string>(boost::any_cast<string>(m["Cookie"]));
    }
    if (m.find("CookieTimeout") != m.end() && !m["CookieTimeout"].empty()) {
      cookieTimeout = make_shared<long>(boost::any_cast<long>(m["CookieTimeout"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("HttpsCaCertId") != m.end() && !m["HttpsCaCertId"].empty()) {
      httpsCaCertId = make_shared<string>(boost::any_cast<string>(m["HttpsCaCertId"]));
    }
    if (m.find("HttpsCertId") != m.end() && !m["HttpsCertId"].empty()) {
      httpsCertId = make_shared<string>(boost::any_cast<string>(m["HttpsCertId"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("StickySession") != m.end() && !m["StickySession"].empty()) {
      stickySession = make_shared<bool>(boost::any_cast<bool>(m["StickySession"]));
    }
    if (m.find("StickySessionType") != m.end() && !m["StickySessionType"].empty()) {
      stickySessionType = make_shared<string>(boost::any_cast<string>(m["StickySessionType"]));
    }
    if (m.find("TargetPort") != m.end() && !m["TargetPort"].empty()) {
      targetPort = make_shared<long>(boost::any_cast<long>(m["TargetPort"]));
    }
  }


  virtual ~DescribeApplicationSlbsResponseBodyDataInternet() = default;
};
class DescribeApplicationSlbsResponseBodyDataIntranet : public Darabonba::Model {
public:
  shared_ptr<string> cookie{};
  shared_ptr<long> cookieTimeout{};
  shared_ptr<long> createTime{};
  shared_ptr<string> httpsCaCertId{};
  shared_ptr<string> httpsCertId{};
  shared_ptr<long> port{};
  shared_ptr<string> protocol{};
  shared_ptr<bool> stickySession{};
  shared_ptr<string> stickySessionType{};
  shared_ptr<long> targetPort{};

  DescribeApplicationSlbsResponseBodyDataIntranet() {}

  explicit DescribeApplicationSlbsResponseBodyDataIntranet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cookie) {
      res["Cookie"] = boost::any(*cookie);
    }
    if (cookieTimeout) {
      res["CookieTimeout"] = boost::any(*cookieTimeout);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (httpsCaCertId) {
      res["HttpsCaCertId"] = boost::any(*httpsCaCertId);
    }
    if (httpsCertId) {
      res["HttpsCertId"] = boost::any(*httpsCertId);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (stickySession) {
      res["StickySession"] = boost::any(*stickySession);
    }
    if (stickySessionType) {
      res["StickySessionType"] = boost::any(*stickySessionType);
    }
    if (targetPort) {
      res["TargetPort"] = boost::any(*targetPort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cookie") != m.end() && !m["Cookie"].empty()) {
      cookie = make_shared<string>(boost::any_cast<string>(m["Cookie"]));
    }
    if (m.find("CookieTimeout") != m.end() && !m["CookieTimeout"].empty()) {
      cookieTimeout = make_shared<long>(boost::any_cast<long>(m["CookieTimeout"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("HttpsCaCertId") != m.end() && !m["HttpsCaCertId"].empty()) {
      httpsCaCertId = make_shared<string>(boost::any_cast<string>(m["HttpsCaCertId"]));
    }
    if (m.find("HttpsCertId") != m.end() && !m["HttpsCertId"].empty()) {
      httpsCertId = make_shared<string>(boost::any_cast<string>(m["HttpsCertId"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("StickySession") != m.end() && !m["StickySession"].empty()) {
      stickySession = make_shared<bool>(boost::any_cast<bool>(m["StickySession"]));
    }
    if (m.find("StickySessionType") != m.end() && !m["StickySessionType"].empty()) {
      stickySessionType = make_shared<string>(boost::any_cast<string>(m["StickySessionType"]));
    }
    if (m.find("TargetPort") != m.end() && !m["TargetPort"].empty()) {
      targetPort = make_shared<long>(boost::any_cast<long>(m["TargetPort"]));
    }
  }


  virtual ~DescribeApplicationSlbsResponseBodyDataIntranet() = default;
};
class DescribeApplicationSlbsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> clusterId{};
  shared_ptr<vector<DescribeApplicationSlbsResponseBodyDataInternet>> internet{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> internetSlbChargeType{};
  shared_ptr<bool> internetSlbExpired{};
  shared_ptr<string> internetSlbId{};
  shared_ptr<vector<DescribeApplicationSlbsResponseBodyDataIntranet>> intranet{};
  shared_ptr<string> intranetIp{};
  shared_ptr<string> intranetSlbChargeType{};
  shared_ptr<bool> intranetSlbExpired{};
  shared_ptr<string> intranetSlbId{};

  DescribeApplicationSlbsResponseBodyData() {}

  explicit DescribeApplicationSlbsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (internet) {
      vector<boost::any> temp1;
      for(auto item1:*internet){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Internet"] = boost::any(temp1);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (internetSlbChargeType) {
      res["InternetSlbChargeType"] = boost::any(*internetSlbChargeType);
    }
    if (internetSlbExpired) {
      res["InternetSlbExpired"] = boost::any(*internetSlbExpired);
    }
    if (internetSlbId) {
      res["InternetSlbId"] = boost::any(*internetSlbId);
    }
    if (intranet) {
      vector<boost::any> temp1;
      for(auto item1:*intranet){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Intranet"] = boost::any(temp1);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (intranetSlbChargeType) {
      res["IntranetSlbChargeType"] = boost::any(*intranetSlbChargeType);
    }
    if (intranetSlbExpired) {
      res["IntranetSlbExpired"] = boost::any(*intranetSlbExpired);
    }
    if (intranetSlbId) {
      res["IntranetSlbId"] = boost::any(*intranetSlbId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Internet") != m.end() && !m["Internet"].empty()) {
      if (typeid(vector<boost::any>) == m["Internet"].type()) {
        vector<DescribeApplicationSlbsResponseBodyDataInternet> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Internet"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApplicationSlbsResponseBodyDataInternet model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        internet = make_shared<vector<DescribeApplicationSlbsResponseBodyDataInternet>>(expect1);
      }
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("InternetSlbChargeType") != m.end() && !m["InternetSlbChargeType"].empty()) {
      internetSlbChargeType = make_shared<string>(boost::any_cast<string>(m["InternetSlbChargeType"]));
    }
    if (m.find("InternetSlbExpired") != m.end() && !m["InternetSlbExpired"].empty()) {
      internetSlbExpired = make_shared<bool>(boost::any_cast<bool>(m["InternetSlbExpired"]));
    }
    if (m.find("InternetSlbId") != m.end() && !m["InternetSlbId"].empty()) {
      internetSlbId = make_shared<string>(boost::any_cast<string>(m["InternetSlbId"]));
    }
    if (m.find("Intranet") != m.end() && !m["Intranet"].empty()) {
      if (typeid(vector<boost::any>) == m["Intranet"].type()) {
        vector<DescribeApplicationSlbsResponseBodyDataIntranet> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Intranet"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApplicationSlbsResponseBodyDataIntranet model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        intranet = make_shared<vector<DescribeApplicationSlbsResponseBodyDataIntranet>>(expect1);
      }
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("IntranetSlbChargeType") != m.end() && !m["IntranetSlbChargeType"].empty()) {
      intranetSlbChargeType = make_shared<string>(boost::any_cast<string>(m["IntranetSlbChargeType"]));
    }
    if (m.find("IntranetSlbExpired") != m.end() && !m["IntranetSlbExpired"].empty()) {
      intranetSlbExpired = make_shared<bool>(boost::any_cast<bool>(m["IntranetSlbExpired"]));
    }
    if (m.find("IntranetSlbId") != m.end() && !m["IntranetSlbId"].empty()) {
      intranetSlbId = make_shared<string>(boost::any_cast<string>(m["IntranetSlbId"]));
    }
  }


  virtual ~DescribeApplicationSlbsResponseBodyData() = default;
};
class DescribeApplicationSlbsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeApplicationSlbsResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  DescribeApplicationSlbsResponseBody() {}

  explicit DescribeApplicationSlbsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeApplicationSlbsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeApplicationSlbsResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~DescribeApplicationSlbsResponseBody() = default;
};
class DescribeApplicationSlbsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApplicationSlbsResponseBody> body{};

  DescribeApplicationSlbsResponse() {}

  explicit DescribeApplicationSlbsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApplicationSlbsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApplicationSlbsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApplicationSlbsResponse() = default;
};
class DescribeApplicationStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  DescribeApplicationStatusRequest() {}

  explicit DescribeApplicationStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~DescribeApplicationStatusRequest() = default;
};
class DescribeApplicationStatusResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> armsAdvancedEnabled{};
  shared_ptr<string> armsApmInfo{};
  shared_ptr<string> createTime{};
  shared_ptr<string> currentStatus{};
  shared_ptr<bool> enableAgent{};
  shared_ptr<long> fileSizeLimit{};
  shared_ptr<string> lastChangeOrderId{};
  shared_ptr<bool> lastChangeOrderRunning{};
  shared_ptr<string> lastChangeOrderStatus{};
  shared_ptr<long> runningInstances{};
  shared_ptr<string> subStatus{};

  DescribeApplicationStatusResponseBodyData() {}

  explicit DescribeApplicationStatusResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (armsAdvancedEnabled) {
      res["ArmsAdvancedEnabled"] = boost::any(*armsAdvancedEnabled);
    }
    if (armsApmInfo) {
      res["ArmsApmInfo"] = boost::any(*armsApmInfo);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (currentStatus) {
      res["CurrentStatus"] = boost::any(*currentStatus);
    }
    if (enableAgent) {
      res["EnableAgent"] = boost::any(*enableAgent);
    }
    if (fileSizeLimit) {
      res["FileSizeLimit"] = boost::any(*fileSizeLimit);
    }
    if (lastChangeOrderId) {
      res["LastChangeOrderId"] = boost::any(*lastChangeOrderId);
    }
    if (lastChangeOrderRunning) {
      res["LastChangeOrderRunning"] = boost::any(*lastChangeOrderRunning);
    }
    if (lastChangeOrderStatus) {
      res["LastChangeOrderStatus"] = boost::any(*lastChangeOrderStatus);
    }
    if (runningInstances) {
      res["RunningInstances"] = boost::any(*runningInstances);
    }
    if (subStatus) {
      res["SubStatus"] = boost::any(*subStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ArmsAdvancedEnabled") != m.end() && !m["ArmsAdvancedEnabled"].empty()) {
      armsAdvancedEnabled = make_shared<string>(boost::any_cast<string>(m["ArmsAdvancedEnabled"]));
    }
    if (m.find("ArmsApmInfo") != m.end() && !m["ArmsApmInfo"].empty()) {
      armsApmInfo = make_shared<string>(boost::any_cast<string>(m["ArmsApmInfo"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CurrentStatus") != m.end() && !m["CurrentStatus"].empty()) {
      currentStatus = make_shared<string>(boost::any_cast<string>(m["CurrentStatus"]));
    }
    if (m.find("EnableAgent") != m.end() && !m["EnableAgent"].empty()) {
      enableAgent = make_shared<bool>(boost::any_cast<bool>(m["EnableAgent"]));
    }
    if (m.find("FileSizeLimit") != m.end() && !m["FileSizeLimit"].empty()) {
      fileSizeLimit = make_shared<long>(boost::any_cast<long>(m["FileSizeLimit"]));
    }
    if (m.find("LastChangeOrderId") != m.end() && !m["LastChangeOrderId"].empty()) {
      lastChangeOrderId = make_shared<string>(boost::any_cast<string>(m["LastChangeOrderId"]));
    }
    if (m.find("LastChangeOrderRunning") != m.end() && !m["LastChangeOrderRunning"].empty()) {
      lastChangeOrderRunning = make_shared<bool>(boost::any_cast<bool>(m["LastChangeOrderRunning"]));
    }
    if (m.find("LastChangeOrderStatus") != m.end() && !m["LastChangeOrderStatus"].empty()) {
      lastChangeOrderStatus = make_shared<string>(boost::any_cast<string>(m["LastChangeOrderStatus"]));
    }
    if (m.find("RunningInstances") != m.end() && !m["RunningInstances"].empty()) {
      runningInstances = make_shared<long>(boost::any_cast<long>(m["RunningInstances"]));
    }
    if (m.find("SubStatus") != m.end() && !m["SubStatus"].empty()) {
      subStatus = make_shared<string>(boost::any_cast<string>(m["SubStatus"]));
    }
  }


  virtual ~DescribeApplicationStatusResponseBodyData() = default;
};
class DescribeApplicationStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeApplicationStatusResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  DescribeApplicationStatusResponseBody() {}

  explicit DescribeApplicationStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeApplicationStatusResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeApplicationStatusResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~DescribeApplicationStatusResponseBody() = default;
};
class DescribeApplicationStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApplicationStatusResponseBody> body{};

  DescribeApplicationStatusResponse() {}

  explicit DescribeApplicationStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApplicationStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApplicationStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApplicationStatusResponse() = default;
};
class DescribeChangeOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};

  DescribeChangeOrderRequest() {}

  explicit DescribeChangeOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
  }


  virtual ~DescribeChangeOrderRequest() = default;
};
class DescribeChangeOrderResponseBodyDataPipelines : public Darabonba::Model {
public:
  shared_ptr<long> batchType{};
  shared_ptr<long> parallelCount{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> pipelineName{};
  shared_ptr<long> startTime{};
  shared_ptr<long> status{};
  shared_ptr<long> updateTime{};

  DescribeChangeOrderResponseBodyDataPipelines() {}

  explicit DescribeChangeOrderResponseBodyDataPipelines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (batchType) {
      res["BatchType"] = boost::any(*batchType);
    }
    if (parallelCount) {
      res["ParallelCount"] = boost::any(*parallelCount);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (pipelineName) {
      res["PipelineName"] = boost::any(*pipelineName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BatchType") != m.end() && !m["BatchType"].empty()) {
      batchType = make_shared<long>(boost::any_cast<long>(m["BatchType"]));
    }
    if (m.find("ParallelCount") != m.end() && !m["ParallelCount"].empty()) {
      parallelCount = make_shared<long>(boost::any_cast<long>(m["ParallelCount"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("PipelineName") != m.end() && !m["PipelineName"].empty()) {
      pipelineName = make_shared<string>(boost::any_cast<string>(m["PipelineName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~DescribeChangeOrderResponseBodyDataPipelines() = default;
};
class DescribeChangeOrderResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<bool> applicationEnableGreyTagRoute{};
  shared_ptr<string> applicationUpdateStrategy{};
  shared_ptr<string> approvalId{};
  shared_ptr<bool> auto_{};
  shared_ptr<long> batchCount{};
  shared_ptr<string> batchType{};
  shared_ptr<long> batchWaitTime{};
  shared_ptr<string> changeOrderId{};
  shared_ptr<string> coType{};
  shared_ptr<string> coTypeCode{};
  shared_ptr<string> createTime{};
  shared_ptr<string> currentPipelineId{};
  shared_ptr<string> description{};
  shared_ptr<string> errorMessage{};
  shared_ptr<vector<DescribeChangeOrderResponseBodyDataPipelines>> pipelines{};
  shared_ptr<long> status{};
  shared_ptr<long> subStatus{};
  shared_ptr<bool> supportRollback{};

  DescribeChangeOrderResponseBodyData() {}

  explicit DescribeChangeOrderResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (applicationEnableGreyTagRoute) {
      res["ApplicationEnableGreyTagRoute"] = boost::any(*applicationEnableGreyTagRoute);
    }
    if (applicationUpdateStrategy) {
      res["ApplicationUpdateStrategy"] = boost::any(*applicationUpdateStrategy);
    }
    if (approvalId) {
      res["ApprovalId"] = boost::any(*approvalId);
    }
    if (auto_) {
      res["Auto"] = boost::any(*auto_);
    }
    if (batchCount) {
      res["BatchCount"] = boost::any(*batchCount);
    }
    if (batchType) {
      res["BatchType"] = boost::any(*batchType);
    }
    if (batchWaitTime) {
      res["BatchWaitTime"] = boost::any(*batchWaitTime);
    }
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (coType) {
      res["CoType"] = boost::any(*coType);
    }
    if (coTypeCode) {
      res["CoTypeCode"] = boost::any(*coTypeCode);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (currentPipelineId) {
      res["CurrentPipelineId"] = boost::any(*currentPipelineId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (pipelines) {
      vector<boost::any> temp1;
      for(auto item1:*pipelines){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Pipelines"] = boost::any(temp1);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (subStatus) {
      res["SubStatus"] = boost::any(*subStatus);
    }
    if (supportRollback) {
      res["SupportRollback"] = boost::any(*supportRollback);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("ApplicationEnableGreyTagRoute") != m.end() && !m["ApplicationEnableGreyTagRoute"].empty()) {
      applicationEnableGreyTagRoute = make_shared<bool>(boost::any_cast<bool>(m["ApplicationEnableGreyTagRoute"]));
    }
    if (m.find("ApplicationUpdateStrategy") != m.end() && !m["ApplicationUpdateStrategy"].empty()) {
      applicationUpdateStrategy = make_shared<string>(boost::any_cast<string>(m["ApplicationUpdateStrategy"]));
    }
    if (m.find("ApprovalId") != m.end() && !m["ApprovalId"].empty()) {
      approvalId = make_shared<string>(boost::any_cast<string>(m["ApprovalId"]));
    }
    if (m.find("Auto") != m.end() && !m["Auto"].empty()) {
      auto_ = make_shared<bool>(boost::any_cast<bool>(m["Auto"]));
    }
    if (m.find("BatchCount") != m.end() && !m["BatchCount"].empty()) {
      batchCount = make_shared<long>(boost::any_cast<long>(m["BatchCount"]));
    }
    if (m.find("BatchType") != m.end() && !m["BatchType"].empty()) {
      batchType = make_shared<string>(boost::any_cast<string>(m["BatchType"]));
    }
    if (m.find("BatchWaitTime") != m.end() && !m["BatchWaitTime"].empty()) {
      batchWaitTime = make_shared<long>(boost::any_cast<long>(m["BatchWaitTime"]));
    }
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("CoType") != m.end() && !m["CoType"].empty()) {
      coType = make_shared<string>(boost::any_cast<string>(m["CoType"]));
    }
    if (m.find("CoTypeCode") != m.end() && !m["CoTypeCode"].empty()) {
      coTypeCode = make_shared<string>(boost::any_cast<string>(m["CoTypeCode"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CurrentPipelineId") != m.end() && !m["CurrentPipelineId"].empty()) {
      currentPipelineId = make_shared<string>(boost::any_cast<string>(m["CurrentPipelineId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Pipelines") != m.end() && !m["Pipelines"].empty()) {
      if (typeid(vector<boost::any>) == m["Pipelines"].type()) {
        vector<DescribeChangeOrderResponseBodyDataPipelines> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Pipelines"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeChangeOrderResponseBodyDataPipelines model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pipelines = make_shared<vector<DescribeChangeOrderResponseBodyDataPipelines>>(expect1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("SubStatus") != m.end() && !m["SubStatus"].empty()) {
      subStatus = make_shared<long>(boost::any_cast<long>(m["SubStatus"]));
    }
    if (m.find("SupportRollback") != m.end() && !m["SupportRollback"].empty()) {
      supportRollback = make_shared<bool>(boost::any_cast<bool>(m["SupportRollback"]));
    }
  }


  virtual ~DescribeChangeOrderResponseBodyData() = default;
};
class DescribeChangeOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeChangeOrderResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  DescribeChangeOrderResponseBody() {}

  explicit DescribeChangeOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeChangeOrderResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeChangeOrderResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~DescribeChangeOrderResponseBody() = default;
};
class DescribeChangeOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeChangeOrderResponseBody> body{};

  DescribeChangeOrderResponse() {}

  explicit DescribeChangeOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeChangeOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeChangeOrderResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeChangeOrderResponse() = default;
};
class DescribeComponentsRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> type{};

  DescribeComponentsRequest() {}

  explicit DescribeComponentsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeComponentsRequest() = default;
};
class DescribeComponentsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> componentDescription{};
  shared_ptr<string> componentKey{};
  shared_ptr<bool> expired{};
  shared_ptr<string> type{};

  DescribeComponentsResponseBodyData() {}

  explicit DescribeComponentsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (componentDescription) {
      res["ComponentDescription"] = boost::any(*componentDescription);
    }
    if (componentKey) {
      res["ComponentKey"] = boost::any(*componentKey);
    }
    if (expired) {
      res["Expired"] = boost::any(*expired);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComponentDescription") != m.end() && !m["ComponentDescription"].empty()) {
      componentDescription = make_shared<string>(boost::any_cast<string>(m["ComponentDescription"]));
    }
    if (m.find("ComponentKey") != m.end() && !m["ComponentKey"].empty()) {
      componentKey = make_shared<string>(boost::any_cast<string>(m["ComponentKey"]));
    }
    if (m.find("Expired") != m.end() && !m["Expired"].empty()) {
      expired = make_shared<bool>(boost::any_cast<bool>(m["Expired"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeComponentsResponseBodyData() = default;
};
class DescribeComponentsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<DescribeComponentsResponseBodyData>> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  DescribeComponentsResponseBody() {}

  explicit DescribeComponentsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeComponentsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeComponentsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeComponentsResponseBodyData>>(expect1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~DescribeComponentsResponseBody() = default;
};
class DescribeComponentsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeComponentsResponseBody> body{};

  DescribeComponentsResponse() {}

  explicit DescribeComponentsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeComponentsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeComponentsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeComponentsResponse() = default;
};
class DescribeConfigMapRequest : public Darabonba::Model {
public:
  shared_ptr<long> configMapId{};

  DescribeConfigMapRequest() {}

  explicit DescribeConfigMapRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configMapId) {
      res["ConfigMapId"] = boost::any(*configMapId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigMapId") != m.end() && !m["ConfigMapId"].empty()) {
      configMapId = make_shared<long>(boost::any_cast<long>(m["ConfigMapId"]));
    }
  }


  virtual ~DescribeConfigMapRequest() = default;
};
class DescribeConfigMapResponseBodyDataRelateApps : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};

  DescribeConfigMapResponseBodyDataRelateApps() {}

  explicit DescribeConfigMapResponseBodyDataRelateApps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
  }


  virtual ~DescribeConfigMapResponseBodyDataRelateApps() = default;
};
class DescribeConfigMapResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> configMapId{};
  shared_ptr<long> createTime{};
  shared_ptr<map<string, boost::any>> data{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> namespaceId{};
  shared_ptr<vector<DescribeConfigMapResponseBodyDataRelateApps>> relateApps{};
  shared_ptr<long> updateTime{};

  DescribeConfigMapResponseBodyData() {}

  explicit DescribeConfigMapResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configMapId) {
      res["ConfigMapId"] = boost::any(*configMapId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (relateApps) {
      vector<boost::any> temp1;
      for(auto item1:*relateApps){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RelateApps"] = boost::any(temp1);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigMapId") != m.end() && !m["ConfigMapId"].empty()) {
      configMapId = make_shared<long>(boost::any_cast<long>(m["ConfigMapId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Data"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      data = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("RelateApps") != m.end() && !m["RelateApps"].empty()) {
      if (typeid(vector<boost::any>) == m["RelateApps"].type()) {
        vector<DescribeConfigMapResponseBodyDataRelateApps> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RelateApps"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeConfigMapResponseBodyDataRelateApps model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        relateApps = make_shared<vector<DescribeConfigMapResponseBodyDataRelateApps>>(expect1);
      }
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~DescribeConfigMapResponseBodyData() = default;
};
class DescribeConfigMapResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeConfigMapResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  DescribeConfigMapResponseBody() {}

  explicit DescribeConfigMapResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeConfigMapResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeConfigMapResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~DescribeConfigMapResponseBody() = default;
};
class DescribeConfigMapResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeConfigMapResponseBody> body{};

  DescribeConfigMapResponse() {}

  explicit DescribeConfigMapResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeConfigMapResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeConfigMapResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeConfigMapResponse() = default;
};
class DescribeConfigurationPriceRequest : public Darabonba::Model {
public:
  shared_ptr<long> cpu{};
  shared_ptr<long> memory{};
  shared_ptr<string> newSaeVersion{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> workload{};

  DescribeConfigurationPriceRequest() {}

  explicit DescribeConfigurationPriceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (newSaeVersion) {
      res["NewSaeVersion"] = boost::any(*newSaeVersion);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (workload) {
      res["Workload"] = boost::any(*workload);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
    if (m.find("NewSaeVersion") != m.end() && !m["NewSaeVersion"].empty()) {
      newSaeVersion = make_shared<string>(boost::any_cast<string>(m["NewSaeVersion"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Workload") != m.end() && !m["Workload"].empty()) {
      workload = make_shared<string>(boost::any_cast<string>(m["Workload"]));
    }
  }


  virtual ~DescribeConfigurationPriceRequest() = default;
};
class DescribeConfigurationPriceResponseBodyDataBagUsage : public Darabonba::Model {
public:
  shared_ptr<double> cpu{};
  shared_ptr<double> cu{};
  shared_ptr<double> mem{};

  DescribeConfigurationPriceResponseBodyDataBagUsage() {}

  explicit DescribeConfigurationPriceResponseBodyDataBagUsage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (cu) {
      res["Cu"] = boost::any(*cu);
    }
    if (mem) {
      res["Mem"] = boost::any(*mem);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<double>(boost::any_cast<double>(m["Cpu"]));
    }
    if (m.find("Cu") != m.end() && !m["Cu"].empty()) {
      cu = make_shared<double>(boost::any_cast<double>(m["Cu"]));
    }
    if (m.find("Mem") != m.end() && !m["Mem"].empty()) {
      mem = make_shared<double>(boost::any_cast<double>(m["Mem"]));
    }
  }


  virtual ~DescribeConfigurationPriceResponseBodyDataBagUsage() = default;
};
class DescribeConfigurationPriceResponseBodyDataCpuMemPriceOrder : public Darabonba::Model {
public:
  shared_ptr<double> discountAmount{};
  shared_ptr<double> originalAmount{};
  shared_ptr<vector<string>> ruleIds{};
  shared_ptr<double> tradeAmount{};

  DescribeConfigurationPriceResponseBodyDataCpuMemPriceOrder() {}

  explicit DescribeConfigurationPriceResponseBodyDataCpuMemPriceOrder(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (discountAmount) {
      res["DiscountAmount"] = boost::any(*discountAmount);
    }
    if (originalAmount) {
      res["OriginalAmount"] = boost::any(*originalAmount);
    }
    if (ruleIds) {
      res["RuleIds"] = boost::any(*ruleIds);
    }
    if (tradeAmount) {
      res["TradeAmount"] = boost::any(*tradeAmount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiscountAmount") != m.end() && !m["DiscountAmount"].empty()) {
      discountAmount = make_shared<double>(boost::any_cast<double>(m["DiscountAmount"]));
    }
    if (m.find("OriginalAmount") != m.end() && !m["OriginalAmount"].empty()) {
      originalAmount = make_shared<double>(boost::any_cast<double>(m["OriginalAmount"]));
    }
    if (m.find("RuleIds") != m.end() && !m["RuleIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RuleIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RuleIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ruleIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TradeAmount") != m.end() && !m["TradeAmount"].empty()) {
      tradeAmount = make_shared<double>(boost::any_cast<double>(m["TradeAmount"]));
    }
  }


  virtual ~DescribeConfigurationPriceResponseBodyDataCpuMemPriceOrder() = default;
};
class DescribeConfigurationPriceResponseBodyDataCpuMemPriceRules : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<double> ruleDescId{};

  DescribeConfigurationPriceResponseBodyDataCpuMemPriceRules() {}

  explicit DescribeConfigurationPriceResponseBodyDataCpuMemPriceRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ruleDescId) {
      res["RuleDescId"] = boost::any(*ruleDescId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RuleDescId") != m.end() && !m["RuleDescId"].empty()) {
      ruleDescId = make_shared<double>(boost::any_cast<double>(m["RuleDescId"]));
    }
  }


  virtual ~DescribeConfigurationPriceResponseBodyDataCpuMemPriceRules() = default;
};
class DescribeConfigurationPriceResponseBodyDataCpuMemPrice : public Darabonba::Model {
public:
  shared_ptr<DescribeConfigurationPriceResponseBodyDataCpuMemPriceOrder> order{};
  shared_ptr<vector<DescribeConfigurationPriceResponseBodyDataCpuMemPriceRules>> rules{};

  DescribeConfigurationPriceResponseBodyDataCpuMemPrice() {}

  explicit DescribeConfigurationPriceResponseBodyDataCpuMemPrice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (order) {
      res["Order"] = order ? boost::any(order->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (rules) {
      vector<boost::any> temp1;
      for(auto item1:*rules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rules"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      if (typeid(map<string, boost::any>) == m["Order"].type()) {
        DescribeConfigurationPriceResponseBodyDataCpuMemPriceOrder model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Order"]));
        order = make_shared<DescribeConfigurationPriceResponseBodyDataCpuMemPriceOrder>(model1);
      }
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      if (typeid(vector<boost::any>) == m["Rules"].type()) {
        vector<DescribeConfigurationPriceResponseBodyDataCpuMemPriceRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeConfigurationPriceResponseBodyDataCpuMemPriceRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rules = make_shared<vector<DescribeConfigurationPriceResponseBodyDataCpuMemPriceRules>>(expect1);
      }
    }
  }


  virtual ~DescribeConfigurationPriceResponseBodyDataCpuMemPrice() = default;
};
class DescribeConfigurationPriceResponseBodyDataOrder : public Darabonba::Model {
public:
  shared_ptr<double> discountAmount{};
  shared_ptr<double> originalAmount{};
  shared_ptr<vector<string>> ruleIds{};
  shared_ptr<double> tradeAmount{};

  DescribeConfigurationPriceResponseBodyDataOrder() {}

  explicit DescribeConfigurationPriceResponseBodyDataOrder(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (discountAmount) {
      res["DiscountAmount"] = boost::any(*discountAmount);
    }
    if (originalAmount) {
      res["OriginalAmount"] = boost::any(*originalAmount);
    }
    if (ruleIds) {
      res["RuleIds"] = boost::any(*ruleIds);
    }
    if (tradeAmount) {
      res["TradeAmount"] = boost::any(*tradeAmount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiscountAmount") != m.end() && !m["DiscountAmount"].empty()) {
      discountAmount = make_shared<double>(boost::any_cast<double>(m["DiscountAmount"]));
    }
    if (m.find("OriginalAmount") != m.end() && !m["OriginalAmount"].empty()) {
      originalAmount = make_shared<double>(boost::any_cast<double>(m["OriginalAmount"]));
    }
    if (m.find("RuleIds") != m.end() && !m["RuleIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RuleIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RuleIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ruleIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TradeAmount") != m.end() && !m["TradeAmount"].empty()) {
      tradeAmount = make_shared<double>(boost::any_cast<double>(m["TradeAmount"]));
    }
  }


  virtual ~DescribeConfigurationPriceResponseBodyDataOrder() = default;
};
class DescribeConfigurationPriceResponseBodyDataRequestPriceOrder : public Darabonba::Model {
public:
  shared_ptr<double> discountAmount{};
  shared_ptr<double> originalAmount{};
  shared_ptr<vector<string>> ruleIds{};
  shared_ptr<double> tradeAmount{};

  DescribeConfigurationPriceResponseBodyDataRequestPriceOrder() {}

  explicit DescribeConfigurationPriceResponseBodyDataRequestPriceOrder(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (discountAmount) {
      res["DiscountAmount"] = boost::any(*discountAmount);
    }
    if (originalAmount) {
      res["OriginalAmount"] = boost::any(*originalAmount);
    }
    if (ruleIds) {
      res["RuleIds"] = boost::any(*ruleIds);
    }
    if (tradeAmount) {
      res["TradeAmount"] = boost::any(*tradeAmount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiscountAmount") != m.end() && !m["DiscountAmount"].empty()) {
      discountAmount = make_shared<double>(boost::any_cast<double>(m["DiscountAmount"]));
    }
    if (m.find("OriginalAmount") != m.end() && !m["OriginalAmount"].empty()) {
      originalAmount = make_shared<double>(boost::any_cast<double>(m["OriginalAmount"]));
    }
    if (m.find("RuleIds") != m.end() && !m["RuleIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RuleIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RuleIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ruleIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TradeAmount") != m.end() && !m["TradeAmount"].empty()) {
      tradeAmount = make_shared<double>(boost::any_cast<double>(m["TradeAmount"]));
    }
  }


  virtual ~DescribeConfigurationPriceResponseBodyDataRequestPriceOrder() = default;
};
class DescribeConfigurationPriceResponseBodyDataRequestPriceRules : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> ruleDescId{};

  DescribeConfigurationPriceResponseBodyDataRequestPriceRules() {}

  explicit DescribeConfigurationPriceResponseBodyDataRequestPriceRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ruleDescId) {
      res["RuleDescId"] = boost::any(*ruleDescId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RuleDescId") != m.end() && !m["RuleDescId"].empty()) {
      ruleDescId = make_shared<long>(boost::any_cast<long>(m["RuleDescId"]));
    }
  }


  virtual ~DescribeConfigurationPriceResponseBodyDataRequestPriceRules() = default;
};
class DescribeConfigurationPriceResponseBodyDataRequestPrice : public Darabonba::Model {
public:
  shared_ptr<DescribeConfigurationPriceResponseBodyDataRequestPriceOrder> order{};
  shared_ptr<vector<DescribeConfigurationPriceResponseBodyDataRequestPriceRules>> rules{};

  DescribeConfigurationPriceResponseBodyDataRequestPrice() {}

  explicit DescribeConfigurationPriceResponseBodyDataRequestPrice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (order) {
      res["Order"] = order ? boost::any(order->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (rules) {
      vector<boost::any> temp1;
      for(auto item1:*rules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rules"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      if (typeid(map<string, boost::any>) == m["Order"].type()) {
        DescribeConfigurationPriceResponseBodyDataRequestPriceOrder model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Order"]));
        order = make_shared<DescribeConfigurationPriceResponseBodyDataRequestPriceOrder>(model1);
      }
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      if (typeid(vector<boost::any>) == m["Rules"].type()) {
        vector<DescribeConfigurationPriceResponseBodyDataRequestPriceRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeConfigurationPriceResponseBodyDataRequestPriceRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rules = make_shared<vector<DescribeConfigurationPriceResponseBodyDataRequestPriceRules>>(expect1);
      }
    }
  }


  virtual ~DescribeConfigurationPriceResponseBodyDataRequestPrice() = default;
};
class DescribeConfigurationPriceResponseBodyDataRules : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> ruleDescId{};

  DescribeConfigurationPriceResponseBodyDataRules() {}

  explicit DescribeConfigurationPriceResponseBodyDataRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ruleDescId) {
      res["RuleDescId"] = boost::any(*ruleDescId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RuleDescId") != m.end() && !m["RuleDescId"].empty()) {
      ruleDescId = make_shared<long>(boost::any_cast<long>(m["RuleDescId"]));
    }
  }


  virtual ~DescribeConfigurationPriceResponseBodyDataRules() = default;
};
class DescribeConfigurationPriceResponseBodyDataTrafficPriceOrder : public Darabonba::Model {
public:
  shared_ptr<double> discountAmount{};
  shared_ptr<double> originalAmount{};
  shared_ptr<vector<string>> ruleIds{};
  shared_ptr<double> tradeAmount{};

  DescribeConfigurationPriceResponseBodyDataTrafficPriceOrder() {}

  explicit DescribeConfigurationPriceResponseBodyDataTrafficPriceOrder(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (discountAmount) {
      res["DiscountAmount"] = boost::any(*discountAmount);
    }
    if (originalAmount) {
      res["OriginalAmount"] = boost::any(*originalAmount);
    }
    if (ruleIds) {
      res["RuleIds"] = boost::any(*ruleIds);
    }
    if (tradeAmount) {
      res["TradeAmount"] = boost::any(*tradeAmount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiscountAmount") != m.end() && !m["DiscountAmount"].empty()) {
      discountAmount = make_shared<double>(boost::any_cast<double>(m["DiscountAmount"]));
    }
    if (m.find("OriginalAmount") != m.end() && !m["OriginalAmount"].empty()) {
      originalAmount = make_shared<double>(boost::any_cast<double>(m["OriginalAmount"]));
    }
    if (m.find("RuleIds") != m.end() && !m["RuleIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RuleIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RuleIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ruleIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TradeAmount") != m.end() && !m["TradeAmount"].empty()) {
      tradeAmount = make_shared<double>(boost::any_cast<double>(m["TradeAmount"]));
    }
  }


  virtual ~DescribeConfigurationPriceResponseBodyDataTrafficPriceOrder() = default;
};
class DescribeConfigurationPriceResponseBodyDataTrafficPriceRules : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<double> ruleDescId{};

  DescribeConfigurationPriceResponseBodyDataTrafficPriceRules() {}

  explicit DescribeConfigurationPriceResponseBodyDataTrafficPriceRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ruleDescId) {
      res["RuleDescId"] = boost::any(*ruleDescId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RuleDescId") != m.end() && !m["RuleDescId"].empty()) {
      ruleDescId = make_shared<double>(boost::any_cast<double>(m["RuleDescId"]));
    }
  }


  virtual ~DescribeConfigurationPriceResponseBodyDataTrafficPriceRules() = default;
};
class DescribeConfigurationPriceResponseBodyDataTrafficPrice : public Darabonba::Model {
public:
  shared_ptr<DescribeConfigurationPriceResponseBodyDataTrafficPriceOrder> order{};
  shared_ptr<vector<DescribeConfigurationPriceResponseBodyDataTrafficPriceRules>> rules{};

  DescribeConfigurationPriceResponseBodyDataTrafficPrice() {}

  explicit DescribeConfigurationPriceResponseBodyDataTrafficPrice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (order) {
      res["Order"] = order ? boost::any(order->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (rules) {
      vector<boost::any> temp1;
      for(auto item1:*rules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rules"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      if (typeid(map<string, boost::any>) == m["Order"].type()) {
        DescribeConfigurationPriceResponseBodyDataTrafficPriceOrder model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Order"]));
        order = make_shared<DescribeConfigurationPriceResponseBodyDataTrafficPriceOrder>(model1);
      }
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      if (typeid(vector<boost::any>) == m["Rules"].type()) {
        vector<DescribeConfigurationPriceResponseBodyDataTrafficPriceRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeConfigurationPriceResponseBodyDataTrafficPriceRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rules = make_shared<vector<DescribeConfigurationPriceResponseBodyDataTrafficPriceRules>>(expect1);
      }
    }
  }


  virtual ~DescribeConfigurationPriceResponseBodyDataTrafficPrice() = default;
};
class DescribeConfigurationPriceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<DescribeConfigurationPriceResponseBodyDataBagUsage> bagUsage{};
  shared_ptr<DescribeConfigurationPriceResponseBodyDataCpuMemPrice> cpuMemPrice{};
  shared_ptr<DescribeConfigurationPriceResponseBodyDataOrder> order{};
  shared_ptr<DescribeConfigurationPriceResponseBodyDataRequestPrice> requestPrice{};
  shared_ptr<vector<DescribeConfigurationPriceResponseBodyDataRules>> rules{};
  shared_ptr<DescribeConfigurationPriceResponseBodyDataTrafficPrice> trafficPrice{};

  DescribeConfigurationPriceResponseBodyData() {}

  explicit DescribeConfigurationPriceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bagUsage) {
      res["BagUsage"] = bagUsage ? boost::any(bagUsage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (cpuMemPrice) {
      res["CpuMemPrice"] = cpuMemPrice ? boost::any(cpuMemPrice->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (order) {
      res["Order"] = order ? boost::any(order->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestPrice) {
      res["RequestPrice"] = requestPrice ? boost::any(requestPrice->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (rules) {
      vector<boost::any> temp1;
      for(auto item1:*rules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rules"] = boost::any(temp1);
    }
    if (trafficPrice) {
      res["TrafficPrice"] = trafficPrice ? boost::any(trafficPrice->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BagUsage") != m.end() && !m["BagUsage"].empty()) {
      if (typeid(map<string, boost::any>) == m["BagUsage"].type()) {
        DescribeConfigurationPriceResponseBodyDataBagUsage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BagUsage"]));
        bagUsage = make_shared<DescribeConfigurationPriceResponseBodyDataBagUsage>(model1);
      }
    }
    if (m.find("CpuMemPrice") != m.end() && !m["CpuMemPrice"].empty()) {
      if (typeid(map<string, boost::any>) == m["CpuMemPrice"].type()) {
        DescribeConfigurationPriceResponseBodyDataCpuMemPrice model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CpuMemPrice"]));
        cpuMemPrice = make_shared<DescribeConfigurationPriceResponseBodyDataCpuMemPrice>(model1);
      }
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      if (typeid(map<string, boost::any>) == m["Order"].type()) {
        DescribeConfigurationPriceResponseBodyDataOrder model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Order"]));
        order = make_shared<DescribeConfigurationPriceResponseBodyDataOrder>(model1);
      }
    }
    if (m.find("RequestPrice") != m.end() && !m["RequestPrice"].empty()) {
      if (typeid(map<string, boost::any>) == m["RequestPrice"].type()) {
        DescribeConfigurationPriceResponseBodyDataRequestPrice model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RequestPrice"]));
        requestPrice = make_shared<DescribeConfigurationPriceResponseBodyDataRequestPrice>(model1);
      }
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      if (typeid(vector<boost::any>) == m["Rules"].type()) {
        vector<DescribeConfigurationPriceResponseBodyDataRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeConfigurationPriceResponseBodyDataRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rules = make_shared<vector<DescribeConfigurationPriceResponseBodyDataRules>>(expect1);
      }
    }
    if (m.find("TrafficPrice") != m.end() && !m["TrafficPrice"].empty()) {
      if (typeid(map<string, boost::any>) == m["TrafficPrice"].type()) {
        DescribeConfigurationPriceResponseBodyDataTrafficPrice model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TrafficPrice"]));
        trafficPrice = make_shared<DescribeConfigurationPriceResponseBodyDataTrafficPrice>(model1);
      }
    }
  }


  virtual ~DescribeConfigurationPriceResponseBodyData() = default;
};
class DescribeConfigurationPriceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeConfigurationPriceResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  DescribeConfigurationPriceResponseBody() {}

  explicit DescribeConfigurationPriceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeConfigurationPriceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeConfigurationPriceResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~DescribeConfigurationPriceResponseBody() = default;
};
class DescribeConfigurationPriceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeConfigurationPriceResponseBody> body{};

  DescribeConfigurationPriceResponse() {}

  explicit DescribeConfigurationPriceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeConfigurationPriceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeConfigurationPriceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeConfigurationPriceResponse() = default;
};
class DescribeEdasContainersResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> disabled{};
  shared_ptr<string> edasContainerVersion{};

  DescribeEdasContainersResponseBodyData() {}

  explicit DescribeEdasContainersResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disabled) {
      res["Disabled"] = boost::any(*disabled);
    }
    if (edasContainerVersion) {
      res["EdasContainerVersion"] = boost::any(*edasContainerVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Disabled") != m.end() && !m["Disabled"].empty()) {
      disabled = make_shared<bool>(boost::any_cast<bool>(m["Disabled"]));
    }
    if (m.find("EdasContainerVersion") != m.end() && !m["EdasContainerVersion"].empty()) {
      edasContainerVersion = make_shared<string>(boost::any_cast<string>(m["EdasContainerVersion"]));
    }
  }


  virtual ~DescribeEdasContainersResponseBodyData() = default;
};
class DescribeEdasContainersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<DescribeEdasContainersResponseBodyData>> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  DescribeEdasContainersResponseBody() {}

  explicit DescribeEdasContainersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeEdasContainersResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEdasContainersResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeEdasContainersResponseBodyData>>(expect1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~DescribeEdasContainersResponseBody() = default;
};
class DescribeEdasContainersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEdasContainersResponseBody> body{};

  DescribeEdasContainersResponse() {}

  explicit DescribeEdasContainersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEdasContainersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEdasContainersResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEdasContainersResponse() = default;
};
class DescribeGreyTagRouteRequest : public Darabonba::Model {
public:
  shared_ptr<long> greyTagRouteId{};

  DescribeGreyTagRouteRequest() {}

  explicit DescribeGreyTagRouteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (greyTagRouteId) {
      res["GreyTagRouteId"] = boost::any(*greyTagRouteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GreyTagRouteId") != m.end() && !m["GreyTagRouteId"].empty()) {
      greyTagRouteId = make_shared<long>(boost::any_cast<long>(m["GreyTagRouteId"]));
    }
  }


  virtual ~DescribeGreyTagRouteRequest() = default;
};
class DescribeGreyTagRouteResponseBodyDataAlbRulesItems : public Darabonba::Model {
public:
  shared_ptr<string> cond{};
  shared_ptr<string> expr{};
  shared_ptr<long> index{};
  shared_ptr<string> name{};
  shared_ptr<string> operator_{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  DescribeGreyTagRouteResponseBodyDataAlbRulesItems() {}

  explicit DescribeGreyTagRouteResponseBodyDataAlbRulesItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cond) {
      res["cond"] = boost::any(*cond);
    }
    if (expr) {
      res["expr"] = boost::any(*expr);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (operator_) {
      res["operator"] = boost::any(*operator_);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cond") != m.end() && !m["cond"].empty()) {
      cond = make_shared<string>(boost::any_cast<string>(m["cond"]));
    }
    if (m.find("expr") != m.end() && !m["expr"].empty()) {
      expr = make_shared<string>(boost::any_cast<string>(m["expr"]));
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["index"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("operator") != m.end() && !m["operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["operator"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~DescribeGreyTagRouteResponseBodyDataAlbRulesItems() = default;
};
class DescribeGreyTagRouteResponseBodyDataAlbRules : public Darabonba::Model {
public:
  shared_ptr<string> condition{};
  shared_ptr<string> ingressId{};
  shared_ptr<vector<DescribeGreyTagRouteResponseBodyDataAlbRulesItems>> items{};
  shared_ptr<string> serviceId{};

  DescribeGreyTagRouteResponseBodyDataAlbRules() {}

  explicit DescribeGreyTagRouteResponseBodyDataAlbRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (condition) {
      res["condition"] = boost::any(*condition);
    }
    if (ingressId) {
      res["ingressId"] = boost::any(*ingressId);
    }
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["items"] = boost::any(temp1);
    }
    if (serviceId) {
      res["serviceId"] = boost::any(*serviceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("condition") != m.end() && !m["condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["condition"]));
    }
    if (m.find("ingressId") != m.end() && !m["ingressId"].empty()) {
      ingressId = make_shared<string>(boost::any_cast<string>(m["ingressId"]));
    }
    if (m.find("items") != m.end() && !m["items"].empty()) {
      if (typeid(vector<boost::any>) == m["items"].type()) {
        vector<DescribeGreyTagRouteResponseBodyDataAlbRulesItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGreyTagRouteResponseBodyDataAlbRulesItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<DescribeGreyTagRouteResponseBodyDataAlbRulesItems>>(expect1);
      }
    }
    if (m.find("serviceId") != m.end() && !m["serviceId"].empty()) {
      serviceId = make_shared<string>(boost::any_cast<string>(m["serviceId"]));
    }
  }


  virtual ~DescribeGreyTagRouteResponseBodyDataAlbRules() = default;
};
class DescribeGreyTagRouteResponseBodyDataDubboRulesItems : public Darabonba::Model {
public:
  shared_ptr<string> cond{};
  shared_ptr<string> expr{};
  shared_ptr<long> index{};
  shared_ptr<string> name{};
  shared_ptr<string> operator_{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  DescribeGreyTagRouteResponseBodyDataDubboRulesItems() {}

  explicit DescribeGreyTagRouteResponseBodyDataDubboRulesItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cond) {
      res["cond"] = boost::any(*cond);
    }
    if (expr) {
      res["expr"] = boost::any(*expr);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (operator_) {
      res["operator"] = boost::any(*operator_);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cond") != m.end() && !m["cond"].empty()) {
      cond = make_shared<string>(boost::any_cast<string>(m["cond"]));
    }
    if (m.find("expr") != m.end() && !m["expr"].empty()) {
      expr = make_shared<string>(boost::any_cast<string>(m["expr"]));
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["index"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("operator") != m.end() && !m["operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["operator"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~DescribeGreyTagRouteResponseBodyDataDubboRulesItems() = default;
};
class DescribeGreyTagRouteResponseBodyDataDubboRules : public Darabonba::Model {
public:
  shared_ptr<string> condition{};
  shared_ptr<string> group{};
  shared_ptr<vector<DescribeGreyTagRouteResponseBodyDataDubboRulesItems>> items{};
  shared_ptr<string> methodName{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> version{};

  DescribeGreyTagRouteResponseBodyDataDubboRules() {}

  explicit DescribeGreyTagRouteResponseBodyDataDubboRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (condition) {
      res["condition"] = boost::any(*condition);
    }
    if (group) {
      res["group"] = boost::any(*group);
    }
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["items"] = boost::any(temp1);
    }
    if (methodName) {
      res["methodName"] = boost::any(*methodName);
    }
    if (serviceName) {
      res["serviceName"] = boost::any(*serviceName);
    }
    if (version) {
      res["version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("condition") != m.end() && !m["condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["condition"]));
    }
    if (m.find("group") != m.end() && !m["group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["group"]));
    }
    if (m.find("items") != m.end() && !m["items"].empty()) {
      if (typeid(vector<boost::any>) == m["items"].type()) {
        vector<DescribeGreyTagRouteResponseBodyDataDubboRulesItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGreyTagRouteResponseBodyDataDubboRulesItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<DescribeGreyTagRouteResponseBodyDataDubboRulesItems>>(expect1);
      }
    }
    if (m.find("methodName") != m.end() && !m["methodName"].empty()) {
      methodName = make_shared<string>(boost::any_cast<string>(m["methodName"]));
    }
    if (m.find("serviceName") != m.end() && !m["serviceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["serviceName"]));
    }
    if (m.find("version") != m.end() && !m["version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["version"]));
    }
  }


  virtual ~DescribeGreyTagRouteResponseBodyDataDubboRules() = default;
};
class DescribeGreyTagRouteResponseBodyDataScRulesItems : public Darabonba::Model {
public:
  shared_ptr<string> cond{};
  shared_ptr<string> expr{};
  shared_ptr<long> index{};
  shared_ptr<string> name{};
  shared_ptr<string> operator_{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  DescribeGreyTagRouteResponseBodyDataScRulesItems() {}

  explicit DescribeGreyTagRouteResponseBodyDataScRulesItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cond) {
      res["cond"] = boost::any(*cond);
    }
    if (expr) {
      res["expr"] = boost::any(*expr);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (operator_) {
      res["operator"] = boost::any(*operator_);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cond") != m.end() && !m["cond"].empty()) {
      cond = make_shared<string>(boost::any_cast<string>(m["cond"]));
    }
    if (m.find("expr") != m.end() && !m["expr"].empty()) {
      expr = make_shared<string>(boost::any_cast<string>(m["expr"]));
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["index"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("operator") != m.end() && !m["operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["operator"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~DescribeGreyTagRouteResponseBodyDataScRulesItems() = default;
};
class DescribeGreyTagRouteResponseBodyDataScRules : public Darabonba::Model {
public:
  shared_ptr<string> condition{};
  shared_ptr<vector<DescribeGreyTagRouteResponseBodyDataScRulesItems>> items{};
  shared_ptr<string> path{};

  DescribeGreyTagRouteResponseBodyDataScRules() {}

  explicit DescribeGreyTagRouteResponseBodyDataScRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (condition) {
      res["condition"] = boost::any(*condition);
    }
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["items"] = boost::any(temp1);
    }
    if (path) {
      res["path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("condition") != m.end() && !m["condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["condition"]));
    }
    if (m.find("items") != m.end() && !m["items"].empty()) {
      if (typeid(vector<boost::any>) == m["items"].type()) {
        vector<DescribeGreyTagRouteResponseBodyDataScRulesItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGreyTagRouteResponseBodyDataScRulesItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<DescribeGreyTagRouteResponseBodyDataScRulesItems>>(expect1);
      }
    }
    if (m.find("path") != m.end() && !m["path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["path"]));
    }
  }


  virtual ~DescribeGreyTagRouteResponseBodyDataScRules() = default;
};
class DescribeGreyTagRouteResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeGreyTagRouteResponseBodyDataAlbRules>> albRules{};
  shared_ptr<string> appId{};
  shared_ptr<long> createTime{};
  shared_ptr<string> description{};
  shared_ptr<vector<DescribeGreyTagRouteResponseBodyDataDubboRules>> dubboRules{};
  shared_ptr<long> greyTagRouteId{};
  shared_ptr<string> name{};
  shared_ptr<vector<DescribeGreyTagRouteResponseBodyDataScRules>> scRules{};
  shared_ptr<long> updateTime{};

  DescribeGreyTagRouteResponseBodyData() {}

  explicit DescribeGreyTagRouteResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (albRules) {
      vector<boost::any> temp1;
      for(auto item1:*albRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlbRules"] = boost::any(temp1);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dubboRules) {
      vector<boost::any> temp1;
      for(auto item1:*dubboRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DubboRules"] = boost::any(temp1);
    }
    if (greyTagRouteId) {
      res["GreyTagRouteId"] = boost::any(*greyTagRouteId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (scRules) {
      vector<boost::any> temp1;
      for(auto item1:*scRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScRules"] = boost::any(temp1);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlbRules") != m.end() && !m["AlbRules"].empty()) {
      if (typeid(vector<boost::any>) == m["AlbRules"].type()) {
        vector<DescribeGreyTagRouteResponseBodyDataAlbRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlbRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGreyTagRouteResponseBodyDataAlbRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        albRules = make_shared<vector<DescribeGreyTagRouteResponseBodyDataAlbRules>>(expect1);
      }
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DubboRules") != m.end() && !m["DubboRules"].empty()) {
      if (typeid(vector<boost::any>) == m["DubboRules"].type()) {
        vector<DescribeGreyTagRouteResponseBodyDataDubboRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DubboRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGreyTagRouteResponseBodyDataDubboRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dubboRules = make_shared<vector<DescribeGreyTagRouteResponseBodyDataDubboRules>>(expect1);
      }
    }
    if (m.find("GreyTagRouteId") != m.end() && !m["GreyTagRouteId"].empty()) {
      greyTagRouteId = make_shared<long>(boost::any_cast<long>(m["GreyTagRouteId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ScRules") != m.end() && !m["ScRules"].empty()) {
      if (typeid(vector<boost::any>) == m["ScRules"].type()) {
        vector<DescribeGreyTagRouteResponseBodyDataScRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGreyTagRouteResponseBodyDataScRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scRules = make_shared<vector<DescribeGreyTagRouteResponseBodyDataScRules>>(expect1);
      }
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~DescribeGreyTagRouteResponseBodyData() = default;
};
class DescribeGreyTagRouteResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeGreyTagRouteResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  DescribeGreyTagRouteResponseBody() {}

  explicit DescribeGreyTagRouteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeGreyTagRouteResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeGreyTagRouteResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~DescribeGreyTagRouteResponseBody() = default;
};
class DescribeGreyTagRouteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeGreyTagRouteResponseBody> body{};

  DescribeGreyTagRouteResponse() {}

  explicit DescribeGreyTagRouteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeGreyTagRouteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeGreyTagRouteResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeGreyTagRouteResponse() = default;
};
class DescribeIngressRequest : public Darabonba::Model {
public:
  shared_ptr<long> ingressId{};

  DescribeIngressRequest() {}

  explicit DescribeIngressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ingressId) {
      res["IngressId"] = boost::any(*ingressId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IngressId") != m.end() && !m["IngressId"].empty()) {
      ingressId = make_shared<long>(boost::any_cast<long>(m["IngressId"]));
    }
  }


  virtual ~DescribeIngressRequest() = default;
};
class DescribeIngressResponseBodyDataCorsConfig : public Darabonba::Model {
public:
  shared_ptr<string> allowCredentials{};
  shared_ptr<string> allowHeaders{};
  shared_ptr<string> allowMethods{};
  shared_ptr<string> allowOrigin{};
  shared_ptr<string> enable{};
  shared_ptr<string> exposeHeaders{};
  shared_ptr<string> maxAge{};

  DescribeIngressResponseBodyDataCorsConfig() {}

  explicit DescribeIngressResponseBodyDataCorsConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowCredentials) {
      res["AllowCredentials"] = boost::any(*allowCredentials);
    }
    if (allowHeaders) {
      res["AllowHeaders"] = boost::any(*allowHeaders);
    }
    if (allowMethods) {
      res["AllowMethods"] = boost::any(*allowMethods);
    }
    if (allowOrigin) {
      res["AllowOrigin"] = boost::any(*allowOrigin);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (exposeHeaders) {
      res["ExposeHeaders"] = boost::any(*exposeHeaders);
    }
    if (maxAge) {
      res["MaxAge"] = boost::any(*maxAge);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowCredentials") != m.end() && !m["AllowCredentials"].empty()) {
      allowCredentials = make_shared<string>(boost::any_cast<string>(m["AllowCredentials"]));
    }
    if (m.find("AllowHeaders") != m.end() && !m["AllowHeaders"].empty()) {
      allowHeaders = make_shared<string>(boost::any_cast<string>(m["AllowHeaders"]));
    }
    if (m.find("AllowMethods") != m.end() && !m["AllowMethods"].empty()) {
      allowMethods = make_shared<string>(boost::any_cast<string>(m["AllowMethods"]));
    }
    if (m.find("AllowOrigin") != m.end() && !m["AllowOrigin"].empty()) {
      allowOrigin = make_shared<string>(boost::any_cast<string>(m["AllowOrigin"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<string>(boost::any_cast<string>(m["Enable"]));
    }
    if (m.find("ExposeHeaders") != m.end() && !m["ExposeHeaders"].empty()) {
      exposeHeaders = make_shared<string>(boost::any_cast<string>(m["ExposeHeaders"]));
    }
    if (m.find("MaxAge") != m.end() && !m["MaxAge"].empty()) {
      maxAge = make_shared<string>(boost::any_cast<string>(m["MaxAge"]));
    }
  }


  virtual ~DescribeIngressResponseBodyDataCorsConfig() = default;
};
class DescribeIngressResponseBodyDataDefaultRule : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> backendProtocol{};
  shared_ptr<long> containerPort{};

  DescribeIngressResponseBodyDataDefaultRule() {}

  explicit DescribeIngressResponseBodyDataDefaultRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (backendProtocol) {
      res["BackendProtocol"] = boost::any(*backendProtocol);
    }
    if (containerPort) {
      res["ContainerPort"] = boost::any(*containerPort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("BackendProtocol") != m.end() && !m["BackendProtocol"].empty()) {
      backendProtocol = make_shared<string>(boost::any_cast<string>(m["BackendProtocol"]));
    }
    if (m.find("ContainerPort") != m.end() && !m["ContainerPort"].empty()) {
      containerPort = make_shared<long>(boost::any_cast<long>(m["ContainerPort"]));
    }
  }


  virtual ~DescribeIngressResponseBodyDataDefaultRule() = default;
};
class DescribeIngressResponseBodyDataRulesRuleActions : public Darabonba::Model {
public:
  shared_ptr<string> actionConfig{};
  shared_ptr<string> actionType{};

  DescribeIngressResponseBodyDataRulesRuleActions() {}

  explicit DescribeIngressResponseBodyDataRulesRuleActions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionConfig) {
      res["ActionConfig"] = boost::any(*actionConfig);
    }
    if (actionType) {
      res["ActionType"] = boost::any(*actionType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionConfig") != m.end() && !m["ActionConfig"].empty()) {
      actionConfig = make_shared<string>(boost::any_cast<string>(m["ActionConfig"]));
    }
    if (m.find("ActionType") != m.end() && !m["ActionType"].empty()) {
      actionType = make_shared<string>(boost::any_cast<string>(m["ActionType"]));
    }
  }


  virtual ~DescribeIngressResponseBodyDataRulesRuleActions() = default;
};
class DescribeIngressResponseBodyDataRules : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> backendProtocol{};
  shared_ptr<long> containerPort{};
  shared_ptr<string> domain{};
  shared_ptr<string> path{};
  shared_ptr<string> rewritePath{};
  shared_ptr<vector<DescribeIngressResponseBodyDataRulesRuleActions>> ruleActions{};

  DescribeIngressResponseBodyDataRules() {}

  explicit DescribeIngressResponseBodyDataRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (backendProtocol) {
      res["BackendProtocol"] = boost::any(*backendProtocol);
    }
    if (containerPort) {
      res["ContainerPort"] = boost::any(*containerPort);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (rewritePath) {
      res["RewritePath"] = boost::any(*rewritePath);
    }
    if (ruleActions) {
      vector<boost::any> temp1;
      for(auto item1:*ruleActions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuleActions"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("BackendProtocol") != m.end() && !m["BackendProtocol"].empty()) {
      backendProtocol = make_shared<string>(boost::any_cast<string>(m["BackendProtocol"]));
    }
    if (m.find("ContainerPort") != m.end() && !m["ContainerPort"].empty()) {
      containerPort = make_shared<long>(boost::any_cast<long>(m["ContainerPort"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("RewritePath") != m.end() && !m["RewritePath"].empty()) {
      rewritePath = make_shared<string>(boost::any_cast<string>(m["RewritePath"]));
    }
    if (m.find("RuleActions") != m.end() && !m["RuleActions"].empty()) {
      if (typeid(vector<boost::any>) == m["RuleActions"].type()) {
        vector<DescribeIngressResponseBodyDataRulesRuleActions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuleActions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeIngressResponseBodyDataRulesRuleActions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleActions = make_shared<vector<DescribeIngressResponseBodyDataRulesRuleActions>>(expect1);
      }
    }
  }


  virtual ~DescribeIngressResponseBodyDataRules() = default;
};
class DescribeIngressResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> certId{};
  shared_ptr<string> certIds{};
  shared_ptr<DescribeIngressResponseBodyDataCorsConfig> corsConfig{};
  shared_ptr<bool> createdBySae{};
  shared_ptr<DescribeIngressResponseBodyDataDefaultRule> defaultRule{};
  shared_ptr<string> description{};
  shared_ptr<bool> enableXForwardedFor{};
  shared_ptr<bool> enableXForwardedForClientSrcPort{};
  shared_ptr<bool> enableXForwardedForProto{};
  shared_ptr<bool> enableXForwardedForSlbId{};
  shared_ptr<bool> enableXForwardedForSlbPort{};
  shared_ptr<long> id{};
  shared_ptr<long> idleTimeout{};
  shared_ptr<long> listenerPort{};
  shared_ptr<string> listenerProtocol{};
  shared_ptr<string> loadBalanceType{};
  shared_ptr<string> name{};
  shared_ptr<string> namespaceId{};
  shared_ptr<long> requestTimeout{};
  shared_ptr<vector<DescribeIngressResponseBodyDataRules>> rules{};
  shared_ptr<string> securityPolicyId{};
  shared_ptr<string> slbId{};
  shared_ptr<string> slbType{};

  DescribeIngressResponseBodyData() {}

  explicit DescribeIngressResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certId) {
      res["CertId"] = boost::any(*certId);
    }
    if (certIds) {
      res["CertIds"] = boost::any(*certIds);
    }
    if (corsConfig) {
      res["CorsConfig"] = corsConfig ? boost::any(corsConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createdBySae) {
      res["CreatedBySae"] = boost::any(*createdBySae);
    }
    if (defaultRule) {
      res["DefaultRule"] = defaultRule ? boost::any(defaultRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enableXForwardedFor) {
      res["EnableXForwardedFor"] = boost::any(*enableXForwardedFor);
    }
    if (enableXForwardedForClientSrcPort) {
      res["EnableXForwardedForClientSrcPort"] = boost::any(*enableXForwardedForClientSrcPort);
    }
    if (enableXForwardedForProto) {
      res["EnableXForwardedForProto"] = boost::any(*enableXForwardedForProto);
    }
    if (enableXForwardedForSlbId) {
      res["EnableXForwardedForSlbId"] = boost::any(*enableXForwardedForSlbId);
    }
    if (enableXForwardedForSlbPort) {
      res["EnableXForwardedForSlbPort"] = boost::any(*enableXForwardedForSlbPort);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (idleTimeout) {
      res["IdleTimeout"] = boost::any(*idleTimeout);
    }
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    if (listenerProtocol) {
      res["ListenerProtocol"] = boost::any(*listenerProtocol);
    }
    if (loadBalanceType) {
      res["LoadBalanceType"] = boost::any(*loadBalanceType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (requestTimeout) {
      res["RequestTimeout"] = boost::any(*requestTimeout);
    }
    if (rules) {
      vector<boost::any> temp1;
      for(auto item1:*rules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rules"] = boost::any(temp1);
    }
    if (securityPolicyId) {
      res["SecurityPolicyId"] = boost::any(*securityPolicyId);
    }
    if (slbId) {
      res["SlbId"] = boost::any(*slbId);
    }
    if (slbType) {
      res["SlbType"] = boost::any(*slbType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertId") != m.end() && !m["CertId"].empty()) {
      certId = make_shared<string>(boost::any_cast<string>(m["CertId"]));
    }
    if (m.find("CertIds") != m.end() && !m["CertIds"].empty()) {
      certIds = make_shared<string>(boost::any_cast<string>(m["CertIds"]));
    }
    if (m.find("CorsConfig") != m.end() && !m["CorsConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CorsConfig"].type()) {
        DescribeIngressResponseBodyDataCorsConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CorsConfig"]));
        corsConfig = make_shared<DescribeIngressResponseBodyDataCorsConfig>(model1);
      }
    }
    if (m.find("CreatedBySae") != m.end() && !m["CreatedBySae"].empty()) {
      createdBySae = make_shared<bool>(boost::any_cast<bool>(m["CreatedBySae"]));
    }
    if (m.find("DefaultRule") != m.end() && !m["DefaultRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["DefaultRule"].type()) {
        DescribeIngressResponseBodyDataDefaultRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DefaultRule"]));
        defaultRule = make_shared<DescribeIngressResponseBodyDataDefaultRule>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnableXForwardedFor") != m.end() && !m["EnableXForwardedFor"].empty()) {
      enableXForwardedFor = make_shared<bool>(boost::any_cast<bool>(m["EnableXForwardedFor"]));
    }
    if (m.find("EnableXForwardedForClientSrcPort") != m.end() && !m["EnableXForwardedForClientSrcPort"].empty()) {
      enableXForwardedForClientSrcPort = make_shared<bool>(boost::any_cast<bool>(m["EnableXForwardedForClientSrcPort"]));
    }
    if (m.find("EnableXForwardedForProto") != m.end() && !m["EnableXForwardedForProto"].empty()) {
      enableXForwardedForProto = make_shared<bool>(boost::any_cast<bool>(m["EnableXForwardedForProto"]));
    }
    if (m.find("EnableXForwardedForSlbId") != m.end() && !m["EnableXForwardedForSlbId"].empty()) {
      enableXForwardedForSlbId = make_shared<bool>(boost::any_cast<bool>(m["EnableXForwardedForSlbId"]));
    }
    if (m.find("EnableXForwardedForSlbPort") != m.end() && !m["EnableXForwardedForSlbPort"].empty()) {
      enableXForwardedForSlbPort = make_shared<bool>(boost::any_cast<bool>(m["EnableXForwardedForSlbPort"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IdleTimeout") != m.end() && !m["IdleTimeout"].empty()) {
      idleTimeout = make_shared<long>(boost::any_cast<long>(m["IdleTimeout"]));
    }
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<long>(boost::any_cast<long>(m["ListenerPort"]));
    }
    if (m.find("ListenerProtocol") != m.end() && !m["ListenerProtocol"].empty()) {
      listenerProtocol = make_shared<string>(boost::any_cast<string>(m["ListenerProtocol"]));
    }
    if (m.find("LoadBalanceType") != m.end() && !m["LoadBalanceType"].empty()) {
      loadBalanceType = make_shared<string>(boost::any_cast<string>(m["LoadBalanceType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("RequestTimeout") != m.end() && !m["RequestTimeout"].empty()) {
      requestTimeout = make_shared<long>(boost::any_cast<long>(m["RequestTimeout"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      if (typeid(vector<boost::any>) == m["Rules"].type()) {
        vector<DescribeIngressResponseBodyDataRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeIngressResponseBodyDataRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rules = make_shared<vector<DescribeIngressResponseBodyDataRules>>(expect1);
      }
    }
    if (m.find("SecurityPolicyId") != m.end() && !m["SecurityPolicyId"].empty()) {
      securityPolicyId = make_shared<string>(boost::any_cast<string>(m["SecurityPolicyId"]));
    }
    if (m.find("SlbId") != m.end() && !m["SlbId"].empty()) {
      slbId = make_shared<string>(boost::any_cast<string>(m["SlbId"]));
    }
    if (m.find("SlbType") != m.end() && !m["SlbType"].empty()) {
      slbType = make_shared<string>(boost::any_cast<string>(m["SlbType"]));
    }
  }


  virtual ~DescribeIngressResponseBodyData() = default;
};
class DescribeIngressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeIngressResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  DescribeIngressResponseBody() {}

  explicit DescribeIngressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeIngressResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeIngressResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~DescribeIngressResponseBody() = default;
};
class DescribeIngressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeIngressResponseBody> body{};

  DescribeIngressResponse() {}

  explicit DescribeIngressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeIngressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeIngressResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeIngressResponse() = default;
};
class DescribeInstanceLogRequest : public Darabonba::Model {
public:
  shared_ptr<string> containerId{};
  shared_ptr<string> instanceId{};

  DescribeInstanceLogRequest() {}

  explicit DescribeInstanceLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (containerId) {
      res["ContainerId"] = boost::any(*containerId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContainerId") != m.end() && !m["ContainerId"].empty()) {
      containerId = make_shared<string>(boost::any_cast<string>(m["ContainerId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DescribeInstanceLogRequest() = default;
};
class DescribeInstanceLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  DescribeInstanceLogResponseBody() {}

  explicit DescribeInstanceLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~DescribeInstanceLogResponseBody() = default;
};
class DescribeInstanceLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstanceLogResponseBody> body{};

  DescribeInstanceLogResponse() {}

  explicit DescribeInstanceLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceLogResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceLogResponse() = default;
};
class DescribeInstanceSpecificationsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> cpu{};
  shared_ptr<bool> enable{};
  shared_ptr<long> id{};
  shared_ptr<long> memory{};
  shared_ptr<string> specInfo{};
  shared_ptr<long> version{};

  DescribeInstanceSpecificationsResponseBodyData() {}

  explicit DescribeInstanceSpecificationsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (specInfo) {
      res["SpecInfo"] = boost::any(*specInfo);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
    if (m.find("SpecInfo") != m.end() && !m["SpecInfo"].empty()) {
      specInfo = make_shared<string>(boost::any_cast<string>(m["SpecInfo"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["Version"]));
    }
  }


  virtual ~DescribeInstanceSpecificationsResponseBodyData() = default;
};
class DescribeInstanceSpecificationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<DescribeInstanceSpecificationsResponseBodyData>> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  DescribeInstanceSpecificationsResponseBody() {}

  explicit DescribeInstanceSpecificationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeInstanceSpecificationsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceSpecificationsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeInstanceSpecificationsResponseBodyData>>(expect1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~DescribeInstanceSpecificationsResponseBody() = default;
};
class DescribeInstanceSpecificationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstanceSpecificationsResponseBody> body{};

  DescribeInstanceSpecificationsResponse() {}

  explicit DescribeInstanceSpecificationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceSpecificationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceSpecificationsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceSpecificationsResponse() = default;
};
class DescribeJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> jobId{};

  DescribeJobRequest() {}

  explicit DescribeJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~DescribeJobRequest() = default;
};
class DescribeJobResponseBodyDataConfigMapMountDesc : public Darabonba::Model {
public:
  shared_ptr<long> configMapId{};
  shared_ptr<string> configMapName{};
  shared_ptr<string> key{};
  shared_ptr<string> mountPath{};

  DescribeJobResponseBodyDataConfigMapMountDesc() {}

  explicit DescribeJobResponseBodyDataConfigMapMountDesc(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configMapId) {
      res["ConfigMapId"] = boost::any(*configMapId);
    }
    if (configMapName) {
      res["ConfigMapName"] = boost::any(*configMapName);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (mountPath) {
      res["MountPath"] = boost::any(*mountPath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigMapId") != m.end() && !m["ConfigMapId"].empty()) {
      configMapId = make_shared<long>(boost::any_cast<long>(m["ConfigMapId"]));
    }
    if (m.find("ConfigMapName") != m.end() && !m["ConfigMapName"].empty()) {
      configMapName = make_shared<string>(boost::any_cast<string>(m["ConfigMapName"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("MountPath") != m.end() && !m["MountPath"].empty()) {
      mountPath = make_shared<string>(boost::any_cast<string>(m["MountPath"]));
    }
  }


  virtual ~DescribeJobResponseBodyDataConfigMapMountDesc() = default;
};
class DescribeJobResponseBodyDataMountDesc : public Darabonba::Model {
public:
  shared_ptr<string> mountPath{};
  shared_ptr<string> nasPath{};

  DescribeJobResponseBodyDataMountDesc() {}

  explicit DescribeJobResponseBodyDataMountDesc(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mountPath) {
      res["MountPath"] = boost::any(*mountPath);
    }
    if (nasPath) {
      res["NasPath"] = boost::any(*nasPath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MountPath") != m.end() && !m["MountPath"].empty()) {
      mountPath = make_shared<string>(boost::any_cast<string>(m["MountPath"]));
    }
    if (m.find("NasPath") != m.end() && !m["NasPath"].empty()) {
      nasPath = make_shared<string>(boost::any_cast<string>(m["NasPath"]));
    }
  }


  virtual ~DescribeJobResponseBodyDataMountDesc() = default;
};
class DescribeJobResponseBodyDataOssMountDescs : public Darabonba::Model {
public:
  shared_ptr<string> bucketName{};
  shared_ptr<string> bucketPath{};
  shared_ptr<string> mountPath{};
  shared_ptr<bool> readOnly{};

  DescribeJobResponseBodyDataOssMountDescs() {}

  explicit DescribeJobResponseBodyDataOssMountDescs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucketName) {
      res["bucketName"] = boost::any(*bucketName);
    }
    if (bucketPath) {
      res["bucketPath"] = boost::any(*bucketPath);
    }
    if (mountPath) {
      res["mountPath"] = boost::any(*mountPath);
    }
    if (readOnly) {
      res["readOnly"] = boost::any(*readOnly);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("bucketName") != m.end() && !m["bucketName"].empty()) {
      bucketName = make_shared<string>(boost::any_cast<string>(m["bucketName"]));
    }
    if (m.find("bucketPath") != m.end() && !m["bucketPath"].empty()) {
      bucketPath = make_shared<string>(boost::any_cast<string>(m["bucketPath"]));
    }
    if (m.find("mountPath") != m.end() && !m["mountPath"].empty()) {
      mountPath = make_shared<string>(boost::any_cast<string>(m["mountPath"]));
    }
    if (m.find("readOnly") != m.end() && !m["readOnly"].empty()) {
      readOnly = make_shared<bool>(boost::any_cast<bool>(m["readOnly"]));
    }
  }


  virtual ~DescribeJobResponseBodyDataOssMountDescs() = default;
};
class DescribeJobResponseBodyDataTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeJobResponseBodyDataTags() {}

  explicit DescribeJobResponseBodyDataTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeJobResponseBodyDataTags() = default;
};
class DescribeJobResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> acrAssumeRoleArn{};
  shared_ptr<string> acrInstanceId{};
  shared_ptr<string> appDescription{};
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<long> backoffLimit{};
  shared_ptr<string> command{};
  shared_ptr<string> commandArgs{};
  shared_ptr<string> concurrencyPolicy{};
  shared_ptr<vector<DescribeJobResponseBodyDataConfigMapMountDesc>> configMapMountDesc{};
  shared_ptr<long> cpu{};
  shared_ptr<string> customHostAlias{};
  shared_ptr<string> edasContainerVersion{};
  shared_ptr<string> envs{};
  shared_ptr<string> imagePullSecrets{};
  shared_ptr<string> imageUrl{};
  shared_ptr<string> jarStartArgs{};
  shared_ptr<string> jarStartOptions{};
  shared_ptr<string> jdk{};
  shared_ptr<long> memory{};
  shared_ptr<vector<DescribeJobResponseBodyDataMountDesc>> mountDesc{};
  shared_ptr<string> mountHost{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> nasConfigs{};
  shared_ptr<string> nasId{};
  shared_ptr<string> ossAkId{};
  shared_ptr<string> ossAkSecret{};
  shared_ptr<vector<DescribeJobResponseBodyDataOssMountDescs>> ossMountDescs{};
  shared_ptr<string> packageType{};
  shared_ptr<string> packageUrl{};
  shared_ptr<string> packageVersion{};
  shared_ptr<string> phpConfig{};
  shared_ptr<string> phpConfigLocation{};
  shared_ptr<string> postStart{};
  shared_ptr<string> preStop{};
  shared_ptr<string> programmingLanguage{};
  shared_ptr<vector<string>> publicWebHookUrls{};
  shared_ptr<string> python{};
  shared_ptr<string> pythonModules{};
  shared_ptr<string> refAppId{};
  shared_ptr<vector<string>> refedAppIds{};
  shared_ptr<string> regionId{};
  shared_ptr<long> replicas{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<bool> slice{};
  shared_ptr<string> sliceEnvs{};
  shared_ptr<string> slsConfigs{};
  shared_ptr<bool> suspend{};
  shared_ptr<vector<DescribeJobResponseBodyDataTags>> tags{};
  shared_ptr<long> terminationGracePeriodSeconds{};
  shared_ptr<long> timeout{};
  shared_ptr<string> timezone{};
  shared_ptr<string> tomcatConfig{};
  shared_ptr<string> triggerConfig{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vpcId{};
  shared_ptr<vector<string>> vpcWebHookUrls{};
  shared_ptr<string> warStartOptions{};
  shared_ptr<string> webContainer{};

  DescribeJobResponseBodyData() {}

  explicit DescribeJobResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acrAssumeRoleArn) {
      res["AcrAssumeRoleArn"] = boost::any(*acrAssumeRoleArn);
    }
    if (acrInstanceId) {
      res["AcrInstanceId"] = boost::any(*acrInstanceId);
    }
    if (appDescription) {
      res["AppDescription"] = boost::any(*appDescription);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (backoffLimit) {
      res["BackoffLimit"] = boost::any(*backoffLimit);
    }
    if (command) {
      res["Command"] = boost::any(*command);
    }
    if (commandArgs) {
      res["CommandArgs"] = boost::any(*commandArgs);
    }
    if (concurrencyPolicy) {
      res["ConcurrencyPolicy"] = boost::any(*concurrencyPolicy);
    }
    if (configMapMountDesc) {
      vector<boost::any> temp1;
      for(auto item1:*configMapMountDesc){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigMapMountDesc"] = boost::any(temp1);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (customHostAlias) {
      res["CustomHostAlias"] = boost::any(*customHostAlias);
    }
    if (edasContainerVersion) {
      res["EdasContainerVersion"] = boost::any(*edasContainerVersion);
    }
    if (envs) {
      res["Envs"] = boost::any(*envs);
    }
    if (imagePullSecrets) {
      res["ImagePullSecrets"] = boost::any(*imagePullSecrets);
    }
    if (imageUrl) {
      res["ImageUrl"] = boost::any(*imageUrl);
    }
    if (jarStartArgs) {
      res["JarStartArgs"] = boost::any(*jarStartArgs);
    }
    if (jarStartOptions) {
      res["JarStartOptions"] = boost::any(*jarStartOptions);
    }
    if (jdk) {
      res["Jdk"] = boost::any(*jdk);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (mountDesc) {
      vector<boost::any> temp1;
      for(auto item1:*mountDesc){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MountDesc"] = boost::any(temp1);
    }
    if (mountHost) {
      res["MountHost"] = boost::any(*mountHost);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (nasConfigs) {
      res["NasConfigs"] = boost::any(*nasConfigs);
    }
    if (nasId) {
      res["NasId"] = boost::any(*nasId);
    }
    if (ossAkId) {
      res["OssAkId"] = boost::any(*ossAkId);
    }
    if (ossAkSecret) {
      res["OssAkSecret"] = boost::any(*ossAkSecret);
    }
    if (ossMountDescs) {
      vector<boost::any> temp1;
      for(auto item1:*ossMountDescs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OssMountDescs"] = boost::any(temp1);
    }
    if (packageType) {
      res["PackageType"] = boost::any(*packageType);
    }
    if (packageUrl) {
      res["PackageUrl"] = boost::any(*packageUrl);
    }
    if (packageVersion) {
      res["PackageVersion"] = boost::any(*packageVersion);
    }
    if (phpConfig) {
      res["PhpConfig"] = boost::any(*phpConfig);
    }
    if (phpConfigLocation) {
      res["PhpConfigLocation"] = boost::any(*phpConfigLocation);
    }
    if (postStart) {
      res["PostStart"] = boost::any(*postStart);
    }
    if (preStop) {
      res["PreStop"] = boost::any(*preStop);
    }
    if (programmingLanguage) {
      res["ProgrammingLanguage"] = boost::any(*programmingLanguage);
    }
    if (publicWebHookUrls) {
      res["PublicWebHookUrls"] = boost::any(*publicWebHookUrls);
    }
    if (python) {
      res["Python"] = boost::any(*python);
    }
    if (pythonModules) {
      res["PythonModules"] = boost::any(*pythonModules);
    }
    if (refAppId) {
      res["RefAppId"] = boost::any(*refAppId);
    }
    if (refedAppIds) {
      res["RefedAppIds"] = boost::any(*refedAppIds);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (replicas) {
      res["Replicas"] = boost::any(*replicas);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (slice) {
      res["Slice"] = boost::any(*slice);
    }
    if (sliceEnvs) {
      res["SliceEnvs"] = boost::any(*sliceEnvs);
    }
    if (slsConfigs) {
      res["SlsConfigs"] = boost::any(*slsConfigs);
    }
    if (suspend) {
      res["Suspend"] = boost::any(*suspend);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (terminationGracePeriodSeconds) {
      res["TerminationGracePeriodSeconds"] = boost::any(*terminationGracePeriodSeconds);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (timezone) {
      res["Timezone"] = boost::any(*timezone);
    }
    if (tomcatConfig) {
      res["TomcatConfig"] = boost::any(*tomcatConfig);
    }
    if (triggerConfig) {
      res["TriggerConfig"] = boost::any(*triggerConfig);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vpcWebHookUrls) {
      res["VpcWebHookUrls"] = boost::any(*vpcWebHookUrls);
    }
    if (warStartOptions) {
      res["WarStartOptions"] = boost::any(*warStartOptions);
    }
    if (webContainer) {
      res["WebContainer"] = boost::any(*webContainer);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcrAssumeRoleArn") != m.end() && !m["AcrAssumeRoleArn"].empty()) {
      acrAssumeRoleArn = make_shared<string>(boost::any_cast<string>(m["AcrAssumeRoleArn"]));
    }
    if (m.find("AcrInstanceId") != m.end() && !m["AcrInstanceId"].empty()) {
      acrInstanceId = make_shared<string>(boost::any_cast<string>(m["AcrInstanceId"]));
    }
    if (m.find("AppDescription") != m.end() && !m["AppDescription"].empty()) {
      appDescription = make_shared<string>(boost::any_cast<string>(m["AppDescription"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("BackoffLimit") != m.end() && !m["BackoffLimit"].empty()) {
      backoffLimit = make_shared<long>(boost::any_cast<long>(m["BackoffLimit"]));
    }
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
    if (m.find("CommandArgs") != m.end() && !m["CommandArgs"].empty()) {
      commandArgs = make_shared<string>(boost::any_cast<string>(m["CommandArgs"]));
    }
    if (m.find("ConcurrencyPolicy") != m.end() && !m["ConcurrencyPolicy"].empty()) {
      concurrencyPolicy = make_shared<string>(boost::any_cast<string>(m["ConcurrencyPolicy"]));
    }
    if (m.find("ConfigMapMountDesc") != m.end() && !m["ConfigMapMountDesc"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigMapMountDesc"].type()) {
        vector<DescribeJobResponseBodyDataConfigMapMountDesc> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigMapMountDesc"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeJobResponseBodyDataConfigMapMountDesc model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configMapMountDesc = make_shared<vector<DescribeJobResponseBodyDataConfigMapMountDesc>>(expect1);
      }
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("CustomHostAlias") != m.end() && !m["CustomHostAlias"].empty()) {
      customHostAlias = make_shared<string>(boost::any_cast<string>(m["CustomHostAlias"]));
    }
    if (m.find("EdasContainerVersion") != m.end() && !m["EdasContainerVersion"].empty()) {
      edasContainerVersion = make_shared<string>(boost::any_cast<string>(m["EdasContainerVersion"]));
    }
    if (m.find("Envs") != m.end() && !m["Envs"].empty()) {
      envs = make_shared<string>(boost::any_cast<string>(m["Envs"]));
    }
    if (m.find("ImagePullSecrets") != m.end() && !m["ImagePullSecrets"].empty()) {
      imagePullSecrets = make_shared<string>(boost::any_cast<string>(m["ImagePullSecrets"]));
    }
    if (m.find("ImageUrl") != m.end() && !m["ImageUrl"].empty()) {
      imageUrl = make_shared<string>(boost::any_cast<string>(m["ImageUrl"]));
    }
    if (m.find("JarStartArgs") != m.end() && !m["JarStartArgs"].empty()) {
      jarStartArgs = make_shared<string>(boost::any_cast<string>(m["JarStartArgs"]));
    }
    if (m.find("JarStartOptions") != m.end() && !m["JarStartOptions"].empty()) {
      jarStartOptions = make_shared<string>(boost::any_cast<string>(m["JarStartOptions"]));
    }
    if (m.find("Jdk") != m.end() && !m["Jdk"].empty()) {
      jdk = make_shared<string>(boost::any_cast<string>(m["Jdk"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
    if (m.find("MountDesc") != m.end() && !m["MountDesc"].empty()) {
      if (typeid(vector<boost::any>) == m["MountDesc"].type()) {
        vector<DescribeJobResponseBodyDataMountDesc> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MountDesc"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeJobResponseBodyDataMountDesc model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mountDesc = make_shared<vector<DescribeJobResponseBodyDataMountDesc>>(expect1);
      }
    }
    if (m.find("MountHost") != m.end() && !m["MountHost"].empty()) {
      mountHost = make_shared<string>(boost::any_cast<string>(m["MountHost"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("NasConfigs") != m.end() && !m["NasConfigs"].empty()) {
      nasConfigs = make_shared<string>(boost::any_cast<string>(m["NasConfigs"]));
    }
    if (m.find("NasId") != m.end() && !m["NasId"].empty()) {
      nasId = make_shared<string>(boost::any_cast<string>(m["NasId"]));
    }
    if (m.find("OssAkId") != m.end() && !m["OssAkId"].empty()) {
      ossAkId = make_shared<string>(boost::any_cast<string>(m["OssAkId"]));
    }
    if (m.find("OssAkSecret") != m.end() && !m["OssAkSecret"].empty()) {
      ossAkSecret = make_shared<string>(boost::any_cast<string>(m["OssAkSecret"]));
    }
    if (m.find("OssMountDescs") != m.end() && !m["OssMountDescs"].empty()) {
      if (typeid(vector<boost::any>) == m["OssMountDescs"].type()) {
        vector<DescribeJobResponseBodyDataOssMountDescs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OssMountDescs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeJobResponseBodyDataOssMountDescs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ossMountDescs = make_shared<vector<DescribeJobResponseBodyDataOssMountDescs>>(expect1);
      }
    }
    if (m.find("PackageType") != m.end() && !m["PackageType"].empty()) {
      packageType = make_shared<string>(boost::any_cast<string>(m["PackageType"]));
    }
    if (m.find("PackageUrl") != m.end() && !m["PackageUrl"].empty()) {
      packageUrl = make_shared<string>(boost::any_cast<string>(m["PackageUrl"]));
    }
    if (m.find("PackageVersion") != m.end() && !m["PackageVersion"].empty()) {
      packageVersion = make_shared<string>(boost::any_cast<string>(m["PackageVersion"]));
    }
    if (m.find("PhpConfig") != m.end() && !m["PhpConfig"].empty()) {
      phpConfig = make_shared<string>(boost::any_cast<string>(m["PhpConfig"]));
    }
    if (m.find("PhpConfigLocation") != m.end() && !m["PhpConfigLocation"].empty()) {
      phpConfigLocation = make_shared<string>(boost::any_cast<string>(m["PhpConfigLocation"]));
    }
    if (m.find("PostStart") != m.end() && !m["PostStart"].empty()) {
      postStart = make_shared<string>(boost::any_cast<string>(m["PostStart"]));
    }
    if (m.find("PreStop") != m.end() && !m["PreStop"].empty()) {
      preStop = make_shared<string>(boost::any_cast<string>(m["PreStop"]));
    }
    if (m.find("ProgrammingLanguage") != m.end() && !m["ProgrammingLanguage"].empty()) {
      programmingLanguage = make_shared<string>(boost::any_cast<string>(m["ProgrammingLanguage"]));
    }
    if (m.find("PublicWebHookUrls") != m.end() && !m["PublicWebHookUrls"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PublicWebHookUrls"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PublicWebHookUrls"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      publicWebHookUrls = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Python") != m.end() && !m["Python"].empty()) {
      python = make_shared<string>(boost::any_cast<string>(m["Python"]));
    }
    if (m.find("PythonModules") != m.end() && !m["PythonModules"].empty()) {
      pythonModules = make_shared<string>(boost::any_cast<string>(m["PythonModules"]));
    }
    if (m.find("RefAppId") != m.end() && !m["RefAppId"].empty()) {
      refAppId = make_shared<string>(boost::any_cast<string>(m["RefAppId"]));
    }
    if (m.find("RefedAppIds") != m.end() && !m["RefedAppIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RefedAppIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RefedAppIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      refedAppIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Replicas") != m.end() && !m["Replicas"].empty()) {
      replicas = make_shared<long>(boost::any_cast<long>(m["Replicas"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("Slice") != m.end() && !m["Slice"].empty()) {
      slice = make_shared<bool>(boost::any_cast<bool>(m["Slice"]));
    }
    if (m.find("SliceEnvs") != m.end() && !m["SliceEnvs"].empty()) {
      sliceEnvs = make_shared<string>(boost::any_cast<string>(m["SliceEnvs"]));
    }
    if (m.find("SlsConfigs") != m.end() && !m["SlsConfigs"].empty()) {
      slsConfigs = make_shared<string>(boost::any_cast<string>(m["SlsConfigs"]));
    }
    if (m.find("Suspend") != m.end() && !m["Suspend"].empty()) {
      suspend = make_shared<bool>(boost::any_cast<bool>(m["Suspend"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<DescribeJobResponseBodyDataTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeJobResponseBodyDataTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<DescribeJobResponseBodyDataTags>>(expect1);
      }
    }
    if (m.find("TerminationGracePeriodSeconds") != m.end() && !m["TerminationGracePeriodSeconds"].empty()) {
      terminationGracePeriodSeconds = make_shared<long>(boost::any_cast<long>(m["TerminationGracePeriodSeconds"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("Timezone") != m.end() && !m["Timezone"].empty()) {
      timezone = make_shared<string>(boost::any_cast<string>(m["Timezone"]));
    }
    if (m.find("TomcatConfig") != m.end() && !m["TomcatConfig"].empty()) {
      tomcatConfig = make_shared<string>(boost::any_cast<string>(m["TomcatConfig"]));
    }
    if (m.find("TriggerConfig") != m.end() && !m["TriggerConfig"].empty()) {
      triggerConfig = make_shared<string>(boost::any_cast<string>(m["TriggerConfig"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VpcWebHookUrls") != m.end() && !m["VpcWebHookUrls"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VpcWebHookUrls"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VpcWebHookUrls"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vpcWebHookUrls = make_shared<vector<string>>(toVec1);
    }
    if (m.find("WarStartOptions") != m.end() && !m["WarStartOptions"].empty()) {
      warStartOptions = make_shared<string>(boost::any_cast<string>(m["WarStartOptions"]));
    }
    if (m.find("WebContainer") != m.end() && !m["WebContainer"].empty()) {
      webContainer = make_shared<string>(boost::any_cast<string>(m["WebContainer"]));
    }
  }


  virtual ~DescribeJobResponseBodyData() = default;
};
class DescribeJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeJobResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  DescribeJobResponseBody() {}

  explicit DescribeJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeJobResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeJobResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~DescribeJobResponseBody() = default;
};
class DescribeJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeJobResponseBody> body{};

  DescribeJobResponse() {}

  explicit DescribeJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeJobResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeJobResponse() = default;
};
class DescribeJobHistoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> state{};

  DescribeJobHistoryRequest() {}

  explicit DescribeJobHistoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~DescribeJobHistoryRequest() = default;
};
class DescribeJobHistoryResponseBodyDataJobs : public Darabonba::Model {
public:
  shared_ptr<long> active{};
  shared_ptr<long> completionTime{};
  shared_ptr<long> failed{};
  shared_ptr<string> jobId{};
  shared_ptr<string> message{};
  shared_ptr<long> startTime{};
  shared_ptr<string> state{};
  shared_ptr<long> succeeded{};

  DescribeJobHistoryResponseBodyDataJobs() {}

  explicit DescribeJobHistoryResponseBodyDataJobs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (active) {
      res["Active"] = boost::any(*active);
    }
    if (completionTime) {
      res["CompletionTime"] = boost::any(*completionTime);
    }
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (succeeded) {
      res["Succeeded"] = boost::any(*succeeded);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Active") != m.end() && !m["Active"].empty()) {
      active = make_shared<long>(boost::any_cast<long>(m["Active"]));
    }
    if (m.find("CompletionTime") != m.end() && !m["CompletionTime"].empty()) {
      completionTime = make_shared<long>(boost::any_cast<long>(m["CompletionTime"]));
    }
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<long>(boost::any_cast<long>(m["Failed"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Succeeded") != m.end() && !m["Succeeded"].empty()) {
      succeeded = make_shared<long>(boost::any_cast<long>(m["Succeeded"]));
    }
  }


  virtual ~DescribeJobHistoryResponseBodyDataJobs() = default;
};
class DescribeJobHistoryResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<vector<DescribeJobHistoryResponseBodyDataJobs>> jobs{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalSize{};

  DescribeJobHistoryResponseBodyData() {}

  explicit DescribeJobHistoryResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (jobs) {
      vector<boost::any> temp1;
      for(auto item1:*jobs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Jobs"] = boost::any(temp1);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Jobs") != m.end() && !m["Jobs"].empty()) {
      if (typeid(vector<boost::any>) == m["Jobs"].type()) {
        vector<DescribeJobHistoryResponseBodyDataJobs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Jobs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeJobHistoryResponseBodyDataJobs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        jobs = make_shared<vector<DescribeJobHistoryResponseBodyDataJobs>>(expect1);
      }
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
  }


  virtual ~DescribeJobHistoryResponseBodyData() = default;
};
class DescribeJobHistoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeJobHistoryResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  DescribeJobHistoryResponseBody() {}

  explicit DescribeJobHistoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeJobHistoryResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeJobHistoryResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~DescribeJobHistoryResponseBody() = default;
};
class DescribeJobHistoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeJobHistoryResponseBody> body{};

  DescribeJobHistoryResponse() {}

  explicit DescribeJobHistoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeJobHistoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeJobHistoryResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeJobHistoryResponse() = default;
};
class DescribeJobStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> jobId{};

  DescribeJobStatusRequest() {}

  explicit DescribeJobStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~DescribeJobStatusRequest() = default;
};
class DescribeJobStatusResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> active{};
  shared_ptr<long> completionTime{};
  shared_ptr<long> failed{};
  shared_ptr<string> jobId{};
  shared_ptr<string> message{};
  shared_ptr<long> startTime{};
  shared_ptr<string> state{};
  shared_ptr<long> succeeded{};

  DescribeJobStatusResponseBodyData() {}

  explicit DescribeJobStatusResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (active) {
      res["Active"] = boost::any(*active);
    }
    if (completionTime) {
      res["CompletionTime"] = boost::any(*completionTime);
    }
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (succeeded) {
      res["Succeeded"] = boost::any(*succeeded);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Active") != m.end() && !m["Active"].empty()) {
      active = make_shared<long>(boost::any_cast<long>(m["Active"]));
    }
    if (m.find("CompletionTime") != m.end() && !m["CompletionTime"].empty()) {
      completionTime = make_shared<long>(boost::any_cast<long>(m["CompletionTime"]));
    }
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<long>(boost::any_cast<long>(m["Failed"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Succeeded") != m.end() && !m["Succeeded"].empty()) {
      succeeded = make_shared<long>(boost::any_cast<long>(m["Succeeded"]));
    }
  }


  virtual ~DescribeJobStatusResponseBodyData() = default;
};
class DescribeJobStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeJobStatusResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  DescribeJobStatusResponseBody() {}

  explicit DescribeJobStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeJobStatusResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeJobStatusResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~DescribeJobStatusResponseBody() = default;
};
class DescribeJobStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeJobStatusResponseBody> body{};

  DescribeJobStatusResponse() {}

  explicit DescribeJobStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeJobStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeJobStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeJobStatusResponse() = default;
};
class DescribeNamespaceRequest : public Darabonba::Model {
public:
  shared_ptr<string> nameSpaceShortId{};
  shared_ptr<string> namespaceId{};

  DescribeNamespaceRequest() {}

  explicit DescribeNamespaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nameSpaceShortId) {
      res["NameSpaceShortId"] = boost::any(*nameSpaceShortId);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NameSpaceShortId") != m.end() && !m["NameSpaceShortId"].empty()) {
      nameSpaceShortId = make_shared<string>(boost::any_cast<string>(m["NameSpaceShortId"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
  }


  virtual ~DescribeNamespaceRequest() = default;
};
class DescribeNamespaceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> enableMicroRegistration{};
  shared_ptr<string> nameSpaceShortId{};
  shared_ptr<string> namespaceDescription{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> namespaceName{};
  shared_ptr<string> regionId{};

  DescribeNamespaceResponseBodyData() {}

  explicit DescribeNamespaceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableMicroRegistration) {
      res["EnableMicroRegistration"] = boost::any(*enableMicroRegistration);
    }
    if (nameSpaceShortId) {
      res["NameSpaceShortId"] = boost::any(*nameSpaceShortId);
    }
    if (namespaceDescription) {
      res["NamespaceDescription"] = boost::any(*namespaceDescription);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (namespaceName) {
      res["NamespaceName"] = boost::any(*namespaceName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableMicroRegistration") != m.end() && !m["EnableMicroRegistration"].empty()) {
      enableMicroRegistration = make_shared<bool>(boost::any_cast<bool>(m["EnableMicroRegistration"]));
    }
    if (m.find("NameSpaceShortId") != m.end() && !m["NameSpaceShortId"].empty()) {
      nameSpaceShortId = make_shared<string>(boost::any_cast<string>(m["NameSpaceShortId"]));
    }
    if (m.find("NamespaceDescription") != m.end() && !m["NamespaceDescription"].empty()) {
      namespaceDescription = make_shared<string>(boost::any_cast<string>(m["NamespaceDescription"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("NamespaceName") != m.end() && !m["NamespaceName"].empty()) {
      namespaceName = make_shared<string>(boost::any_cast<string>(m["NamespaceName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeNamespaceResponseBodyData() = default;
};
class DescribeNamespaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeNamespaceResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  DescribeNamespaceResponseBody() {}

  explicit DescribeNamespaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeNamespaceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeNamespaceResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~DescribeNamespaceResponseBody() = default;
};
class DescribeNamespaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeNamespaceResponseBody> body{};

  DescribeNamespaceResponse() {}

  explicit DescribeNamespaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeNamespaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeNamespaceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeNamespaceResponse() = default;
};
class DescribeNamespaceListRequest : public Darabonba::Model {
public:
  shared_ptr<bool> containCustom{};
  shared_ptr<bool> hybridCloudExclude{};

  DescribeNamespaceListRequest() {}

  explicit DescribeNamespaceListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (containCustom) {
      res["ContainCustom"] = boost::any(*containCustom);
    }
    if (hybridCloudExclude) {
      res["HybridCloudExclude"] = boost::any(*hybridCloudExclude);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContainCustom") != m.end() && !m["ContainCustom"].empty()) {
      containCustom = make_shared<bool>(boost::any_cast<bool>(m["ContainCustom"]));
    }
    if (m.find("HybridCloudExclude") != m.end() && !m["HybridCloudExclude"].empty()) {
      hybridCloudExclude = make_shared<bool>(boost::any_cast<bool>(m["HybridCloudExclude"]));
    }
  }


  virtual ~DescribeNamespaceListRequest() = default;
};
class DescribeNamespaceListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> agentInstall{};
  shared_ptr<bool> current{};
  shared_ptr<bool> custom{};
  shared_ptr<bool> hybridCloudEnable{};
  shared_ptr<string> nameSpaceShortId{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> namespaceName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vpcId{};

  DescribeNamespaceListResponseBodyData() {}

  explicit DescribeNamespaceListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentInstall) {
      res["AgentInstall"] = boost::any(*agentInstall);
    }
    if (current) {
      res["Current"] = boost::any(*current);
    }
    if (custom) {
      res["Custom"] = boost::any(*custom);
    }
    if (hybridCloudEnable) {
      res["HybridCloudEnable"] = boost::any(*hybridCloudEnable);
    }
    if (nameSpaceShortId) {
      res["NameSpaceShortId"] = boost::any(*nameSpaceShortId);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (namespaceName) {
      res["NamespaceName"] = boost::any(*namespaceName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentInstall") != m.end() && !m["AgentInstall"].empty()) {
      agentInstall = make_shared<string>(boost::any_cast<string>(m["AgentInstall"]));
    }
    if (m.find("Current") != m.end() && !m["Current"].empty()) {
      current = make_shared<bool>(boost::any_cast<bool>(m["Current"]));
    }
    if (m.find("Custom") != m.end() && !m["Custom"].empty()) {
      custom = make_shared<bool>(boost::any_cast<bool>(m["Custom"]));
    }
    if (m.find("HybridCloudEnable") != m.end() && !m["HybridCloudEnable"].empty()) {
      hybridCloudEnable = make_shared<bool>(boost::any_cast<bool>(m["HybridCloudEnable"]));
    }
    if (m.find("NameSpaceShortId") != m.end() && !m["NameSpaceShortId"].empty()) {
      nameSpaceShortId = make_shared<string>(boost::any_cast<string>(m["NameSpaceShortId"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("NamespaceName") != m.end() && !m["NamespaceName"].empty()) {
      namespaceName = make_shared<string>(boost::any_cast<string>(m["NamespaceName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~DescribeNamespaceListResponseBodyData() = default;
};
class DescribeNamespaceListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<DescribeNamespaceListResponseBodyData>> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  DescribeNamespaceListResponseBody() {}

  explicit DescribeNamespaceListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeNamespaceListResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNamespaceListResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeNamespaceListResponseBodyData>>(expect1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~DescribeNamespaceListResponseBody() = default;
};
class DescribeNamespaceListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeNamespaceListResponseBody> body{};

  DescribeNamespaceListResponse() {}

  explicit DescribeNamespaceListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeNamespaceListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeNamespaceListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeNamespaceListResponse() = default;
};
class DescribeNamespaceResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> nameSpaceShortId{};
  shared_ptr<string> namespaceId{};

  DescribeNamespaceResourcesRequest() {}

  explicit DescribeNamespaceResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nameSpaceShortId) {
      res["NameSpaceShortId"] = boost::any(*nameSpaceShortId);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NameSpaceShortId") != m.end() && !m["NameSpaceShortId"].empty()) {
      nameSpaceShortId = make_shared<string>(boost::any_cast<string>(m["NameSpaceShortId"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
  }


  virtual ~DescribeNamespaceResourcesRequest() = default;
};
class DescribeNamespaceResourcesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> appCount{};
  shared_ptr<string> belongRegion{};
  shared_ptr<string> description{};
  shared_ptr<string> jumpServerAppId{};
  shared_ptr<string> jumpServerIp{};
  shared_ptr<string> lastChangeOrderId{};
  shared_ptr<bool> lastChangeOrderRunning{};
  shared_ptr<string> lastChangeOrderStatus{};
  shared_ptr<string> nameSpaceShortId{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> namespaceName{};
  shared_ptr<bool> notificationExpired{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> userId{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vSwitchName{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vpcName{};

  DescribeNamespaceResourcesResponseBodyData() {}

  explicit DescribeNamespaceResourcesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appCount) {
      res["AppCount"] = boost::any(*appCount);
    }
    if (belongRegion) {
      res["BelongRegion"] = boost::any(*belongRegion);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (jumpServerAppId) {
      res["JumpServerAppId"] = boost::any(*jumpServerAppId);
    }
    if (jumpServerIp) {
      res["JumpServerIp"] = boost::any(*jumpServerIp);
    }
    if (lastChangeOrderId) {
      res["LastChangeOrderId"] = boost::any(*lastChangeOrderId);
    }
    if (lastChangeOrderRunning) {
      res["LastChangeOrderRunning"] = boost::any(*lastChangeOrderRunning);
    }
    if (lastChangeOrderStatus) {
      res["LastChangeOrderStatus"] = boost::any(*lastChangeOrderStatus);
    }
    if (nameSpaceShortId) {
      res["NameSpaceShortId"] = boost::any(*nameSpaceShortId);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (namespaceName) {
      res["NamespaceName"] = boost::any(*namespaceName);
    }
    if (notificationExpired) {
      res["NotificationExpired"] = boost::any(*notificationExpired);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vSwitchName) {
      res["VSwitchName"] = boost::any(*vSwitchName);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vpcName) {
      res["VpcName"] = boost::any(*vpcName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppCount") != m.end() && !m["AppCount"].empty()) {
      appCount = make_shared<long>(boost::any_cast<long>(m["AppCount"]));
    }
    if (m.find("BelongRegion") != m.end() && !m["BelongRegion"].empty()) {
      belongRegion = make_shared<string>(boost::any_cast<string>(m["BelongRegion"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("JumpServerAppId") != m.end() && !m["JumpServerAppId"].empty()) {
      jumpServerAppId = make_shared<string>(boost::any_cast<string>(m["JumpServerAppId"]));
    }
    if (m.find("JumpServerIp") != m.end() && !m["JumpServerIp"].empty()) {
      jumpServerIp = make_shared<string>(boost::any_cast<string>(m["JumpServerIp"]));
    }
    if (m.find("LastChangeOrderId") != m.end() && !m["LastChangeOrderId"].empty()) {
      lastChangeOrderId = make_shared<string>(boost::any_cast<string>(m["LastChangeOrderId"]));
    }
    if (m.find("LastChangeOrderRunning") != m.end() && !m["LastChangeOrderRunning"].empty()) {
      lastChangeOrderRunning = make_shared<bool>(boost::any_cast<bool>(m["LastChangeOrderRunning"]));
    }
    if (m.find("LastChangeOrderStatus") != m.end() && !m["LastChangeOrderStatus"].empty()) {
      lastChangeOrderStatus = make_shared<string>(boost::any_cast<string>(m["LastChangeOrderStatus"]));
    }
    if (m.find("NameSpaceShortId") != m.end() && !m["NameSpaceShortId"].empty()) {
      nameSpaceShortId = make_shared<string>(boost::any_cast<string>(m["NameSpaceShortId"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("NamespaceName") != m.end() && !m["NamespaceName"].empty()) {
      namespaceName = make_shared<string>(boost::any_cast<string>(m["NamespaceName"]));
    }
    if (m.find("NotificationExpired") != m.end() && !m["NotificationExpired"].empty()) {
      notificationExpired = make_shared<bool>(boost::any_cast<bool>(m["NotificationExpired"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VSwitchName") != m.end() && !m["VSwitchName"].empty()) {
      vSwitchName = make_shared<string>(boost::any_cast<string>(m["VSwitchName"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VpcName") != m.end() && !m["VpcName"].empty()) {
      vpcName = make_shared<string>(boost::any_cast<string>(m["VpcName"]));
    }
  }


  virtual ~DescribeNamespaceResourcesResponseBodyData() = default;
};
class DescribeNamespaceResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeNamespaceResourcesResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  DescribeNamespaceResourcesResponseBody() {}

  explicit DescribeNamespaceResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeNamespaceResourcesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeNamespaceResourcesResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~DescribeNamespaceResourcesResponseBody() = default;
};
class DescribeNamespaceResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeNamespaceResourcesResponseBody> body{};

  DescribeNamespaceResourcesResponse() {}

  explicit DescribeNamespaceResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeNamespaceResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeNamespaceResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeNamespaceResourcesResponse() = default;
};
class DescribeNamespacesRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};

  DescribeNamespacesRequest() {}

  explicit DescribeNamespacesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeNamespacesRequest() = default;
};
class DescribeNamespacesResponseBodyDataNamespaces : public Darabonba::Model {
public:
  shared_ptr<string> accessKey{};
  shared_ptr<string> addressServerHost{};
  shared_ptr<string> nameSpaceShortId{};
  shared_ptr<string> namespaceDescription{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> namespaceName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> secretKey{};
  shared_ptr<string> tenantId{};

  DescribeNamespacesResponseBodyDataNamespaces() {}

  explicit DescribeNamespacesResponseBodyDataNamespaces(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessKey) {
      res["AccessKey"] = boost::any(*accessKey);
    }
    if (addressServerHost) {
      res["AddressServerHost"] = boost::any(*addressServerHost);
    }
    if (nameSpaceShortId) {
      res["NameSpaceShortId"] = boost::any(*nameSpaceShortId);
    }
    if (namespaceDescription) {
      res["NamespaceDescription"] = boost::any(*namespaceDescription);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (namespaceName) {
      res["NamespaceName"] = boost::any(*namespaceName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (secretKey) {
      res["SecretKey"] = boost::any(*secretKey);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessKey") != m.end() && !m["AccessKey"].empty()) {
      accessKey = make_shared<string>(boost::any_cast<string>(m["AccessKey"]));
    }
    if (m.find("AddressServerHost") != m.end() && !m["AddressServerHost"].empty()) {
      addressServerHost = make_shared<string>(boost::any_cast<string>(m["AddressServerHost"]));
    }
    if (m.find("NameSpaceShortId") != m.end() && !m["NameSpaceShortId"].empty()) {
      nameSpaceShortId = make_shared<string>(boost::any_cast<string>(m["NameSpaceShortId"]));
    }
    if (m.find("NamespaceDescription") != m.end() && !m["NamespaceDescription"].empty()) {
      namespaceDescription = make_shared<string>(boost::any_cast<string>(m["NamespaceDescription"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("NamespaceName") != m.end() && !m["NamespaceName"].empty()) {
      namespaceName = make_shared<string>(boost::any_cast<string>(m["NamespaceName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SecretKey") != m.end() && !m["SecretKey"].empty()) {
      secretKey = make_shared<string>(boost::any_cast<string>(m["SecretKey"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~DescribeNamespacesResponseBodyDataNamespaces() = default;
};
class DescribeNamespacesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<vector<DescribeNamespacesResponseBodyDataNamespaces>> namespaces{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalSize{};

  DescribeNamespacesResponseBodyData() {}

  explicit DescribeNamespacesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (namespaces) {
      vector<boost::any> temp1;
      for(auto item1:*namespaces){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Namespaces"] = boost::any(temp1);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Namespaces") != m.end() && !m["Namespaces"].empty()) {
      if (typeid(vector<boost::any>) == m["Namespaces"].type()) {
        vector<DescribeNamespacesResponseBodyDataNamespaces> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Namespaces"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNamespacesResponseBodyDataNamespaces model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        namespaces = make_shared<vector<DescribeNamespacesResponseBodyDataNamespaces>>(expect1);
      }
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
  }


  virtual ~DescribeNamespacesResponseBodyData() = default;
};
class DescribeNamespacesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeNamespacesResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  DescribeNamespacesResponseBody() {}

  explicit DescribeNamespacesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeNamespacesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeNamespacesResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~DescribeNamespacesResponseBody() = default;
};
class DescribeNamespacesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeNamespacesResponseBody> body{};

  DescribeNamespacesResponse() {}

  explicit DescribeNamespacesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeNamespacesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeNamespacesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeNamespacesResponse() = default;
};
class DescribePipelineRequest : public Darabonba::Model {
public:
  shared_ptr<string> pipelineId{};

  DescribePipelineRequest() {}

  explicit DescribePipelineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
  }


  virtual ~DescribePipelineRequest() = default;
};
class DescribePipelineResponseBodyDataStageListTaskList : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<long> errorIgnore{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> message{};
  shared_ptr<bool> showManualIgnore{};
  shared_ptr<string> stageId{};
  shared_ptr<long> status{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskName{};

  DescribePipelineResponseBodyDataStageListTaskList() {}

  explicit DescribePipelineResponseBodyDataStageListTaskList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorIgnore) {
      res["ErrorIgnore"] = boost::any(*errorIgnore);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (showManualIgnore) {
      res["ShowManualIgnore"] = boost::any(*showManualIgnore);
    }
    if (stageId) {
      res["StageId"] = boost::any(*stageId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorIgnore") != m.end() && !m["ErrorIgnore"].empty()) {
      errorIgnore = make_shared<long>(boost::any_cast<long>(m["ErrorIgnore"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("ShowManualIgnore") != m.end() && !m["ShowManualIgnore"].empty()) {
      showManualIgnore = make_shared<bool>(boost::any_cast<bool>(m["ShowManualIgnore"]));
    }
    if (m.find("StageId") != m.end() && !m["StageId"].empty()) {
      stageId = make_shared<string>(boost::any_cast<string>(m["StageId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
  }


  virtual ~DescribePipelineResponseBodyDataStageListTaskList() = default;
};
class DescribePipelineResponseBodyDataStageList : public Darabonba::Model {
public:
  shared_ptr<long> executorType{};
  shared_ptr<string> stageId{};
  shared_ptr<string> stageName{};
  shared_ptr<long> status{};
  shared_ptr<vector<DescribePipelineResponseBodyDataStageListTaskList>> taskList{};

  DescribePipelineResponseBodyDataStageList() {}

  explicit DescribePipelineResponseBodyDataStageList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (executorType) {
      res["ExecutorType"] = boost::any(*executorType);
    }
    if (stageId) {
      res["StageId"] = boost::any(*stageId);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskList) {
      vector<boost::any> temp1;
      for(auto item1:*taskList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExecutorType") != m.end() && !m["ExecutorType"].empty()) {
      executorType = make_shared<long>(boost::any_cast<long>(m["ExecutorType"]));
    }
    if (m.find("StageId") != m.end() && !m["StageId"].empty()) {
      stageId = make_shared<string>(boost::any_cast<string>(m["StageId"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("TaskList") != m.end() && !m["TaskList"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskList"].type()) {
        vector<DescribePipelineResponseBodyDataStageListTaskList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePipelineResponseBodyDataStageListTaskList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskList = make_shared<vector<DescribePipelineResponseBodyDataStageListTaskList>>(expect1);
      }
    }
  }


  virtual ~DescribePipelineResponseBodyDataStageList() = default;
};
class DescribePipelineResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> coStatus{};
  shared_ptr<string> currentStageId{};
  shared_ptr<string> nextPipelineId{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> pipelineName{};
  shared_ptr<long> pipelineStatus{};
  shared_ptr<bool> showBatch{};
  shared_ptr<vector<DescribePipelineResponseBodyDataStageList>> stageList{};

  DescribePipelineResponseBodyData() {}

  explicit DescribePipelineResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coStatus) {
      res["CoStatus"] = boost::any(*coStatus);
    }
    if (currentStageId) {
      res["CurrentStageId"] = boost::any(*currentStageId);
    }
    if (nextPipelineId) {
      res["NextPipelineId"] = boost::any(*nextPipelineId);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (pipelineName) {
      res["PipelineName"] = boost::any(*pipelineName);
    }
    if (pipelineStatus) {
      res["PipelineStatus"] = boost::any(*pipelineStatus);
    }
    if (showBatch) {
      res["ShowBatch"] = boost::any(*showBatch);
    }
    if (stageList) {
      vector<boost::any> temp1;
      for(auto item1:*stageList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StageList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CoStatus") != m.end() && !m["CoStatus"].empty()) {
      coStatus = make_shared<string>(boost::any_cast<string>(m["CoStatus"]));
    }
    if (m.find("CurrentStageId") != m.end() && !m["CurrentStageId"].empty()) {
      currentStageId = make_shared<string>(boost::any_cast<string>(m["CurrentStageId"]));
    }
    if (m.find("NextPipelineId") != m.end() && !m["NextPipelineId"].empty()) {
      nextPipelineId = make_shared<string>(boost::any_cast<string>(m["NextPipelineId"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("PipelineName") != m.end() && !m["PipelineName"].empty()) {
      pipelineName = make_shared<string>(boost::any_cast<string>(m["PipelineName"]));
    }
    if (m.find("PipelineStatus") != m.end() && !m["PipelineStatus"].empty()) {
      pipelineStatus = make_shared<long>(boost::any_cast<long>(m["PipelineStatus"]));
    }
    if (m.find("ShowBatch") != m.end() && !m["ShowBatch"].empty()) {
      showBatch = make_shared<bool>(boost::any_cast<bool>(m["ShowBatch"]));
    }
    if (m.find("StageList") != m.end() && !m["StageList"].empty()) {
      if (typeid(vector<boost::any>) == m["StageList"].type()) {
        vector<DescribePipelineResponseBodyDataStageList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StageList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePipelineResponseBodyDataStageList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        stageList = make_shared<vector<DescribePipelineResponseBodyDataStageList>>(expect1);
      }
    }
  }


  virtual ~DescribePipelineResponseBodyData() = default;
};
class DescribePipelineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribePipelineResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  DescribePipelineResponseBody() {}

  explicit DescribePipelineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribePipelineResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribePipelineResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~DescribePipelineResponseBody() = default;
};
class DescribePipelineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePipelineResponseBody> body{};

  DescribePipelineResponse() {}

  explicit DescribePipelineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePipelineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePipelineResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePipelineResponse() = default;
};
class DescribeRegionsResponseBodyRegionsRegionRecommendZones : public Darabonba::Model {
public:
  shared_ptr<vector<string>> recommendZone{};

  DescribeRegionsResponseBodyRegionsRegionRecommendZones() {}

  explicit DescribeRegionsResponseBodyRegionsRegionRecommendZones(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recommendZone) {
      res["RecommendZone"] = boost::any(*recommendZone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecommendZone") != m.end() && !m["RecommendZone"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RecommendZone"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RecommendZone"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      recommendZone = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeRegionsResponseBodyRegionsRegionRecommendZones() = default;
};
class DescribeRegionsResponseBodyRegionsRegion : public Darabonba::Model {
public:
  shared_ptr<string> localName{};
  shared_ptr<DescribeRegionsResponseBodyRegionsRegionRecommendZones> recommendZones{};
  shared_ptr<string> regionEndpoint{};
  shared_ptr<string> regionId{};

  DescribeRegionsResponseBodyRegionsRegion() {}

  explicit DescribeRegionsResponseBodyRegionsRegion(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (localName) {
      res["LocalName"] = boost::any(*localName);
    }
    if (recommendZones) {
      res["RecommendZones"] = recommendZones ? boost::any(recommendZones->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (regionEndpoint) {
      res["RegionEndpoint"] = boost::any(*regionEndpoint);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LocalName") != m.end() && !m["LocalName"].empty()) {
      localName = make_shared<string>(boost::any_cast<string>(m["LocalName"]));
    }
    if (m.find("RecommendZones") != m.end() && !m["RecommendZones"].empty()) {
      if (typeid(map<string, boost::any>) == m["RecommendZones"].type()) {
        DescribeRegionsResponseBodyRegionsRegionRecommendZones model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RecommendZones"]));
        recommendZones = make_shared<DescribeRegionsResponseBodyRegionsRegionRecommendZones>(model1);
      }
    }
    if (m.find("RegionEndpoint") != m.end() && !m["RegionEndpoint"].empty()) {
      regionEndpoint = make_shared<string>(boost::any_cast<string>(m["RegionEndpoint"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeRegionsResponseBodyRegionsRegion() = default;
};
class DescribeRegionsResponseBodyRegions : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRegionsResponseBodyRegionsRegion>> region{};

  DescribeRegionsResponseBodyRegions() {}

  explicit DescribeRegionsResponseBodyRegions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (region) {
      vector<boost::any> temp1;
      for(auto item1:*region){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Region"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      if (typeid(vector<boost::any>) == m["Region"].type()) {
        vector<DescribeRegionsResponseBodyRegionsRegion> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Region"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRegionsResponseBodyRegionsRegion model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        region = make_shared<vector<DescribeRegionsResponseBodyRegionsRegion>>(expect1);
      }
    }
  }


  virtual ~DescribeRegionsResponseBodyRegions() = default;
};
class DescribeRegionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<DescribeRegionsResponseBodyRegions> regions{};
  shared_ptr<string> requestId{};

  DescribeRegionsResponseBody() {}

  explicit DescribeRegionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (regions) {
      res["Regions"] = regions ? boost::any(regions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Regions") != m.end() && !m["Regions"].empty()) {
      if (typeid(map<string, boost::any>) == m["Regions"].type()) {
        DescribeRegionsResponseBodyRegions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Regions"]));
        regions = make_shared<DescribeRegionsResponseBodyRegions>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeRegionsResponseBody() = default;
};
class DescribeRegionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRegionsResponseBody> body{};

  DescribeRegionsResponse() {}

  explicit DescribeRegionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRegionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRegionsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRegionsResponse() = default;
};
class DescribeSecretRequest : public Darabonba::Model {
public:
  shared_ptr<string> namespaceId{};
  shared_ptr<long> secretId{};

  DescribeSecretRequest() {}

  explicit DescribeSecretRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (secretId) {
      res["SecretId"] = boost::any(*secretId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("SecretId") != m.end() && !m["SecretId"].empty()) {
      secretId = make_shared<long>(boost::any_cast<long>(m["SecretId"]));
    }
  }


  virtual ~DescribeSecretRequest() = default;
};
class DescribeSecretResponseBodyDataRelateApps : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};

  DescribeSecretResponseBodyDataRelateApps() {}

  explicit DescribeSecretResponseBodyDataRelateApps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
  }


  virtual ~DescribeSecretResponseBodyDataRelateApps() = default;
};
class DescribeSecretResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> namespaceId{};
  shared_ptr<vector<DescribeSecretResponseBodyDataRelateApps>> relateApps{};
  shared_ptr<map<string, string>> secretData{};
  shared_ptr<long> secretId{};
  shared_ptr<string> secretName{};
  shared_ptr<string> secretType{};
  shared_ptr<long> updateTime{};

  DescribeSecretResponseBodyData() {}

  explicit DescribeSecretResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (relateApps) {
      vector<boost::any> temp1;
      for(auto item1:*relateApps){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RelateApps"] = boost::any(temp1);
    }
    if (secretData) {
      res["SecretData"] = boost::any(*secretData);
    }
    if (secretId) {
      res["SecretId"] = boost::any(*secretId);
    }
    if (secretName) {
      res["SecretName"] = boost::any(*secretName);
    }
    if (secretType) {
      res["SecretType"] = boost::any(*secretType);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("RelateApps") != m.end() && !m["RelateApps"].empty()) {
      if (typeid(vector<boost::any>) == m["RelateApps"].type()) {
        vector<DescribeSecretResponseBodyDataRelateApps> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RelateApps"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSecretResponseBodyDataRelateApps model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        relateApps = make_shared<vector<DescribeSecretResponseBodyDataRelateApps>>(expect1);
      }
    }
    if (m.find("SecretData") != m.end() && !m["SecretData"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["SecretData"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      secretData = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("SecretId") != m.end() && !m["SecretId"].empty()) {
      secretId = make_shared<long>(boost::any_cast<long>(m["SecretId"]));
    }
    if (m.find("SecretName") != m.end() && !m["SecretName"].empty()) {
      secretName = make_shared<string>(boost::any_cast<string>(m["SecretName"]));
    }
    if (m.find("SecretType") != m.end() && !m["SecretType"].empty()) {
      secretType = make_shared<string>(boost::any_cast<string>(m["SecretType"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~DescribeSecretResponseBodyData() = default;
};
class DescribeSecretResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeSecretResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  DescribeSecretResponseBody() {}

  explicit DescribeSecretResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeSecretResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeSecretResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~DescribeSecretResponseBody() = default;
};
class DescribeSecretResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSecretResponseBody> body{};

  DescribeSecretResponse() {}

  explicit DescribeSecretResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSecretResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSecretResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSecretResponse() = default;
};
class DescribeSwimmingLaneRequest : public Darabonba::Model {
public:
  shared_ptr<long> groupId{};
  shared_ptr<long> laneId{};
  shared_ptr<string> namespaceId{};

  DescribeSwimmingLaneRequest() {}

  explicit DescribeSwimmingLaneRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (laneId) {
      res["LaneId"] = boost::any(*laneId);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("LaneId") != m.end() && !m["LaneId"].empty()) {
      laneId = make_shared<long>(boost::any_cast<long>(m["LaneId"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
  }


  virtual ~DescribeSwimmingLaneRequest() = default;
};
class DescribeSwimmingLaneResponseBodyDataAppEntryRuleConditions : public Darabonba::Model {
public:
  shared_ptr<string> condition{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};
  shared_ptr<vector<string>> values{};

  DescribeSwimmingLaneResponseBodyDataAppEntryRuleConditions() {}

  explicit DescribeSwimmingLaneResponseBodyDataAppEntryRuleConditions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (condition) {
      res["Condition"] = boost::any(*condition);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (values) {
      res["Values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Condition") != m.end() && !m["Condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["Condition"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Values"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Values"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      values = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeSwimmingLaneResponseBodyDataAppEntryRuleConditions() = default;
};
class DescribeSwimmingLaneResponseBodyDataAppEntryRule : public Darabonba::Model {
public:
  shared_ptr<string> conditionJoiner{};
  shared_ptr<vector<DescribeSwimmingLaneResponseBodyDataAppEntryRuleConditions>> conditions{};
  shared_ptr<bool> independentPercentageEnable{};
  shared_ptr<vector<string>> paths{};
  shared_ptr<long> percentage{};
  shared_ptr<map<string, long>> percentageByPath{};

  DescribeSwimmingLaneResponseBodyDataAppEntryRule() {}

  explicit DescribeSwimmingLaneResponseBodyDataAppEntryRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conditionJoiner) {
      res["ConditionJoiner"] = boost::any(*conditionJoiner);
    }
    if (conditions) {
      vector<boost::any> temp1;
      for(auto item1:*conditions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Conditions"] = boost::any(temp1);
    }
    if (independentPercentageEnable) {
      res["IndependentPercentageEnable"] = boost::any(*independentPercentageEnable);
    }
    if (paths) {
      res["Paths"] = boost::any(*paths);
    }
    if (percentage) {
      res["Percentage"] = boost::any(*percentage);
    }
    if (percentageByPath) {
      res["PercentageByPath"] = boost::any(*percentageByPath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConditionJoiner") != m.end() && !m["ConditionJoiner"].empty()) {
      conditionJoiner = make_shared<string>(boost::any_cast<string>(m["ConditionJoiner"]));
    }
    if (m.find("Conditions") != m.end() && !m["Conditions"].empty()) {
      if (typeid(vector<boost::any>) == m["Conditions"].type()) {
        vector<DescribeSwimmingLaneResponseBodyDataAppEntryRuleConditions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Conditions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSwimmingLaneResponseBodyDataAppEntryRuleConditions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        conditions = make_shared<vector<DescribeSwimmingLaneResponseBodyDataAppEntryRuleConditions>>(expect1);
      }
    }
    if (m.find("IndependentPercentageEnable") != m.end() && !m["IndependentPercentageEnable"].empty()) {
      independentPercentageEnable = make_shared<bool>(boost::any_cast<bool>(m["IndependentPercentageEnable"]));
    }
    if (m.find("Paths") != m.end() && !m["Paths"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Paths"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Paths"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      paths = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Percentage") != m.end() && !m["Percentage"].empty()) {
      percentage = make_shared<long>(boost::any_cast<long>(m["Percentage"]));
    }
    if (m.find("PercentageByPath") != m.end() && !m["PercentageByPath"].empty()) {
      map<string, long> map1 = boost::any_cast<map<string, long>>(m["PercentageByPath"]);
      map<string, long> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      percentageByPath = make_shared<map<string, long>>(toMap1);
    }
  }


  virtual ~DescribeSwimmingLaneResponseBodyDataAppEntryRule() = default;
};
class DescribeSwimmingLaneResponseBodyDataApps : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> mseAppId{};
  shared_ptr<string> mseAppName{};
  shared_ptr<string> mseNamespaceId{};

  DescribeSwimmingLaneResponseBodyDataApps() {}

  explicit DescribeSwimmingLaneResponseBodyDataApps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (mseAppId) {
      res["MseAppId"] = boost::any(*mseAppId);
    }
    if (mseAppName) {
      res["MseAppName"] = boost::any(*mseAppName);
    }
    if (mseNamespaceId) {
      res["mseNamespaceId"] = boost::any(*mseNamespaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("MseAppId") != m.end() && !m["MseAppId"].empty()) {
      mseAppId = make_shared<string>(boost::any_cast<string>(m["MseAppId"]));
    }
    if (m.find("MseAppName") != m.end() && !m["MseAppName"].empty()) {
      mseAppName = make_shared<string>(boost::any_cast<string>(m["MseAppName"]));
    }
    if (m.find("mseNamespaceId") != m.end() && !m["mseNamespaceId"].empty()) {
      mseNamespaceId = make_shared<string>(boost::any_cast<string>(m["mseNamespaceId"]));
    }
  }


  virtual ~DescribeSwimmingLaneResponseBodyDataApps() = default;
};
class DescribeSwimmingLaneResponseBodyDataMseGatewayEntryRuleConditions : public Darabonba::Model {
public:
  shared_ptr<string> condition{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  DescribeSwimmingLaneResponseBodyDataMseGatewayEntryRuleConditions() {}

  explicit DescribeSwimmingLaneResponseBodyDataMseGatewayEntryRuleConditions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (condition) {
      res["Condition"] = boost::any(*condition);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Condition") != m.end() && !m["Condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["Condition"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeSwimmingLaneResponseBodyDataMseGatewayEntryRuleConditions() = default;
};
class DescribeSwimmingLaneResponseBodyDataMseGatewayEntryRuleRoutesRoutePredicatePathPredicate : public Darabonba::Model {
public:
  shared_ptr<string> path{};
  shared_ptr<string> type{};

  DescribeSwimmingLaneResponseBodyDataMseGatewayEntryRuleRoutesRoutePredicatePathPredicate() {}

  explicit DescribeSwimmingLaneResponseBodyDataMseGatewayEntryRuleRoutesRoutePredicatePathPredicate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeSwimmingLaneResponseBodyDataMseGatewayEntryRuleRoutesRoutePredicatePathPredicate() = default;
};
class DescribeSwimmingLaneResponseBodyDataMseGatewayEntryRuleRoutesRoutePredicate : public Darabonba::Model {
public:
  shared_ptr<DescribeSwimmingLaneResponseBodyDataMseGatewayEntryRuleRoutesRoutePredicatePathPredicate> pathPredicate{};

  DescribeSwimmingLaneResponseBodyDataMseGatewayEntryRuleRoutesRoutePredicate() {}

  explicit DescribeSwimmingLaneResponseBodyDataMseGatewayEntryRuleRoutesRoutePredicate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pathPredicate) {
      res["PathPredicate"] = pathPredicate ? boost::any(pathPredicate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PathPredicate") != m.end() && !m["PathPredicate"].empty()) {
      if (typeid(map<string, boost::any>) == m["PathPredicate"].type()) {
        DescribeSwimmingLaneResponseBodyDataMseGatewayEntryRuleRoutesRoutePredicatePathPredicate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PathPredicate"]));
        pathPredicate = make_shared<DescribeSwimmingLaneResponseBodyDataMseGatewayEntryRuleRoutesRoutePredicatePathPredicate>(model1);
      }
    }
  }


  virtual ~DescribeSwimmingLaneResponseBodyDataMseGatewayEntryRuleRoutesRoutePredicate() = default;
};
class DescribeSwimmingLaneResponseBodyDataMseGatewayEntryRuleRoutes : public Darabonba::Model {
public:
  shared_ptr<long> routeId{};
  shared_ptr<string> routeName{};
  shared_ptr<DescribeSwimmingLaneResponseBodyDataMseGatewayEntryRuleRoutesRoutePredicate> routePredicate{};

  DescribeSwimmingLaneResponseBodyDataMseGatewayEntryRuleRoutes() {}

  explicit DescribeSwimmingLaneResponseBodyDataMseGatewayEntryRuleRoutes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (routeId) {
      res["RouteId"] = boost::any(*routeId);
    }
    if (routeName) {
      res["RouteName"] = boost::any(*routeName);
    }
    if (routePredicate) {
      res["RoutePredicate"] = routePredicate ? boost::any(routePredicate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RouteId") != m.end() && !m["RouteId"].empty()) {
      routeId = make_shared<long>(boost::any_cast<long>(m["RouteId"]));
    }
    if (m.find("RouteName") != m.end() && !m["RouteName"].empty()) {
      routeName = make_shared<string>(boost::any_cast<string>(m["RouteName"]));
    }
    if (m.find("RoutePredicate") != m.end() && !m["RoutePredicate"].empty()) {
      if (typeid(map<string, boost::any>) == m["RoutePredicate"].type()) {
        DescribeSwimmingLaneResponseBodyDataMseGatewayEntryRuleRoutesRoutePredicate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RoutePredicate"]));
        routePredicate = make_shared<DescribeSwimmingLaneResponseBodyDataMseGatewayEntryRuleRoutesRoutePredicate>(model1);
      }
    }
  }


  virtual ~DescribeSwimmingLaneResponseBodyDataMseGatewayEntryRuleRoutes() = default;
};
class DescribeSwimmingLaneResponseBodyDataMseGatewayEntryRule : public Darabonba::Model {
public:
  shared_ptr<string> conditionJoiner{};
  shared_ptr<vector<DescribeSwimmingLaneResponseBodyDataMseGatewayEntryRuleConditions>> conditions{};
  shared_ptr<bool> independentPercentageEnable{};
  shared_ptr<long> percentage{};
  shared_ptr<map<string, long>> percentageByRoute{};
  shared_ptr<vector<long>> routeIds{};
  shared_ptr<vector<DescribeSwimmingLaneResponseBodyDataMseGatewayEntryRuleRoutes>> routes{};

  DescribeSwimmingLaneResponseBodyDataMseGatewayEntryRule() {}

  explicit DescribeSwimmingLaneResponseBodyDataMseGatewayEntryRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conditionJoiner) {
      res["ConditionJoiner"] = boost::any(*conditionJoiner);
    }
    if (conditions) {
      vector<boost::any> temp1;
      for(auto item1:*conditions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Conditions"] = boost::any(temp1);
    }
    if (independentPercentageEnable) {
      res["IndependentPercentageEnable"] = boost::any(*independentPercentageEnable);
    }
    if (percentage) {
      res["Percentage"] = boost::any(*percentage);
    }
    if (percentageByRoute) {
      res["PercentageByRoute"] = boost::any(*percentageByRoute);
    }
    if (routeIds) {
      res["RouteIds"] = boost::any(*routeIds);
    }
    if (routes) {
      vector<boost::any> temp1;
      for(auto item1:*routes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Routes"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConditionJoiner") != m.end() && !m["ConditionJoiner"].empty()) {
      conditionJoiner = make_shared<string>(boost::any_cast<string>(m["ConditionJoiner"]));
    }
    if (m.find("Conditions") != m.end() && !m["Conditions"].empty()) {
      if (typeid(vector<boost::any>) == m["Conditions"].type()) {
        vector<DescribeSwimmingLaneResponseBodyDataMseGatewayEntryRuleConditions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Conditions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSwimmingLaneResponseBodyDataMseGatewayEntryRuleConditions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        conditions = make_shared<vector<DescribeSwimmingLaneResponseBodyDataMseGatewayEntryRuleConditions>>(expect1);
      }
    }
    if (m.find("IndependentPercentageEnable") != m.end() && !m["IndependentPercentageEnable"].empty()) {
      independentPercentageEnable = make_shared<bool>(boost::any_cast<bool>(m["IndependentPercentageEnable"]));
    }
    if (m.find("Percentage") != m.end() && !m["Percentage"].empty()) {
      percentage = make_shared<long>(boost::any_cast<long>(m["Percentage"]));
    }
    if (m.find("PercentageByRoute") != m.end() && !m["PercentageByRoute"].empty()) {
      map<string, long> map1 = boost::any_cast<map<string, long>>(m["PercentageByRoute"]);
      map<string, long> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      percentageByRoute = make_shared<map<string, long>>(toMap1);
    }
    if (m.find("RouteIds") != m.end() && !m["RouteIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["RouteIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RouteIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      routeIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Routes") != m.end() && !m["Routes"].empty()) {
      if (typeid(vector<boost::any>) == m["Routes"].type()) {
        vector<DescribeSwimmingLaneResponseBodyDataMseGatewayEntryRuleRoutes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Routes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSwimmingLaneResponseBodyDataMseGatewayEntryRuleRoutes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        routes = make_shared<vector<DescribeSwimmingLaneResponseBodyDataMseGatewayEntryRuleRoutes>>(expect1);
      }
    }
  }


  virtual ~DescribeSwimmingLaneResponseBodyDataMseGatewayEntryRule() = default;
};
class DescribeSwimmingLaneResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<DescribeSwimmingLaneResponseBodyDataAppEntryRule> appEntryRule{};
  shared_ptr<vector<DescribeSwimmingLaneResponseBodyDataApps>> apps{};
  shared_ptr<long> canaryModel{};
  shared_ptr<bool> enable{};
  shared_ptr<bool> enableRules{};
  shared_ptr<long> laneId{};
  shared_ptr<string> laneName{};
  shared_ptr<string> laneTag{};
  shared_ptr<DescribeSwimmingLaneResponseBodyDataMseGatewayEntryRule> mseGatewayEntryRule{};

  DescribeSwimmingLaneResponseBodyData() {}

  explicit DescribeSwimmingLaneResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appEntryRule) {
      res["AppEntryRule"] = appEntryRule ? boost::any(appEntryRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (apps) {
      vector<boost::any> temp1;
      for(auto item1:*apps){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Apps"] = boost::any(temp1);
    }
    if (canaryModel) {
      res["CanaryModel"] = boost::any(*canaryModel);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (enableRules) {
      res["EnableRules"] = boost::any(*enableRules);
    }
    if (laneId) {
      res["LaneId"] = boost::any(*laneId);
    }
    if (laneName) {
      res["LaneName"] = boost::any(*laneName);
    }
    if (laneTag) {
      res["LaneTag"] = boost::any(*laneTag);
    }
    if (mseGatewayEntryRule) {
      res["MseGatewayEntryRule"] = mseGatewayEntryRule ? boost::any(mseGatewayEntryRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppEntryRule") != m.end() && !m["AppEntryRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["AppEntryRule"].type()) {
        DescribeSwimmingLaneResponseBodyDataAppEntryRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AppEntryRule"]));
        appEntryRule = make_shared<DescribeSwimmingLaneResponseBodyDataAppEntryRule>(model1);
      }
    }
    if (m.find("Apps") != m.end() && !m["Apps"].empty()) {
      if (typeid(vector<boost::any>) == m["Apps"].type()) {
        vector<DescribeSwimmingLaneResponseBodyDataApps> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Apps"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSwimmingLaneResponseBodyDataApps model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apps = make_shared<vector<DescribeSwimmingLaneResponseBodyDataApps>>(expect1);
      }
    }
    if (m.find("CanaryModel") != m.end() && !m["CanaryModel"].empty()) {
      canaryModel = make_shared<long>(boost::any_cast<long>(m["CanaryModel"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("EnableRules") != m.end() && !m["EnableRules"].empty()) {
      enableRules = make_shared<bool>(boost::any_cast<bool>(m["EnableRules"]));
    }
    if (m.find("LaneId") != m.end() && !m["LaneId"].empty()) {
      laneId = make_shared<long>(boost::any_cast<long>(m["LaneId"]));
    }
    if (m.find("LaneName") != m.end() && !m["LaneName"].empty()) {
      laneName = make_shared<string>(boost::any_cast<string>(m["LaneName"]));
    }
    if (m.find("LaneTag") != m.end() && !m["LaneTag"].empty()) {
      laneTag = make_shared<string>(boost::any_cast<string>(m["LaneTag"]));
    }
    if (m.find("MseGatewayEntryRule") != m.end() && !m["MseGatewayEntryRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["MseGatewayEntryRule"].type()) {
        DescribeSwimmingLaneResponseBodyDataMseGatewayEntryRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MseGatewayEntryRule"]));
        mseGatewayEntryRule = make_shared<DescribeSwimmingLaneResponseBodyDataMseGatewayEntryRule>(model1);
      }
    }
  }


  virtual ~DescribeSwimmingLaneResponseBodyData() = default;
};
class DescribeSwimmingLaneResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeSwimmingLaneResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  DescribeSwimmingLaneResponseBody() {}

  explicit DescribeSwimmingLaneResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeSwimmingLaneResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeSwimmingLaneResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~DescribeSwimmingLaneResponseBody() = default;
};
class DescribeSwimmingLaneResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSwimmingLaneResponseBody> body{};

  DescribeSwimmingLaneResponse() {}

  explicit DescribeSwimmingLaneResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSwimmingLaneResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSwimmingLaneResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSwimmingLaneResponse() = default;
};
class DescribeWebApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> namespaceId{};

  DescribeWebApplicationRequest() {}

  explicit DescribeWebApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
  }


  virtual ~DescribeWebApplicationRequest() = default;
};
class DescribeWebApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<WebApplicationBody> body{};

  DescribeWebApplicationResponse() {}

  explicit DescribeWebApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        WebApplicationBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<WebApplicationBody>(model1);
      }
    }
  }


  virtual ~DescribeWebApplicationResponse() = default;
};
class DescribeWebApplicationResourceStaticsRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> startTime{};

  DescribeWebApplicationResourceStaticsRequest() {}

  explicit DescribeWebApplicationResourceStaticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribeWebApplicationResourceStaticsRequest() = default;
};
class DescribeWebApplicationResourceStaticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<WebApplicationResourceStaticsBody> body{};

  DescribeWebApplicationResourceStaticsResponse() {}

  explicit DescribeWebApplicationResourceStaticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        WebApplicationResourceStaticsBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<WebApplicationResourceStaticsBody>(model1);
      }
    }
  }


  virtual ~DescribeWebApplicationResourceStaticsResponse() = default;
};
class DescribeWebApplicationRevisionRequest : public Darabonba::Model {
public:
  shared_ptr<string> namespaceId{};

  DescribeWebApplicationRevisionRequest() {}

  explicit DescribeWebApplicationRevisionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
  }


  virtual ~DescribeWebApplicationRevisionRequest() = default;
};
class DescribeWebApplicationRevisionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<WebApplicationRevisionBody> body{};

  DescribeWebApplicationRevisionResponse() {}

  explicit DescribeWebApplicationRevisionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        WebApplicationRevisionBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<WebApplicationRevisionBody>(model1);
      }
    }
  }


  virtual ~DescribeWebApplicationRevisionResponse() = default;
};
class DescribeWebApplicationScalingConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> namespaceId{};

  DescribeWebApplicationScalingConfigRequest() {}

  explicit DescribeWebApplicationScalingConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
  }


  virtual ~DescribeWebApplicationScalingConfigRequest() = default;
};
class DescribeWebApplicationScalingConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<WebApplicationScalingConfigBody> body{};

  DescribeWebApplicationScalingConfigResponse() {}

  explicit DescribeWebApplicationScalingConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        WebApplicationScalingConfigBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<WebApplicationScalingConfigBody>(model1);
      }
    }
  }


  virtual ~DescribeWebApplicationScalingConfigResponse() = default;
};
class DescribeWebApplicationTrafficConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> namespaceId{};

  DescribeWebApplicationTrafficConfigRequest() {}

  explicit DescribeWebApplicationTrafficConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
  }


  virtual ~DescribeWebApplicationTrafficConfigRequest() = default;
};
class DescribeWebApplicationTrafficConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<WebApplicationTrafficConfigBody> body{};

  DescribeWebApplicationTrafficConfigResponse() {}

  explicit DescribeWebApplicationTrafficConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        WebApplicationTrafficConfigBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<WebApplicationTrafficConfigBody>(model1);
      }
    }
  }


  virtual ~DescribeWebApplicationTrafficConfigResponse() = default;
};
class DescribeWebCustomDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> namespaceId{};

  DescribeWebCustomDomainRequest() {}

  explicit DescribeWebCustomDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
  }


  virtual ~DescribeWebCustomDomainRequest() = default;
};
class DescribeWebCustomDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<WebCustomDomain> body{};

  DescribeWebCustomDomainResponse() {}

  explicit DescribeWebCustomDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        WebCustomDomain model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<WebCustomDomain>(model1);
      }
    }
  }


  virtual ~DescribeWebCustomDomainResponse() = default;
};
class DescribeWebInstanceLogsRequest : public Darabonba::Model {
public:
  shared_ptr<string> namespaceId{};

  DescribeWebInstanceLogsRequest() {}

  explicit DescribeWebInstanceLogsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
  }


  virtual ~DescribeWebInstanceLogsRequest() = default;
};
class DescribeWebInstanceLogsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<WebApplicationInstanceLogsBody> body{};

  DescribeWebInstanceLogsResponse() {}

  explicit DescribeWebInstanceLogsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        WebApplicationInstanceLogsBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<WebApplicationInstanceLogsBody>(model1);
      }
    }
  }


  virtual ~DescribeWebInstanceLogsResponse() = default;
};
class DisableApplicationScalingRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> scalingRuleName{};

  DisableApplicationScalingRuleRequest() {}

  explicit DisableApplicationScalingRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (scalingRuleName) {
      res["ScalingRuleName"] = boost::any(*scalingRuleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ScalingRuleName") != m.end() && !m["ScalingRuleName"].empty()) {
      scalingRuleName = make_shared<string>(boost::any_cast<string>(m["ScalingRuleName"]));
    }
  }


  virtual ~DisableApplicationScalingRuleRequest() = default;
};
class DisableApplicationScalingRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  DisableApplicationScalingRuleResponseBody() {}

  explicit DisableApplicationScalingRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~DisableApplicationScalingRuleResponseBody() = default;
};
class DisableApplicationScalingRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisableApplicationScalingRuleResponseBody> body{};

  DisableApplicationScalingRuleResponse() {}

  explicit DisableApplicationScalingRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableApplicationScalingRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableApplicationScalingRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DisableApplicationScalingRuleResponse() = default;
};
class DowngradeApplicationApmServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  DowngradeApplicationApmServiceRequest() {}

  explicit DowngradeApplicationApmServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~DowngradeApplicationApmServiceRequest() = default;
};
class DowngradeApplicationApmServiceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> status{};

  DowngradeApplicationApmServiceResponseBodyData() {}

  explicit DowngradeApplicationApmServiceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<bool>(boost::any_cast<bool>(m["Status"]));
    }
  }


  virtual ~DowngradeApplicationApmServiceResponseBodyData() = default;
};
class DowngradeApplicationApmServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DowngradeApplicationApmServiceResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  DowngradeApplicationApmServiceResponseBody() {}

  explicit DowngradeApplicationApmServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DowngradeApplicationApmServiceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DowngradeApplicationApmServiceResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~DowngradeApplicationApmServiceResponseBody() = default;
};
class DowngradeApplicationApmServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DowngradeApplicationApmServiceResponseBody> body{};

  DowngradeApplicationApmServiceResponse() {}

  explicit DowngradeApplicationApmServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DowngradeApplicationApmServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DowngradeApplicationApmServiceResponseBody>(model1);
      }
    }
  }


  virtual ~DowngradeApplicationApmServiceResponse() = default;
};
class EnableApplicationScalingRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> scalingRuleName{};

  EnableApplicationScalingRuleRequest() {}

  explicit EnableApplicationScalingRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (scalingRuleName) {
      res["ScalingRuleName"] = boost::any(*scalingRuleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ScalingRuleName") != m.end() && !m["ScalingRuleName"].empty()) {
      scalingRuleName = make_shared<string>(boost::any_cast<string>(m["ScalingRuleName"]));
    }
  }


  virtual ~EnableApplicationScalingRuleRequest() = default;
};
class EnableApplicationScalingRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  EnableApplicationScalingRuleResponseBody() {}

  explicit EnableApplicationScalingRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~EnableApplicationScalingRuleResponseBody() = default;
};
class EnableApplicationScalingRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableApplicationScalingRuleResponseBody> body{};

  EnableApplicationScalingRuleResponse() {}

  explicit EnableApplicationScalingRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableApplicationScalingRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableApplicationScalingRuleResponseBody>(model1);
      }
    }
  }


  virtual ~EnableApplicationScalingRuleResponse() = default;
};
class ExecJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> command{};
  shared_ptr<string> commandArgs{};
  shared_ptr<string> envs{};
  shared_ptr<string> eventId{};
  shared_ptr<string> jarStartArgs{};
  shared_ptr<string> jarStartOptions{};
  shared_ptr<string> replicas{};
  shared_ptr<string> time{};
  shared_ptr<string> warStartOptions{};

  ExecJobRequest() {}

  explicit ExecJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (command) {
      res["Command"] = boost::any(*command);
    }
    if (commandArgs) {
      res["CommandArgs"] = boost::any(*commandArgs);
    }
    if (envs) {
      res["Envs"] = boost::any(*envs);
    }
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (jarStartArgs) {
      res["JarStartArgs"] = boost::any(*jarStartArgs);
    }
    if (jarStartOptions) {
      res["JarStartOptions"] = boost::any(*jarStartOptions);
    }
    if (replicas) {
      res["Replicas"] = boost::any(*replicas);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (warStartOptions) {
      res["WarStartOptions"] = boost::any(*warStartOptions);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
    if (m.find("CommandArgs") != m.end() && !m["CommandArgs"].empty()) {
      commandArgs = make_shared<string>(boost::any_cast<string>(m["CommandArgs"]));
    }
    if (m.find("Envs") != m.end() && !m["Envs"].empty()) {
      envs = make_shared<string>(boost::any_cast<string>(m["Envs"]));
    }
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("JarStartArgs") != m.end() && !m["JarStartArgs"].empty()) {
      jarStartArgs = make_shared<string>(boost::any_cast<string>(m["JarStartArgs"]));
    }
    if (m.find("JarStartOptions") != m.end() && !m["JarStartOptions"].empty()) {
      jarStartOptions = make_shared<string>(boost::any_cast<string>(m["JarStartOptions"]));
    }
    if (m.find("Replicas") != m.end() && !m["Replicas"].empty()) {
      replicas = make_shared<string>(boost::any_cast<string>(m["Replicas"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("WarStartOptions") != m.end() && !m["WarStartOptions"].empty()) {
      warStartOptions = make_shared<string>(boost::any_cast<string>(m["WarStartOptions"]));
    }
  }


  virtual ~ExecJobRequest() = default;
};
class ExecJobResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> msg{};
  shared_ptr<string> success{};

  ExecJobResponseBodyData() {}

  explicit ExecJobResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (msg) {
      res["Msg"] = boost::any(*msg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Msg") != m.end() && !m["Msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["Msg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~ExecJobResponseBodyData() = default;
};
class ExecJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ExecJobResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  ExecJobResponseBody() {}

  explicit ExecJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ExecJobResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ExecJobResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~ExecJobResponseBody() = default;
};
class ExecJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExecJobResponseBody> body{};

  ExecJobResponse() {}

  explicit ExecJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExecJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExecJobResponseBody>(model1);
      }
    }
  }


  virtual ~ExecJobResponse() = default;
};
class GetApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> namespaceId{};

  GetApplicationRequest() {}

  explicit GetApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
  }


  virtual ~GetApplicationRequest() = default;
};
class GetApplicationResponseBodyApplication : public Darabonba::Model {
public:
  shared_ptr<string> appDescription{};
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> baseAppId{};
  shared_ptr<long> cpu{};
  shared_ptr<long> instances{};
  shared_ptr<long> mem{};
  shared_ptr<bool> mseEnabled{};
  shared_ptr<string> mseNamespaceId{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> programmingLanguage{};
  shared_ptr<long> runningInstances{};
  shared_ptr<string> scaleRuleEnabled{};
  shared_ptr<string> scaleRuleType{};

  GetApplicationResponseBodyApplication() {}

  explicit GetApplicationResponseBodyApplication(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appDescription) {
      res["AppDescription"] = boost::any(*appDescription);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (baseAppId) {
      res["BaseAppId"] = boost::any(*baseAppId);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (instances) {
      res["Instances"] = boost::any(*instances);
    }
    if (mem) {
      res["Mem"] = boost::any(*mem);
    }
    if (mseEnabled) {
      res["MseEnabled"] = boost::any(*mseEnabled);
    }
    if (mseNamespaceId) {
      res["MseNamespaceId"] = boost::any(*mseNamespaceId);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (programmingLanguage) {
      res["ProgrammingLanguage"] = boost::any(*programmingLanguage);
    }
    if (runningInstances) {
      res["RunningInstances"] = boost::any(*runningInstances);
    }
    if (scaleRuleEnabled) {
      res["ScaleRuleEnabled"] = boost::any(*scaleRuleEnabled);
    }
    if (scaleRuleType) {
      res["ScaleRuleType"] = boost::any(*scaleRuleType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppDescription") != m.end() && !m["AppDescription"].empty()) {
      appDescription = make_shared<string>(boost::any_cast<string>(m["AppDescription"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("BaseAppId") != m.end() && !m["BaseAppId"].empty()) {
      baseAppId = make_shared<string>(boost::any_cast<string>(m["BaseAppId"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      instances = make_shared<long>(boost::any_cast<long>(m["Instances"]));
    }
    if (m.find("Mem") != m.end() && !m["Mem"].empty()) {
      mem = make_shared<long>(boost::any_cast<long>(m["Mem"]));
    }
    if (m.find("MseEnabled") != m.end() && !m["MseEnabled"].empty()) {
      mseEnabled = make_shared<bool>(boost::any_cast<bool>(m["MseEnabled"]));
    }
    if (m.find("MseNamespaceId") != m.end() && !m["MseNamespaceId"].empty()) {
      mseNamespaceId = make_shared<string>(boost::any_cast<string>(m["MseNamespaceId"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("ProgrammingLanguage") != m.end() && !m["ProgrammingLanguage"].empty()) {
      programmingLanguage = make_shared<string>(boost::any_cast<string>(m["ProgrammingLanguage"]));
    }
    if (m.find("RunningInstances") != m.end() && !m["RunningInstances"].empty()) {
      runningInstances = make_shared<long>(boost::any_cast<long>(m["RunningInstances"]));
    }
    if (m.find("ScaleRuleEnabled") != m.end() && !m["ScaleRuleEnabled"].empty()) {
      scaleRuleEnabled = make_shared<string>(boost::any_cast<string>(m["ScaleRuleEnabled"]));
    }
    if (m.find("ScaleRuleType") != m.end() && !m["ScaleRuleType"].empty()) {
      scaleRuleType = make_shared<string>(boost::any_cast<string>(m["ScaleRuleType"]));
    }
  }


  virtual ~GetApplicationResponseBodyApplication() = default;
};
class GetApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetApplicationResponseBodyApplication> application{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> traceId{};

  GetApplicationResponseBody() {}

  explicit GetApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (application) {
      res["Application"] = application ? boost::any(application->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Application") != m.end() && !m["Application"].empty()) {
      if (typeid(map<string, boost::any>) == m["Application"].type()) {
        GetApplicationResponseBodyApplication model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Application"]));
        application = make_shared<GetApplicationResponseBodyApplication>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~GetApplicationResponseBody() = default;
};
class GetApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetApplicationResponseBody> body{};

  GetApplicationResponse() {}

  explicit GetApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~GetApplicationResponse() = default;
};
class GetArmsTopNMetricRequest : public Darabonba::Model {
public:
  shared_ptr<string> appSource{};
  shared_ptr<string> cpuStrategy{};
  shared_ptr<long> endTime{};
  shared_ptr<long> limit{};
  shared_ptr<string> orderBy{};
  shared_ptr<string> regionId{};
  shared_ptr<long> startTime{};

  GetArmsTopNMetricRequest() {}

  explicit GetArmsTopNMetricRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appSource) {
      res["AppSource"] = boost::any(*appSource);
    }
    if (cpuStrategy) {
      res["CpuStrategy"] = boost::any(*cpuStrategy);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (limit) {
      res["Limit"] = boost::any(*limit);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppSource") != m.end() && !m["AppSource"].empty()) {
      appSource = make_shared<string>(boost::any_cast<string>(m["AppSource"]));
    }
    if (m.find("CpuStrategy") != m.end() && !m["CpuStrategy"].empty()) {
      cpuStrategy = make_shared<string>(boost::any_cast<string>(m["CpuStrategy"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Limit") != m.end() && !m["Limit"].empty()) {
      limit = make_shared<long>(boost::any_cast<long>(m["Limit"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~GetArmsTopNMetricRequest() = default;
};
class GetArmsTopNMetricResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> count{};
  shared_ptr<long> error{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<long> rt{};

  GetArmsTopNMetricResponseBodyData() {}

  explicit GetArmsTopNMetricResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (error) {
      res["Error"] = boost::any(*error);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (rt) {
      res["Rt"] = boost::any(*rt);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Error") != m.end() && !m["Error"].empty()) {
      error = make_shared<long>(boost::any_cast<long>(m["Error"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Rt") != m.end() && !m["Rt"].empty()) {
      rt = make_shared<long>(boost::any_cast<long>(m["Rt"]));
    }
  }


  virtual ~GetArmsTopNMetricResponseBodyData() = default;
};
class GetArmsTopNMetricResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<GetArmsTopNMetricResponseBodyData>> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetArmsTopNMetricResponseBody() {}

  explicit GetArmsTopNMetricResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<GetArmsTopNMetricResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetArmsTopNMetricResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<GetArmsTopNMetricResponseBodyData>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetArmsTopNMetricResponseBody() = default;
};
class GetArmsTopNMetricResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetArmsTopNMetricResponseBody> body{};

  GetArmsTopNMetricResponse() {}

  explicit GetArmsTopNMetricResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetArmsTopNMetricResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetArmsTopNMetricResponseBody>(model1);
      }
    }
  }


  virtual ~GetArmsTopNMetricResponse() = default;
};
class GetAvailabilityMetricRequest : public Darabonba::Model {
public:
  shared_ptr<string> appSource{};
  shared_ptr<string> cpuStrategy{};
  shared_ptr<long> limit{};
  shared_ptr<string> regionId{};

  GetAvailabilityMetricRequest() {}

  explicit GetAvailabilityMetricRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appSource) {
      res["AppSource"] = boost::any(*appSource);
    }
    if (cpuStrategy) {
      res["CpuStrategy"] = boost::any(*cpuStrategy);
    }
    if (limit) {
      res["Limit"] = boost::any(*limit);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppSource") != m.end() && !m["AppSource"].empty()) {
      appSource = make_shared<string>(boost::any_cast<string>(m["AppSource"]));
    }
    if (m.find("CpuStrategy") != m.end() && !m["CpuStrategy"].empty()) {
      cpuStrategy = make_shared<string>(boost::any_cast<string>(m["CpuStrategy"]));
    }
    if (m.find("Limit") != m.end() && !m["Limit"].empty()) {
      limit = make_shared<long>(boost::any_cast<long>(m["Limit"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetAvailabilityMetricRequest() = default;
};
class GetAvailabilityMetricResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> enableAutoscale{};
  shared_ptr<long> errorInstances{};
  shared_ptr<long> instances{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<long> runnings{};

  GetAvailabilityMetricResponseBodyData() {}

  explicit GetAvailabilityMetricResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (enableAutoscale) {
      res["EnableAutoscale"] = boost::any(*enableAutoscale);
    }
    if (errorInstances) {
      res["ErrorInstances"] = boost::any(*errorInstances);
    }
    if (instances) {
      res["Instances"] = boost::any(*instances);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (runnings) {
      res["Runnings"] = boost::any(*runnings);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("EnableAutoscale") != m.end() && !m["EnableAutoscale"].empty()) {
      enableAutoscale = make_shared<long>(boost::any_cast<long>(m["EnableAutoscale"]));
    }
    if (m.find("ErrorInstances") != m.end() && !m["ErrorInstances"].empty()) {
      errorInstances = make_shared<long>(boost::any_cast<long>(m["ErrorInstances"]));
    }
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      instances = make_shared<long>(boost::any_cast<long>(m["Instances"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Runnings") != m.end() && !m["Runnings"].empty()) {
      runnings = make_shared<long>(boost::any_cast<long>(m["Runnings"]));
    }
  }


  virtual ~GetAvailabilityMetricResponseBodyData() = default;
};
class GetAvailabilityMetricResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<GetAvailabilityMetricResponseBodyData>> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetAvailabilityMetricResponseBody() {}

  explicit GetAvailabilityMetricResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<GetAvailabilityMetricResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAvailabilityMetricResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<GetAvailabilityMetricResponseBodyData>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetAvailabilityMetricResponseBody() = default;
};
class GetAvailabilityMetricResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAvailabilityMetricResponseBody> body{};

  GetAvailabilityMetricResponse() {}

  explicit GetAvailabilityMetricResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAvailabilityMetricResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAvailabilityMetricResponseBody>(model1);
      }
    }
  }


  virtual ~GetAvailabilityMetricResponse() = default;
};
class GetChangeOrderMetricRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appSource{};
  shared_ptr<string> coType{};
  shared_ptr<string> cpuStrategy{};
  shared_ptr<string> createTime{};
  shared_ptr<long> limit{};
  shared_ptr<string> orderBy{};
  shared_ptr<string> regionId{};

  GetChangeOrderMetricRequest() {}

  explicit GetChangeOrderMetricRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appSource) {
      res["AppSource"] = boost::any(*appSource);
    }
    if (coType) {
      res["CoType"] = boost::any(*coType);
    }
    if (cpuStrategy) {
      res["CpuStrategy"] = boost::any(*cpuStrategy);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (limit) {
      res["Limit"] = boost::any(*limit);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppSource") != m.end() && !m["AppSource"].empty()) {
      appSource = make_shared<string>(boost::any_cast<string>(m["AppSource"]));
    }
    if (m.find("CoType") != m.end() && !m["CoType"].empty()) {
      coType = make_shared<string>(boost::any_cast<string>(m["CoType"]));
    }
    if (m.find("CpuStrategy") != m.end() && !m["CpuStrategy"].empty()) {
      cpuStrategy = make_shared<string>(boost::any_cast<string>(m["CpuStrategy"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Limit") != m.end() && !m["Limit"].empty()) {
      limit = make_shared<long>(boost::any_cast<long>(m["Limit"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetChangeOrderMetricRequest() = default;
};
class GetChangeOrderMetricResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<double> avgTimeCostMs{};
  shared_ptr<long> error{};
  shared_ptr<double> errorPercent{};
  shared_ptr<double> maxTimeCostMs{};
  shared_ptr<string> name{};
  shared_ptr<string> optimizeSuggestions{};
  shared_ptr<string> regionId{};
  shared_ptr<string> taskTimeCostMsAvg{};
  shared_ptr<long> total{};

  GetChangeOrderMetricResponseBodyData() {}

  explicit GetChangeOrderMetricResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (avgTimeCostMs) {
      res["AvgTimeCostMs"] = boost::any(*avgTimeCostMs);
    }
    if (error) {
      res["Error"] = boost::any(*error);
    }
    if (errorPercent) {
      res["ErrorPercent"] = boost::any(*errorPercent);
    }
    if (maxTimeCostMs) {
      res["MaxTimeCostMs"] = boost::any(*maxTimeCostMs);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (optimizeSuggestions) {
      res["OptimizeSuggestions"] = boost::any(*optimizeSuggestions);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskTimeCostMsAvg) {
      res["TaskTimeCostMsAvg"] = boost::any(*taskTimeCostMsAvg);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AvgTimeCostMs") != m.end() && !m["AvgTimeCostMs"].empty()) {
      avgTimeCostMs = make_shared<double>(boost::any_cast<double>(m["AvgTimeCostMs"]));
    }
    if (m.find("Error") != m.end() && !m["Error"].empty()) {
      error = make_shared<long>(boost::any_cast<long>(m["Error"]));
    }
    if (m.find("ErrorPercent") != m.end() && !m["ErrorPercent"].empty()) {
      errorPercent = make_shared<double>(boost::any_cast<double>(m["ErrorPercent"]));
    }
    if (m.find("MaxTimeCostMs") != m.end() && !m["MaxTimeCostMs"].empty()) {
      maxTimeCostMs = make_shared<double>(boost::any_cast<double>(m["MaxTimeCostMs"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OptimizeSuggestions") != m.end() && !m["OptimizeSuggestions"].empty()) {
      optimizeSuggestions = make_shared<string>(boost::any_cast<string>(m["OptimizeSuggestions"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskTimeCostMsAvg") != m.end() && !m["TaskTimeCostMsAvg"].empty()) {
      taskTimeCostMsAvg = make_shared<string>(boost::any_cast<string>(m["TaskTimeCostMsAvg"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetChangeOrderMetricResponseBodyData() = default;
};
class GetChangeOrderMetricResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<GetChangeOrderMetricResponseBodyData>> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetChangeOrderMetricResponseBody() {}

  explicit GetChangeOrderMetricResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<GetChangeOrderMetricResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetChangeOrderMetricResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<GetChangeOrderMetricResponseBodyData>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetChangeOrderMetricResponseBody() = default;
};
class GetChangeOrderMetricResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetChangeOrderMetricResponseBody> body{};

  GetChangeOrderMetricResponse() {}

  explicit GetChangeOrderMetricResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetChangeOrderMetricResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetChangeOrderMetricResponseBody>(model1);
      }
    }
  }


  virtual ~GetChangeOrderMetricResponse() = default;
};
class GetScaleAppMetricRequest : public Darabonba::Model {
public:
  shared_ptr<string> appSource{};
  shared_ptr<string> cpuStrategy{};
  shared_ptr<long> limit{};
  shared_ptr<string> regionId{};

  GetScaleAppMetricRequest() {}

  explicit GetScaleAppMetricRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appSource) {
      res["AppSource"] = boost::any(*appSource);
    }
    if (cpuStrategy) {
      res["CpuStrategy"] = boost::any(*cpuStrategy);
    }
    if (limit) {
      res["Limit"] = boost::any(*limit);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppSource") != m.end() && !m["AppSource"].empty()) {
      appSource = make_shared<string>(boost::any_cast<string>(m["AppSource"]));
    }
    if (m.find("CpuStrategy") != m.end() && !m["CpuStrategy"].empty()) {
      cpuStrategy = make_shared<string>(boost::any_cast<string>(m["CpuStrategy"]));
    }
    if (m.find("Limit") != m.end() && !m["Limit"].empty()) {
      limit = make_shared<long>(boost::any_cast<long>(m["Limit"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetScaleAppMetricRequest() = default;
};
class GetScaleAppMetricResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> maxReplicas{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<long> runnings{};

  GetScaleAppMetricResponseBodyData() {}

  explicit GetScaleAppMetricResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (maxReplicas) {
      res["MaxReplicas"] = boost::any(*maxReplicas);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (runnings) {
      res["Runnings"] = boost::any(*runnings);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("MaxReplicas") != m.end() && !m["MaxReplicas"].empty()) {
      maxReplicas = make_shared<long>(boost::any_cast<long>(m["MaxReplicas"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Runnings") != m.end() && !m["Runnings"].empty()) {
      runnings = make_shared<long>(boost::any_cast<long>(m["Runnings"]));
    }
  }


  virtual ~GetScaleAppMetricResponseBodyData() = default;
};
class GetScaleAppMetricResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<GetScaleAppMetricResponseBodyData>> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetScaleAppMetricResponseBody() {}

  explicit GetScaleAppMetricResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<GetScaleAppMetricResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetScaleAppMetricResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<GetScaleAppMetricResponseBodyData>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetScaleAppMetricResponseBody() = default;
};
class GetScaleAppMetricResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetScaleAppMetricResponseBody> body{};

  GetScaleAppMetricResponse() {}

  explicit GetScaleAppMetricResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetScaleAppMetricResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetScaleAppMetricResponseBody>(model1);
      }
    }
  }


  virtual ~GetScaleAppMetricResponse() = default;
};
class GetWarningEventMetricRequest : public Darabonba::Model {
public:
  shared_ptr<string> appSource{};
  shared_ptr<string> cpuStrategy{};
  shared_ptr<long> endTime{};
  shared_ptr<long> limit{};
  shared_ptr<string> regionId{};
  shared_ptr<long> startTime{};

  GetWarningEventMetricRequest() {}

  explicit GetWarningEventMetricRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appSource) {
      res["AppSource"] = boost::any(*appSource);
    }
    if (cpuStrategy) {
      res["CpuStrategy"] = boost::any(*cpuStrategy);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (limit) {
      res["Limit"] = boost::any(*limit);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppSource") != m.end() && !m["AppSource"].empty()) {
      appSource = make_shared<string>(boost::any_cast<string>(m["AppSource"]));
    }
    if (m.find("CpuStrategy") != m.end() && !m["CpuStrategy"].empty()) {
      cpuStrategy = make_shared<string>(boost::any_cast<string>(m["CpuStrategy"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Limit") != m.end() && !m["Limit"].empty()) {
      limit = make_shared<long>(boost::any_cast<long>(m["Limit"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~GetWarningEventMetricRequest() = default;
};
class GetWarningEventMetricResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<long> warningCount{};

  GetWarningEventMetricResponseBodyData() {}

  explicit GetWarningEventMetricResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (warningCount) {
      res["WarningCount"] = boost::any(*warningCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("WarningCount") != m.end() && !m["WarningCount"].empty()) {
      warningCount = make_shared<long>(boost::any_cast<long>(m["WarningCount"]));
    }
  }


  virtual ~GetWarningEventMetricResponseBodyData() = default;
};
class GetWarningEventMetricResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<GetWarningEventMetricResponseBodyData>> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetWarningEventMetricResponseBody() {}

  explicit GetWarningEventMetricResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<GetWarningEventMetricResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetWarningEventMetricResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<GetWarningEventMetricResponseBodyData>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetWarningEventMetricResponseBody() = default;
};
class GetWarningEventMetricResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetWarningEventMetricResponseBody> body{};

  GetWarningEventMetricResponse() {}

  explicit GetWarningEventMetricResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetWarningEventMetricResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetWarningEventMetricResponseBody>(model1);
      }
    }
  }


  virtual ~GetWarningEventMetricResponse() = default;
};
class GetWebshellTokenRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> containerName{};
  shared_ptr<string> podName{};

  GetWebshellTokenRequest() {}

  explicit GetWebshellTokenRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (containerName) {
      res["ContainerName"] = boost::any(*containerName);
    }
    if (podName) {
      res["PodName"] = boost::any(*podName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ContainerName") != m.end() && !m["ContainerName"].empty()) {
      containerName = make_shared<string>(boost::any_cast<string>(m["ContainerName"]));
    }
    if (m.find("PodName") != m.end() && !m["PodName"].empty()) {
      podName = make_shared<string>(boost::any_cast<string>(m["PodName"]));
    }
  }


  virtual ~GetWebshellTokenRequest() = default;
};
class GetWebshellTokenResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> httpUrl{};
  shared_ptr<string> token{};
  shared_ptr<string> webSocketUrl{};

  GetWebshellTokenResponseBodyData() {}

  explicit GetWebshellTokenResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpUrl) {
      res["HttpUrl"] = boost::any(*httpUrl);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    if (webSocketUrl) {
      res["WebSocketUrl"] = boost::any(*webSocketUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpUrl") != m.end() && !m["HttpUrl"].empty()) {
      httpUrl = make_shared<string>(boost::any_cast<string>(m["HttpUrl"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
    if (m.find("WebSocketUrl") != m.end() && !m["WebSocketUrl"].empty()) {
      webSocketUrl = make_shared<string>(boost::any_cast<string>(m["WebSocketUrl"]));
    }
  }


  virtual ~GetWebshellTokenResponseBodyData() = default;
};
class GetWebshellTokenResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetWebshellTokenResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  GetWebshellTokenResponseBody() {}

  explicit GetWebshellTokenResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetWebshellTokenResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetWebshellTokenResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~GetWebshellTokenResponseBody() = default;
};
class GetWebshellTokenResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetWebshellTokenResponseBody> body{};

  GetWebshellTokenResponse() {}

  explicit GetWebshellTokenResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetWebshellTokenResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetWebshellTokenResponseBody>(model1);
      }
    }
  }


  virtual ~GetWebshellTokenResponse() = default;
};
class ListAllSwimmingLaneGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> namespaceId{};

  ListAllSwimmingLaneGroupsRequest() {}

  explicit ListAllSwimmingLaneGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
  }


  virtual ~ListAllSwimmingLaneGroupsRequest() = default;
};
class ListAllSwimmingLaneGroupsResponseBodyDataApps : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> mseAppId{};
  shared_ptr<string> mseAppName{};
  shared_ptr<string> mseNamespaceId{};

  ListAllSwimmingLaneGroupsResponseBodyDataApps() {}

  explicit ListAllSwimmingLaneGroupsResponseBodyDataApps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (mseAppId) {
      res["MseAppId"] = boost::any(*mseAppId);
    }
    if (mseAppName) {
      res["MseAppName"] = boost::any(*mseAppName);
    }
    if (mseNamespaceId) {
      res["MseNamespaceId"] = boost::any(*mseNamespaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("MseAppId") != m.end() && !m["MseAppId"].empty()) {
      mseAppId = make_shared<string>(boost::any_cast<string>(m["MseAppId"]));
    }
    if (m.find("MseAppName") != m.end() && !m["MseAppName"].empty()) {
      mseAppName = make_shared<string>(boost::any_cast<string>(m["MseAppName"]));
    }
    if (m.find("MseNamespaceId") != m.end() && !m["MseNamespaceId"].empty()) {
      mseNamespaceId = make_shared<string>(boost::any_cast<string>(m["MseNamespaceId"]));
    }
  }


  virtual ~ListAllSwimmingLaneGroupsResponseBodyDataApps() = default;
};
class ListAllSwimmingLaneGroupsResponseBodyDataEntryApp : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> appType{};
  shared_ptr<string> mseAppId{};
  shared_ptr<string> mseAppName{};
  shared_ptr<string> mseNamespaceId{};

  ListAllSwimmingLaneGroupsResponseBodyDataEntryApp() {}

  explicit ListAllSwimmingLaneGroupsResponseBodyDataEntryApp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (mseAppId) {
      res["MseAppId"] = boost::any(*mseAppId);
    }
    if (mseAppName) {
      res["MseAppName"] = boost::any(*mseAppName);
    }
    if (mseNamespaceId) {
      res["MseNamespaceId"] = boost::any(*mseNamespaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("MseAppId") != m.end() && !m["MseAppId"].empty()) {
      mseAppId = make_shared<string>(boost::any_cast<string>(m["MseAppId"]));
    }
    if (m.find("MseAppName") != m.end() && !m["MseAppName"].empty()) {
      mseAppName = make_shared<string>(boost::any_cast<string>(m["MseAppName"]));
    }
    if (m.find("MseNamespaceId") != m.end() && !m["MseNamespaceId"].empty()) {
      mseNamespaceId = make_shared<string>(boost::any_cast<string>(m["MseNamespaceId"]));
    }
  }


  virtual ~ListAllSwimmingLaneGroupsResponseBodyDataEntryApp() = default;
};
class ListAllSwimmingLaneGroupsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<string>> appIds{};
  shared_ptr<vector<ListAllSwimmingLaneGroupsResponseBodyDataApps>> apps{};
  shared_ptr<long> canaryModel{};
  shared_ptr<ListAllSwimmingLaneGroupsResponseBodyDataEntryApp> entryApp{};
  shared_ptr<string> entryAppId{};
  shared_ptr<string> entryAppType{};
  shared_ptr<long> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> mseNamespaceId{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> swimVersion{};

  ListAllSwimmingLaneGroupsResponseBodyData() {}

  explicit ListAllSwimmingLaneGroupsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appIds) {
      res["AppIds"] = boost::any(*appIds);
    }
    if (apps) {
      vector<boost::any> temp1;
      for(auto item1:*apps){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Apps"] = boost::any(temp1);
    }
    if (canaryModel) {
      res["CanaryModel"] = boost::any(*canaryModel);
    }
    if (entryApp) {
      res["EntryApp"] = entryApp ? boost::any(entryApp->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (entryAppId) {
      res["EntryAppId"] = boost::any(*entryAppId);
    }
    if (entryAppType) {
      res["EntryAppType"] = boost::any(*entryAppType);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (mseNamespaceId) {
      res["MseNamespaceId"] = boost::any(*mseNamespaceId);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (swimVersion) {
      res["SwimVersion"] = boost::any(*swimVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppIds") != m.end() && !m["AppIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AppIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AppIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      appIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Apps") != m.end() && !m["Apps"].empty()) {
      if (typeid(vector<boost::any>) == m["Apps"].type()) {
        vector<ListAllSwimmingLaneGroupsResponseBodyDataApps> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Apps"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAllSwimmingLaneGroupsResponseBodyDataApps model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apps = make_shared<vector<ListAllSwimmingLaneGroupsResponseBodyDataApps>>(expect1);
      }
    }
    if (m.find("CanaryModel") != m.end() && !m["CanaryModel"].empty()) {
      canaryModel = make_shared<long>(boost::any_cast<long>(m["CanaryModel"]));
    }
    if (m.find("EntryApp") != m.end() && !m["EntryApp"].empty()) {
      if (typeid(map<string, boost::any>) == m["EntryApp"].type()) {
        ListAllSwimmingLaneGroupsResponseBodyDataEntryApp model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EntryApp"]));
        entryApp = make_shared<ListAllSwimmingLaneGroupsResponseBodyDataEntryApp>(model1);
      }
    }
    if (m.find("EntryAppId") != m.end() && !m["EntryAppId"].empty()) {
      entryAppId = make_shared<string>(boost::any_cast<string>(m["EntryAppId"]));
    }
    if (m.find("EntryAppType") != m.end() && !m["EntryAppType"].empty()) {
      entryAppType = make_shared<string>(boost::any_cast<string>(m["EntryAppType"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("MseNamespaceId") != m.end() && !m["MseNamespaceId"].empty()) {
      mseNamespaceId = make_shared<string>(boost::any_cast<string>(m["MseNamespaceId"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("SwimVersion") != m.end() && !m["SwimVersion"].empty()) {
      swimVersion = make_shared<string>(boost::any_cast<string>(m["SwimVersion"]));
    }
  }


  virtual ~ListAllSwimmingLaneGroupsResponseBodyData() = default;
};
class ListAllSwimmingLaneGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListAllSwimmingLaneGroupsResponseBodyData>> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  ListAllSwimmingLaneGroupsResponseBody() {}

  explicit ListAllSwimmingLaneGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListAllSwimmingLaneGroupsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAllSwimmingLaneGroupsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListAllSwimmingLaneGroupsResponseBodyData>>(expect1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~ListAllSwimmingLaneGroupsResponseBody() = default;
};
class ListAllSwimmingLaneGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAllSwimmingLaneGroupsResponseBody> body{};

  ListAllSwimmingLaneGroupsResponse() {}

  explicit ListAllSwimmingLaneGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAllSwimmingLaneGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAllSwimmingLaneGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~ListAllSwimmingLaneGroupsResponse() = default;
};
class ListAllSwimmingLanesRequest : public Darabonba::Model {
public:
  shared_ptr<long> groupId{};
  shared_ptr<string> namespaceId{};

  ListAllSwimmingLanesRequest() {}

  explicit ListAllSwimmingLanesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
  }


  virtual ~ListAllSwimmingLanesRequest() = default;
};
class ListAllSwimmingLanesResponseBodyDataAppEntryRuleConditions : public Darabonba::Model {
public:
  shared_ptr<string> condition{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};
  shared_ptr<vector<string>> values{};

  ListAllSwimmingLanesResponseBodyDataAppEntryRuleConditions() {}

  explicit ListAllSwimmingLanesResponseBodyDataAppEntryRuleConditions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (condition) {
      res["Condition"] = boost::any(*condition);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (values) {
      res["Values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Condition") != m.end() && !m["Condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["Condition"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Values"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Values"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      values = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListAllSwimmingLanesResponseBodyDataAppEntryRuleConditions() = default;
};
class ListAllSwimmingLanesResponseBodyDataAppEntryRule : public Darabonba::Model {
public:
  shared_ptr<string> conditionJoiner{};
  shared_ptr<vector<ListAllSwimmingLanesResponseBodyDataAppEntryRuleConditions>> conditions{};
  shared_ptr<bool> independentPercentageEnable{};
  shared_ptr<vector<string>> paths{};
  shared_ptr<long> percentage{};
  shared_ptr<map<string, long>> percentageByPath{};

  ListAllSwimmingLanesResponseBodyDataAppEntryRule() {}

  explicit ListAllSwimmingLanesResponseBodyDataAppEntryRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conditionJoiner) {
      res["ConditionJoiner"] = boost::any(*conditionJoiner);
    }
    if (conditions) {
      vector<boost::any> temp1;
      for(auto item1:*conditions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Conditions"] = boost::any(temp1);
    }
    if (independentPercentageEnable) {
      res["IndependentPercentageEnable"] = boost::any(*independentPercentageEnable);
    }
    if (paths) {
      res["Paths"] = boost::any(*paths);
    }
    if (percentage) {
      res["Percentage"] = boost::any(*percentage);
    }
    if (percentageByPath) {
      res["PercentageByPath"] = boost::any(*percentageByPath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConditionJoiner") != m.end() && !m["ConditionJoiner"].empty()) {
      conditionJoiner = make_shared<string>(boost::any_cast<string>(m["ConditionJoiner"]));
    }
    if (m.find("Conditions") != m.end() && !m["Conditions"].empty()) {
      if (typeid(vector<boost::any>) == m["Conditions"].type()) {
        vector<ListAllSwimmingLanesResponseBodyDataAppEntryRuleConditions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Conditions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAllSwimmingLanesResponseBodyDataAppEntryRuleConditions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        conditions = make_shared<vector<ListAllSwimmingLanesResponseBodyDataAppEntryRuleConditions>>(expect1);
      }
    }
    if (m.find("IndependentPercentageEnable") != m.end() && !m["IndependentPercentageEnable"].empty()) {
      independentPercentageEnable = make_shared<bool>(boost::any_cast<bool>(m["IndependentPercentageEnable"]));
    }
    if (m.find("Paths") != m.end() && !m["Paths"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Paths"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Paths"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      paths = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Percentage") != m.end() && !m["Percentage"].empty()) {
      percentage = make_shared<long>(boost::any_cast<long>(m["Percentage"]));
    }
    if (m.find("PercentageByPath") != m.end() && !m["PercentageByPath"].empty()) {
      map<string, long> map1 = boost::any_cast<map<string, long>>(m["PercentageByPath"]);
      map<string, long> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      percentageByPath = make_shared<map<string, long>>(toMap1);
    }
  }


  virtual ~ListAllSwimmingLanesResponseBodyDataAppEntryRule() = default;
};
class ListAllSwimmingLanesResponseBodyDataApps : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> mseAppId{};
  shared_ptr<string> mseAppName{};
  shared_ptr<string> mseNamespaceId{};

  ListAllSwimmingLanesResponseBodyDataApps() {}

  explicit ListAllSwimmingLanesResponseBodyDataApps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (mseAppId) {
      res["MseAppId"] = boost::any(*mseAppId);
    }
    if (mseAppName) {
      res["MseAppName"] = boost::any(*mseAppName);
    }
    if (mseNamespaceId) {
      res["MseNamespaceId"] = boost::any(*mseNamespaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("MseAppId") != m.end() && !m["MseAppId"].empty()) {
      mseAppId = make_shared<string>(boost::any_cast<string>(m["MseAppId"]));
    }
    if (m.find("MseAppName") != m.end() && !m["MseAppName"].empty()) {
      mseAppName = make_shared<string>(boost::any_cast<string>(m["MseAppName"]));
    }
    if (m.find("MseNamespaceId") != m.end() && !m["MseNamespaceId"].empty()) {
      mseNamespaceId = make_shared<string>(boost::any_cast<string>(m["MseNamespaceId"]));
    }
  }


  virtual ~ListAllSwimmingLanesResponseBodyDataApps() = default;
};
class ListAllSwimmingLanesResponseBodyDataMseGatewayEntryRuleConditions : public Darabonba::Model {
public:
  shared_ptr<string> condition{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  ListAllSwimmingLanesResponseBodyDataMseGatewayEntryRuleConditions() {}

  explicit ListAllSwimmingLanesResponseBodyDataMseGatewayEntryRuleConditions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (condition) {
      res["Condition"] = boost::any(*condition);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Condition") != m.end() && !m["Condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["Condition"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListAllSwimmingLanesResponseBodyDataMseGatewayEntryRuleConditions() = default;
};
class ListAllSwimmingLanesResponseBodyDataMseGatewayEntryRuleRoutesRoutePredicatePathPredicate : public Darabonba::Model {
public:
  shared_ptr<string> path{};
  shared_ptr<string> type{};

  ListAllSwimmingLanesResponseBodyDataMseGatewayEntryRuleRoutesRoutePredicatePathPredicate() {}

  explicit ListAllSwimmingLanesResponseBodyDataMseGatewayEntryRuleRoutesRoutePredicatePathPredicate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (path) {
      res["path"] = boost::any(*path);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("path") != m.end() && !m["path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["path"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~ListAllSwimmingLanesResponseBodyDataMseGatewayEntryRuleRoutesRoutePredicatePathPredicate() = default;
};
class ListAllSwimmingLanesResponseBodyDataMseGatewayEntryRuleRoutesRoutePredicate : public Darabonba::Model {
public:
  shared_ptr<ListAllSwimmingLanesResponseBodyDataMseGatewayEntryRuleRoutesRoutePredicatePathPredicate> pathPredicate{};

  ListAllSwimmingLanesResponseBodyDataMseGatewayEntryRuleRoutesRoutePredicate() {}

  explicit ListAllSwimmingLanesResponseBodyDataMseGatewayEntryRuleRoutesRoutePredicate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pathPredicate) {
      res["PathPredicate"] = pathPredicate ? boost::any(pathPredicate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PathPredicate") != m.end() && !m["PathPredicate"].empty()) {
      if (typeid(map<string, boost::any>) == m["PathPredicate"].type()) {
        ListAllSwimmingLanesResponseBodyDataMseGatewayEntryRuleRoutesRoutePredicatePathPredicate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PathPredicate"]));
        pathPredicate = make_shared<ListAllSwimmingLanesResponseBodyDataMseGatewayEntryRuleRoutesRoutePredicatePathPredicate>(model1);
      }
    }
  }


  virtual ~ListAllSwimmingLanesResponseBodyDataMseGatewayEntryRuleRoutesRoutePredicate() = default;
};
class ListAllSwimmingLanesResponseBodyDataMseGatewayEntryRuleRoutes : public Darabonba::Model {
public:
  shared_ptr<long> routeId{};
  shared_ptr<string> routeName{};
  shared_ptr<ListAllSwimmingLanesResponseBodyDataMseGatewayEntryRuleRoutesRoutePredicate> routePredicate{};

  ListAllSwimmingLanesResponseBodyDataMseGatewayEntryRuleRoutes() {}

  explicit ListAllSwimmingLanesResponseBodyDataMseGatewayEntryRuleRoutes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (routeId) {
      res["RouteId"] = boost::any(*routeId);
    }
    if (routeName) {
      res["RouteName"] = boost::any(*routeName);
    }
    if (routePredicate) {
      res["RoutePredicate"] = routePredicate ? boost::any(routePredicate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RouteId") != m.end() && !m["RouteId"].empty()) {
      routeId = make_shared<long>(boost::any_cast<long>(m["RouteId"]));
    }
    if (m.find("RouteName") != m.end() && !m["RouteName"].empty()) {
      routeName = make_shared<string>(boost::any_cast<string>(m["RouteName"]));
    }
    if (m.find("RoutePredicate") != m.end() && !m["RoutePredicate"].empty()) {
      if (typeid(map<string, boost::any>) == m["RoutePredicate"].type()) {
        ListAllSwimmingLanesResponseBodyDataMseGatewayEntryRuleRoutesRoutePredicate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RoutePredicate"]));
        routePredicate = make_shared<ListAllSwimmingLanesResponseBodyDataMseGatewayEntryRuleRoutesRoutePredicate>(model1);
      }
    }
  }


  virtual ~ListAllSwimmingLanesResponseBodyDataMseGatewayEntryRuleRoutes() = default;
};
class ListAllSwimmingLanesResponseBodyDataMseGatewayEntryRule : public Darabonba::Model {
public:
  shared_ptr<string> conditionJoiner{};
  shared_ptr<vector<ListAllSwimmingLanesResponseBodyDataMseGatewayEntryRuleConditions>> conditions{};
  shared_ptr<bool> independentPercentageEnable{};
  shared_ptr<long> percentage{};
  shared_ptr<map<string, long>> percentageByRoute{};
  shared_ptr<vector<long>> routeIds{};
  shared_ptr<vector<ListAllSwimmingLanesResponseBodyDataMseGatewayEntryRuleRoutes>> routes{};

  ListAllSwimmingLanesResponseBodyDataMseGatewayEntryRule() {}

  explicit ListAllSwimmingLanesResponseBodyDataMseGatewayEntryRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conditionJoiner) {
      res["ConditionJoiner"] = boost::any(*conditionJoiner);
    }
    if (conditions) {
      vector<boost::any> temp1;
      for(auto item1:*conditions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Conditions"] = boost::any(temp1);
    }
    if (independentPercentageEnable) {
      res["IndependentPercentageEnable"] = boost::any(*independentPercentageEnable);
    }
    if (percentage) {
      res["Percentage"] = boost::any(*percentage);
    }
    if (percentageByRoute) {
      res["PercentageByRoute"] = boost::any(*percentageByRoute);
    }
    if (routeIds) {
      res["RouteIds"] = boost::any(*routeIds);
    }
    if (routes) {
      vector<boost::any> temp1;
      for(auto item1:*routes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Routes"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConditionJoiner") != m.end() && !m["ConditionJoiner"].empty()) {
      conditionJoiner = make_shared<string>(boost::any_cast<string>(m["ConditionJoiner"]));
    }
    if (m.find("Conditions") != m.end() && !m["Conditions"].empty()) {
      if (typeid(vector<boost::any>) == m["Conditions"].type()) {
        vector<ListAllSwimmingLanesResponseBodyDataMseGatewayEntryRuleConditions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Conditions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAllSwimmingLanesResponseBodyDataMseGatewayEntryRuleConditions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        conditions = make_shared<vector<ListAllSwimmingLanesResponseBodyDataMseGatewayEntryRuleConditions>>(expect1);
      }
    }
    if (m.find("IndependentPercentageEnable") != m.end() && !m["IndependentPercentageEnable"].empty()) {
      independentPercentageEnable = make_shared<bool>(boost::any_cast<bool>(m["IndependentPercentageEnable"]));
    }
    if (m.find("Percentage") != m.end() && !m["Percentage"].empty()) {
      percentage = make_shared<long>(boost::any_cast<long>(m["Percentage"]));
    }
    if (m.find("PercentageByRoute") != m.end() && !m["PercentageByRoute"].empty()) {
      map<string, long> map1 = boost::any_cast<map<string, long>>(m["PercentageByRoute"]);
      map<string, long> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      percentageByRoute = make_shared<map<string, long>>(toMap1);
    }
    if (m.find("RouteIds") != m.end() && !m["RouteIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["RouteIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RouteIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      routeIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Routes") != m.end() && !m["Routes"].empty()) {
      if (typeid(vector<boost::any>) == m["Routes"].type()) {
        vector<ListAllSwimmingLanesResponseBodyDataMseGatewayEntryRuleRoutes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Routes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAllSwimmingLanesResponseBodyDataMseGatewayEntryRuleRoutes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        routes = make_shared<vector<ListAllSwimmingLanesResponseBodyDataMseGatewayEntryRuleRoutes>>(expect1);
      }
    }
  }


  virtual ~ListAllSwimmingLanesResponseBodyDataMseGatewayEntryRule() = default;
};
class ListAllSwimmingLanesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<ListAllSwimmingLanesResponseBodyDataAppEntryRule> appEntryRule{};
  shared_ptr<vector<ListAllSwimmingLanesResponseBodyDataApps>> apps{};
  shared_ptr<long> canaryModel{};
  shared_ptr<bool> enable{};
  shared_ptr<bool> enableRules{};
  shared_ptr<long> laneId{};
  shared_ptr<string> laneName{};
  shared_ptr<string> laneTag{};
  shared_ptr<ListAllSwimmingLanesResponseBodyDataMseGatewayEntryRule> mseGatewayEntryRule{};

  ListAllSwimmingLanesResponseBodyData() {}

  explicit ListAllSwimmingLanesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appEntryRule) {
      res["AppEntryRule"] = appEntryRule ? boost::any(appEntryRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (apps) {
      vector<boost::any> temp1;
      for(auto item1:*apps){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Apps"] = boost::any(temp1);
    }
    if (canaryModel) {
      res["CanaryModel"] = boost::any(*canaryModel);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (enableRules) {
      res["EnableRules"] = boost::any(*enableRules);
    }
    if (laneId) {
      res["LaneId"] = boost::any(*laneId);
    }
    if (laneName) {
      res["LaneName"] = boost::any(*laneName);
    }
    if (laneTag) {
      res["LaneTag"] = boost::any(*laneTag);
    }
    if (mseGatewayEntryRule) {
      res["MseGatewayEntryRule"] = mseGatewayEntryRule ? boost::any(mseGatewayEntryRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppEntryRule") != m.end() && !m["AppEntryRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["AppEntryRule"].type()) {
        ListAllSwimmingLanesResponseBodyDataAppEntryRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AppEntryRule"]));
        appEntryRule = make_shared<ListAllSwimmingLanesResponseBodyDataAppEntryRule>(model1);
      }
    }
    if (m.find("Apps") != m.end() && !m["Apps"].empty()) {
      if (typeid(vector<boost::any>) == m["Apps"].type()) {
        vector<ListAllSwimmingLanesResponseBodyDataApps> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Apps"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAllSwimmingLanesResponseBodyDataApps model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apps = make_shared<vector<ListAllSwimmingLanesResponseBodyDataApps>>(expect1);
      }
    }
    if (m.find("CanaryModel") != m.end() && !m["CanaryModel"].empty()) {
      canaryModel = make_shared<long>(boost::any_cast<long>(m["CanaryModel"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("EnableRules") != m.end() && !m["EnableRules"].empty()) {
      enableRules = make_shared<bool>(boost::any_cast<bool>(m["EnableRules"]));
    }
    if (m.find("LaneId") != m.end() && !m["LaneId"].empty()) {
      laneId = make_shared<long>(boost::any_cast<long>(m["LaneId"]));
    }
    if (m.find("LaneName") != m.end() && !m["LaneName"].empty()) {
      laneName = make_shared<string>(boost::any_cast<string>(m["LaneName"]));
    }
    if (m.find("LaneTag") != m.end() && !m["LaneTag"].empty()) {
      laneTag = make_shared<string>(boost::any_cast<string>(m["LaneTag"]));
    }
    if (m.find("MseGatewayEntryRule") != m.end() && !m["MseGatewayEntryRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["MseGatewayEntryRule"].type()) {
        ListAllSwimmingLanesResponseBodyDataMseGatewayEntryRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MseGatewayEntryRule"]));
        mseGatewayEntryRule = make_shared<ListAllSwimmingLanesResponseBodyDataMseGatewayEntryRule>(model1);
      }
    }
  }


  virtual ~ListAllSwimmingLanesResponseBodyData() = default;
};
class ListAllSwimmingLanesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListAllSwimmingLanesResponseBodyData>> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  ListAllSwimmingLanesResponseBody() {}

  explicit ListAllSwimmingLanesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListAllSwimmingLanesResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAllSwimmingLanesResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListAllSwimmingLanesResponseBodyData>>(expect1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~ListAllSwimmingLanesResponseBody() = default;
};
class ListAllSwimmingLanesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAllSwimmingLanesResponseBody> body{};

  ListAllSwimmingLanesResponse() {}

  explicit ListAllSwimmingLanesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAllSwimmingLanesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAllSwimmingLanesResponseBody>(model1);
      }
    }
  }


  virtual ~ListAllSwimmingLanesResponse() = default;
};
class ListAppEventsRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> eventType{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> objectKind{};
  shared_ptr<string> objectName{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> reason{};

  ListAppEventsRequest() {}

  explicit ListAppEventsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (objectKind) {
      res["ObjectKind"] = boost::any(*objectKind);
    }
    if (objectName) {
      res["ObjectName"] = boost::any(*objectName);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("ObjectKind") != m.end() && !m["ObjectKind"].empty()) {
      objectKind = make_shared<string>(boost::any_cast<string>(m["ObjectKind"]));
    }
    if (m.find("ObjectName") != m.end() && !m["ObjectName"].empty()) {
      objectName = make_shared<string>(boost::any_cast<string>(m["ObjectName"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
  }


  virtual ~ListAppEventsRequest() = default;
};
class ListAppEventsResponseBodyDataAppEventEntity : public Darabonba::Model {
public:
  shared_ptr<string> eventType{};
  shared_ptr<string> firstTimestamp{};
  shared_ptr<string> lastTimestamp{};
  shared_ptr<string> message{};
  shared_ptr<string> objectKind{};
  shared_ptr<string> objectName{};
  shared_ptr<string> reason{};

  ListAppEventsResponseBodyDataAppEventEntity() {}

  explicit ListAppEventsResponseBodyDataAppEventEntity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (firstTimestamp) {
      res["FirstTimestamp"] = boost::any(*firstTimestamp);
    }
    if (lastTimestamp) {
      res["LastTimestamp"] = boost::any(*lastTimestamp);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (objectKind) {
      res["ObjectKind"] = boost::any(*objectKind);
    }
    if (objectName) {
      res["ObjectName"] = boost::any(*objectName);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("FirstTimestamp") != m.end() && !m["FirstTimestamp"].empty()) {
      firstTimestamp = make_shared<string>(boost::any_cast<string>(m["FirstTimestamp"]));
    }
    if (m.find("LastTimestamp") != m.end() && !m["LastTimestamp"].empty()) {
      lastTimestamp = make_shared<string>(boost::any_cast<string>(m["LastTimestamp"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("ObjectKind") != m.end() && !m["ObjectKind"].empty()) {
      objectKind = make_shared<string>(boost::any_cast<string>(m["ObjectKind"]));
    }
    if (m.find("ObjectName") != m.end() && !m["ObjectName"].empty()) {
      objectName = make_shared<string>(boost::any_cast<string>(m["ObjectName"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
  }


  virtual ~ListAppEventsResponseBodyDataAppEventEntity() = default;
};
class ListAppEventsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListAppEventsResponseBodyDataAppEventEntity>> appEventEntity{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalSize{};

  ListAppEventsResponseBodyData() {}

  explicit ListAppEventsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appEventEntity) {
      vector<boost::any> temp1;
      for(auto item1:*appEventEntity){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AppEventEntity"] = boost::any(temp1);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppEventEntity") != m.end() && !m["AppEventEntity"].empty()) {
      if (typeid(vector<boost::any>) == m["AppEventEntity"].type()) {
        vector<ListAppEventsResponseBodyDataAppEventEntity> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AppEventEntity"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAppEventsResponseBodyDataAppEventEntity model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        appEventEntity = make_shared<vector<ListAppEventsResponseBodyDataAppEventEntity>>(expect1);
      }
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
  }


  virtual ~ListAppEventsResponseBodyData() = default;
};
class ListAppEventsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListAppEventsResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListAppEventsResponseBody() {}

  explicit ListAppEventsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListAppEventsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListAppEventsResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListAppEventsResponseBody() = default;
};
class ListAppEventsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAppEventsResponseBody> body{};

  ListAppEventsResponse() {}

  explicit ListAppEventsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAppEventsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAppEventsResponseBody>(model1);
      }
    }
  }


  virtual ~ListAppEventsResponse() = default;
};
class ListAppServicesRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> nacosInstanceId{};
  shared_ptr<string> nacosNamespaceId{};
  shared_ptr<string> namespaceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> registryType{};
  shared_ptr<string> serviceType{};
  shared_ptr<string> vpcId{};

  ListAppServicesRequest() {}

  explicit ListAppServicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (nacosInstanceId) {
      res["NacosInstanceId"] = boost::any(*nacosInstanceId);
    }
    if (nacosNamespaceId) {
      res["NacosNamespaceId"] = boost::any(*nacosNamespaceId);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (registryType) {
      res["RegistryType"] = boost::any(*registryType);
    }
    if (serviceType) {
      res["ServiceType"] = boost::any(*serviceType);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("NacosInstanceId") != m.end() && !m["NacosInstanceId"].empty()) {
      nacosInstanceId = make_shared<string>(boost::any_cast<string>(m["NacosInstanceId"]));
    }
    if (m.find("NacosNamespaceId") != m.end() && !m["NacosNamespaceId"].empty()) {
      nacosNamespaceId = make_shared<string>(boost::any_cast<string>(m["NacosNamespaceId"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegistryType") != m.end() && !m["RegistryType"].empty()) {
      registryType = make_shared<string>(boost::any_cast<string>(m["RegistryType"]));
    }
    if (m.find("ServiceType") != m.end() && !m["ServiceType"].empty()) {
      serviceType = make_shared<string>(boost::any_cast<string>(m["ServiceType"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~ListAppServicesRequest() = default;
};
class ListAppServicesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> instanceCount{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> namespaceName{};
  shared_ptr<string> registryType{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> serviceGroup{};
  shared_ptr<string> serviceName{};
  shared_ptr<map<string, string>> servicePortAndProtocol{};
  shared_ptr<vector<long>> servicePorts{};
  shared_ptr<string> serviceProtocol{};
  shared_ptr<string> serviceType{};
  shared_ptr<string> serviceVersion{};

  ListAppServicesResponseBodyData() {}

  explicit ListAppServicesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (instanceCount) {
      res["InstanceCount"] = boost::any(*instanceCount);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (namespaceName) {
      res["NamespaceName"] = boost::any(*namespaceName);
    }
    if (registryType) {
      res["RegistryType"] = boost::any(*registryType);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (serviceGroup) {
      res["ServiceGroup"] = boost::any(*serviceGroup);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (servicePortAndProtocol) {
      res["ServicePortAndProtocol"] = boost::any(*servicePortAndProtocol);
    }
    if (servicePorts) {
      res["ServicePorts"] = boost::any(*servicePorts);
    }
    if (serviceProtocol) {
      res["ServiceProtocol"] = boost::any(*serviceProtocol);
    }
    if (serviceType) {
      res["ServiceType"] = boost::any(*serviceType);
    }
    if (serviceVersion) {
      res["ServiceVersion"] = boost::any(*serviceVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("InstanceCount") != m.end() && !m["InstanceCount"].empty()) {
      instanceCount = make_shared<string>(boost::any_cast<string>(m["InstanceCount"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("NamespaceName") != m.end() && !m["NamespaceName"].empty()) {
      namespaceName = make_shared<string>(boost::any_cast<string>(m["NamespaceName"]));
    }
    if (m.find("RegistryType") != m.end() && !m["RegistryType"].empty()) {
      registryType = make_shared<string>(boost::any_cast<string>(m["RegistryType"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("ServiceGroup") != m.end() && !m["ServiceGroup"].empty()) {
      serviceGroup = make_shared<string>(boost::any_cast<string>(m["ServiceGroup"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("ServicePortAndProtocol") != m.end() && !m["ServicePortAndProtocol"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ServicePortAndProtocol"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      servicePortAndProtocol = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ServicePorts") != m.end() && !m["ServicePorts"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["ServicePorts"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ServicePorts"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      servicePorts = make_shared<vector<long>>(toVec1);
    }
    if (m.find("ServiceProtocol") != m.end() && !m["ServiceProtocol"].empty()) {
      serviceProtocol = make_shared<string>(boost::any_cast<string>(m["ServiceProtocol"]));
    }
    if (m.find("ServiceType") != m.end() && !m["ServiceType"].empty()) {
      serviceType = make_shared<string>(boost::any_cast<string>(m["ServiceType"]));
    }
    if (m.find("ServiceVersion") != m.end() && !m["ServiceVersion"].empty()) {
      serviceVersion = make_shared<string>(boost::any_cast<string>(m["ServiceVersion"]));
    }
  }


  virtual ~ListAppServicesResponseBodyData() = default;
};
class ListAppServicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListAppServicesResponseBodyData>> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  ListAppServicesResponseBody() {}

  explicit ListAppServicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListAppServicesResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAppServicesResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListAppServicesResponseBodyData>>(expect1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~ListAppServicesResponseBody() = default;
};
class ListAppServicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAppServicesResponseBody> body{};

  ListAppServicesResponse() {}

  explicit ListAppServicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAppServicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAppServicesResponseBody>(model1);
      }
    }
  }


  virtual ~ListAppServicesResponse() = default;
};
class ListAppServicesPageRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> serviceType{};

  ListAppServicesPageRequest() {}

  explicit ListAppServicesPageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (serviceType) {
      res["ServiceType"] = boost::any(*serviceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ServiceType") != m.end() && !m["ServiceType"].empty()) {
      serviceType = make_shared<string>(boost::any_cast<string>(m["ServiceType"]));
    }
  }


  virtual ~ListAppServicesPageRequest() = default;
};
class ListAppServicesPageResponseBodyDataResult : public Darabonba::Model {
public:
  shared_ptr<string> edasAppId{};
  shared_ptr<string> edasAppName{};
  shared_ptr<string> group{};
  shared_ptr<long> instanceNum{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> version{};

  ListAppServicesPageResponseBodyDataResult() {}

  explicit ListAppServicesPageResponseBodyDataResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (edasAppId) {
      res["EdasAppId"] = boost::any(*edasAppId);
    }
    if (edasAppName) {
      res["EdasAppName"] = boost::any(*edasAppName);
    }
    if (group) {
      res["Group"] = boost::any(*group);
    }
    if (instanceNum) {
      res["InstanceNum"] = boost::any(*instanceNum);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EdasAppId") != m.end() && !m["EdasAppId"].empty()) {
      edasAppId = make_shared<string>(boost::any_cast<string>(m["EdasAppId"]));
    }
    if (m.find("EdasAppName") != m.end() && !m["EdasAppName"].empty()) {
      edasAppName = make_shared<string>(boost::any_cast<string>(m["EdasAppName"]));
    }
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["Group"]));
    }
    if (m.find("InstanceNum") != m.end() && !m["InstanceNum"].empty()) {
      instanceNum = make_shared<long>(boost::any_cast<long>(m["InstanceNum"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~ListAppServicesPageResponseBodyDataResult() = default;
};
class ListAppServicesPageResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> currentPage{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<vector<ListAppServicesPageResponseBodyDataResult>> result{};
  shared_ptr<string> totalSize{};

  ListAppServicesPageResponseBodyData() {}

  explicit ListAppServicesPageResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<string>(boost::any_cast<string>(m["CurrentPage"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<ListAppServicesPageResponseBodyDataResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAppServicesPageResponseBodyDataResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListAppServicesPageResponseBodyDataResult>>(expect1);
      }
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<string>(boost::any_cast<string>(m["TotalSize"]));
    }
  }


  virtual ~ListAppServicesPageResponseBodyData() = default;
};
class ListAppServicesPageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListAppServicesPageResponseBodyData>> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  ListAppServicesPageResponseBody() {}

  explicit ListAppServicesPageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListAppServicesPageResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAppServicesPageResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListAppServicesPageResponseBodyData>>(expect1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~ListAppServicesPageResponseBody() = default;
};
class ListAppServicesPageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAppServicesPageResponseBody> body{};

  ListAppServicesPageResponse() {}

  explicit ListAppServicesPageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAppServicesPageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAppServicesPageResponseBody>(model1);
      }
    }
  }


  virtual ~ListAppServicesPageResponse() = default;
};
class ListAppVersionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  ListAppVersionsRequest() {}

  explicit ListAppVersionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~ListAppVersionsRequest() = default;
};
class ListAppVersionsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> buildPackageUrl{};
  shared_ptr<string> createTime{};
  shared_ptr<string> id{};
  shared_ptr<string> type{};
  shared_ptr<string> warUrl{};

  ListAppVersionsResponseBodyData() {}

  explicit ListAppVersionsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (buildPackageUrl) {
      res["BuildPackageUrl"] = boost::any(*buildPackageUrl);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (warUrl) {
      res["WarUrl"] = boost::any(*warUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BuildPackageUrl") != m.end() && !m["BuildPackageUrl"].empty()) {
      buildPackageUrl = make_shared<string>(boost::any_cast<string>(m["BuildPackageUrl"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WarUrl") != m.end() && !m["WarUrl"].empty()) {
      warUrl = make_shared<string>(boost::any_cast<string>(m["WarUrl"]));
    }
  }


  virtual ~ListAppVersionsResponseBodyData() = default;
};
class ListAppVersionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListAppVersionsResponseBodyData>> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListAppVersionsResponseBody() {}

  explicit ListAppVersionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListAppVersionsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAppVersionsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListAppVersionsResponseBodyData>>(expect1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListAppVersionsResponseBody() = default;
};
class ListAppVersionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAppVersionsResponseBody> body{};

  ListAppVersionsResponse() {}

  explicit ListAppVersionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAppVersionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAppVersionsResponseBody>(model1);
      }
    }
  }


  virtual ~ListAppVersionsResponse() = default;
};
class ListApplicationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> appSource{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> fieldType{};
  shared_ptr<string> fieldValue{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> orderBy{};
  shared_ptr<long> pageSize{};
  shared_ptr<bool> reverse{};
  shared_ptr<string> tags{};

  ListApplicationsRequest() {}

  explicit ListApplicationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (appSource) {
      res["AppSource"] = boost::any(*appSource);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (fieldType) {
      res["FieldType"] = boost::any(*fieldType);
    }
    if (fieldValue) {
      res["FieldValue"] = boost::any(*fieldValue);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (reverse) {
      res["Reverse"] = boost::any(*reverse);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AppSource") != m.end() && !m["AppSource"].empty()) {
      appSource = make_shared<string>(boost::any_cast<string>(m["AppSource"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("FieldType") != m.end() && !m["FieldType"].empty()) {
      fieldType = make_shared<string>(boost::any_cast<string>(m["FieldType"]));
    }
    if (m.find("FieldValue") != m.end() && !m["FieldValue"].empty()) {
      fieldValue = make_shared<string>(boost::any_cast<string>(m["FieldValue"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Reverse") != m.end() && !m["Reverse"].empty()) {
      reverse = make_shared<bool>(boost::any_cast<bool>(m["Reverse"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
  }


  virtual ~ListApplicationsRequest() = default;
};
class ListApplicationsResponseBodyDataApplicationsChildrenTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListApplicationsResponseBodyDataApplicationsChildrenTags() {}

  explicit ListApplicationsResponseBodyDataApplicationsChildrenTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListApplicationsResponseBodyDataApplicationsChildrenTags() = default;
};
class ListApplicationsResponseBodyDataApplicationsChildren : public Darabonba::Model {
public:
  shared_ptr<bool> appDeletingStatus{};
  shared_ptr<string> appDescription{};
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> appType{};
  shared_ptr<string> baseAppId{};
  shared_ptr<long> cpu{};
  shared_ptr<long> instances{};
  shared_ptr<long> mem{};
  shared_ptr<bool> mseEnabled{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> namespaceName{};
  shared_ptr<string> newSaeVersion{};
  shared_ptr<string> programmingLanguage{};
  shared_ptr<string> regionId{};
  shared_ptr<long> runningInstances{};
  shared_ptr<bool> scaleRuleEnabled{};
  shared_ptr<string> scaleRuleType{};
  shared_ptr<vector<ListApplicationsResponseBodyDataApplicationsChildrenTags>> tags{};

  ListApplicationsResponseBodyDataApplicationsChildren() {}

  explicit ListApplicationsResponseBodyDataApplicationsChildren(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appDeletingStatus) {
      res["AppDeletingStatus"] = boost::any(*appDeletingStatus);
    }
    if (appDescription) {
      res["AppDescription"] = boost::any(*appDescription);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (baseAppId) {
      res["BaseAppId"] = boost::any(*baseAppId);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (instances) {
      res["Instances"] = boost::any(*instances);
    }
    if (mem) {
      res["Mem"] = boost::any(*mem);
    }
    if (mseEnabled) {
      res["MseEnabled"] = boost::any(*mseEnabled);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (namespaceName) {
      res["NamespaceName"] = boost::any(*namespaceName);
    }
    if (newSaeVersion) {
      res["NewSaeVersion"] = boost::any(*newSaeVersion);
    }
    if (programmingLanguage) {
      res["ProgrammingLanguage"] = boost::any(*programmingLanguage);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (runningInstances) {
      res["RunningInstances"] = boost::any(*runningInstances);
    }
    if (scaleRuleEnabled) {
      res["ScaleRuleEnabled"] = boost::any(*scaleRuleEnabled);
    }
    if (scaleRuleType) {
      res["ScaleRuleType"] = boost::any(*scaleRuleType);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppDeletingStatus") != m.end() && !m["AppDeletingStatus"].empty()) {
      appDeletingStatus = make_shared<bool>(boost::any_cast<bool>(m["AppDeletingStatus"]));
    }
    if (m.find("AppDescription") != m.end() && !m["AppDescription"].empty()) {
      appDescription = make_shared<string>(boost::any_cast<string>(m["AppDescription"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("BaseAppId") != m.end() && !m["BaseAppId"].empty()) {
      baseAppId = make_shared<string>(boost::any_cast<string>(m["BaseAppId"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      instances = make_shared<long>(boost::any_cast<long>(m["Instances"]));
    }
    if (m.find("Mem") != m.end() && !m["Mem"].empty()) {
      mem = make_shared<long>(boost::any_cast<long>(m["Mem"]));
    }
    if (m.find("MseEnabled") != m.end() && !m["MseEnabled"].empty()) {
      mseEnabled = make_shared<bool>(boost::any_cast<bool>(m["MseEnabled"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("NamespaceName") != m.end() && !m["NamespaceName"].empty()) {
      namespaceName = make_shared<string>(boost::any_cast<string>(m["NamespaceName"]));
    }
    if (m.find("NewSaeVersion") != m.end() && !m["NewSaeVersion"].empty()) {
      newSaeVersion = make_shared<string>(boost::any_cast<string>(m["NewSaeVersion"]));
    }
    if (m.find("ProgrammingLanguage") != m.end() && !m["ProgrammingLanguage"].empty()) {
      programmingLanguage = make_shared<string>(boost::any_cast<string>(m["ProgrammingLanguage"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RunningInstances") != m.end() && !m["RunningInstances"].empty()) {
      runningInstances = make_shared<long>(boost::any_cast<long>(m["RunningInstances"]));
    }
    if (m.find("ScaleRuleEnabled") != m.end() && !m["ScaleRuleEnabled"].empty()) {
      scaleRuleEnabled = make_shared<bool>(boost::any_cast<bool>(m["ScaleRuleEnabled"]));
    }
    if (m.find("ScaleRuleType") != m.end() && !m["ScaleRuleType"].empty()) {
      scaleRuleType = make_shared<string>(boost::any_cast<string>(m["ScaleRuleType"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListApplicationsResponseBodyDataApplicationsChildrenTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListApplicationsResponseBodyDataApplicationsChildrenTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListApplicationsResponseBodyDataApplicationsChildrenTags>>(expect1);
      }
    }
  }


  virtual ~ListApplicationsResponseBodyDataApplicationsChildren() = default;
};
class ListApplicationsResponseBodyDataApplicationsTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListApplicationsResponseBodyDataApplicationsTags() {}

  explicit ListApplicationsResponseBodyDataApplicationsTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListApplicationsResponseBodyDataApplicationsTags() = default;
};
class ListApplicationsResponseBodyDataApplications : public Darabonba::Model {
public:
  shared_ptr<bool> appDeletingStatus{};
  shared_ptr<string> appDescription{};
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> appType{};
  shared_ptr<string> baseAppId{};
  shared_ptr<vector<ListApplicationsResponseBodyDataApplicationsChildren>> children{};
  shared_ptr<long> cpu{};
  shared_ptr<long> diskSize{};
  shared_ptr<string> enableIdle{};
  shared_ptr<string> imageUrl{};
  shared_ptr<long> instances{};
  shared_ptr<long> mem{};
  shared_ptr<bool> mseEnabled{};
  shared_ptr<string> mseNamespaceId{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> namespaceName{};
  shared_ptr<string> newSaeVersion{};
  shared_ptr<string> packageUrl{};
  shared_ptr<string> programmingLanguage{};
  shared_ptr<string> regionId{};
  shared_ptr<long> runningInstances{};
  shared_ptr<vector<ListApplicationsResponseBodyDataApplicationsTags>> tags{};

  ListApplicationsResponseBodyDataApplications() {}

  explicit ListApplicationsResponseBodyDataApplications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appDeletingStatus) {
      res["AppDeletingStatus"] = boost::any(*appDeletingStatus);
    }
    if (appDescription) {
      res["AppDescription"] = boost::any(*appDescription);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (baseAppId) {
      res["BaseAppId"] = boost::any(*baseAppId);
    }
    if (children) {
      vector<boost::any> temp1;
      for(auto item1:*children){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Children"] = boost::any(temp1);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (diskSize) {
      res["DiskSize"] = boost::any(*diskSize);
    }
    if (enableIdle) {
      res["EnableIdle"] = boost::any(*enableIdle);
    }
    if (imageUrl) {
      res["ImageUrl"] = boost::any(*imageUrl);
    }
    if (instances) {
      res["Instances"] = boost::any(*instances);
    }
    if (mem) {
      res["Mem"] = boost::any(*mem);
    }
    if (mseEnabled) {
      res["MseEnabled"] = boost::any(*mseEnabled);
    }
    if (mseNamespaceId) {
      res["MseNamespaceId"] = boost::any(*mseNamespaceId);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (namespaceName) {
      res["NamespaceName"] = boost::any(*namespaceName);
    }
    if (newSaeVersion) {
      res["NewSaeVersion"] = boost::any(*newSaeVersion);
    }
    if (packageUrl) {
      res["PackageUrl"] = boost::any(*packageUrl);
    }
    if (programmingLanguage) {
      res["ProgrammingLanguage"] = boost::any(*programmingLanguage);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (runningInstances) {
      res["RunningInstances"] = boost::any(*runningInstances);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppDeletingStatus") != m.end() && !m["AppDeletingStatus"].empty()) {
      appDeletingStatus = make_shared<bool>(boost::any_cast<bool>(m["AppDeletingStatus"]));
    }
    if (m.find("AppDescription") != m.end() && !m["AppDescription"].empty()) {
      appDescription = make_shared<string>(boost::any_cast<string>(m["AppDescription"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("BaseAppId") != m.end() && !m["BaseAppId"].empty()) {
      baseAppId = make_shared<string>(boost::any_cast<string>(m["BaseAppId"]));
    }
    if (m.find("Children") != m.end() && !m["Children"].empty()) {
      if (typeid(vector<boost::any>) == m["Children"].type()) {
        vector<ListApplicationsResponseBodyDataApplicationsChildren> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Children"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListApplicationsResponseBodyDataApplicationsChildren model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        children = make_shared<vector<ListApplicationsResponseBodyDataApplicationsChildren>>(expect1);
      }
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("DiskSize") != m.end() && !m["DiskSize"].empty()) {
      diskSize = make_shared<long>(boost::any_cast<long>(m["DiskSize"]));
    }
    if (m.find("EnableIdle") != m.end() && !m["EnableIdle"].empty()) {
      enableIdle = make_shared<string>(boost::any_cast<string>(m["EnableIdle"]));
    }
    if (m.find("ImageUrl") != m.end() && !m["ImageUrl"].empty()) {
      imageUrl = make_shared<string>(boost::any_cast<string>(m["ImageUrl"]));
    }
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      instances = make_shared<long>(boost::any_cast<long>(m["Instances"]));
    }
    if (m.find("Mem") != m.end() && !m["Mem"].empty()) {
      mem = make_shared<long>(boost::any_cast<long>(m["Mem"]));
    }
    if (m.find("MseEnabled") != m.end() && !m["MseEnabled"].empty()) {
      mseEnabled = make_shared<bool>(boost::any_cast<bool>(m["MseEnabled"]));
    }
    if (m.find("MseNamespaceId") != m.end() && !m["MseNamespaceId"].empty()) {
      mseNamespaceId = make_shared<string>(boost::any_cast<string>(m["MseNamespaceId"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("NamespaceName") != m.end() && !m["NamespaceName"].empty()) {
      namespaceName = make_shared<string>(boost::any_cast<string>(m["NamespaceName"]));
    }
    if (m.find("NewSaeVersion") != m.end() && !m["NewSaeVersion"].empty()) {
      newSaeVersion = make_shared<string>(boost::any_cast<string>(m["NewSaeVersion"]));
    }
    if (m.find("PackageUrl") != m.end() && !m["PackageUrl"].empty()) {
      packageUrl = make_shared<string>(boost::any_cast<string>(m["PackageUrl"]));
    }
    if (m.find("ProgrammingLanguage") != m.end() && !m["ProgrammingLanguage"].empty()) {
      programmingLanguage = make_shared<string>(boost::any_cast<string>(m["ProgrammingLanguage"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RunningInstances") != m.end() && !m["RunningInstances"].empty()) {
      runningInstances = make_shared<long>(boost::any_cast<long>(m["RunningInstances"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListApplicationsResponseBodyDataApplicationsTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListApplicationsResponseBodyDataApplicationsTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListApplicationsResponseBodyDataApplicationsTags>>(expect1);
      }
    }
  }


  virtual ~ListApplicationsResponseBodyDataApplications() = default;
};
class ListApplicationsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListApplicationsResponseBodyDataApplications>> applications{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalSize{};

  ListApplicationsResponseBodyData() {}

  explicit ListApplicationsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applications) {
      vector<boost::any> temp1;
      for(auto item1:*applications){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Applications"] = boost::any(temp1);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Applications") != m.end() && !m["Applications"].empty()) {
      if (typeid(vector<boost::any>) == m["Applications"].type()) {
        vector<ListApplicationsResponseBodyDataApplications> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Applications"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListApplicationsResponseBodyDataApplications model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        applications = make_shared<vector<ListApplicationsResponseBodyDataApplications>>(expect1);
      }
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
  }


  virtual ~ListApplicationsResponseBodyData() = default;
};
class ListApplicationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> currentPage{};
  shared_ptr<ListApplicationsResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalSize{};

  ListApplicationsResponseBody() {}

  explicit ListApplicationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListApplicationsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListApplicationsResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
  }


  virtual ~ListApplicationsResponseBody() = default;
};
class ListApplicationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListApplicationsResponseBody> body{};

  ListApplicationsResponse() {}

  explicit ListApplicationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListApplicationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListApplicationsResponseBody>(model1);
      }
    }
  }


  virtual ~ListApplicationsResponse() = default;
};
class ListApplicationsForSwimmingLaneRequest : public Darabonba::Model {
public:
  shared_ptr<long> groupId{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> tag{};

  ListApplicationsForSwimmingLaneRequest() {}

  explicit ListApplicationsForSwimmingLaneRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
  }


  virtual ~ListApplicationsForSwimmingLaneRequest() = default;
};
class ListApplicationsForSwimmingLaneResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> baseAppId{};
  shared_ptr<string> baseAppName{};
  shared_ptr<string> mseAppId{};
  shared_ptr<string> mseAppName{};
  shared_ptr<string> mseNamespaceId{};
  shared_ptr<map<string, string>> serviceTags{};

  ListApplicationsForSwimmingLaneResponseBodyData() {}

  explicit ListApplicationsForSwimmingLaneResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (baseAppId) {
      res["BaseAppId"] = boost::any(*baseAppId);
    }
    if (baseAppName) {
      res["BaseAppName"] = boost::any(*baseAppName);
    }
    if (mseAppId) {
      res["MseAppId"] = boost::any(*mseAppId);
    }
    if (mseAppName) {
      res["MseAppName"] = boost::any(*mseAppName);
    }
    if (mseNamespaceId) {
      res["MseNamespaceId"] = boost::any(*mseNamespaceId);
    }
    if (serviceTags) {
      res["ServiceTags"] = boost::any(*serviceTags);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("BaseAppId") != m.end() && !m["BaseAppId"].empty()) {
      baseAppId = make_shared<string>(boost::any_cast<string>(m["BaseAppId"]));
    }
    if (m.find("BaseAppName") != m.end() && !m["BaseAppName"].empty()) {
      baseAppName = make_shared<string>(boost::any_cast<string>(m["BaseAppName"]));
    }
    if (m.find("MseAppId") != m.end() && !m["MseAppId"].empty()) {
      mseAppId = make_shared<string>(boost::any_cast<string>(m["MseAppId"]));
    }
    if (m.find("MseAppName") != m.end() && !m["MseAppName"].empty()) {
      mseAppName = make_shared<string>(boost::any_cast<string>(m["MseAppName"]));
    }
    if (m.find("MseNamespaceId") != m.end() && !m["MseNamespaceId"].empty()) {
      mseNamespaceId = make_shared<string>(boost::any_cast<string>(m["MseNamespaceId"]));
    }
    if (m.find("ServiceTags") != m.end() && !m["ServiceTags"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ServiceTags"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      serviceTags = make_shared<map<string, string>>(toMap1);
    }
  }


  virtual ~ListApplicationsForSwimmingLaneResponseBodyData() = default;
};
class ListApplicationsForSwimmingLaneResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListApplicationsForSwimmingLaneResponseBodyData>> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListApplicationsForSwimmingLaneResponseBody() {}

  explicit ListApplicationsForSwimmingLaneResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListApplicationsForSwimmingLaneResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListApplicationsForSwimmingLaneResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListApplicationsForSwimmingLaneResponseBodyData>>(expect1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListApplicationsForSwimmingLaneResponseBody() = default;
};
class ListApplicationsForSwimmingLaneResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListApplicationsForSwimmingLaneResponseBody> body{};

  ListApplicationsForSwimmingLaneResponse() {}

  explicit ListApplicationsForSwimmingLaneResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListApplicationsForSwimmingLaneResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListApplicationsForSwimmingLaneResponseBody>(model1);
      }
    }
  }


  virtual ~ListApplicationsForSwimmingLaneResponse() = default;
};
class ListChangeOrdersRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> coStatus{};
  shared_ptr<string> coType{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> key{};
  shared_ptr<string> orderBy{};
  shared_ptr<long> pageSize{};
  shared_ptr<bool> reverse{};

  ListChangeOrdersRequest() {}

  explicit ListChangeOrdersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (coStatus) {
      res["CoStatus"] = boost::any(*coStatus);
    }
    if (coType) {
      res["CoType"] = boost::any(*coType);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (reverse) {
      res["Reverse"] = boost::any(*reverse);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CoStatus") != m.end() && !m["CoStatus"].empty()) {
      coStatus = make_shared<string>(boost::any_cast<string>(m["CoStatus"]));
    }
    if (m.find("CoType") != m.end() && !m["CoType"].empty()) {
      coType = make_shared<string>(boost::any_cast<string>(m["CoType"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Reverse") != m.end() && !m["Reverse"].empty()) {
      reverse = make_shared<bool>(boost::any_cast<bool>(m["Reverse"]));
    }
  }


  virtual ~ListChangeOrdersRequest() = default;
};
class ListChangeOrdersResponseBodyDataChangeOrderList : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> batchCount{};
  shared_ptr<string> batchType{};
  shared_ptr<string> changeOrderId{};
  shared_ptr<string> coType{};
  shared_ptr<string> coTypeCode{};
  shared_ptr<string> createTime{};
  shared_ptr<string> createUserId{};
  shared_ptr<string> description{};
  shared_ptr<string> finishTime{};
  shared_ptr<string> groupId{};
  shared_ptr<string> source{};
  shared_ptr<long> status{};
  shared_ptr<string> userId{};

  ListChangeOrdersResponseBodyDataChangeOrderList() {}

  explicit ListChangeOrdersResponseBodyDataChangeOrderList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (batchCount) {
      res["BatchCount"] = boost::any(*batchCount);
    }
    if (batchType) {
      res["BatchType"] = boost::any(*batchType);
    }
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (coType) {
      res["CoType"] = boost::any(*coType);
    }
    if (coTypeCode) {
      res["CoTypeCode"] = boost::any(*coTypeCode);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUserId) {
      res["CreateUserId"] = boost::any(*createUserId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("BatchCount") != m.end() && !m["BatchCount"].empty()) {
      batchCount = make_shared<long>(boost::any_cast<long>(m["BatchCount"]));
    }
    if (m.find("BatchType") != m.end() && !m["BatchType"].empty()) {
      batchType = make_shared<string>(boost::any_cast<string>(m["BatchType"]));
    }
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("CoType") != m.end() && !m["CoType"].empty()) {
      coType = make_shared<string>(boost::any_cast<string>(m["CoType"]));
    }
    if (m.find("CoTypeCode") != m.end() && !m["CoTypeCode"].empty()) {
      coTypeCode = make_shared<string>(boost::any_cast<string>(m["CoTypeCode"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateUserId") != m.end() && !m["CreateUserId"].empty()) {
      createUserId = make_shared<string>(boost::any_cast<string>(m["CreateUserId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListChangeOrdersResponseBodyDataChangeOrderList() = default;
};
class ListChangeOrdersResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListChangeOrdersResponseBodyDataChangeOrderList>> changeOrderList{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalSize{};

  ListChangeOrdersResponseBodyData() {}

  explicit ListChangeOrdersResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderList) {
      vector<boost::any> temp1;
      for(auto item1:*changeOrderList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChangeOrderList"] = boost::any(temp1);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderList") != m.end() && !m["ChangeOrderList"].empty()) {
      if (typeid(vector<boost::any>) == m["ChangeOrderList"].type()) {
        vector<ListChangeOrdersResponseBodyDataChangeOrderList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChangeOrderList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListChangeOrdersResponseBodyDataChangeOrderList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        changeOrderList = make_shared<vector<ListChangeOrdersResponseBodyDataChangeOrderList>>(expect1);
      }
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
  }


  virtual ~ListChangeOrdersResponseBodyData() = default;
};
class ListChangeOrdersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListChangeOrdersResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  ListChangeOrdersResponseBody() {}

  explicit ListChangeOrdersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListChangeOrdersResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListChangeOrdersResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~ListChangeOrdersResponseBody() = default;
};
class ListChangeOrdersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListChangeOrdersResponseBody> body{};

  ListChangeOrdersResponse() {}

  explicit ListChangeOrdersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListChangeOrdersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListChangeOrdersResponseBody>(model1);
      }
    }
  }


  virtual ~ListChangeOrdersResponse() = default;
};
class ListConsumedServicesRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  ListConsumedServicesRequest() {}

  explicit ListConsumedServicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~ListConsumedServicesRequest() = default;
};
class ListConsumedServicesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> group2Ip{};
  shared_ptr<vector<string>> groups{};
  shared_ptr<vector<string>> ips{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> version{};

  ListConsumedServicesResponseBodyData() {}

  explicit ListConsumedServicesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (group2Ip) {
      res["Group2Ip"] = boost::any(*group2Ip);
    }
    if (groups) {
      res["Groups"] = boost::any(*groups);
    }
    if (ips) {
      res["Ips"] = boost::any(*ips);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Group2Ip") != m.end() && !m["Group2Ip"].empty()) {
      group2Ip = make_shared<string>(boost::any_cast<string>(m["Group2Ip"]));
    }
    if (m.find("Groups") != m.end() && !m["Groups"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Groups"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Groups"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      groups = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Ips") != m.end() && !m["Ips"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Ips"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ips"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ips = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~ListConsumedServicesResponseBodyData() = default;
};
class ListConsumedServicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListConsumedServicesResponseBodyData>> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  ListConsumedServicesResponseBody() {}

  explicit ListConsumedServicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListConsumedServicesResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListConsumedServicesResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListConsumedServicesResponseBodyData>>(expect1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~ListConsumedServicesResponseBody() = default;
};
class ListConsumedServicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListConsumedServicesResponseBody> body{};

  ListConsumedServicesResponse() {}

  explicit ListConsumedServicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListConsumedServicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListConsumedServicesResponseBody>(model1);
      }
    }
  }


  virtual ~ListConsumedServicesResponse() = default;
};
class ListGreyTagRouteRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  ListGreyTagRouteRequest() {}

  explicit ListGreyTagRouteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~ListGreyTagRouteRequest() = default;
};
class ListGreyTagRouteResponseBodyDataResultAlbRulesItems : public Darabonba::Model {
public:
  shared_ptr<string> cond{};
  shared_ptr<string> expr{};
  shared_ptr<long> index{};
  shared_ptr<string> name{};
  shared_ptr<string> operator_{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  ListGreyTagRouteResponseBodyDataResultAlbRulesItems() {}

  explicit ListGreyTagRouteResponseBodyDataResultAlbRulesItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cond) {
      res["cond"] = boost::any(*cond);
    }
    if (expr) {
      res["expr"] = boost::any(*expr);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (operator_) {
      res["operator"] = boost::any(*operator_);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cond") != m.end() && !m["cond"].empty()) {
      cond = make_shared<string>(boost::any_cast<string>(m["cond"]));
    }
    if (m.find("expr") != m.end() && !m["expr"].empty()) {
      expr = make_shared<string>(boost::any_cast<string>(m["expr"]));
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["index"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("operator") != m.end() && !m["operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["operator"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~ListGreyTagRouteResponseBodyDataResultAlbRulesItems() = default;
};
class ListGreyTagRouteResponseBodyDataResultAlbRules : public Darabonba::Model {
public:
  shared_ptr<string> condition{};
  shared_ptr<string> ingressId{};
  shared_ptr<vector<ListGreyTagRouteResponseBodyDataResultAlbRulesItems>> items{};
  shared_ptr<string> serviceName{};

  ListGreyTagRouteResponseBodyDataResultAlbRules() {}

  explicit ListGreyTagRouteResponseBodyDataResultAlbRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (condition) {
      res["condition"] = boost::any(*condition);
    }
    if (ingressId) {
      res["ingressId"] = boost::any(*ingressId);
    }
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["items"] = boost::any(temp1);
    }
    if (serviceName) {
      res["serviceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("condition") != m.end() && !m["condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["condition"]));
    }
    if (m.find("ingressId") != m.end() && !m["ingressId"].empty()) {
      ingressId = make_shared<string>(boost::any_cast<string>(m["ingressId"]));
    }
    if (m.find("items") != m.end() && !m["items"].empty()) {
      if (typeid(vector<boost::any>) == m["items"].type()) {
        vector<ListGreyTagRouteResponseBodyDataResultAlbRulesItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListGreyTagRouteResponseBodyDataResultAlbRulesItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<ListGreyTagRouteResponseBodyDataResultAlbRulesItems>>(expect1);
      }
    }
    if (m.find("serviceName") != m.end() && !m["serviceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["serviceName"]));
    }
  }


  virtual ~ListGreyTagRouteResponseBodyDataResultAlbRules() = default;
};
class ListGreyTagRouteResponseBodyDataResultDubboRulesItems : public Darabonba::Model {
public:
  shared_ptr<string> cond{};
  shared_ptr<string> expr{};
  shared_ptr<long> index{};
  shared_ptr<string> name{};
  shared_ptr<string> operator_{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  ListGreyTagRouteResponseBodyDataResultDubboRulesItems() {}

  explicit ListGreyTagRouteResponseBodyDataResultDubboRulesItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cond) {
      res["cond"] = boost::any(*cond);
    }
    if (expr) {
      res["expr"] = boost::any(*expr);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (operator_) {
      res["operator"] = boost::any(*operator_);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cond") != m.end() && !m["cond"].empty()) {
      cond = make_shared<string>(boost::any_cast<string>(m["cond"]));
    }
    if (m.find("expr") != m.end() && !m["expr"].empty()) {
      expr = make_shared<string>(boost::any_cast<string>(m["expr"]));
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["index"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("operator") != m.end() && !m["operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["operator"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~ListGreyTagRouteResponseBodyDataResultDubboRulesItems() = default;
};
class ListGreyTagRouteResponseBodyDataResultDubboRules : public Darabonba::Model {
public:
  shared_ptr<string> condition{};
  shared_ptr<string> group{};
  shared_ptr<vector<ListGreyTagRouteResponseBodyDataResultDubboRulesItems>> items{};
  shared_ptr<string> methodName{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> version{};

  ListGreyTagRouteResponseBodyDataResultDubboRules() {}

  explicit ListGreyTagRouteResponseBodyDataResultDubboRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (condition) {
      res["condition"] = boost::any(*condition);
    }
    if (group) {
      res["group"] = boost::any(*group);
    }
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["items"] = boost::any(temp1);
    }
    if (methodName) {
      res["methodName"] = boost::any(*methodName);
    }
    if (serviceName) {
      res["serviceName"] = boost::any(*serviceName);
    }
    if (version) {
      res["version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("condition") != m.end() && !m["condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["condition"]));
    }
    if (m.find("group") != m.end() && !m["group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["group"]));
    }
    if (m.find("items") != m.end() && !m["items"].empty()) {
      if (typeid(vector<boost::any>) == m["items"].type()) {
        vector<ListGreyTagRouteResponseBodyDataResultDubboRulesItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListGreyTagRouteResponseBodyDataResultDubboRulesItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<ListGreyTagRouteResponseBodyDataResultDubboRulesItems>>(expect1);
      }
    }
    if (m.find("methodName") != m.end() && !m["methodName"].empty()) {
      methodName = make_shared<string>(boost::any_cast<string>(m["methodName"]));
    }
    if (m.find("serviceName") != m.end() && !m["serviceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["serviceName"]));
    }
    if (m.find("version") != m.end() && !m["version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["version"]));
    }
  }


  virtual ~ListGreyTagRouteResponseBodyDataResultDubboRules() = default;
};
class ListGreyTagRouteResponseBodyDataResultScRulesItems : public Darabonba::Model {
public:
  shared_ptr<string> cond{};
  shared_ptr<string> expr{};
  shared_ptr<long> index{};
  shared_ptr<string> name{};
  shared_ptr<string> operator_{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  ListGreyTagRouteResponseBodyDataResultScRulesItems() {}

  explicit ListGreyTagRouteResponseBodyDataResultScRulesItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cond) {
      res["cond"] = boost::any(*cond);
    }
    if (expr) {
      res["expr"] = boost::any(*expr);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (operator_) {
      res["operator"] = boost::any(*operator_);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cond") != m.end() && !m["cond"].empty()) {
      cond = make_shared<string>(boost::any_cast<string>(m["cond"]));
    }
    if (m.find("expr") != m.end() && !m["expr"].empty()) {
      expr = make_shared<string>(boost::any_cast<string>(m["expr"]));
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["index"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("operator") != m.end() && !m["operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["operator"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~ListGreyTagRouteResponseBodyDataResultScRulesItems() = default;
};
class ListGreyTagRouteResponseBodyDataResultScRules : public Darabonba::Model {
public:
  shared_ptr<string> condition{};
  shared_ptr<vector<ListGreyTagRouteResponseBodyDataResultScRulesItems>> items{};
  shared_ptr<string> path{};

  ListGreyTagRouteResponseBodyDataResultScRules() {}

  explicit ListGreyTagRouteResponseBodyDataResultScRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (condition) {
      res["condition"] = boost::any(*condition);
    }
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["items"] = boost::any(temp1);
    }
    if (path) {
      res["path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("condition") != m.end() && !m["condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["condition"]));
    }
    if (m.find("items") != m.end() && !m["items"].empty()) {
      if (typeid(vector<boost::any>) == m["items"].type()) {
        vector<ListGreyTagRouteResponseBodyDataResultScRulesItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListGreyTagRouteResponseBodyDataResultScRulesItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<ListGreyTagRouteResponseBodyDataResultScRulesItems>>(expect1);
      }
    }
    if (m.find("path") != m.end() && !m["path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["path"]));
    }
  }


  virtual ~ListGreyTagRouteResponseBodyDataResultScRules() = default;
};
class ListGreyTagRouteResponseBodyDataResult : public Darabonba::Model {
public:
  shared_ptr<vector<ListGreyTagRouteResponseBodyDataResultAlbRules>> albRules{};
  shared_ptr<long> createTime{};
  shared_ptr<string> description{};
  shared_ptr<vector<ListGreyTagRouteResponseBodyDataResultDubboRules>> dubboRules{};
  shared_ptr<long> greyTagRouteId{};
  shared_ptr<string> name{};
  shared_ptr<vector<ListGreyTagRouteResponseBodyDataResultScRules>> scRules{};
  shared_ptr<long> updateTime{};

  ListGreyTagRouteResponseBodyDataResult() {}

  explicit ListGreyTagRouteResponseBodyDataResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (albRules) {
      vector<boost::any> temp1;
      for(auto item1:*albRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlbRules"] = boost::any(temp1);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dubboRules) {
      vector<boost::any> temp1;
      for(auto item1:*dubboRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DubboRules"] = boost::any(temp1);
    }
    if (greyTagRouteId) {
      res["GreyTagRouteId"] = boost::any(*greyTagRouteId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (scRules) {
      vector<boost::any> temp1;
      for(auto item1:*scRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScRules"] = boost::any(temp1);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlbRules") != m.end() && !m["AlbRules"].empty()) {
      if (typeid(vector<boost::any>) == m["AlbRules"].type()) {
        vector<ListGreyTagRouteResponseBodyDataResultAlbRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlbRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListGreyTagRouteResponseBodyDataResultAlbRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        albRules = make_shared<vector<ListGreyTagRouteResponseBodyDataResultAlbRules>>(expect1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DubboRules") != m.end() && !m["DubboRules"].empty()) {
      if (typeid(vector<boost::any>) == m["DubboRules"].type()) {
        vector<ListGreyTagRouteResponseBodyDataResultDubboRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DubboRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListGreyTagRouteResponseBodyDataResultDubboRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dubboRules = make_shared<vector<ListGreyTagRouteResponseBodyDataResultDubboRules>>(expect1);
      }
    }
    if (m.find("GreyTagRouteId") != m.end() && !m["GreyTagRouteId"].empty()) {
      greyTagRouteId = make_shared<long>(boost::any_cast<long>(m["GreyTagRouteId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ScRules") != m.end() && !m["ScRules"].empty()) {
      if (typeid(vector<boost::any>) == m["ScRules"].type()) {
        vector<ListGreyTagRouteResponseBodyDataResultScRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListGreyTagRouteResponseBodyDataResultScRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scRules = make_shared<vector<ListGreyTagRouteResponseBodyDataResultScRules>>(expect1);
      }
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~ListGreyTagRouteResponseBodyDataResult() = default;
};
class ListGreyTagRouteResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListGreyTagRouteResponseBodyDataResult>> result{};
  shared_ptr<long> totalSize{};

  ListGreyTagRouteResponseBodyData() {}

  explicit ListGreyTagRouteResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<ListGreyTagRouteResponseBodyDataResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListGreyTagRouteResponseBodyDataResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListGreyTagRouteResponseBodyDataResult>>(expect1);
      }
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
  }


  virtual ~ListGreyTagRouteResponseBodyData() = default;
};
class ListGreyTagRouteResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListGreyTagRouteResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  ListGreyTagRouteResponseBody() {}

  explicit ListGreyTagRouteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListGreyTagRouteResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListGreyTagRouteResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~ListGreyTagRouteResponseBody() = default;
};
class ListGreyTagRouteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListGreyTagRouteResponseBody> body{};

  ListGreyTagRouteResponse() {}

  explicit ListGreyTagRouteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListGreyTagRouteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListGreyTagRouteResponseBody>(model1);
      }
    }
  }


  virtual ~ListGreyTagRouteResponse() = default;
};
class ListIngressesRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> namespaceId{};

  ListIngressesRequest() {}

  explicit ListIngressesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
  }


  virtual ~ListIngressesRequest() = default;
};
class ListIngressesResponseBodyDataIngressListCorsConfig : public Darabonba::Model {
public:
  shared_ptr<string> allowCredentials{};
  shared_ptr<string> allowHeaders{};
  shared_ptr<string> allowMethods{};
  shared_ptr<string> allowOrigin{};
  shared_ptr<string> enable{};
  shared_ptr<string> exposeHeaders{};
  shared_ptr<string> maxAge{};

  ListIngressesResponseBodyDataIngressListCorsConfig() {}

  explicit ListIngressesResponseBodyDataIngressListCorsConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowCredentials) {
      res["AllowCredentials"] = boost::any(*allowCredentials);
    }
    if (allowHeaders) {
      res["AllowHeaders"] = boost::any(*allowHeaders);
    }
    if (allowMethods) {
      res["AllowMethods"] = boost::any(*allowMethods);
    }
    if (allowOrigin) {
      res["AllowOrigin"] = boost::any(*allowOrigin);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (exposeHeaders) {
      res["ExposeHeaders"] = boost::any(*exposeHeaders);
    }
    if (maxAge) {
      res["MaxAge"] = boost::any(*maxAge);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowCredentials") != m.end() && !m["AllowCredentials"].empty()) {
      allowCredentials = make_shared<string>(boost::any_cast<string>(m["AllowCredentials"]));
    }
    if (m.find("AllowHeaders") != m.end() && !m["AllowHeaders"].empty()) {
      allowHeaders = make_shared<string>(boost::any_cast<string>(m["AllowHeaders"]));
    }
    if (m.find("AllowMethods") != m.end() && !m["AllowMethods"].empty()) {
      allowMethods = make_shared<string>(boost::any_cast<string>(m["AllowMethods"]));
    }
    if (m.find("AllowOrigin") != m.end() && !m["AllowOrigin"].empty()) {
      allowOrigin = make_shared<string>(boost::any_cast<string>(m["AllowOrigin"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<string>(boost::any_cast<string>(m["Enable"]));
    }
    if (m.find("ExposeHeaders") != m.end() && !m["ExposeHeaders"].empty()) {
      exposeHeaders = make_shared<string>(boost::any_cast<string>(m["ExposeHeaders"]));
    }
    if (m.find("MaxAge") != m.end() && !m["MaxAge"].empty()) {
      maxAge = make_shared<string>(boost::any_cast<string>(m["MaxAge"]));
    }
  }


  virtual ~ListIngressesResponseBodyDataIngressListCorsConfig() = default;
};
class ListIngressesResponseBodyDataIngressListDefaultRule : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> backendProtocol{};
  shared_ptr<long> containerPort{};

  ListIngressesResponseBodyDataIngressListDefaultRule() {}

  explicit ListIngressesResponseBodyDataIngressListDefaultRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (backendProtocol) {
      res["BackendProtocol"] = boost::any(*backendProtocol);
    }
    if (containerPort) {
      res["ContainerPort"] = boost::any(*containerPort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("BackendProtocol") != m.end() && !m["BackendProtocol"].empty()) {
      backendProtocol = make_shared<string>(boost::any_cast<string>(m["BackendProtocol"]));
    }
    if (m.find("ContainerPort") != m.end() && !m["ContainerPort"].empty()) {
      containerPort = make_shared<long>(boost::any_cast<long>(m["ContainerPort"]));
    }
  }


  virtual ~ListIngressesResponseBodyDataIngressListDefaultRule() = default;
};
class ListIngressesResponseBodyDataIngressListRulesRuleActions : public Darabonba::Model {
public:
  shared_ptr<string> actionConfig{};
  shared_ptr<string> actionType{};

  ListIngressesResponseBodyDataIngressListRulesRuleActions() {}

  explicit ListIngressesResponseBodyDataIngressListRulesRuleActions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionConfig) {
      res["ActionConfig"] = boost::any(*actionConfig);
    }
    if (actionType) {
      res["ActionType"] = boost::any(*actionType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionConfig") != m.end() && !m["ActionConfig"].empty()) {
      actionConfig = make_shared<string>(boost::any_cast<string>(m["ActionConfig"]));
    }
    if (m.find("ActionType") != m.end() && !m["ActionType"].empty()) {
      actionType = make_shared<string>(boost::any_cast<string>(m["ActionType"]));
    }
  }


  virtual ~ListIngressesResponseBodyDataIngressListRulesRuleActions() = default;
};
class ListIngressesResponseBodyDataIngressListRules : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> backendProtocol{};
  shared_ptr<long> containerPort{};
  shared_ptr<string> domain{};
  shared_ptr<string> path{};
  shared_ptr<string> rewritePath{};
  shared_ptr<vector<ListIngressesResponseBodyDataIngressListRulesRuleActions>> ruleActions{};

  ListIngressesResponseBodyDataIngressListRules() {}

  explicit ListIngressesResponseBodyDataIngressListRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (backendProtocol) {
      res["BackendProtocol"] = boost::any(*backendProtocol);
    }
    if (containerPort) {
      res["ContainerPort"] = boost::any(*containerPort);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (rewritePath) {
      res["RewritePath"] = boost::any(*rewritePath);
    }
    if (ruleActions) {
      vector<boost::any> temp1;
      for(auto item1:*ruleActions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuleActions"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("BackendProtocol") != m.end() && !m["BackendProtocol"].empty()) {
      backendProtocol = make_shared<string>(boost::any_cast<string>(m["BackendProtocol"]));
    }
    if (m.find("ContainerPort") != m.end() && !m["ContainerPort"].empty()) {
      containerPort = make_shared<long>(boost::any_cast<long>(m["ContainerPort"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("RewritePath") != m.end() && !m["RewritePath"].empty()) {
      rewritePath = make_shared<string>(boost::any_cast<string>(m["RewritePath"]));
    }
    if (m.find("RuleActions") != m.end() && !m["RuleActions"].empty()) {
      if (typeid(vector<boost::any>) == m["RuleActions"].type()) {
        vector<ListIngressesResponseBodyDataIngressListRulesRuleActions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuleActions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIngressesResponseBodyDataIngressListRulesRuleActions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleActions = make_shared<vector<ListIngressesResponseBodyDataIngressListRulesRuleActions>>(expect1);
      }
    }
  }


  virtual ~ListIngressesResponseBodyDataIngressListRules() = default;
};
class ListIngressesResponseBodyDataIngressList : public Darabonba::Model {
public:
  shared_ptr<string> certId{};
  shared_ptr<string> certIds{};
  shared_ptr<ListIngressesResponseBodyDataIngressListCorsConfig> corsConfig{};
  shared_ptr<long> createTime{};
  shared_ptr<ListIngressesResponseBodyDataIngressListDefaultRule> defaultRule{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<long> idleTimeout{};
  shared_ptr<string> listenerPort{};
  shared_ptr<string> listenerProtocol{};
  shared_ptr<string> loadBalanceType{};
  shared_ptr<string> mseGatewayId{};
  shared_ptr<string> mseGatewayPort{};
  shared_ptr<string> mseGatewayProtocol{};
  shared_ptr<string> name{};
  shared_ptr<string> namespaceId{};
  shared_ptr<long> requestTimeout{};
  shared_ptr<vector<ListIngressesResponseBodyDataIngressListRules>> rules{};
  shared_ptr<string> slbId{};
  shared_ptr<string> slbType{};

  ListIngressesResponseBodyDataIngressList() {}

  explicit ListIngressesResponseBodyDataIngressList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certId) {
      res["CertId"] = boost::any(*certId);
    }
    if (certIds) {
      res["CertIds"] = boost::any(*certIds);
    }
    if (corsConfig) {
      res["CorsConfig"] = corsConfig ? boost::any(corsConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (defaultRule) {
      res["DefaultRule"] = defaultRule ? boost::any(defaultRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (idleTimeout) {
      res["IdleTimeout"] = boost::any(*idleTimeout);
    }
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    if (listenerProtocol) {
      res["ListenerProtocol"] = boost::any(*listenerProtocol);
    }
    if (loadBalanceType) {
      res["LoadBalanceType"] = boost::any(*loadBalanceType);
    }
    if (mseGatewayId) {
      res["MseGatewayId"] = boost::any(*mseGatewayId);
    }
    if (mseGatewayPort) {
      res["MseGatewayPort"] = boost::any(*mseGatewayPort);
    }
    if (mseGatewayProtocol) {
      res["MseGatewayProtocol"] = boost::any(*mseGatewayProtocol);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (requestTimeout) {
      res["RequestTimeout"] = boost::any(*requestTimeout);
    }
    if (rules) {
      vector<boost::any> temp1;
      for(auto item1:*rules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rules"] = boost::any(temp1);
    }
    if (slbId) {
      res["SlbId"] = boost::any(*slbId);
    }
    if (slbType) {
      res["SlbType"] = boost::any(*slbType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertId") != m.end() && !m["CertId"].empty()) {
      certId = make_shared<string>(boost::any_cast<string>(m["CertId"]));
    }
    if (m.find("CertIds") != m.end() && !m["CertIds"].empty()) {
      certIds = make_shared<string>(boost::any_cast<string>(m["CertIds"]));
    }
    if (m.find("CorsConfig") != m.end() && !m["CorsConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CorsConfig"].type()) {
        ListIngressesResponseBodyDataIngressListCorsConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CorsConfig"]));
        corsConfig = make_shared<ListIngressesResponseBodyDataIngressListCorsConfig>(model1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DefaultRule") != m.end() && !m["DefaultRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["DefaultRule"].type()) {
        ListIngressesResponseBodyDataIngressListDefaultRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DefaultRule"]));
        defaultRule = make_shared<ListIngressesResponseBodyDataIngressListDefaultRule>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IdleTimeout") != m.end() && !m["IdleTimeout"].empty()) {
      idleTimeout = make_shared<long>(boost::any_cast<long>(m["IdleTimeout"]));
    }
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<string>(boost::any_cast<string>(m["ListenerPort"]));
    }
    if (m.find("ListenerProtocol") != m.end() && !m["ListenerProtocol"].empty()) {
      listenerProtocol = make_shared<string>(boost::any_cast<string>(m["ListenerProtocol"]));
    }
    if (m.find("LoadBalanceType") != m.end() && !m["LoadBalanceType"].empty()) {
      loadBalanceType = make_shared<string>(boost::any_cast<string>(m["LoadBalanceType"]));
    }
    if (m.find("MseGatewayId") != m.end() && !m["MseGatewayId"].empty()) {
      mseGatewayId = make_shared<string>(boost::any_cast<string>(m["MseGatewayId"]));
    }
    if (m.find("MseGatewayPort") != m.end() && !m["MseGatewayPort"].empty()) {
      mseGatewayPort = make_shared<string>(boost::any_cast<string>(m["MseGatewayPort"]));
    }
    if (m.find("MseGatewayProtocol") != m.end() && !m["MseGatewayProtocol"].empty()) {
      mseGatewayProtocol = make_shared<string>(boost::any_cast<string>(m["MseGatewayProtocol"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("RequestTimeout") != m.end() && !m["RequestTimeout"].empty()) {
      requestTimeout = make_shared<long>(boost::any_cast<long>(m["RequestTimeout"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      if (typeid(vector<boost::any>) == m["Rules"].type()) {
        vector<ListIngressesResponseBodyDataIngressListRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIngressesResponseBodyDataIngressListRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rules = make_shared<vector<ListIngressesResponseBodyDataIngressListRules>>(expect1);
      }
    }
    if (m.find("SlbId") != m.end() && !m["SlbId"].empty()) {
      slbId = make_shared<string>(boost::any_cast<string>(m["SlbId"]));
    }
    if (m.find("SlbType") != m.end() && !m["SlbType"].empty()) {
      slbType = make_shared<string>(boost::any_cast<string>(m["SlbType"]));
    }
  }


  virtual ~ListIngressesResponseBodyDataIngressList() = default;
};
class ListIngressesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListIngressesResponseBodyDataIngressList>> ingressList{};

  ListIngressesResponseBodyData() {}

  explicit ListIngressesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ingressList) {
      vector<boost::any> temp1;
      for(auto item1:*ingressList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IngressList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IngressList") != m.end() && !m["IngressList"].empty()) {
      if (typeid(vector<boost::any>) == m["IngressList"].type()) {
        vector<ListIngressesResponseBodyDataIngressList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IngressList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIngressesResponseBodyDataIngressList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ingressList = make_shared<vector<ListIngressesResponseBodyDataIngressList>>(expect1);
      }
    }
  }


  virtual ~ListIngressesResponseBodyData() = default;
};
class ListIngressesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListIngressesResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  ListIngressesResponseBody() {}

  explicit ListIngressesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListIngressesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListIngressesResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~ListIngressesResponseBody() = default;
};
class ListIngressesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListIngressesResponseBody> body{};

  ListIngressesResponse() {}

  explicit ListIngressesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListIngressesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListIngressesResponseBody>(model1);
      }
    }
  }


  virtual ~ListIngressesResponse() = default;
};
class ListJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> fieldType{};
  shared_ptr<string> fieldValue{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> orderBy{};
  shared_ptr<long> pageSize{};
  shared_ptr<bool> reverse{};
  shared_ptr<string> tags{};
  shared_ptr<string> workload{};

  ListJobsRequest() {}

  explicit ListJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (fieldType) {
      res["FieldType"] = boost::any(*fieldType);
    }
    if (fieldValue) {
      res["FieldValue"] = boost::any(*fieldValue);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (reverse) {
      res["Reverse"] = boost::any(*reverse);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (workload) {
      res["Workload"] = boost::any(*workload);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("FieldType") != m.end() && !m["FieldType"].empty()) {
      fieldType = make_shared<string>(boost::any_cast<string>(m["FieldType"]));
    }
    if (m.find("FieldValue") != m.end() && !m["FieldValue"].empty()) {
      fieldValue = make_shared<string>(boost::any_cast<string>(m["FieldValue"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Reverse") != m.end() && !m["Reverse"].empty()) {
      reverse = make_shared<bool>(boost::any_cast<bool>(m["Reverse"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("Workload") != m.end() && !m["Workload"].empty()) {
      workload = make_shared<string>(boost::any_cast<string>(m["Workload"]));
    }
  }


  virtual ~ListJobsRequest() = default;
};
class ListJobsResponseBodyDataApplicationsTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListJobsResponseBodyDataApplicationsTags() {}

  explicit ListJobsResponseBodyDataApplicationsTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListJobsResponseBodyDataApplicationsTags() = default;
};
class ListJobsResponseBodyDataApplications : public Darabonba::Model {
public:
  shared_ptr<long> active{};
  shared_ptr<string> appDescription{};
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<long> completionTime{};
  shared_ptr<long> cpu{};
  shared_ptr<long> failed{};
  shared_ptr<string> lastChangeorderState{};
  shared_ptr<string> lastJobState{};
  shared_ptr<long> lastStartTime{};
  shared_ptr<long> mem{};
  shared_ptr<string> message{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> succeeded{};
  shared_ptr<bool> suspend{};
  shared_ptr<vector<ListJobsResponseBodyDataApplicationsTags>> tags{};
  shared_ptr<string> triggerConfig{};

  ListJobsResponseBodyDataApplications() {}

  explicit ListJobsResponseBodyDataApplications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (active) {
      res["Active"] = boost::any(*active);
    }
    if (appDescription) {
      res["AppDescription"] = boost::any(*appDescription);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (completionTime) {
      res["CompletionTime"] = boost::any(*completionTime);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (lastChangeorderState) {
      res["LastChangeorderState"] = boost::any(*lastChangeorderState);
    }
    if (lastJobState) {
      res["LastJobState"] = boost::any(*lastJobState);
    }
    if (lastStartTime) {
      res["LastStartTime"] = boost::any(*lastStartTime);
    }
    if (mem) {
      res["Mem"] = boost::any(*mem);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (succeeded) {
      res["Succeeded"] = boost::any(*succeeded);
    }
    if (suspend) {
      res["Suspend"] = boost::any(*suspend);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (triggerConfig) {
      res["TriggerConfig"] = boost::any(*triggerConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Active") != m.end() && !m["Active"].empty()) {
      active = make_shared<long>(boost::any_cast<long>(m["Active"]));
    }
    if (m.find("AppDescription") != m.end() && !m["AppDescription"].empty()) {
      appDescription = make_shared<string>(boost::any_cast<string>(m["AppDescription"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("CompletionTime") != m.end() && !m["CompletionTime"].empty()) {
      completionTime = make_shared<long>(boost::any_cast<long>(m["CompletionTime"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<long>(boost::any_cast<long>(m["Failed"]));
    }
    if (m.find("LastChangeorderState") != m.end() && !m["LastChangeorderState"].empty()) {
      lastChangeorderState = make_shared<string>(boost::any_cast<string>(m["LastChangeorderState"]));
    }
    if (m.find("LastJobState") != m.end() && !m["LastJobState"].empty()) {
      lastJobState = make_shared<string>(boost::any_cast<string>(m["LastJobState"]));
    }
    if (m.find("LastStartTime") != m.end() && !m["LastStartTime"].empty()) {
      lastStartTime = make_shared<long>(boost::any_cast<long>(m["LastStartTime"]));
    }
    if (m.find("Mem") != m.end() && !m["Mem"].empty()) {
      mem = make_shared<long>(boost::any_cast<long>(m["Mem"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Succeeded") != m.end() && !m["Succeeded"].empty()) {
      succeeded = make_shared<long>(boost::any_cast<long>(m["Succeeded"]));
    }
    if (m.find("Suspend") != m.end() && !m["Suspend"].empty()) {
      suspend = make_shared<bool>(boost::any_cast<bool>(m["Suspend"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListJobsResponseBodyDataApplicationsTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobsResponseBodyDataApplicationsTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListJobsResponseBodyDataApplicationsTags>>(expect1);
      }
    }
    if (m.find("TriggerConfig") != m.end() && !m["TriggerConfig"].empty()) {
      triggerConfig = make_shared<string>(boost::any_cast<string>(m["TriggerConfig"]));
    }
  }


  virtual ~ListJobsResponseBodyDataApplications() = default;
};
class ListJobsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListJobsResponseBodyDataApplications>> applications{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalSize{};

  ListJobsResponseBodyData() {}

  explicit ListJobsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applications) {
      vector<boost::any> temp1;
      for(auto item1:*applications){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Applications"] = boost::any(temp1);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Applications") != m.end() && !m["Applications"].empty()) {
      if (typeid(vector<boost::any>) == m["Applications"].type()) {
        vector<ListJobsResponseBodyDataApplications> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Applications"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobsResponseBodyDataApplications model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        applications = make_shared<vector<ListJobsResponseBodyDataApplications>>(expect1);
      }
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
  }


  virtual ~ListJobsResponseBodyData() = default;
};
class ListJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> currentPage{};
  shared_ptr<ListJobsResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalSize{};

  ListJobsResponseBody() {}

  explicit ListJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListJobsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListJobsResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
  }


  virtual ~ListJobsResponseBody() = default;
};
class ListJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListJobsResponseBody> body{};

  ListJobsResponse() {}

  explicit ListJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListJobsResponseBody>(model1);
      }
    }
  }


  virtual ~ListJobsResponse() = default;
};
class ListLogConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};

  ListLogConfigsRequest() {}

  explicit ListLogConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListLogConfigsRequest() = default;
};
class ListLogConfigsResponseBodyDataLogConfigs : public Darabonba::Model {
public:
  shared_ptr<string> configName{};
  shared_ptr<string> createTime{};
  shared_ptr<string> logDir{};
  shared_ptr<string> logType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> slsLogStore{};
  shared_ptr<string> slsProject{};
  shared_ptr<string> storeType{};

  ListLogConfigsResponseBodyDataLogConfigs() {}

  explicit ListLogConfigsResponseBodyDataLogConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configName) {
      res["ConfigName"] = boost::any(*configName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (logDir) {
      res["LogDir"] = boost::any(*logDir);
    }
    if (logType) {
      res["LogType"] = boost::any(*logType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (slsLogStore) {
      res["SlsLogStore"] = boost::any(*slsLogStore);
    }
    if (slsProject) {
      res["SlsProject"] = boost::any(*slsProject);
    }
    if (storeType) {
      res["StoreType"] = boost::any(*storeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigName") != m.end() && !m["ConfigName"].empty()) {
      configName = make_shared<string>(boost::any_cast<string>(m["ConfigName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("LogDir") != m.end() && !m["LogDir"].empty()) {
      logDir = make_shared<string>(boost::any_cast<string>(m["LogDir"]));
    }
    if (m.find("LogType") != m.end() && !m["LogType"].empty()) {
      logType = make_shared<string>(boost::any_cast<string>(m["LogType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SlsLogStore") != m.end() && !m["SlsLogStore"].empty()) {
      slsLogStore = make_shared<string>(boost::any_cast<string>(m["SlsLogStore"]));
    }
    if (m.find("SlsProject") != m.end() && !m["SlsProject"].empty()) {
      slsProject = make_shared<string>(boost::any_cast<string>(m["SlsProject"]));
    }
    if (m.find("StoreType") != m.end() && !m["StoreType"].empty()) {
      storeType = make_shared<string>(boost::any_cast<string>(m["StoreType"]));
    }
  }


  virtual ~ListLogConfigsResponseBodyDataLogConfigs() = default;
};
class ListLogConfigsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<vector<ListLogConfigsResponseBodyDataLogConfigs>> logConfigs{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalSize{};

  ListLogConfigsResponseBodyData() {}

  explicit ListLogConfigsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (logConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*logConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LogConfigs"] = boost::any(temp1);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("LogConfigs") != m.end() && !m["LogConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["LogConfigs"].type()) {
        vector<ListLogConfigsResponseBodyDataLogConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LogConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLogConfigsResponseBodyDataLogConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logConfigs = make_shared<vector<ListLogConfigsResponseBodyDataLogConfigs>>(expect1);
      }
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
  }


  virtual ~ListLogConfigsResponseBodyData() = default;
};
class ListLogConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListLogConfigsResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  ListLogConfigsResponseBody() {}

  explicit ListLogConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListLogConfigsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListLogConfigsResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~ListLogConfigsResponseBody() = default;
};
class ListLogConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListLogConfigsResponseBody> body{};

  ListLogConfigsResponse() {}

  explicit ListLogConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLogConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLogConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~ListLogConfigsResponse() = default;
};
class ListNamespaceChangeOrdersRequest : public Darabonba::Model {
public:
  shared_ptr<string> coStatus{};
  shared_ptr<string> coType{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> key{};
  shared_ptr<string> namespaceId{};
  shared_ptr<long> pageSize{};

  ListNamespaceChangeOrdersRequest() {}

  explicit ListNamespaceChangeOrdersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coStatus) {
      res["CoStatus"] = boost::any(*coStatus);
    }
    if (coType) {
      res["CoType"] = boost::any(*coType);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CoStatus") != m.end() && !m["CoStatus"].empty()) {
      coStatus = make_shared<string>(boost::any_cast<string>(m["CoStatus"]));
    }
    if (m.find("CoType") != m.end() && !m["CoType"].empty()) {
      coType = make_shared<string>(boost::any_cast<string>(m["CoType"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListNamespaceChangeOrdersRequest() = default;
};
class ListNamespaceChangeOrdersResponseBodyDataChangeOrderList : public Darabonba::Model {
public:
  shared_ptr<long> batchCount{};
  shared_ptr<string> batchType{};
  shared_ptr<string> changeOrderId{};
  shared_ptr<string> coType{};
  shared_ptr<string> coTypeCode{};
  shared_ptr<string> createTime{};
  shared_ptr<string> createUserId{};
  shared_ptr<string> description{};
  shared_ptr<string> finishTime{};
  shared_ptr<string> groupId{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> pipelines{};
  shared_ptr<string> source{};
  shared_ptr<long> status{};
  shared_ptr<string> userId{};

  ListNamespaceChangeOrdersResponseBodyDataChangeOrderList() {}

  explicit ListNamespaceChangeOrdersResponseBodyDataChangeOrderList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (batchCount) {
      res["BatchCount"] = boost::any(*batchCount);
    }
    if (batchType) {
      res["BatchType"] = boost::any(*batchType);
    }
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (coType) {
      res["CoType"] = boost::any(*coType);
    }
    if (coTypeCode) {
      res["CoTypeCode"] = boost::any(*coTypeCode);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUserId) {
      res["CreateUserId"] = boost::any(*createUserId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (pipelines) {
      res["Pipelines"] = boost::any(*pipelines);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BatchCount") != m.end() && !m["BatchCount"].empty()) {
      batchCount = make_shared<long>(boost::any_cast<long>(m["BatchCount"]));
    }
    if (m.find("BatchType") != m.end() && !m["BatchType"].empty()) {
      batchType = make_shared<string>(boost::any_cast<string>(m["BatchType"]));
    }
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("CoType") != m.end() && !m["CoType"].empty()) {
      coType = make_shared<string>(boost::any_cast<string>(m["CoType"]));
    }
    if (m.find("CoTypeCode") != m.end() && !m["CoTypeCode"].empty()) {
      coTypeCode = make_shared<string>(boost::any_cast<string>(m["CoTypeCode"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateUserId") != m.end() && !m["CreateUserId"].empty()) {
      createUserId = make_shared<string>(boost::any_cast<string>(m["CreateUserId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("Pipelines") != m.end() && !m["Pipelines"].empty()) {
      pipelines = make_shared<string>(boost::any_cast<string>(m["Pipelines"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListNamespaceChangeOrdersResponseBodyDataChangeOrderList() = default;
};
class ListNamespaceChangeOrdersResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListNamespaceChangeOrdersResponseBodyDataChangeOrderList>> changeOrderList{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalSize{};

  ListNamespaceChangeOrdersResponseBodyData() {}

  explicit ListNamespaceChangeOrdersResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderList) {
      vector<boost::any> temp1;
      for(auto item1:*changeOrderList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChangeOrderList"] = boost::any(temp1);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderList") != m.end() && !m["ChangeOrderList"].empty()) {
      if (typeid(vector<boost::any>) == m["ChangeOrderList"].type()) {
        vector<ListNamespaceChangeOrdersResponseBodyDataChangeOrderList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChangeOrderList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNamespaceChangeOrdersResponseBodyDataChangeOrderList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        changeOrderList = make_shared<vector<ListNamespaceChangeOrdersResponseBodyDataChangeOrderList>>(expect1);
      }
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
  }


  virtual ~ListNamespaceChangeOrdersResponseBodyData() = default;
};
class ListNamespaceChangeOrdersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListNamespaceChangeOrdersResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  ListNamespaceChangeOrdersResponseBody() {}

  explicit ListNamespaceChangeOrdersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListNamespaceChangeOrdersResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListNamespaceChangeOrdersResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~ListNamespaceChangeOrdersResponseBody() = default;
};
class ListNamespaceChangeOrdersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListNamespaceChangeOrdersResponseBody> body{};

  ListNamespaceChangeOrdersResponse() {}

  explicit ListNamespaceChangeOrdersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListNamespaceChangeOrdersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListNamespaceChangeOrdersResponseBody>(model1);
      }
    }
  }


  virtual ~ListNamespaceChangeOrdersResponse() = default;
};
class ListNamespacedConfigMapsRequest : public Darabonba::Model {
public:
  shared_ptr<string> namespaceId{};

  ListNamespacedConfigMapsRequest() {}

  explicit ListNamespacedConfigMapsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
  }


  virtual ~ListNamespacedConfigMapsRequest() = default;
};
class ListNamespacedConfigMapsResponseBodyDataConfigMapsRelateApps : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};

  ListNamespacedConfigMapsResponseBodyDataConfigMapsRelateApps() {}

  explicit ListNamespacedConfigMapsResponseBodyDataConfigMapsRelateApps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
  }


  virtual ~ListNamespacedConfigMapsResponseBodyDataConfigMapsRelateApps() = default;
};
class ListNamespacedConfigMapsResponseBodyDataConfigMaps : public Darabonba::Model {
public:
  shared_ptr<long> configMapId{};
  shared_ptr<long> createTime{};
  shared_ptr<map<string, boost::any>> data{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> namespaceId{};
  shared_ptr<vector<ListNamespacedConfigMapsResponseBodyDataConfigMapsRelateApps>> relateApps{};
  shared_ptr<long> updateTime{};

  ListNamespacedConfigMapsResponseBodyDataConfigMaps() {}

  explicit ListNamespacedConfigMapsResponseBodyDataConfigMaps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configMapId) {
      res["ConfigMapId"] = boost::any(*configMapId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (relateApps) {
      vector<boost::any> temp1;
      for(auto item1:*relateApps){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RelateApps"] = boost::any(temp1);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigMapId") != m.end() && !m["ConfigMapId"].empty()) {
      configMapId = make_shared<long>(boost::any_cast<long>(m["ConfigMapId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Data"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      data = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("RelateApps") != m.end() && !m["RelateApps"].empty()) {
      if (typeid(vector<boost::any>) == m["RelateApps"].type()) {
        vector<ListNamespacedConfigMapsResponseBodyDataConfigMapsRelateApps> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RelateApps"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNamespacedConfigMapsResponseBodyDataConfigMapsRelateApps model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        relateApps = make_shared<vector<ListNamespacedConfigMapsResponseBodyDataConfigMapsRelateApps>>(expect1);
      }
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~ListNamespacedConfigMapsResponseBodyDataConfigMaps() = default;
};
class ListNamespacedConfigMapsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListNamespacedConfigMapsResponseBodyDataConfigMaps>> configMaps{};

  ListNamespacedConfigMapsResponseBodyData() {}

  explicit ListNamespacedConfigMapsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configMaps) {
      vector<boost::any> temp1;
      for(auto item1:*configMaps){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigMaps"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigMaps") != m.end() && !m["ConfigMaps"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigMaps"].type()) {
        vector<ListNamespacedConfigMapsResponseBodyDataConfigMaps> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigMaps"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNamespacedConfigMapsResponseBodyDataConfigMaps model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configMaps = make_shared<vector<ListNamespacedConfigMapsResponseBodyDataConfigMaps>>(expect1);
      }
    }
  }


  virtual ~ListNamespacedConfigMapsResponseBodyData() = default;
};
class ListNamespacedConfigMapsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListNamespacedConfigMapsResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  ListNamespacedConfigMapsResponseBody() {}

  explicit ListNamespacedConfigMapsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListNamespacedConfigMapsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListNamespacedConfigMapsResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~ListNamespacedConfigMapsResponseBody() = default;
};
class ListNamespacedConfigMapsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListNamespacedConfigMapsResponseBody> body{};

  ListNamespacedConfigMapsResponse() {}

  explicit ListNamespacedConfigMapsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListNamespacedConfigMapsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListNamespacedConfigMapsResponseBody>(model1);
      }
    }
  }


  virtual ~ListNamespacedConfigMapsResponse() = default;
};
class ListPublishedServicesRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  ListPublishedServicesRequest() {}

  explicit ListPublishedServicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~ListPublishedServicesRequest() = default;
};
class ListPublishedServicesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> group2Ip{};
  shared_ptr<vector<string>> groups{};
  shared_ptr<vector<string>> ips{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> version{};

  ListPublishedServicesResponseBodyData() {}

  explicit ListPublishedServicesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (group2Ip) {
      res["Group2Ip"] = boost::any(*group2Ip);
    }
    if (groups) {
      res["Groups"] = boost::any(*groups);
    }
    if (ips) {
      res["Ips"] = boost::any(*ips);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Group2Ip") != m.end() && !m["Group2Ip"].empty()) {
      group2Ip = make_shared<string>(boost::any_cast<string>(m["Group2Ip"]));
    }
    if (m.find("Groups") != m.end() && !m["Groups"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Groups"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Groups"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      groups = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Ips") != m.end() && !m["Ips"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Ips"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ips"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ips = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~ListPublishedServicesResponseBodyData() = default;
};
class ListPublishedServicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListPublishedServicesResponseBodyData>> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  ListPublishedServicesResponseBody() {}

  explicit ListPublishedServicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListPublishedServicesResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPublishedServicesResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListPublishedServicesResponseBodyData>>(expect1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~ListPublishedServicesResponseBody() = default;
};
class ListPublishedServicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPublishedServicesResponseBody> body{};

  ListPublishedServicesResponse() {}

  explicit ListPublishedServicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPublishedServicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPublishedServicesResponseBody>(model1);
      }
    }
  }


  virtual ~ListPublishedServicesResponse() = default;
};
class ListSecretsRequest : public Darabonba::Model {
public:
  shared_ptr<string> namespaceId{};

  ListSecretsRequest() {}

  explicit ListSecretsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
  }


  virtual ~ListSecretsRequest() = default;
};
class ListSecretsResponseBodyDataSecretsRelateApps : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};

  ListSecretsResponseBodyDataSecretsRelateApps() {}

  explicit ListSecretsResponseBodyDataSecretsRelateApps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
  }


  virtual ~ListSecretsResponseBodyDataSecretsRelateApps() = default;
};
class ListSecretsResponseBodyDataSecrets : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> namespaceId{};
  shared_ptr<vector<ListSecretsResponseBodyDataSecretsRelateApps>> relateApps{};
  shared_ptr<long> secretId{};
  shared_ptr<string> secretName{};
  shared_ptr<string> secretType{};
  shared_ptr<long> updateTime{};

  ListSecretsResponseBodyDataSecrets() {}

  explicit ListSecretsResponseBodyDataSecrets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (relateApps) {
      vector<boost::any> temp1;
      for(auto item1:*relateApps){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RelateApps"] = boost::any(temp1);
    }
    if (secretId) {
      res["SecretId"] = boost::any(*secretId);
    }
    if (secretName) {
      res["SecretName"] = boost::any(*secretName);
    }
    if (secretType) {
      res["SecretType"] = boost::any(*secretType);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("RelateApps") != m.end() && !m["RelateApps"].empty()) {
      if (typeid(vector<boost::any>) == m["RelateApps"].type()) {
        vector<ListSecretsResponseBodyDataSecretsRelateApps> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RelateApps"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSecretsResponseBodyDataSecretsRelateApps model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        relateApps = make_shared<vector<ListSecretsResponseBodyDataSecretsRelateApps>>(expect1);
      }
    }
    if (m.find("SecretId") != m.end() && !m["SecretId"].empty()) {
      secretId = make_shared<long>(boost::any_cast<long>(m["SecretId"]));
    }
    if (m.find("SecretName") != m.end() && !m["SecretName"].empty()) {
      secretName = make_shared<string>(boost::any_cast<string>(m["SecretName"]));
    }
    if (m.find("SecretType") != m.end() && !m["SecretType"].empty()) {
      secretType = make_shared<string>(boost::any_cast<string>(m["SecretType"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~ListSecretsResponseBodyDataSecrets() = default;
};
class ListSecretsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListSecretsResponseBodyDataSecrets>> secrets{};

  ListSecretsResponseBodyData() {}

  explicit ListSecretsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (secrets) {
      vector<boost::any> temp1;
      for(auto item1:*secrets){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Secrets"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Secrets") != m.end() && !m["Secrets"].empty()) {
      if (typeid(vector<boost::any>) == m["Secrets"].type()) {
        vector<ListSecretsResponseBodyDataSecrets> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Secrets"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSecretsResponseBodyDataSecrets model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        secrets = make_shared<vector<ListSecretsResponseBodyDataSecrets>>(expect1);
      }
    }
  }


  virtual ~ListSecretsResponseBodyData() = default;
};
class ListSecretsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListSecretsResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  ListSecretsResponseBody() {}

  explicit ListSecretsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListSecretsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListSecretsResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~ListSecretsResponseBody() = default;
};
class ListSecretsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSecretsResponseBody> body{};

  ListSecretsResponse() {}

  explicit ListSecretsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSecretsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSecretsResponseBody>(model1);
      }
    }
  }


  virtual ~ListSecretsResponse() = default;
};
class ListSwimmingLaneGatewayRoutesRequest : public Darabonba::Model {
public:
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> namespaceId{};

  ListSwimmingLaneGatewayRoutesRequest() {}

  explicit ListSwimmingLaneGatewayRoutesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
  }


  virtual ~ListSwimmingLaneGatewayRoutesRequest() = default;
};
class ListSwimmingLaneGatewayRoutesResponseBodyDataRoutePredicatePathPredicate : public Darabonba::Model {
public:
  shared_ptr<string> path{};
  shared_ptr<string> type{};

  ListSwimmingLaneGatewayRoutesResponseBodyDataRoutePredicatePathPredicate() {}

  explicit ListSwimmingLaneGatewayRoutesResponseBodyDataRoutePredicatePathPredicate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListSwimmingLaneGatewayRoutesResponseBodyDataRoutePredicatePathPredicate() = default;
};
class ListSwimmingLaneGatewayRoutesResponseBodyDataRoutePredicate : public Darabonba::Model {
public:
  shared_ptr<ListSwimmingLaneGatewayRoutesResponseBodyDataRoutePredicatePathPredicate> pathPredicate{};

  ListSwimmingLaneGatewayRoutesResponseBodyDataRoutePredicate() {}

  explicit ListSwimmingLaneGatewayRoutesResponseBodyDataRoutePredicate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pathPredicate) {
      res["PathPredicate"] = pathPredicate ? boost::any(pathPredicate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PathPredicate") != m.end() && !m["PathPredicate"].empty()) {
      if (typeid(map<string, boost::any>) == m["PathPredicate"].type()) {
        ListSwimmingLaneGatewayRoutesResponseBodyDataRoutePredicatePathPredicate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PathPredicate"]));
        pathPredicate = make_shared<ListSwimmingLaneGatewayRoutesResponseBodyDataRoutePredicatePathPredicate>(model1);
      }
    }
  }


  virtual ~ListSwimmingLaneGatewayRoutesResponseBodyDataRoutePredicate() = default;
};
class ListSwimmingLaneGatewayRoutesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> routeId{};
  shared_ptr<string> routeName{};
  shared_ptr<ListSwimmingLaneGatewayRoutesResponseBodyDataRoutePredicate> routePredicate{};

  ListSwimmingLaneGatewayRoutesResponseBodyData() {}

  explicit ListSwimmingLaneGatewayRoutesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (routeId) {
      res["RouteId"] = boost::any(*routeId);
    }
    if (routeName) {
      res["RouteName"] = boost::any(*routeName);
    }
    if (routePredicate) {
      res["RoutePredicate"] = routePredicate ? boost::any(routePredicate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RouteId") != m.end() && !m["RouteId"].empty()) {
      routeId = make_shared<long>(boost::any_cast<long>(m["RouteId"]));
    }
    if (m.find("RouteName") != m.end() && !m["RouteName"].empty()) {
      routeName = make_shared<string>(boost::any_cast<string>(m["RouteName"]));
    }
    if (m.find("RoutePredicate") != m.end() && !m["RoutePredicate"].empty()) {
      if (typeid(map<string, boost::any>) == m["RoutePredicate"].type()) {
        ListSwimmingLaneGatewayRoutesResponseBodyDataRoutePredicate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RoutePredicate"]));
        routePredicate = make_shared<ListSwimmingLaneGatewayRoutesResponseBodyDataRoutePredicate>(model1);
      }
    }
  }


  virtual ~ListSwimmingLaneGatewayRoutesResponseBodyData() = default;
};
class ListSwimmingLaneGatewayRoutesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListSwimmingLaneGatewayRoutesResponseBodyData>> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  ListSwimmingLaneGatewayRoutesResponseBody() {}

  explicit ListSwimmingLaneGatewayRoutesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListSwimmingLaneGatewayRoutesResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSwimmingLaneGatewayRoutesResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListSwimmingLaneGatewayRoutesResponseBodyData>>(expect1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~ListSwimmingLaneGatewayRoutesResponseBody() = default;
};
class ListSwimmingLaneGatewayRoutesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSwimmingLaneGatewayRoutesResponseBody> body{};

  ListSwimmingLaneGatewayRoutesResponse() {}

  explicit ListSwimmingLaneGatewayRoutesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSwimmingLaneGatewayRoutesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSwimmingLaneGatewayRoutesResponseBody>(model1);
      }
    }
  }


  virtual ~ListSwimmingLaneGatewayRoutesResponse() = default;
};
class ListSwimmingLaneGroupTagsRequest : public Darabonba::Model {
public:
  shared_ptr<long> groupId{};
  shared_ptr<string> namespaceId{};

  ListSwimmingLaneGroupTagsRequest() {}

  explicit ListSwimmingLaneGroupTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
  }


  virtual ~ListSwimmingLaneGroupTagsRequest() = default;
};
class ListSwimmingLaneGroupTagsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> metadata{};
  shared_ptr<string> tag{};

  ListSwimmingLaneGroupTagsResponseBodyData() {}

  explicit ListSwimmingLaneGroupTagsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metadata) {
      res["Metadata"] = boost::any(*metadata);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Metadata") != m.end() && !m["Metadata"].empty()) {
      metadata = make_shared<string>(boost::any_cast<string>(m["Metadata"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
  }


  virtual ~ListSwimmingLaneGroupTagsResponseBodyData() = default;
};
class ListSwimmingLaneGroupTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListSwimmingLaneGroupTagsResponseBodyData>> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  ListSwimmingLaneGroupTagsResponseBody() {}

  explicit ListSwimmingLaneGroupTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListSwimmingLaneGroupTagsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSwimmingLaneGroupTagsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListSwimmingLaneGroupTagsResponseBodyData>>(expect1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~ListSwimmingLaneGroupTagsResponseBody() = default;
};
class ListSwimmingLaneGroupTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSwimmingLaneGroupTagsResponseBody> body{};

  ListSwimmingLaneGroupTagsResponse() {}

  explicit ListSwimmingLaneGroupTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSwimmingLaneGroupTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSwimmingLaneGroupTagsResponseBody>(model1);
      }
    }
  }


  virtual ~ListSwimmingLaneGroupTagsResponse() = default;
};
class ListTagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceIds{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tags{};

  ListTagResourcesRequest() {}

  explicit ListTagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceIds) {
      res["ResourceIds"] = boost::any(*resourceIds);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceIds") != m.end() && !m["ResourceIds"].empty()) {
      resourceIds = make_shared<string>(boost::any_cast<string>(m["ResourceIds"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
  }


  virtual ~ListTagResourcesRequest() = default;
};
class ListTagResourcesResponseBodyDataTagResources : public Darabonba::Model {
public:
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  ListTagResourcesResponseBodyDataTagResources() {}

  explicit ListTagResourcesResponseBodyDataTagResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~ListTagResourcesResponseBodyDataTagResources() = default;
};
class ListTagResourcesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<vector<ListTagResourcesResponseBodyDataTagResources>> tagResources{};

  ListTagResourcesResponseBodyData() {}

  explicit ListTagResourcesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (tagResources) {
      vector<boost::any> temp1;
      for(auto item1:*tagResources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagResources"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("TagResources") != m.end() && !m["TagResources"].empty()) {
      if (typeid(vector<boost::any>) == m["TagResources"].type()) {
        vector<ListTagResourcesResponseBodyDataTagResources> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagResources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagResourcesResponseBodyDataTagResources model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagResources = make_shared<vector<ListTagResourcesResponseBodyDataTagResources>>(expect1);
      }
    }
  }


  virtual ~ListTagResourcesResponseBodyData() = default;
};
class ListTagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListTagResourcesResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  ListTagResourcesResponseBody() {}

  explicit ListTagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListTagResourcesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListTagResourcesResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~ListTagResourcesResponseBody() = default;
};
class ListTagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTagResourcesResponseBody> body{};

  ListTagResourcesResponse() {}

  explicit ListTagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~ListTagResourcesResponse() = default;
};
class ListWebApplicationInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<string> limit{};
  shared_ptr<string> namespaceId{};
  shared_ptr<long> startTime{};
  shared_ptr<vector<string>> statuses{};
  shared_ptr<vector<string>> versionIds{};

  ListWebApplicationInstancesRequest() {}

  explicit ListWebApplicationInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (limit) {
      res["Limit"] = boost::any(*limit);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (statuses) {
      res["Statuses"] = boost::any(*statuses);
    }
    if (versionIds) {
      res["VersionIds"] = boost::any(*versionIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Limit") != m.end() && !m["Limit"].empty()) {
      limit = make_shared<string>(boost::any_cast<string>(m["Limit"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Statuses") != m.end() && !m["Statuses"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Statuses"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Statuses"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      statuses = make_shared<vector<string>>(toVec1);
    }
    if (m.find("VersionIds") != m.end() && !m["VersionIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VersionIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VersionIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      versionIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListWebApplicationInstancesRequest() = default;
};
class ListWebApplicationInstancesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceIdsShrink{};
  shared_ptr<string> limit{};
  shared_ptr<string> namespaceId{};
  shared_ptr<long> startTime{};
  shared_ptr<string> statusesShrink{};
  shared_ptr<string> versionIdsShrink{};

  ListWebApplicationInstancesShrinkRequest() {}

  explicit ListWebApplicationInstancesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceIdsShrink) {
      res["InstanceIds"] = boost::any(*instanceIdsShrink);
    }
    if (limit) {
      res["Limit"] = boost::any(*limit);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (statusesShrink) {
      res["Statuses"] = boost::any(*statusesShrink);
    }
    if (versionIdsShrink) {
      res["VersionIds"] = boost::any(*versionIdsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIdsShrink = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("Limit") != m.end() && !m["Limit"].empty()) {
      limit = make_shared<string>(boost::any_cast<string>(m["Limit"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Statuses") != m.end() && !m["Statuses"].empty()) {
      statusesShrink = make_shared<string>(boost::any_cast<string>(m["Statuses"]));
    }
    if (m.find("VersionIds") != m.end() && !m["VersionIds"].empty()) {
      versionIdsShrink = make_shared<string>(boost::any_cast<string>(m["VersionIds"]));
    }
  }


  virtual ~ListWebApplicationInstancesShrinkRequest() = default;
};
class ListWebApplicationInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListWebApplicationInstancesBody> body{};

  ListWebApplicationInstancesResponse() {}

  explicit ListWebApplicationInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListWebApplicationInstancesBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListWebApplicationInstancesBody>(model1);
      }
    }
  }


  virtual ~ListWebApplicationInstancesResponse() = default;
};
class ListWebApplicationRevisionsRequest : public Darabonba::Model {
public:
  shared_ptr<long> limit{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> nextToken{};

  ListWebApplicationRevisionsRequest() {}

  explicit ListWebApplicationRevisionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (limit) {
      res["Limit"] = boost::any(*limit);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Limit") != m.end() && !m["Limit"].empty()) {
      limit = make_shared<long>(boost::any_cast<long>(m["Limit"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
  }


  virtual ~ListWebApplicationRevisionsRequest() = default;
};
class ListWebApplicationRevisionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListWebApplicationRevisionsBody> body{};

  ListWebApplicationRevisionsResponse() {}

  explicit ListWebApplicationRevisionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListWebApplicationRevisionsBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListWebApplicationRevisionsBody>(model1);
      }
    }
  }


  virtual ~ListWebApplicationRevisionsResponse() = default;
};
class ListWebApplicationsRequest : public Darabonba::Model {
public:
  shared_ptr<long> limit{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> prefix{};

  ListWebApplicationsRequest() {}

  explicit ListWebApplicationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (limit) {
      res["Limit"] = boost::any(*limit);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (prefix) {
      res["Prefix"] = boost::any(*prefix);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Limit") != m.end() && !m["Limit"].empty()) {
      limit = make_shared<long>(boost::any_cast<long>(m["Limit"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Prefix") != m.end() && !m["Prefix"].empty()) {
      prefix = make_shared<string>(boost::any_cast<string>(m["Prefix"]));
    }
  }


  virtual ~ListWebApplicationsRequest() = default;
};
class ListWebApplicationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListWebApplicationsBody> body{};

  ListWebApplicationsResponse() {}

  explicit ListWebApplicationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListWebApplicationsBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListWebApplicationsBody>(model1);
      }
    }
  }


  virtual ~ListWebApplicationsResponse() = default;
};
class ListWebCustomDomainsRequest : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};
  shared_ptr<long> limit{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> prefix{};

  ListWebCustomDomainsRequest() {}

  explicit ListWebCustomDomainsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (limit) {
      res["Limit"] = boost::any(*limit);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (prefix) {
      res["Prefix"] = boost::any(*prefix);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("Limit") != m.end() && !m["Limit"].empty()) {
      limit = make_shared<long>(boost::any_cast<long>(m["Limit"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Prefix") != m.end() && !m["Prefix"].empty()) {
      prefix = make_shared<string>(boost::any_cast<string>(m["Prefix"]));
    }
  }


  virtual ~ListWebCustomDomainsRequest() = default;
};
class ListWebCustomDomainsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListWebCustomDomainBody> body{};

  ListWebCustomDomainsResponse() {}

  explicit ListWebCustomDomainsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListWebCustomDomainBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListWebCustomDomainBody>(model1);
      }
    }
  }


  virtual ~ListWebCustomDomainsResponse() = default;
};
class OpenSaeServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> orderId{};
  shared_ptr<string> requestId{};

  OpenSaeServiceResponseBody() {}

  explicit OpenSaeServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~OpenSaeServiceResponseBody() = default;
};
class OpenSaeServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OpenSaeServiceResponseBody> body{};

  OpenSaeServiceResponse() {}

  explicit OpenSaeServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OpenSaeServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OpenSaeServiceResponseBody>(model1);
      }
    }
  }


  virtual ~OpenSaeServiceResponse() = default;
};
class PublishWebApplicationRevisionRequest : public Darabonba::Model {
public:
  shared_ptr<string> namespaceId{};
  shared_ptr<PublishWebApplicationRevisionInput> body{};

  PublishWebApplicationRevisionRequest() {}

  explicit PublishWebApplicationRevisionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PublishWebApplicationRevisionInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PublishWebApplicationRevisionInput>(model1);
      }
    }
  }


  virtual ~PublishWebApplicationRevisionRequest() = default;
};
class PublishWebApplicationRevisionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<WebApplicationRevisionBody> body{};

  PublishWebApplicationRevisionResponse() {}

  explicit PublishWebApplicationRevisionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        WebApplicationRevisionBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<WebApplicationRevisionBody>(model1);
      }
    }
  }


  virtual ~PublishWebApplicationRevisionResponse() = default;
};
class QueryResourceStaticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  QueryResourceStaticsRequest() {}

  explicit QueryResourceStaticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~QueryResourceStaticsRequest() = default;
};
class QueryResourceStaticsResponseBodyDataRealTimeRes : public Darabonba::Model {
public:
  shared_ptr<double> cpu{};
  shared_ptr<double> ephemeralStorage{};
  shared_ptr<double> memory{};

  QueryResourceStaticsResponseBodyDataRealTimeRes() {}

  explicit QueryResourceStaticsResponseBodyDataRealTimeRes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (ephemeralStorage) {
      res["EphemeralStorage"] = boost::any(*ephemeralStorage);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<double>(boost::any_cast<double>(m["Cpu"]));
    }
    if (m.find("EphemeralStorage") != m.end() && !m["EphemeralStorage"].empty()) {
      ephemeralStorage = make_shared<double>(boost::any_cast<double>(m["EphemeralStorage"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<double>(boost::any_cast<double>(m["Memory"]));
    }
  }


  virtual ~QueryResourceStaticsResponseBodyDataRealTimeRes() = default;
};
class QueryResourceStaticsResponseBodyDataSummary : public Darabonba::Model {
public:
  shared_ptr<double> activeCpu{};
  shared_ptr<double> cpu{};
  shared_ptr<double> cu{};
  shared_ptr<double> ephemeralStorage{};
  shared_ptr<double> gpuA10{};
  shared_ptr<double> gpuPpu810e{};
  shared_ptr<double> idleCpu{};
  shared_ptr<double> memory{};

  QueryResourceStaticsResponseBodyDataSummary() {}

  explicit QueryResourceStaticsResponseBodyDataSummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activeCpu) {
      res["ActiveCpu"] = boost::any(*activeCpu);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (cu) {
      res["Cu"] = boost::any(*cu);
    }
    if (ephemeralStorage) {
      res["EphemeralStorage"] = boost::any(*ephemeralStorage);
    }
    if (gpuA10) {
      res["GpuA10"] = boost::any(*gpuA10);
    }
    if (gpuPpu810e) {
      res["GpuPpu810e"] = boost::any(*gpuPpu810e);
    }
    if (idleCpu) {
      res["IdleCpu"] = boost::any(*idleCpu);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActiveCpu") != m.end() && !m["ActiveCpu"].empty()) {
      activeCpu = make_shared<double>(boost::any_cast<double>(m["ActiveCpu"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<double>(boost::any_cast<double>(m["Cpu"]));
    }
    if (m.find("Cu") != m.end() && !m["Cu"].empty()) {
      cu = make_shared<double>(boost::any_cast<double>(m["Cu"]));
    }
    if (m.find("EphemeralStorage") != m.end() && !m["EphemeralStorage"].empty()) {
      ephemeralStorage = make_shared<double>(boost::any_cast<double>(m["EphemeralStorage"]));
    }
    if (m.find("GpuA10") != m.end() && !m["GpuA10"].empty()) {
      gpuA10 = make_shared<double>(boost::any_cast<double>(m["GpuA10"]));
    }
    if (m.find("GpuPpu810e") != m.end() && !m["GpuPpu810e"].empty()) {
      gpuPpu810e = make_shared<double>(boost::any_cast<double>(m["GpuPpu810e"]));
    }
    if (m.find("IdleCpu") != m.end() && !m["IdleCpu"].empty()) {
      idleCpu = make_shared<double>(boost::any_cast<double>(m["IdleCpu"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<double>(boost::any_cast<double>(m["Memory"]));
    }
  }


  virtual ~QueryResourceStaticsResponseBodyDataSummary() = default;
};
class QueryResourceStaticsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<QueryResourceStaticsResponseBodyDataRealTimeRes> realTimeRes{};
  shared_ptr<QueryResourceStaticsResponseBodyDataSummary> summary{};

  QueryResourceStaticsResponseBodyData() {}

  explicit QueryResourceStaticsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (realTimeRes) {
      res["RealTimeRes"] = realTimeRes ? boost::any(realTimeRes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (summary) {
      res["Summary"] = summary ? boost::any(summary->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RealTimeRes") != m.end() && !m["RealTimeRes"].empty()) {
      if (typeid(map<string, boost::any>) == m["RealTimeRes"].type()) {
        QueryResourceStaticsResponseBodyDataRealTimeRes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RealTimeRes"]));
        realTimeRes = make_shared<QueryResourceStaticsResponseBodyDataRealTimeRes>(model1);
      }
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      if (typeid(map<string, boost::any>) == m["Summary"].type()) {
        QueryResourceStaticsResponseBodyDataSummary model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Summary"]));
        summary = make_shared<QueryResourceStaticsResponseBodyDataSummary>(model1);
      }
    }
  }


  virtual ~QueryResourceStaticsResponseBodyData() = default;
};
class QueryResourceStaticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryResourceStaticsResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  QueryResourceStaticsResponseBody() {}

  explicit QueryResourceStaticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryResourceStaticsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryResourceStaticsResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~QueryResourceStaticsResponseBody() = default;
};
class QueryResourceStaticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryResourceStaticsResponseBody> body{};

  QueryResourceStaticsResponse() {}

  explicit QueryResourceStaticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryResourceStaticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryResourceStaticsResponseBody>(model1);
      }
    }
  }


  virtual ~QueryResourceStaticsResponse() = default;
};
class ReduceApplicationCapacityByInstanceIdsRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> instanceIds{};

  ReduceApplicationCapacityByInstanceIdsRequest() {}

  explicit ReduceApplicationCapacityByInstanceIdsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
  }


  virtual ~ReduceApplicationCapacityByInstanceIdsRequest() = default;
};
class ReduceApplicationCapacityByInstanceIdsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};

  ReduceApplicationCapacityByInstanceIdsResponseBodyData() {}

  explicit ReduceApplicationCapacityByInstanceIdsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
  }


  virtual ~ReduceApplicationCapacityByInstanceIdsResponseBodyData() = default;
};
class ReduceApplicationCapacityByInstanceIdsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ReduceApplicationCapacityByInstanceIdsResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  ReduceApplicationCapacityByInstanceIdsResponseBody() {}

  explicit ReduceApplicationCapacityByInstanceIdsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ReduceApplicationCapacityByInstanceIdsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ReduceApplicationCapacityByInstanceIdsResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~ReduceApplicationCapacityByInstanceIdsResponseBody() = default;
};
class ReduceApplicationCapacityByInstanceIdsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ReduceApplicationCapacityByInstanceIdsResponseBody> body{};

  ReduceApplicationCapacityByInstanceIdsResponse() {}

  explicit ReduceApplicationCapacityByInstanceIdsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReduceApplicationCapacityByInstanceIdsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReduceApplicationCapacityByInstanceIdsResponseBody>(model1);
      }
    }
  }


  virtual ~ReduceApplicationCapacityByInstanceIdsResponse() = default;
};
class RescaleApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<bool> autoEnableApplicationScalingRule{};
  shared_ptr<long> minReadyInstanceRatio{};
  shared_ptr<long> minReadyInstances{};
  shared_ptr<long> replicas{};

  RescaleApplicationRequest() {}

  explicit RescaleApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (autoEnableApplicationScalingRule) {
      res["AutoEnableApplicationScalingRule"] = boost::any(*autoEnableApplicationScalingRule);
    }
    if (minReadyInstanceRatio) {
      res["MinReadyInstanceRatio"] = boost::any(*minReadyInstanceRatio);
    }
    if (minReadyInstances) {
      res["MinReadyInstances"] = boost::any(*minReadyInstances);
    }
    if (replicas) {
      res["Replicas"] = boost::any(*replicas);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AutoEnableApplicationScalingRule") != m.end() && !m["AutoEnableApplicationScalingRule"].empty()) {
      autoEnableApplicationScalingRule = make_shared<bool>(boost::any_cast<bool>(m["AutoEnableApplicationScalingRule"]));
    }
    if (m.find("MinReadyInstanceRatio") != m.end() && !m["MinReadyInstanceRatio"].empty()) {
      minReadyInstanceRatio = make_shared<long>(boost::any_cast<long>(m["MinReadyInstanceRatio"]));
    }
    if (m.find("MinReadyInstances") != m.end() && !m["MinReadyInstances"].empty()) {
      minReadyInstances = make_shared<long>(boost::any_cast<long>(m["MinReadyInstances"]));
    }
    if (m.find("Replicas") != m.end() && !m["Replicas"].empty()) {
      replicas = make_shared<long>(boost::any_cast<long>(m["Replicas"]));
    }
  }


  virtual ~RescaleApplicationRequest() = default;
};
class RescaleApplicationResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};

  RescaleApplicationResponseBodyData() {}

  explicit RescaleApplicationResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
  }


  virtual ~RescaleApplicationResponseBodyData() = default;
};
class RescaleApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<RescaleApplicationResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  RescaleApplicationResponseBody() {}

  explicit RescaleApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        RescaleApplicationResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<RescaleApplicationResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RescaleApplicationResponseBody() = default;
};
class RescaleApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RescaleApplicationResponseBody> body{};

  RescaleApplicationResponse() {}

  explicit RescaleApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RescaleApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RescaleApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~RescaleApplicationResponse() = default;
};
class RescaleApplicationVerticallyRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> cpu{};
  shared_ptr<string> diskSize{};
  shared_ptr<string> memory{};
  shared_ptr<bool> autoEnableApplicationScalingRule{};
  shared_ptr<long> minReadyInstanceRatio{};
  shared_ptr<long> minReadyInstances{};

  RescaleApplicationVerticallyRequest() {}

  explicit RescaleApplicationVerticallyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (diskSize) {
      res["DiskSize"] = boost::any(*diskSize);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (autoEnableApplicationScalingRule) {
      res["autoEnableApplicationScalingRule"] = boost::any(*autoEnableApplicationScalingRule);
    }
    if (minReadyInstanceRatio) {
      res["minReadyInstanceRatio"] = boost::any(*minReadyInstanceRatio);
    }
    if (minReadyInstances) {
      res["minReadyInstances"] = boost::any(*minReadyInstances);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<string>(boost::any_cast<string>(m["Cpu"]));
    }
    if (m.find("DiskSize") != m.end() && !m["DiskSize"].empty()) {
      diskSize = make_shared<string>(boost::any_cast<string>(m["DiskSize"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<string>(boost::any_cast<string>(m["Memory"]));
    }
    if (m.find("autoEnableApplicationScalingRule") != m.end() && !m["autoEnableApplicationScalingRule"].empty()) {
      autoEnableApplicationScalingRule = make_shared<bool>(boost::any_cast<bool>(m["autoEnableApplicationScalingRule"]));
    }
    if (m.find("minReadyInstanceRatio") != m.end() && !m["minReadyInstanceRatio"].empty()) {
      minReadyInstanceRatio = make_shared<long>(boost::any_cast<long>(m["minReadyInstanceRatio"]));
    }
    if (m.find("minReadyInstances") != m.end() && !m["minReadyInstances"].empty()) {
      minReadyInstances = make_shared<long>(boost::any_cast<long>(m["minReadyInstances"]));
    }
  }


  virtual ~RescaleApplicationVerticallyRequest() = default;
};
class RescaleApplicationVerticallyResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};

  RescaleApplicationVerticallyResponseBodyData() {}

  explicit RescaleApplicationVerticallyResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
  }


  virtual ~RescaleApplicationVerticallyResponseBodyData() = default;
};
class RescaleApplicationVerticallyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<RescaleApplicationVerticallyResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  RescaleApplicationVerticallyResponseBody() {}

  explicit RescaleApplicationVerticallyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        RescaleApplicationVerticallyResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<RescaleApplicationVerticallyResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~RescaleApplicationVerticallyResponseBody() = default;
};
class RescaleApplicationVerticallyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RescaleApplicationVerticallyResponseBody> body{};

  RescaleApplicationVerticallyResponse() {}

  explicit RescaleApplicationVerticallyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RescaleApplicationVerticallyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RescaleApplicationVerticallyResponseBody>(model1);
      }
    }
  }


  virtual ~RescaleApplicationVerticallyResponse() = default;
};
class RestartApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<bool> autoEnableApplicationScalingRule{};
  shared_ptr<long> minReadyInstanceRatio{};
  shared_ptr<long> minReadyInstances{};

  RestartApplicationRequest() {}

  explicit RestartApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (autoEnableApplicationScalingRule) {
      res["AutoEnableApplicationScalingRule"] = boost::any(*autoEnableApplicationScalingRule);
    }
    if (minReadyInstanceRatio) {
      res["MinReadyInstanceRatio"] = boost::any(*minReadyInstanceRatio);
    }
    if (minReadyInstances) {
      res["MinReadyInstances"] = boost::any(*minReadyInstances);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AutoEnableApplicationScalingRule") != m.end() && !m["AutoEnableApplicationScalingRule"].empty()) {
      autoEnableApplicationScalingRule = make_shared<bool>(boost::any_cast<bool>(m["AutoEnableApplicationScalingRule"]));
    }
    if (m.find("MinReadyInstanceRatio") != m.end() && !m["MinReadyInstanceRatio"].empty()) {
      minReadyInstanceRatio = make_shared<long>(boost::any_cast<long>(m["MinReadyInstanceRatio"]));
    }
    if (m.find("MinReadyInstances") != m.end() && !m["MinReadyInstances"].empty()) {
      minReadyInstances = make_shared<long>(boost::any_cast<long>(m["MinReadyInstances"]));
    }
  }


  virtual ~RestartApplicationRequest() = default;
};
class RestartApplicationResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};

  RestartApplicationResponseBodyData() {}

  explicit RestartApplicationResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
  }


  virtual ~RestartApplicationResponseBodyData() = default;
};
class RestartApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<RestartApplicationResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  RestartApplicationResponseBody() {}

  explicit RestartApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        RestartApplicationResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<RestartApplicationResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~RestartApplicationResponseBody() = default;
};
class RestartApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RestartApplicationResponseBody> body{};

  RestartApplicationResponse() {}

  explicit RestartApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RestartApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RestartApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~RestartApplicationResponse() = default;
};
class RestartInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> instanceIds{};

  RestartInstancesRequest() {}

  explicit RestartInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
  }


  virtual ~RestartInstancesRequest() = default;
};
class RestartInstancesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};

  RestartInstancesResponseBodyData() {}

  explicit RestartInstancesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
  }


  virtual ~RestartInstancesResponseBodyData() = default;
};
class RestartInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<RestartInstancesResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  RestartInstancesResponseBody() {}

  explicit RestartInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        RestartInstancesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<RestartInstancesResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~RestartInstancesResponseBody() = default;
};
class RestartInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RestartInstancesResponseBody> body{};

  RestartInstancesResponse() {}

  explicit RestartInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RestartInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RestartInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~RestartInstancesResponse() = default;
};
class RollbackApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> autoEnableApplicationScalingRule{};
  shared_ptr<long> batchWaitTime{};
  shared_ptr<long> minReadyInstanceRatio{};
  shared_ptr<long> minReadyInstances{};
  shared_ptr<string> updateStrategy{};
  shared_ptr<string> versionId{};

  RollbackApplicationRequest() {}

  explicit RollbackApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (autoEnableApplicationScalingRule) {
      res["AutoEnableApplicationScalingRule"] = boost::any(*autoEnableApplicationScalingRule);
    }
    if (batchWaitTime) {
      res["BatchWaitTime"] = boost::any(*batchWaitTime);
    }
    if (minReadyInstanceRatio) {
      res["MinReadyInstanceRatio"] = boost::any(*minReadyInstanceRatio);
    }
    if (minReadyInstances) {
      res["MinReadyInstances"] = boost::any(*minReadyInstances);
    }
    if (updateStrategy) {
      res["UpdateStrategy"] = boost::any(*updateStrategy);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AutoEnableApplicationScalingRule") != m.end() && !m["AutoEnableApplicationScalingRule"].empty()) {
      autoEnableApplicationScalingRule = make_shared<string>(boost::any_cast<string>(m["AutoEnableApplicationScalingRule"]));
    }
    if (m.find("BatchWaitTime") != m.end() && !m["BatchWaitTime"].empty()) {
      batchWaitTime = make_shared<long>(boost::any_cast<long>(m["BatchWaitTime"]));
    }
    if (m.find("MinReadyInstanceRatio") != m.end() && !m["MinReadyInstanceRatio"].empty()) {
      minReadyInstanceRatio = make_shared<long>(boost::any_cast<long>(m["MinReadyInstanceRatio"]));
    }
    if (m.find("MinReadyInstances") != m.end() && !m["MinReadyInstances"].empty()) {
      minReadyInstances = make_shared<long>(boost::any_cast<long>(m["MinReadyInstances"]));
    }
    if (m.find("UpdateStrategy") != m.end() && !m["UpdateStrategy"].empty()) {
      updateStrategy = make_shared<string>(boost::any_cast<string>(m["UpdateStrategy"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
  }


  virtual ~RollbackApplicationRequest() = default;
};
class RollbackApplicationResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};
  shared_ptr<bool> isNeedApproval{};

  RollbackApplicationResponseBodyData() {}

  explicit RollbackApplicationResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (isNeedApproval) {
      res["IsNeedApproval"] = boost::any(*isNeedApproval);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("IsNeedApproval") != m.end() && !m["IsNeedApproval"].empty()) {
      isNeedApproval = make_shared<bool>(boost::any_cast<bool>(m["IsNeedApproval"]));
    }
  }


  virtual ~RollbackApplicationResponseBodyData() = default;
};
class RollbackApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<RollbackApplicationResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  RollbackApplicationResponseBody() {}

  explicit RollbackApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        RollbackApplicationResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<RollbackApplicationResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~RollbackApplicationResponseBody() = default;
};
class RollbackApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RollbackApplicationResponseBody> body{};

  RollbackApplicationResponse() {}

  explicit RollbackApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RollbackApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RollbackApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~RollbackApplicationResponse() = default;
};
class StartApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  StartApplicationRequest() {}

  explicit StartApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~StartApplicationRequest() = default;
};
class StartApplicationResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};

  StartApplicationResponseBodyData() {}

  explicit StartApplicationResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
  }


  virtual ~StartApplicationResponseBodyData() = default;
};
class StartApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<StartApplicationResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  StartApplicationResponseBody() {}

  explicit StartApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        StartApplicationResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<StartApplicationResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~StartApplicationResponseBody() = default;
};
class StartApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartApplicationResponseBody> body{};

  StartApplicationResponse() {}

  explicit StartApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~StartApplicationResponse() = default;
};
class StartWebApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> namespaceId{};

  StartWebApplicationRequest() {}

  explicit StartWebApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
  }


  virtual ~StartWebApplicationRequest() = default;
};
class StartWebApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<WebApplicationBody> body{};

  StartWebApplicationResponse() {}

  explicit StartWebApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        WebApplicationBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<WebApplicationBody>(model1);
      }
    }
  }


  virtual ~StartWebApplicationResponse() = default;
};
class StopApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  StopApplicationRequest() {}

  explicit StopApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~StopApplicationRequest() = default;
};
class StopApplicationResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};

  StopApplicationResponseBodyData() {}

  explicit StopApplicationResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
  }


  virtual ~StopApplicationResponseBodyData() = default;
};
class StopApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<StopApplicationResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  StopApplicationResponseBody() {}

  explicit StopApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        StopApplicationResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<StopApplicationResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~StopApplicationResponseBody() = default;
};
class StopApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopApplicationResponseBody> body{};

  StopApplicationResponse() {}

  explicit StopApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~StopApplicationResponse() = default;
};
class StopWebApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> namespaceId{};

  StopWebApplicationRequest() {}

  explicit StopWebApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
  }


  virtual ~StopWebApplicationRequest() = default;
};
class StopWebApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<WebApplicationBody> body{};

  StopWebApplicationResponse() {}

  explicit StopWebApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        WebApplicationBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<WebApplicationBody>(model1);
      }
    }
  }


  virtual ~StopWebApplicationResponse() = default;
};
class SuspendJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<bool> suspend{};

  SuspendJobRequest() {}

  explicit SuspendJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (suspend) {
      res["Suspend"] = boost::any(*suspend);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Suspend") != m.end() && !m["Suspend"].empty()) {
      suspend = make_shared<bool>(boost::any_cast<bool>(m["Suspend"]));
    }
  }


  virtual ~SuspendJobRequest() = default;
};
class SuspendJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  SuspendJobResponseBody() {}

  explicit SuspendJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~SuspendJobResponseBody() = default;
};
class SuspendJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SuspendJobResponseBody> body{};

  SuspendJobResponse() {}

  explicit SuspendJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SuspendJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SuspendJobResponseBody>(model1);
      }
    }
  }


  virtual ~SuspendJobResponse() = default;
};
class TagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceIds{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tags{};

  TagResourcesRequest() {}

  explicit TagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceIds) {
      res["ResourceIds"] = boost::any(*resourceIds);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceIds") != m.end() && !m["ResourceIds"].empty()) {
      resourceIds = make_shared<string>(boost::any_cast<string>(m["ResourceIds"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
  }


  virtual ~TagResourcesRequest() = default;
};
class TagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<bool> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  TagResourcesResponseBody() {}

  explicit TagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~TagResourcesResponseBody() = default;
};
class TagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TagResourcesResponseBody> body{};

  TagResourcesResponse() {}

  explicit TagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~TagResourcesResponse() = default;
};
class UnbindNlbRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> nlbId{};
  shared_ptr<long> port{};
  shared_ptr<string> protocol{};

  UnbindNlbRequest() {}

  explicit UnbindNlbRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (nlbId) {
      res["NlbId"] = boost::any(*nlbId);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("NlbId") != m.end() && !m["NlbId"].empty()) {
      nlbId = make_shared<string>(boost::any_cast<string>(m["NlbId"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
  }


  virtual ~UnbindNlbRequest() = default;
};
class UnbindNlbResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};

  UnbindNlbResponseBodyData() {}

  explicit UnbindNlbResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
  }


  virtual ~UnbindNlbResponseBodyData() = default;
};
class UnbindNlbResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<UnbindNlbResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  UnbindNlbResponseBody() {}

  explicit UnbindNlbResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        UnbindNlbResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<UnbindNlbResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~UnbindNlbResponseBody() = default;
};
class UnbindNlbResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnbindNlbResponseBody> body{};

  UnbindNlbResponse() {}

  explicit UnbindNlbResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnbindNlbResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnbindNlbResponseBody>(model1);
      }
    }
  }


  virtual ~UnbindNlbResponse() = default;
};
class UnbindSlbRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<bool> internet{};
  shared_ptr<bool> intranet{};

  UnbindSlbRequest() {}

  explicit UnbindSlbRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (internet) {
      res["Internet"] = boost::any(*internet);
    }
    if (intranet) {
      res["Intranet"] = boost::any(*intranet);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Internet") != m.end() && !m["Internet"].empty()) {
      internet = make_shared<bool>(boost::any_cast<bool>(m["Internet"]));
    }
    if (m.find("Intranet") != m.end() && !m["Intranet"].empty()) {
      intranet = make_shared<bool>(boost::any_cast<bool>(m["Intranet"]));
    }
  }


  virtual ~UnbindSlbRequest() = default;
};
class UnbindSlbResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};

  UnbindSlbResponseBodyData() {}

  explicit UnbindSlbResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
  }


  virtual ~UnbindSlbResponseBodyData() = default;
};
class UnbindSlbResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<UnbindSlbResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  UnbindSlbResponseBody() {}

  explicit UnbindSlbResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        UnbindSlbResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<UnbindSlbResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~UnbindSlbResponseBody() = default;
};
class UnbindSlbResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnbindSlbResponseBody> body{};

  UnbindSlbResponse() {}

  explicit UnbindSlbResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnbindSlbResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnbindSlbResponseBody>(model1);
      }
    }
  }


  virtual ~UnbindSlbResponse() = default;
};
class UntagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> deleteAll{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceIds{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tagKeys{};

  UntagResourcesRequest() {}

  explicit UntagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deleteAll) {
      res["DeleteAll"] = boost::any(*deleteAll);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceIds) {
      res["ResourceIds"] = boost::any(*resourceIds);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKeys) {
      res["TagKeys"] = boost::any(*tagKeys);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeleteAll") != m.end() && !m["DeleteAll"].empty()) {
      deleteAll = make_shared<bool>(boost::any_cast<bool>(m["DeleteAll"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceIds") != m.end() && !m["ResourceIds"].empty()) {
      resourceIds = make_shared<string>(boost::any_cast<string>(m["ResourceIds"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKeys") != m.end() && !m["TagKeys"].empty()) {
      tagKeys = make_shared<string>(boost::any_cast<string>(m["TagKeys"]));
    }
  }


  virtual ~UntagResourcesRequest() = default;
};
class UntagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<bool> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  UntagResourcesResponseBody() {}

  explicit UntagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~UntagResourcesResponseBody() = default;
};
class UntagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UntagResourcesResponseBody> body{};

  UntagResourcesResponse() {}

  explicit UntagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UntagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UntagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~UntagResourcesResponse() = default;
};
class UpdateAppSecurityGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> securityGroupId{};

  UpdateAppSecurityGroupRequest() {}

  explicit UpdateAppSecurityGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
  }


  virtual ~UpdateAppSecurityGroupRequest() = default;
};
class UpdateAppSecurityGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  UpdateAppSecurityGroupResponseBody() {}

  explicit UpdateAppSecurityGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~UpdateAppSecurityGroupResponseBody() = default;
};
class UpdateAppSecurityGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateAppSecurityGroupResponseBody> body{};

  UpdateAppSecurityGroupResponse() {}

  explicit UpdateAppSecurityGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAppSecurityGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAppSecurityGroupResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAppSecurityGroupResponse() = default;
};
class UpdateApplicationDescriptionRequest : public Darabonba::Model {
public:
  shared_ptr<string> appDescription{};
  shared_ptr<string> appId{};

  UpdateApplicationDescriptionRequest() {}

  explicit UpdateApplicationDescriptionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appDescription) {
      res["AppDescription"] = boost::any(*appDescription);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppDescription") != m.end() && !m["AppDescription"].empty()) {
      appDescription = make_shared<string>(boost::any_cast<string>(m["AppDescription"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~UpdateApplicationDescriptionRequest() = default;
};
class UpdateApplicationDescriptionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  UpdateApplicationDescriptionResponseBody() {}

  explicit UpdateApplicationDescriptionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~UpdateApplicationDescriptionResponseBody() = default;
};
class UpdateApplicationDescriptionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateApplicationDescriptionResponseBody> body{};

  UpdateApplicationDescriptionResponse() {}

  explicit UpdateApplicationDescriptionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateApplicationDescriptionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateApplicationDescriptionResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateApplicationDescriptionResponse() = default;
};
class UpdateApplicationScalingRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<bool> enableIdle{};
  shared_ptr<long> minReadyInstanceRatio{};
  shared_ptr<long> minReadyInstances{};
  shared_ptr<string> scalingRuleMetric{};
  shared_ptr<string> scalingRuleName{};
  shared_ptr<string> scalingRuleTimer{};

  UpdateApplicationScalingRuleRequest() {}

  explicit UpdateApplicationScalingRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (enableIdle) {
      res["EnableIdle"] = boost::any(*enableIdle);
    }
    if (minReadyInstanceRatio) {
      res["MinReadyInstanceRatio"] = boost::any(*minReadyInstanceRatio);
    }
    if (minReadyInstances) {
      res["MinReadyInstances"] = boost::any(*minReadyInstances);
    }
    if (scalingRuleMetric) {
      res["ScalingRuleMetric"] = boost::any(*scalingRuleMetric);
    }
    if (scalingRuleName) {
      res["ScalingRuleName"] = boost::any(*scalingRuleName);
    }
    if (scalingRuleTimer) {
      res["ScalingRuleTimer"] = boost::any(*scalingRuleTimer);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("EnableIdle") != m.end() && !m["EnableIdle"].empty()) {
      enableIdle = make_shared<bool>(boost::any_cast<bool>(m["EnableIdle"]));
    }
    if (m.find("MinReadyInstanceRatio") != m.end() && !m["MinReadyInstanceRatio"].empty()) {
      minReadyInstanceRatio = make_shared<long>(boost::any_cast<long>(m["MinReadyInstanceRatio"]));
    }
    if (m.find("MinReadyInstances") != m.end() && !m["MinReadyInstances"].empty()) {
      minReadyInstances = make_shared<long>(boost::any_cast<long>(m["MinReadyInstances"]));
    }
    if (m.find("ScalingRuleMetric") != m.end() && !m["ScalingRuleMetric"].empty()) {
      scalingRuleMetric = make_shared<string>(boost::any_cast<string>(m["ScalingRuleMetric"]));
    }
    if (m.find("ScalingRuleName") != m.end() && !m["ScalingRuleName"].empty()) {
      scalingRuleName = make_shared<string>(boost::any_cast<string>(m["ScalingRuleName"]));
    }
    if (m.find("ScalingRuleTimer") != m.end() && !m["ScalingRuleTimer"].empty()) {
      scalingRuleTimer = make_shared<string>(boost::any_cast<string>(m["ScalingRuleTimer"]));
    }
  }


  virtual ~UpdateApplicationScalingRuleRequest() = default;
};
class UpdateApplicationScalingRuleResponseBodyDataMetricMetrics : public Darabonba::Model {
public:
  shared_ptr<long> metricTargetAverageUtilization{};
  shared_ptr<string> metricType{};
  shared_ptr<string> slbId{};
  shared_ptr<string> slbLogstore{};
  shared_ptr<string> slbProject{};
  shared_ptr<string> vport{};

  UpdateApplicationScalingRuleResponseBodyDataMetricMetrics() {}

  explicit UpdateApplicationScalingRuleResponseBodyDataMetricMetrics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metricTargetAverageUtilization) {
      res["MetricTargetAverageUtilization"] = boost::any(*metricTargetAverageUtilization);
    }
    if (metricType) {
      res["MetricType"] = boost::any(*metricType);
    }
    if (slbId) {
      res["SlbId"] = boost::any(*slbId);
    }
    if (slbLogstore) {
      res["SlbLogstore"] = boost::any(*slbLogstore);
    }
    if (slbProject) {
      res["SlbProject"] = boost::any(*slbProject);
    }
    if (vport) {
      res["Vport"] = boost::any(*vport);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MetricTargetAverageUtilization") != m.end() && !m["MetricTargetAverageUtilization"].empty()) {
      metricTargetAverageUtilization = make_shared<long>(boost::any_cast<long>(m["MetricTargetAverageUtilization"]));
    }
    if (m.find("MetricType") != m.end() && !m["MetricType"].empty()) {
      metricType = make_shared<string>(boost::any_cast<string>(m["MetricType"]));
    }
    if (m.find("SlbId") != m.end() && !m["SlbId"].empty()) {
      slbId = make_shared<string>(boost::any_cast<string>(m["SlbId"]));
    }
    if (m.find("SlbLogstore") != m.end() && !m["SlbLogstore"].empty()) {
      slbLogstore = make_shared<string>(boost::any_cast<string>(m["SlbLogstore"]));
    }
    if (m.find("SlbProject") != m.end() && !m["SlbProject"].empty()) {
      slbProject = make_shared<string>(boost::any_cast<string>(m["SlbProject"]));
    }
    if (m.find("Vport") != m.end() && !m["Vport"].empty()) {
      vport = make_shared<string>(boost::any_cast<string>(m["Vport"]));
    }
  }


  virtual ~UpdateApplicationScalingRuleResponseBodyDataMetricMetrics() = default;
};
class UpdateApplicationScalingRuleResponseBodyDataMetric : public Darabonba::Model {
public:
  shared_ptr<long> maxReplicas{};
  shared_ptr<vector<UpdateApplicationScalingRuleResponseBodyDataMetricMetrics>> metrics{};
  shared_ptr<long> minReplicas{};

  UpdateApplicationScalingRuleResponseBodyDataMetric() {}

  explicit UpdateApplicationScalingRuleResponseBodyDataMetric(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxReplicas) {
      res["MaxReplicas"] = boost::any(*maxReplicas);
    }
    if (metrics) {
      vector<boost::any> temp1;
      for(auto item1:*metrics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Metrics"] = boost::any(temp1);
    }
    if (minReplicas) {
      res["MinReplicas"] = boost::any(*minReplicas);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxReplicas") != m.end() && !m["MaxReplicas"].empty()) {
      maxReplicas = make_shared<long>(boost::any_cast<long>(m["MaxReplicas"]));
    }
    if (m.find("Metrics") != m.end() && !m["Metrics"].empty()) {
      if (typeid(vector<boost::any>) == m["Metrics"].type()) {
        vector<UpdateApplicationScalingRuleResponseBodyDataMetricMetrics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Metrics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateApplicationScalingRuleResponseBodyDataMetricMetrics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        metrics = make_shared<vector<UpdateApplicationScalingRuleResponseBodyDataMetricMetrics>>(expect1);
      }
    }
    if (m.find("MinReplicas") != m.end() && !m["MinReplicas"].empty()) {
      minReplicas = make_shared<long>(boost::any_cast<long>(m["MinReplicas"]));
    }
  }


  virtual ~UpdateApplicationScalingRuleResponseBodyDataMetric() = default;
};
class UpdateApplicationScalingRuleResponseBodyDataTimerSchedules : public Darabonba::Model {
public:
  shared_ptr<string> atTime{};
  shared_ptr<long> maxReplicas{};
  shared_ptr<long> minReplicas{};
  shared_ptr<long> targetReplicas{};

  UpdateApplicationScalingRuleResponseBodyDataTimerSchedules() {}

  explicit UpdateApplicationScalingRuleResponseBodyDataTimerSchedules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (atTime) {
      res["AtTime"] = boost::any(*atTime);
    }
    if (maxReplicas) {
      res["MaxReplicas"] = boost::any(*maxReplicas);
    }
    if (minReplicas) {
      res["MinReplicas"] = boost::any(*minReplicas);
    }
    if (targetReplicas) {
      res["TargetReplicas"] = boost::any(*targetReplicas);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AtTime") != m.end() && !m["AtTime"].empty()) {
      atTime = make_shared<string>(boost::any_cast<string>(m["AtTime"]));
    }
    if (m.find("MaxReplicas") != m.end() && !m["MaxReplicas"].empty()) {
      maxReplicas = make_shared<long>(boost::any_cast<long>(m["MaxReplicas"]));
    }
    if (m.find("MinReplicas") != m.end() && !m["MinReplicas"].empty()) {
      minReplicas = make_shared<long>(boost::any_cast<long>(m["MinReplicas"]));
    }
    if (m.find("TargetReplicas") != m.end() && !m["TargetReplicas"].empty()) {
      targetReplicas = make_shared<long>(boost::any_cast<long>(m["TargetReplicas"]));
    }
  }


  virtual ~UpdateApplicationScalingRuleResponseBodyDataTimerSchedules() = default;
};
class UpdateApplicationScalingRuleResponseBodyDataTimer : public Darabonba::Model {
public:
  shared_ptr<string> beginDate{};
  shared_ptr<string> endDate{};
  shared_ptr<string> period{};
  shared_ptr<vector<UpdateApplicationScalingRuleResponseBodyDataTimerSchedules>> schedules{};

  UpdateApplicationScalingRuleResponseBodyDataTimer() {}

  explicit UpdateApplicationScalingRuleResponseBodyDataTimer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beginDate) {
      res["BeginDate"] = boost::any(*beginDate);
    }
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (schedules) {
      vector<boost::any> temp1;
      for(auto item1:*schedules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Schedules"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BeginDate") != m.end() && !m["BeginDate"].empty()) {
      beginDate = make_shared<string>(boost::any_cast<string>(m["BeginDate"]));
    }
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("Schedules") != m.end() && !m["Schedules"].empty()) {
      if (typeid(vector<boost::any>) == m["Schedules"].type()) {
        vector<UpdateApplicationScalingRuleResponseBodyDataTimerSchedules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Schedules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateApplicationScalingRuleResponseBodyDataTimerSchedules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        schedules = make_shared<vector<UpdateApplicationScalingRuleResponseBodyDataTimerSchedules>>(expect1);
      }
    }
  }


  virtual ~UpdateApplicationScalingRuleResponseBodyDataTimer() = default;
};
class UpdateApplicationScalingRuleResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> createTime{};
  shared_ptr<bool> enableIdle{};
  shared_ptr<long> lastDisableTime{};
  shared_ptr<UpdateApplicationScalingRuleResponseBodyDataMetric> metric{};
  shared_ptr<bool> scaleRuleEnabled{};
  shared_ptr<string> scaleRuleName{};
  shared_ptr<string> scaleRuleType{};
  shared_ptr<UpdateApplicationScalingRuleResponseBodyDataTimer> timer{};
  shared_ptr<long> updateTime{};

  UpdateApplicationScalingRuleResponseBodyData() {}

  explicit UpdateApplicationScalingRuleResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (enableIdle) {
      res["EnableIdle"] = boost::any(*enableIdle);
    }
    if (lastDisableTime) {
      res["LastDisableTime"] = boost::any(*lastDisableTime);
    }
    if (metric) {
      res["Metric"] = metric ? boost::any(metric->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scaleRuleEnabled) {
      res["ScaleRuleEnabled"] = boost::any(*scaleRuleEnabled);
    }
    if (scaleRuleName) {
      res["ScaleRuleName"] = boost::any(*scaleRuleName);
    }
    if (scaleRuleType) {
      res["ScaleRuleType"] = boost::any(*scaleRuleType);
    }
    if (timer) {
      res["Timer"] = timer ? boost::any(timer->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("EnableIdle") != m.end() && !m["EnableIdle"].empty()) {
      enableIdle = make_shared<bool>(boost::any_cast<bool>(m["EnableIdle"]));
    }
    if (m.find("LastDisableTime") != m.end() && !m["LastDisableTime"].empty()) {
      lastDisableTime = make_shared<long>(boost::any_cast<long>(m["LastDisableTime"]));
    }
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      if (typeid(map<string, boost::any>) == m["Metric"].type()) {
        UpdateApplicationScalingRuleResponseBodyDataMetric model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Metric"]));
        metric = make_shared<UpdateApplicationScalingRuleResponseBodyDataMetric>(model1);
      }
    }
    if (m.find("ScaleRuleEnabled") != m.end() && !m["ScaleRuleEnabled"].empty()) {
      scaleRuleEnabled = make_shared<bool>(boost::any_cast<bool>(m["ScaleRuleEnabled"]));
    }
    if (m.find("ScaleRuleName") != m.end() && !m["ScaleRuleName"].empty()) {
      scaleRuleName = make_shared<string>(boost::any_cast<string>(m["ScaleRuleName"]));
    }
    if (m.find("ScaleRuleType") != m.end() && !m["ScaleRuleType"].empty()) {
      scaleRuleType = make_shared<string>(boost::any_cast<string>(m["ScaleRuleType"]));
    }
    if (m.find("Timer") != m.end() && !m["Timer"].empty()) {
      if (typeid(map<string, boost::any>) == m["Timer"].type()) {
        UpdateApplicationScalingRuleResponseBodyDataTimer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Timer"]));
        timer = make_shared<UpdateApplicationScalingRuleResponseBodyDataTimer>(model1);
      }
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~UpdateApplicationScalingRuleResponseBodyData() = default;
};
class UpdateApplicationScalingRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<UpdateApplicationScalingRuleResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  UpdateApplicationScalingRuleResponseBody() {}

  explicit UpdateApplicationScalingRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        UpdateApplicationScalingRuleResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<UpdateApplicationScalingRuleResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~UpdateApplicationScalingRuleResponseBody() = default;
};
class UpdateApplicationScalingRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateApplicationScalingRuleResponseBody> body{};

  UpdateApplicationScalingRuleResponse() {}

  explicit UpdateApplicationScalingRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateApplicationScalingRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateApplicationScalingRuleResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateApplicationScalingRuleResponse() = default;
};
class UpdateApplicationVswitchesRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> vSwitchId{};

  UpdateApplicationVswitchesRequest() {}

  explicit UpdateApplicationVswitchesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~UpdateApplicationVswitchesRequest() = default;
};
class UpdateApplicationVswitchesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  UpdateApplicationVswitchesResponseBody() {}

  explicit UpdateApplicationVswitchesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~UpdateApplicationVswitchesResponseBody() = default;
};
class UpdateApplicationVswitchesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateApplicationVswitchesResponseBody> body{};

  UpdateApplicationVswitchesResponse() {}

  explicit UpdateApplicationVswitchesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateApplicationVswitchesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateApplicationVswitchesResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateApplicationVswitchesResponse() = default;
};
class UpdateConfigMapRequest : public Darabonba::Model {
public:
  shared_ptr<long> configMapId{};
  shared_ptr<string> data{};
  shared_ptr<string> description{};

  UpdateConfigMapRequest() {}

  explicit UpdateConfigMapRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configMapId) {
      res["ConfigMapId"] = boost::any(*configMapId);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigMapId") != m.end() && !m["ConfigMapId"].empty()) {
      configMapId = make_shared<long>(boost::any_cast<long>(m["ConfigMapId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~UpdateConfigMapRequest() = default;
};
class UpdateConfigMapResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> configMapId{};

  UpdateConfigMapResponseBodyData() {}

  explicit UpdateConfigMapResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configMapId) {
      res["ConfigMapId"] = boost::any(*configMapId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigMapId") != m.end() && !m["ConfigMapId"].empty()) {
      configMapId = make_shared<string>(boost::any_cast<string>(m["ConfigMapId"]));
    }
  }


  virtual ~UpdateConfigMapResponseBodyData() = default;
};
class UpdateConfigMapResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<UpdateConfigMapResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  UpdateConfigMapResponseBody() {}

  explicit UpdateConfigMapResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        UpdateConfigMapResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<UpdateConfigMapResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~UpdateConfigMapResponseBody() = default;
};
class UpdateConfigMapResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateConfigMapResponseBody> body{};

  UpdateConfigMapResponse() {}

  explicit UpdateConfigMapResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateConfigMapResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateConfigMapResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateConfigMapResponse() = default;
};
class UpdateGreyTagRouteRequest : public Darabonba::Model {
public:
  shared_ptr<string> albRules{};
  shared_ptr<string> description{};
  shared_ptr<string> dubboRules{};
  shared_ptr<long> greyTagRouteId{};
  shared_ptr<string> scRules{};

  UpdateGreyTagRouteRequest() {}

  explicit UpdateGreyTagRouteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (albRules) {
      res["AlbRules"] = boost::any(*albRules);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dubboRules) {
      res["DubboRules"] = boost::any(*dubboRules);
    }
    if (greyTagRouteId) {
      res["GreyTagRouteId"] = boost::any(*greyTagRouteId);
    }
    if (scRules) {
      res["ScRules"] = boost::any(*scRules);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlbRules") != m.end() && !m["AlbRules"].empty()) {
      albRules = make_shared<string>(boost::any_cast<string>(m["AlbRules"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DubboRules") != m.end() && !m["DubboRules"].empty()) {
      dubboRules = make_shared<string>(boost::any_cast<string>(m["DubboRules"]));
    }
    if (m.find("GreyTagRouteId") != m.end() && !m["GreyTagRouteId"].empty()) {
      greyTagRouteId = make_shared<long>(boost::any_cast<long>(m["GreyTagRouteId"]));
    }
    if (m.find("ScRules") != m.end() && !m["ScRules"].empty()) {
      scRules = make_shared<string>(boost::any_cast<string>(m["ScRules"]));
    }
  }


  virtual ~UpdateGreyTagRouteRequest() = default;
};
class UpdateGreyTagRouteResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> greyTagRouteId{};

  UpdateGreyTagRouteResponseBodyData() {}

  explicit UpdateGreyTagRouteResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (greyTagRouteId) {
      res["GreyTagRouteId"] = boost::any(*greyTagRouteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GreyTagRouteId") != m.end() && !m["GreyTagRouteId"].empty()) {
      greyTagRouteId = make_shared<long>(boost::any_cast<long>(m["GreyTagRouteId"]));
    }
  }


  virtual ~UpdateGreyTagRouteResponseBodyData() = default;
};
class UpdateGreyTagRouteResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<UpdateGreyTagRouteResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  UpdateGreyTagRouteResponseBody() {}

  explicit UpdateGreyTagRouteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        UpdateGreyTagRouteResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<UpdateGreyTagRouteResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~UpdateGreyTagRouteResponseBody() = default;
};
class UpdateGreyTagRouteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateGreyTagRouteResponseBody> body{};

  UpdateGreyTagRouteResponse() {}

  explicit UpdateGreyTagRouteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateGreyTagRouteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateGreyTagRouteResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateGreyTagRouteResponse() = default;
};
class UpdateIngressRequest : public Darabonba::Model {
public:
  shared_ptr<string> certId{};
  shared_ptr<string> certIds{};
  shared_ptr<string> corsConfig{};
  shared_ptr<string> defaultRule{};
  shared_ptr<string> description{};
  shared_ptr<bool> enableXForwardedFor{};
  shared_ptr<bool> enableXForwardedForClientSrcPort{};
  shared_ptr<bool> enableXForwardedForProto{};
  shared_ptr<bool> enableXForwardedForSlbId{};
  shared_ptr<bool> enableXForwardedForSlbPort{};
  shared_ptr<long> idleTimeout{};
  shared_ptr<long> ingressId{};
  shared_ptr<string> listenerPort{};
  shared_ptr<string> listenerProtocol{};
  shared_ptr<string> loadBalanceType{};
  shared_ptr<long> requestTimeout{};
  shared_ptr<string> rules{};
  shared_ptr<string> securityPolicyId{};

  UpdateIngressRequest() {}

  explicit UpdateIngressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certId) {
      res["CertId"] = boost::any(*certId);
    }
    if (certIds) {
      res["CertIds"] = boost::any(*certIds);
    }
    if (corsConfig) {
      res["CorsConfig"] = boost::any(*corsConfig);
    }
    if (defaultRule) {
      res["DefaultRule"] = boost::any(*defaultRule);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enableXForwardedFor) {
      res["EnableXForwardedFor"] = boost::any(*enableXForwardedFor);
    }
    if (enableXForwardedForClientSrcPort) {
      res["EnableXForwardedForClientSrcPort"] = boost::any(*enableXForwardedForClientSrcPort);
    }
    if (enableXForwardedForProto) {
      res["EnableXForwardedForProto"] = boost::any(*enableXForwardedForProto);
    }
    if (enableXForwardedForSlbId) {
      res["EnableXForwardedForSlbId"] = boost::any(*enableXForwardedForSlbId);
    }
    if (enableXForwardedForSlbPort) {
      res["EnableXForwardedForSlbPort"] = boost::any(*enableXForwardedForSlbPort);
    }
    if (idleTimeout) {
      res["IdleTimeout"] = boost::any(*idleTimeout);
    }
    if (ingressId) {
      res["IngressId"] = boost::any(*ingressId);
    }
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    if (listenerProtocol) {
      res["ListenerProtocol"] = boost::any(*listenerProtocol);
    }
    if (loadBalanceType) {
      res["LoadBalanceType"] = boost::any(*loadBalanceType);
    }
    if (requestTimeout) {
      res["RequestTimeout"] = boost::any(*requestTimeout);
    }
    if (rules) {
      res["Rules"] = boost::any(*rules);
    }
    if (securityPolicyId) {
      res["SecurityPolicyId"] = boost::any(*securityPolicyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertId") != m.end() && !m["CertId"].empty()) {
      certId = make_shared<string>(boost::any_cast<string>(m["CertId"]));
    }
    if (m.find("CertIds") != m.end() && !m["CertIds"].empty()) {
      certIds = make_shared<string>(boost::any_cast<string>(m["CertIds"]));
    }
    if (m.find("CorsConfig") != m.end() && !m["CorsConfig"].empty()) {
      corsConfig = make_shared<string>(boost::any_cast<string>(m["CorsConfig"]));
    }
    if (m.find("DefaultRule") != m.end() && !m["DefaultRule"].empty()) {
      defaultRule = make_shared<string>(boost::any_cast<string>(m["DefaultRule"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnableXForwardedFor") != m.end() && !m["EnableXForwardedFor"].empty()) {
      enableXForwardedFor = make_shared<bool>(boost::any_cast<bool>(m["EnableXForwardedFor"]));
    }
    if (m.find("EnableXForwardedForClientSrcPort") != m.end() && !m["EnableXForwardedForClientSrcPort"].empty()) {
      enableXForwardedForClientSrcPort = make_shared<bool>(boost::any_cast<bool>(m["EnableXForwardedForClientSrcPort"]));
    }
    if (m.find("EnableXForwardedForProto") != m.end() && !m["EnableXForwardedForProto"].empty()) {
      enableXForwardedForProto = make_shared<bool>(boost::any_cast<bool>(m["EnableXForwardedForProto"]));
    }
    if (m.find("EnableXForwardedForSlbId") != m.end() && !m["EnableXForwardedForSlbId"].empty()) {
      enableXForwardedForSlbId = make_shared<bool>(boost::any_cast<bool>(m["EnableXForwardedForSlbId"]));
    }
    if (m.find("EnableXForwardedForSlbPort") != m.end() && !m["EnableXForwardedForSlbPort"].empty()) {
      enableXForwardedForSlbPort = make_shared<bool>(boost::any_cast<bool>(m["EnableXForwardedForSlbPort"]));
    }
    if (m.find("IdleTimeout") != m.end() && !m["IdleTimeout"].empty()) {
      idleTimeout = make_shared<long>(boost::any_cast<long>(m["IdleTimeout"]));
    }
    if (m.find("IngressId") != m.end() && !m["IngressId"].empty()) {
      ingressId = make_shared<long>(boost::any_cast<long>(m["IngressId"]));
    }
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<string>(boost::any_cast<string>(m["ListenerPort"]));
    }
    if (m.find("ListenerProtocol") != m.end() && !m["ListenerProtocol"].empty()) {
      listenerProtocol = make_shared<string>(boost::any_cast<string>(m["ListenerProtocol"]));
    }
    if (m.find("LoadBalanceType") != m.end() && !m["LoadBalanceType"].empty()) {
      loadBalanceType = make_shared<string>(boost::any_cast<string>(m["LoadBalanceType"]));
    }
    if (m.find("RequestTimeout") != m.end() && !m["RequestTimeout"].empty()) {
      requestTimeout = make_shared<long>(boost::any_cast<long>(m["RequestTimeout"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      rules = make_shared<string>(boost::any_cast<string>(m["Rules"]));
    }
    if (m.find("SecurityPolicyId") != m.end() && !m["SecurityPolicyId"].empty()) {
      securityPolicyId = make_shared<string>(boost::any_cast<string>(m["SecurityPolicyId"]));
    }
  }


  virtual ~UpdateIngressRequest() = default;
};
class UpdateIngressResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> ingressId{};

  UpdateIngressResponseBodyData() {}

  explicit UpdateIngressResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ingressId) {
      res["IngressId"] = boost::any(*ingressId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IngressId") != m.end() && !m["IngressId"].empty()) {
      ingressId = make_shared<long>(boost::any_cast<long>(m["IngressId"]));
    }
  }


  virtual ~UpdateIngressResponseBodyData() = default;
};
class UpdateIngressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<UpdateIngressResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  UpdateIngressResponseBody() {}

  explicit UpdateIngressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        UpdateIngressResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<UpdateIngressResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~UpdateIngressResponseBody() = default;
};
class UpdateIngressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateIngressResponseBody> body{};

  UpdateIngressResponse() {}

  explicit UpdateIngressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateIngressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateIngressResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateIngressResponse() = default;
};
class UpdateJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> acrAssumeRoleArn{};
  shared_ptr<string> acrInstanceId{};
  shared_ptr<string> appId{};
  shared_ptr<long> backoffLimit{};
  shared_ptr<string> command{};
  shared_ptr<string> commandArgs{};
  shared_ptr<string> concurrencyPolicy{};
  shared_ptr<string> configMapMountDesc{};
  shared_ptr<string> customHostAlias{};
  shared_ptr<string> edasContainerVersion{};
  shared_ptr<bool> enableImageAccl{};
  shared_ptr<string> envs{};
  shared_ptr<string> imagePullSecrets{};
  shared_ptr<string> imageUrl{};
  shared_ptr<string> jarStartArgs{};
  shared_ptr<string> jarStartOptions{};
  shared_ptr<string> jdk{};
  shared_ptr<string> mountDesc{};
  shared_ptr<string> mountHost{};
  shared_ptr<string> nasId{};
  shared_ptr<string> ossAkId{};
  shared_ptr<string> ossAkSecret{};
  shared_ptr<string> ossMountDescs{};
  shared_ptr<string> packageUrl{};
  shared_ptr<string> packageVersion{};
  shared_ptr<string> php{};
  shared_ptr<string> phpConfig{};
  shared_ptr<string> phpConfigLocation{};
  shared_ptr<string> postStart{};
  shared_ptr<string> preStop{};
  shared_ptr<string> programmingLanguage{};
  shared_ptr<string> python{};
  shared_ptr<string> pythonModules{};
  shared_ptr<string> refAppId{};
  shared_ptr<string> replicas{};
  shared_ptr<bool> slice{};
  shared_ptr<string> sliceEnvs{};
  shared_ptr<string> slsConfigs{};
  shared_ptr<long> terminationGracePeriodSeconds{};
  shared_ptr<long> timeout{};
  shared_ptr<string> timezone{};
  shared_ptr<string> tomcatConfig{};
  shared_ptr<string> triggerConfig{};
  shared_ptr<string> warStartOptions{};
  shared_ptr<string> webContainer{};

  UpdateJobRequest() {}

  explicit UpdateJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acrAssumeRoleArn) {
      res["AcrAssumeRoleArn"] = boost::any(*acrAssumeRoleArn);
    }
    if (acrInstanceId) {
      res["AcrInstanceId"] = boost::any(*acrInstanceId);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (backoffLimit) {
      res["BackoffLimit"] = boost::any(*backoffLimit);
    }
    if (command) {
      res["Command"] = boost::any(*command);
    }
    if (commandArgs) {
      res["CommandArgs"] = boost::any(*commandArgs);
    }
    if (concurrencyPolicy) {
      res["ConcurrencyPolicy"] = boost::any(*concurrencyPolicy);
    }
    if (configMapMountDesc) {
      res["ConfigMapMountDesc"] = boost::any(*configMapMountDesc);
    }
    if (customHostAlias) {
      res["CustomHostAlias"] = boost::any(*customHostAlias);
    }
    if (edasContainerVersion) {
      res["EdasContainerVersion"] = boost::any(*edasContainerVersion);
    }
    if (enableImageAccl) {
      res["EnableImageAccl"] = boost::any(*enableImageAccl);
    }
    if (envs) {
      res["Envs"] = boost::any(*envs);
    }
    if (imagePullSecrets) {
      res["ImagePullSecrets"] = boost::any(*imagePullSecrets);
    }
    if (imageUrl) {
      res["ImageUrl"] = boost::any(*imageUrl);
    }
    if (jarStartArgs) {
      res["JarStartArgs"] = boost::any(*jarStartArgs);
    }
    if (jarStartOptions) {
      res["JarStartOptions"] = boost::any(*jarStartOptions);
    }
    if (jdk) {
      res["Jdk"] = boost::any(*jdk);
    }
    if (mountDesc) {
      res["MountDesc"] = boost::any(*mountDesc);
    }
    if (mountHost) {
      res["MountHost"] = boost::any(*mountHost);
    }
    if (nasId) {
      res["NasId"] = boost::any(*nasId);
    }
    if (ossAkId) {
      res["OssAkId"] = boost::any(*ossAkId);
    }
    if (ossAkSecret) {
      res["OssAkSecret"] = boost::any(*ossAkSecret);
    }
    if (ossMountDescs) {
      res["OssMountDescs"] = boost::any(*ossMountDescs);
    }
    if (packageUrl) {
      res["PackageUrl"] = boost::any(*packageUrl);
    }
    if (packageVersion) {
      res["PackageVersion"] = boost::any(*packageVersion);
    }
    if (php) {
      res["Php"] = boost::any(*php);
    }
    if (phpConfig) {
      res["PhpConfig"] = boost::any(*phpConfig);
    }
    if (phpConfigLocation) {
      res["PhpConfigLocation"] = boost::any(*phpConfigLocation);
    }
    if (postStart) {
      res["PostStart"] = boost::any(*postStart);
    }
    if (preStop) {
      res["PreStop"] = boost::any(*preStop);
    }
    if (programmingLanguage) {
      res["ProgrammingLanguage"] = boost::any(*programmingLanguage);
    }
    if (python) {
      res["Python"] = boost::any(*python);
    }
    if (pythonModules) {
      res["PythonModules"] = boost::any(*pythonModules);
    }
    if (refAppId) {
      res["RefAppId"] = boost::any(*refAppId);
    }
    if (replicas) {
      res["Replicas"] = boost::any(*replicas);
    }
    if (slice) {
      res["Slice"] = boost::any(*slice);
    }
    if (sliceEnvs) {
      res["SliceEnvs"] = boost::any(*sliceEnvs);
    }
    if (slsConfigs) {
      res["SlsConfigs"] = boost::any(*slsConfigs);
    }
    if (terminationGracePeriodSeconds) {
      res["TerminationGracePeriodSeconds"] = boost::any(*terminationGracePeriodSeconds);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (timezone) {
      res["Timezone"] = boost::any(*timezone);
    }
    if (tomcatConfig) {
      res["TomcatConfig"] = boost::any(*tomcatConfig);
    }
    if (triggerConfig) {
      res["TriggerConfig"] = boost::any(*triggerConfig);
    }
    if (warStartOptions) {
      res["WarStartOptions"] = boost::any(*warStartOptions);
    }
    if (webContainer) {
      res["WebContainer"] = boost::any(*webContainer);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcrAssumeRoleArn") != m.end() && !m["AcrAssumeRoleArn"].empty()) {
      acrAssumeRoleArn = make_shared<string>(boost::any_cast<string>(m["AcrAssumeRoleArn"]));
    }
    if (m.find("AcrInstanceId") != m.end() && !m["AcrInstanceId"].empty()) {
      acrInstanceId = make_shared<string>(boost::any_cast<string>(m["AcrInstanceId"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("BackoffLimit") != m.end() && !m["BackoffLimit"].empty()) {
      backoffLimit = make_shared<long>(boost::any_cast<long>(m["BackoffLimit"]));
    }
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
    if (m.find("CommandArgs") != m.end() && !m["CommandArgs"].empty()) {
      commandArgs = make_shared<string>(boost::any_cast<string>(m["CommandArgs"]));
    }
    if (m.find("ConcurrencyPolicy") != m.end() && !m["ConcurrencyPolicy"].empty()) {
      concurrencyPolicy = make_shared<string>(boost::any_cast<string>(m["ConcurrencyPolicy"]));
    }
    if (m.find("ConfigMapMountDesc") != m.end() && !m["ConfigMapMountDesc"].empty()) {
      configMapMountDesc = make_shared<string>(boost::any_cast<string>(m["ConfigMapMountDesc"]));
    }
    if (m.find("CustomHostAlias") != m.end() && !m["CustomHostAlias"].empty()) {
      customHostAlias = make_shared<string>(boost::any_cast<string>(m["CustomHostAlias"]));
    }
    if (m.find("EdasContainerVersion") != m.end() && !m["EdasContainerVersion"].empty()) {
      edasContainerVersion = make_shared<string>(boost::any_cast<string>(m["EdasContainerVersion"]));
    }
    if (m.find("EnableImageAccl") != m.end() && !m["EnableImageAccl"].empty()) {
      enableImageAccl = make_shared<bool>(boost::any_cast<bool>(m["EnableImageAccl"]));
    }
    if (m.find("Envs") != m.end() && !m["Envs"].empty()) {
      envs = make_shared<string>(boost::any_cast<string>(m["Envs"]));
    }
    if (m.find("ImagePullSecrets") != m.end() && !m["ImagePullSecrets"].empty()) {
      imagePullSecrets = make_shared<string>(boost::any_cast<string>(m["ImagePullSecrets"]));
    }
    if (m.find("ImageUrl") != m.end() && !m["ImageUrl"].empty()) {
      imageUrl = make_shared<string>(boost::any_cast<string>(m["ImageUrl"]));
    }
    if (m.find("JarStartArgs") != m.end() && !m["JarStartArgs"].empty()) {
      jarStartArgs = make_shared<string>(boost::any_cast<string>(m["JarStartArgs"]));
    }
    if (m.find("JarStartOptions") != m.end() && !m["JarStartOptions"].empty()) {
      jarStartOptions = make_shared<string>(boost::any_cast<string>(m["JarStartOptions"]));
    }
    if (m.find("Jdk") != m.end() && !m["Jdk"].empty()) {
      jdk = make_shared<string>(boost::any_cast<string>(m["Jdk"]));
    }
    if (m.find("MountDesc") != m.end() && !m["MountDesc"].empty()) {
      mountDesc = make_shared<string>(boost::any_cast<string>(m["MountDesc"]));
    }
    if (m.find("MountHost") != m.end() && !m["MountHost"].empty()) {
      mountHost = make_shared<string>(boost::any_cast<string>(m["MountHost"]));
    }
    if (m.find("NasId") != m.end() && !m["NasId"].empty()) {
      nasId = make_shared<string>(boost::any_cast<string>(m["NasId"]));
    }
    if (m.find("OssAkId") != m.end() && !m["OssAkId"].empty()) {
      ossAkId = make_shared<string>(boost::any_cast<string>(m["OssAkId"]));
    }
    if (m.find("OssAkSecret") != m.end() && !m["OssAkSecret"].empty()) {
      ossAkSecret = make_shared<string>(boost::any_cast<string>(m["OssAkSecret"]));
    }
    if (m.find("OssMountDescs") != m.end() && !m["OssMountDescs"].empty()) {
      ossMountDescs = make_shared<string>(boost::any_cast<string>(m["OssMountDescs"]));
    }
    if (m.find("PackageUrl") != m.end() && !m["PackageUrl"].empty()) {
      packageUrl = make_shared<string>(boost::any_cast<string>(m["PackageUrl"]));
    }
    if (m.find("PackageVersion") != m.end() && !m["PackageVersion"].empty()) {
      packageVersion = make_shared<string>(boost::any_cast<string>(m["PackageVersion"]));
    }
    if (m.find("Php") != m.end() && !m["Php"].empty()) {
      php = make_shared<string>(boost::any_cast<string>(m["Php"]));
    }
    if (m.find("PhpConfig") != m.end() && !m["PhpConfig"].empty()) {
      phpConfig = make_shared<string>(boost::any_cast<string>(m["PhpConfig"]));
    }
    if (m.find("PhpConfigLocation") != m.end() && !m["PhpConfigLocation"].empty()) {
      phpConfigLocation = make_shared<string>(boost::any_cast<string>(m["PhpConfigLocation"]));
    }
    if (m.find("PostStart") != m.end() && !m["PostStart"].empty()) {
      postStart = make_shared<string>(boost::any_cast<string>(m["PostStart"]));
    }
    if (m.find("PreStop") != m.end() && !m["PreStop"].empty()) {
      preStop = make_shared<string>(boost::any_cast<string>(m["PreStop"]));
    }
    if (m.find("ProgrammingLanguage") != m.end() && !m["ProgrammingLanguage"].empty()) {
      programmingLanguage = make_shared<string>(boost::any_cast<string>(m["ProgrammingLanguage"]));
    }
    if (m.find("Python") != m.end() && !m["Python"].empty()) {
      python = make_shared<string>(boost::any_cast<string>(m["Python"]));
    }
    if (m.find("PythonModules") != m.end() && !m["PythonModules"].empty()) {
      pythonModules = make_shared<string>(boost::any_cast<string>(m["PythonModules"]));
    }
    if (m.find("RefAppId") != m.end() && !m["RefAppId"].empty()) {
      refAppId = make_shared<string>(boost::any_cast<string>(m["RefAppId"]));
    }
    if (m.find("Replicas") != m.end() && !m["Replicas"].empty()) {
      replicas = make_shared<string>(boost::any_cast<string>(m["Replicas"]));
    }
    if (m.find("Slice") != m.end() && !m["Slice"].empty()) {
      slice = make_shared<bool>(boost::any_cast<bool>(m["Slice"]));
    }
    if (m.find("SliceEnvs") != m.end() && !m["SliceEnvs"].empty()) {
      sliceEnvs = make_shared<string>(boost::any_cast<string>(m["SliceEnvs"]));
    }
    if (m.find("SlsConfigs") != m.end() && !m["SlsConfigs"].empty()) {
      slsConfigs = make_shared<string>(boost::any_cast<string>(m["SlsConfigs"]));
    }
    if (m.find("TerminationGracePeriodSeconds") != m.end() && !m["TerminationGracePeriodSeconds"].empty()) {
      terminationGracePeriodSeconds = make_shared<long>(boost::any_cast<long>(m["TerminationGracePeriodSeconds"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("Timezone") != m.end() && !m["Timezone"].empty()) {
      timezone = make_shared<string>(boost::any_cast<string>(m["Timezone"]));
    }
    if (m.find("TomcatConfig") != m.end() && !m["TomcatConfig"].empty()) {
      tomcatConfig = make_shared<string>(boost::any_cast<string>(m["TomcatConfig"]));
    }
    if (m.find("TriggerConfig") != m.end() && !m["TriggerConfig"].empty()) {
      triggerConfig = make_shared<string>(boost::any_cast<string>(m["TriggerConfig"]));
    }
    if (m.find("WarStartOptions") != m.end() && !m["WarStartOptions"].empty()) {
      warStartOptions = make_shared<string>(boost::any_cast<string>(m["WarStartOptions"]));
    }
    if (m.find("WebContainer") != m.end() && !m["WebContainer"].empty()) {
      webContainer = make_shared<string>(boost::any_cast<string>(m["WebContainer"]));
    }
  }


  virtual ~UpdateJobRequest() = default;
};
class UpdateJobResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> changeOrderId{};

  UpdateJobResponseBodyData() {}

  explicit UpdateJobResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
  }


  virtual ~UpdateJobResponseBodyData() = default;
};
class UpdateJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<UpdateJobResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  UpdateJobResponseBody() {}

  explicit UpdateJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        UpdateJobResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<UpdateJobResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~UpdateJobResponseBody() = default;
};
class UpdateJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateJobResponseBody> body{};

  UpdateJobResponse() {}

  explicit UpdateJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateJobResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateJobResponse() = default;
};
class UpdateNamespaceRequest : public Darabonba::Model {
public:
  shared_ptr<bool> enableMicroRegistration{};
  shared_ptr<string> nameSpaceShortId{};
  shared_ptr<string> namespaceDescription{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> namespaceName{};

  UpdateNamespaceRequest() {}

  explicit UpdateNamespaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableMicroRegistration) {
      res["EnableMicroRegistration"] = boost::any(*enableMicroRegistration);
    }
    if (nameSpaceShortId) {
      res["NameSpaceShortId"] = boost::any(*nameSpaceShortId);
    }
    if (namespaceDescription) {
      res["NamespaceDescription"] = boost::any(*namespaceDescription);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (namespaceName) {
      res["NamespaceName"] = boost::any(*namespaceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableMicroRegistration") != m.end() && !m["EnableMicroRegistration"].empty()) {
      enableMicroRegistration = make_shared<bool>(boost::any_cast<bool>(m["EnableMicroRegistration"]));
    }
    if (m.find("NameSpaceShortId") != m.end() && !m["NameSpaceShortId"].empty()) {
      nameSpaceShortId = make_shared<string>(boost::any_cast<string>(m["NameSpaceShortId"]));
    }
    if (m.find("NamespaceDescription") != m.end() && !m["NamespaceDescription"].empty()) {
      namespaceDescription = make_shared<string>(boost::any_cast<string>(m["NamespaceDescription"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("NamespaceName") != m.end() && !m["NamespaceName"].empty()) {
      namespaceName = make_shared<string>(boost::any_cast<string>(m["NamespaceName"]));
    }
  }


  virtual ~UpdateNamespaceRequest() = default;
};
class UpdateNamespaceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> enableMicroRegistration{};
  shared_ptr<string> nameSpaceShortId{};
  shared_ptr<string> namespaceDescription{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> namespaceName{};
  shared_ptr<string> regionId{};

  UpdateNamespaceResponseBodyData() {}

  explicit UpdateNamespaceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableMicroRegistration) {
      res["EnableMicroRegistration"] = boost::any(*enableMicroRegistration);
    }
    if (nameSpaceShortId) {
      res["NameSpaceShortId"] = boost::any(*nameSpaceShortId);
    }
    if (namespaceDescription) {
      res["NamespaceDescription"] = boost::any(*namespaceDescription);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (namespaceName) {
      res["NamespaceName"] = boost::any(*namespaceName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableMicroRegistration") != m.end() && !m["EnableMicroRegistration"].empty()) {
      enableMicroRegistration = make_shared<bool>(boost::any_cast<bool>(m["EnableMicroRegistration"]));
    }
    if (m.find("NameSpaceShortId") != m.end() && !m["NameSpaceShortId"].empty()) {
      nameSpaceShortId = make_shared<string>(boost::any_cast<string>(m["NameSpaceShortId"]));
    }
    if (m.find("NamespaceDescription") != m.end() && !m["NamespaceDescription"].empty()) {
      namespaceDescription = make_shared<string>(boost::any_cast<string>(m["NamespaceDescription"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("NamespaceName") != m.end() && !m["NamespaceName"].empty()) {
      namespaceName = make_shared<string>(boost::any_cast<string>(m["NamespaceName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~UpdateNamespaceResponseBodyData() = default;
};
class UpdateNamespaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<UpdateNamespaceResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  UpdateNamespaceResponseBody() {}

  explicit UpdateNamespaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        UpdateNamespaceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<UpdateNamespaceResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~UpdateNamespaceResponseBody() = default;
};
class UpdateNamespaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateNamespaceResponseBody> body{};

  UpdateNamespaceResponse() {}

  explicit UpdateNamespaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateNamespaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateNamespaceResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateNamespaceResponse() = default;
};
class UpdateNamespaceVpcRequest : public Darabonba::Model {
public:
  shared_ptr<string> nameSpaceShortId{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> vpcId{};

  UpdateNamespaceVpcRequest() {}

  explicit UpdateNamespaceVpcRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nameSpaceShortId) {
      res["NameSpaceShortId"] = boost::any(*nameSpaceShortId);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NameSpaceShortId") != m.end() && !m["NameSpaceShortId"].empty()) {
      nameSpaceShortId = make_shared<string>(boost::any_cast<string>(m["NameSpaceShortId"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~UpdateNamespaceVpcRequest() = default;
};
class UpdateNamespaceVpcResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  UpdateNamespaceVpcResponseBody() {}

  explicit UpdateNamespaceVpcResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~UpdateNamespaceVpcResponseBody() = default;
};
class UpdateNamespaceVpcResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateNamespaceVpcResponseBody> body{};

  UpdateNamespaceVpcResponse() {}

  explicit UpdateNamespaceVpcResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateNamespaceVpcResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateNamespaceVpcResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateNamespaceVpcResponse() = default;
};
class UpdateSecretRequestSecretData : public Darabonba::Model {
public:
  shared_ptr<string> secretData{};

  UpdateSecretRequestSecretData() {}

  explicit UpdateSecretRequestSecretData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (secretData) {
      res["SecretData"] = boost::any(*secretData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecretData") != m.end() && !m["SecretData"].empty()) {
      secretData = make_shared<string>(boost::any_cast<string>(m["SecretData"]));
    }
  }


  virtual ~UpdateSecretRequestSecretData() = default;
};
class UpdateSecretRequest : public Darabonba::Model {
public:
  shared_ptr<string> namespaceId{};
  shared_ptr<UpdateSecretRequestSecretData> secretData{};
  shared_ptr<long> secretId{};

  UpdateSecretRequest() {}

  explicit UpdateSecretRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (secretData) {
      res["SecretData"] = secretData ? boost::any(secretData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (secretId) {
      res["SecretId"] = boost::any(*secretId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("SecretData") != m.end() && !m["SecretData"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecretData"].type()) {
        UpdateSecretRequestSecretData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecretData"]));
        secretData = make_shared<UpdateSecretRequestSecretData>(model1);
      }
    }
    if (m.find("SecretId") != m.end() && !m["SecretId"].empty()) {
      secretId = make_shared<long>(boost::any_cast<long>(m["SecretId"]));
    }
  }


  virtual ~UpdateSecretRequest() = default;
};
class UpdateSecretShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> namespaceId{};
  shared_ptr<string> secretDataShrink{};
  shared_ptr<long> secretId{};

  UpdateSecretShrinkRequest() {}

  explicit UpdateSecretShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (secretDataShrink) {
      res["SecretData"] = boost::any(*secretDataShrink);
    }
    if (secretId) {
      res["SecretId"] = boost::any(*secretId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("SecretData") != m.end() && !m["SecretData"].empty()) {
      secretDataShrink = make_shared<string>(boost::any_cast<string>(m["SecretData"]));
    }
    if (m.find("SecretId") != m.end() && !m["SecretId"].empty()) {
      secretId = make_shared<long>(boost::any_cast<long>(m["SecretId"]));
    }
  }


  virtual ~UpdateSecretShrinkRequest() = default;
};
class UpdateSecretResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> secretId{};

  UpdateSecretResponseBodyData() {}

  explicit UpdateSecretResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (secretId) {
      res["SecretId"] = boost::any(*secretId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecretId") != m.end() && !m["SecretId"].empty()) {
      secretId = make_shared<long>(boost::any_cast<long>(m["SecretId"]));
    }
  }


  virtual ~UpdateSecretResponseBodyData() = default;
};
class UpdateSecretResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<UpdateSecretResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  UpdateSecretResponseBody() {}

  explicit UpdateSecretResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        UpdateSecretResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<UpdateSecretResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~UpdateSecretResponseBody() = default;
};
class UpdateSecretResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateSecretResponseBody> body{};

  UpdateSecretResponse() {}

  explicit UpdateSecretResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateSecretResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateSecretResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateSecretResponse() = default;
};
class UpdateSwimmingLaneEnableAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<bool> enable{};
  shared_ptr<long> groupId{};
  shared_ptr<long> laneId{};
  shared_ptr<string> namespaceId{};

  UpdateSwimmingLaneEnableAttributeRequest() {}

  explicit UpdateSwimmingLaneEnableAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (laneId) {
      res["LaneId"] = boost::any(*laneId);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("LaneId") != m.end() && !m["LaneId"].empty()) {
      laneId = make_shared<long>(boost::any_cast<long>(m["LaneId"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
  }


  virtual ~UpdateSwimmingLaneEnableAttributeRequest() = default;
};
class UpdateSwimmingLaneEnableAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  UpdateSwimmingLaneEnableAttributeResponseBody() {}

  explicit UpdateSwimmingLaneEnableAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~UpdateSwimmingLaneEnableAttributeResponseBody() = default;
};
class UpdateSwimmingLaneEnableAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateSwimmingLaneEnableAttributeResponseBody> body{};

  UpdateSwimmingLaneEnableAttributeResponse() {}

  explicit UpdateSwimmingLaneEnableAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateSwimmingLaneEnableAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateSwimmingLaneEnableAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateSwimmingLaneEnableAttributeResponse() = default;
};
class UpdateWebApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> namespaceId{};
  shared_ptr<UpdateWebApplicationInput> body{};

  UpdateWebApplicationRequest() {}

  explicit UpdateWebApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateWebApplicationInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateWebApplicationInput>(model1);
      }
    }
  }


  virtual ~UpdateWebApplicationRequest() = default;
};
class UpdateWebApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<WebApplicationBody> body{};

  UpdateWebApplicationResponse() {}

  explicit UpdateWebApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        WebApplicationBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<WebApplicationBody>(model1);
      }
    }
  }


  virtual ~UpdateWebApplicationResponse() = default;
};
class UpdateWebApplicationScalingConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> namespaceId{};
  shared_ptr<UpdateWebApplicationScalingConfigInput> body{};

  UpdateWebApplicationScalingConfigRequest() {}

  explicit UpdateWebApplicationScalingConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateWebApplicationScalingConfigInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateWebApplicationScalingConfigInput>(model1);
      }
    }
  }


  virtual ~UpdateWebApplicationScalingConfigRequest() = default;
};
class UpdateWebApplicationScalingConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<WebApplicationScalingConfigBody> body{};

  UpdateWebApplicationScalingConfigResponse() {}

  explicit UpdateWebApplicationScalingConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        WebApplicationScalingConfigBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<WebApplicationScalingConfigBody>(model1);
      }
    }
  }


  virtual ~UpdateWebApplicationScalingConfigResponse() = default;
};
class UpdateWebApplicationTrafficConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> namespaceId{};
  shared_ptr<UpdateWebApplicationTrafficConfigInput> body{};

  UpdateWebApplicationTrafficConfigRequest() {}

  explicit UpdateWebApplicationTrafficConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateWebApplicationTrafficConfigInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateWebApplicationTrafficConfigInput>(model1);
      }
    }
  }


  virtual ~UpdateWebApplicationTrafficConfigRequest() = default;
};
class UpdateWebApplicationTrafficConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<WebApplicationTrafficConfigBody> body{};

  UpdateWebApplicationTrafficConfigResponse() {}

  explicit UpdateWebApplicationTrafficConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        WebApplicationTrafficConfigBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<WebApplicationTrafficConfigBody>(model1);
      }
    }
  }


  virtual ~UpdateWebApplicationTrafficConfigResponse() = default;
};
class UpdateWebCustomDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> namespaceId{};
  shared_ptr<UpdateWebCustomDomainInput> body{};

  UpdateWebCustomDomainRequest() {}

  explicit UpdateWebCustomDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateWebCustomDomainInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateWebCustomDomainInput>(model1);
      }
    }
  }


  virtual ~UpdateWebCustomDomainRequest() = default;
};
class UpdateWebCustomDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<WebCustomDomainBody> body{};

  UpdateWebCustomDomainResponse() {}

  explicit UpdateWebCustomDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        WebCustomDomainBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<WebCustomDomainBody>(model1);
      }
    }
  }


  virtual ~UpdateWebCustomDomainResponse() = default;
};
class UpgradeApplicationApmServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  UpgradeApplicationApmServiceRequest() {}

  explicit UpgradeApplicationApmServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~UpgradeApplicationApmServiceRequest() = default;
};
class UpgradeApplicationApmServiceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> status{};

  UpgradeApplicationApmServiceResponseBodyData() {}

  explicit UpgradeApplicationApmServiceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<bool>(boost::any_cast<bool>(m["Status"]));
    }
  }


  virtual ~UpgradeApplicationApmServiceResponseBodyData() = default;
};
class UpgradeApplicationApmServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<UpgradeApplicationApmServiceResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  UpgradeApplicationApmServiceResponseBody() {}

  explicit UpgradeApplicationApmServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        UpgradeApplicationApmServiceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<UpgradeApplicationApmServiceResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~UpgradeApplicationApmServiceResponseBody() = default;
};
class UpgradeApplicationApmServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpgradeApplicationApmServiceResponseBody> body{};

  UpgradeApplicationApmServiceResponse() {}

  explicit UpgradeApplicationApmServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpgradeApplicationApmServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpgradeApplicationApmServiceResponseBody>(model1);
      }
    }
  }


  virtual ~UpgradeApplicationApmServiceResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AbortAndRollbackChangeOrderResponse abortAndRollbackChangeOrderWithOptions(shared_ptr<AbortAndRollbackChangeOrderRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AbortAndRollbackChangeOrderResponse abortAndRollbackChangeOrder(shared_ptr<AbortAndRollbackChangeOrderRequest> request);
  AbortChangeOrderResponse abortChangeOrderWithOptions(shared_ptr<AbortChangeOrderRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AbortChangeOrderResponse abortChangeOrder(shared_ptr<AbortChangeOrderRequest> request);
  BatchStartApplicationsResponse batchStartApplicationsWithOptions(shared_ptr<BatchStartApplicationsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchStartApplicationsResponse batchStartApplications(shared_ptr<BatchStartApplicationsRequest> request);
  BatchStopApplicationsResponse batchStopApplicationsWithOptions(shared_ptr<BatchStopApplicationsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchStopApplicationsResponse batchStopApplications(shared_ptr<BatchStopApplicationsRequest> request);
  BindSlbResponse bindSlbWithOptions(shared_ptr<BindSlbRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BindSlbResponse bindSlb(shared_ptr<BindSlbRequest> request);
  ConfirmPipelineBatchResponse confirmPipelineBatchWithOptions(shared_ptr<ConfirmPipelineBatchRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ConfirmPipelineBatchResponse confirmPipelineBatch(shared_ptr<ConfirmPipelineBatchRequest> request);
  CreateApplicationResponse createApplicationWithOptions(shared_ptr<CreateApplicationRequest> tmpReq, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateApplicationResponse createApplication(shared_ptr<CreateApplicationRequest> request);
  CreateApplicationScalingRuleResponse createApplicationScalingRuleWithOptions(shared_ptr<CreateApplicationScalingRuleRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateApplicationScalingRuleResponse createApplicationScalingRule(shared_ptr<CreateApplicationScalingRuleRequest> request);
  CreateConfigMapResponse createConfigMapWithOptions(shared_ptr<CreateConfigMapRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateConfigMapResponse createConfigMap(shared_ptr<CreateConfigMapRequest> request);
  CreateGreyTagRouteResponse createGreyTagRouteWithOptions(shared_ptr<CreateGreyTagRouteRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateGreyTagRouteResponse createGreyTagRoute(shared_ptr<CreateGreyTagRouteRequest> request);
  CreateIngressResponse createIngressWithOptions(shared_ptr<CreateIngressRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateIngressResponse createIngress(shared_ptr<CreateIngressRequest> request);
  CreateJobResponse createJobWithOptions(shared_ptr<CreateJobRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateJobResponse createJob(shared_ptr<CreateJobRequest> request);
  CreateNamespaceResponse createNamespaceWithOptions(shared_ptr<CreateNamespaceRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateNamespaceResponse createNamespace(shared_ptr<CreateNamespaceRequest> request);
  CreateOrUpdateSwimmingLaneResponse createOrUpdateSwimmingLaneWithOptions(shared_ptr<CreateOrUpdateSwimmingLaneRequest> tmpReq, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOrUpdateSwimmingLaneResponse createOrUpdateSwimmingLane(shared_ptr<CreateOrUpdateSwimmingLaneRequest> request);
  CreateOrUpdateSwimmingLaneGroupResponse createOrUpdateSwimmingLaneGroupWithOptions(shared_ptr<CreateOrUpdateSwimmingLaneGroupRequest> tmpReq, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOrUpdateSwimmingLaneGroupResponse createOrUpdateSwimmingLaneGroup(shared_ptr<CreateOrUpdateSwimmingLaneGroupRequest> request);
  CreateSecretResponse createSecretWithOptions(shared_ptr<CreateSecretRequest> tmpReq, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSecretResponse createSecret(shared_ptr<CreateSecretRequest> request);
  CreateWebApplicationResponse createWebApplicationWithOptions(shared_ptr<CreateWebApplicationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateWebApplicationResponse createWebApplication(shared_ptr<CreateWebApplicationRequest> request);
  CreateWebCustomDomainResponse createWebCustomDomainWithOptions(shared_ptr<CreateWebCustomDomainRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateWebCustomDomainResponse createWebCustomDomain(shared_ptr<CreateWebCustomDomainRequest> request);
  DeleteApplicationResponse deleteApplicationWithOptions(shared_ptr<DeleteApplicationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteApplicationResponse deleteApplication(shared_ptr<DeleteApplicationRequest> request);
  DeleteApplicationScalingRuleResponse deleteApplicationScalingRuleWithOptions(shared_ptr<DeleteApplicationScalingRuleRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteApplicationScalingRuleResponse deleteApplicationScalingRule(shared_ptr<DeleteApplicationScalingRuleRequest> request);
  DeleteConfigMapResponse deleteConfigMapWithOptions(shared_ptr<DeleteConfigMapRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteConfigMapResponse deleteConfigMap(shared_ptr<DeleteConfigMapRequest> request);
  DeleteGreyTagRouteResponse deleteGreyTagRouteWithOptions(shared_ptr<DeleteGreyTagRouteRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteGreyTagRouteResponse deleteGreyTagRoute(shared_ptr<DeleteGreyTagRouteRequest> request);
  DeleteHistoryJobResponse deleteHistoryJobWithOptions(shared_ptr<DeleteHistoryJobRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteHistoryJobResponse deleteHistoryJob(shared_ptr<DeleteHistoryJobRequest> request);
  DeleteIngressResponse deleteIngressWithOptions(shared_ptr<DeleteIngressRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteIngressResponse deleteIngress(shared_ptr<DeleteIngressRequest> request);
  DeleteInstancesResponse deleteInstancesWithOptions(shared_ptr<DeleteInstancesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteInstancesResponse deleteInstances(shared_ptr<DeleteInstancesRequest> request);
  DeleteJobResponse deleteJobWithOptions(shared_ptr<DeleteJobRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteJobResponse deleteJob(shared_ptr<DeleteJobRequest> request);
  DeleteNamespaceResponse deleteNamespaceWithOptions(shared_ptr<DeleteNamespaceRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteNamespaceResponse deleteNamespace(shared_ptr<DeleteNamespaceRequest> request);
  DeleteSecretResponse deleteSecretWithOptions(shared_ptr<DeleteSecretRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSecretResponse deleteSecret(shared_ptr<DeleteSecretRequest> request);
  DeleteSwimmingLaneGroupResponse deleteSwimmingLaneGroupWithOptions(shared_ptr<DeleteSwimmingLaneGroupRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSwimmingLaneGroupResponse deleteSwimmingLaneGroup(shared_ptr<DeleteSwimmingLaneGroupRequest> request);
  DeleteWebApplicationResponse deleteWebApplicationWithOptions(shared_ptr<string> ApplicationId,
                                                               shared_ptr<DeleteWebApplicationRequest> request,
                                                               shared_ptr<map<string, string>> headers,
                                                               shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteWebApplicationResponse deleteWebApplication(shared_ptr<string> ApplicationId, shared_ptr<DeleteWebApplicationRequest> request);
  DeleteWebApplicationRevisionResponse deleteWebApplicationRevisionWithOptions(shared_ptr<string> ApplicationId,
                                                                               shared_ptr<string> RevisionId,
                                                                               shared_ptr<DeleteWebApplicationRevisionRequest> request,
                                                                               shared_ptr<map<string, string>> headers,
                                                                               shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteWebApplicationRevisionResponse deleteWebApplicationRevision(shared_ptr<string> ApplicationId, shared_ptr<string> RevisionId, shared_ptr<DeleteWebApplicationRevisionRequest> request);
  DeleteWebCustomDomainResponse deleteWebCustomDomainWithOptions(shared_ptr<string> DomainName,
                                                                 shared_ptr<DeleteWebCustomDomainRequest> request,
                                                                 shared_ptr<map<string, string>> headers,
                                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteWebCustomDomainResponse deleteWebCustomDomain(shared_ptr<string> DomainName, shared_ptr<DeleteWebCustomDomainRequest> request);
  DeployApplicationResponse deployApplicationWithOptions(shared_ptr<DeployApplicationRequest> tmpReq, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeployApplicationResponse deployApplication(shared_ptr<DeployApplicationRequest> request);
  DescribeAppServiceDetailResponse describeAppServiceDetailWithOptions(shared_ptr<DescribeAppServiceDetailRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAppServiceDetailResponse describeAppServiceDetail(shared_ptr<DescribeAppServiceDetailRequest> request);
  DescribeApplicationConfigResponse describeApplicationConfigWithOptions(shared_ptr<DescribeApplicationConfigRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApplicationConfigResponse describeApplicationConfig(shared_ptr<DescribeApplicationConfigRequest> request);
  DescribeApplicationGroupsResponse describeApplicationGroupsWithOptions(shared_ptr<DescribeApplicationGroupsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApplicationGroupsResponse describeApplicationGroups(shared_ptr<DescribeApplicationGroupsRequest> request);
  DescribeApplicationImageResponse describeApplicationImageWithOptions(shared_ptr<DescribeApplicationImageRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApplicationImageResponse describeApplicationImage(shared_ptr<DescribeApplicationImageRequest> request);
  DescribeApplicationInstancesResponse describeApplicationInstancesWithOptions(shared_ptr<DescribeApplicationInstancesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApplicationInstancesResponse describeApplicationInstances(shared_ptr<DescribeApplicationInstancesRequest> request);
  DescribeApplicationScalingRuleResponse describeApplicationScalingRuleWithOptions(shared_ptr<DescribeApplicationScalingRuleRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApplicationScalingRuleResponse describeApplicationScalingRule(shared_ptr<DescribeApplicationScalingRuleRequest> request);
  DescribeApplicationScalingRulesResponse describeApplicationScalingRulesWithOptions(shared_ptr<DescribeApplicationScalingRulesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApplicationScalingRulesResponse describeApplicationScalingRules(shared_ptr<DescribeApplicationScalingRulesRequest> request);
  DescribeApplicationSlbsResponse describeApplicationSlbsWithOptions(shared_ptr<DescribeApplicationSlbsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApplicationSlbsResponse describeApplicationSlbs(shared_ptr<DescribeApplicationSlbsRequest> request);
  DescribeApplicationStatusResponse describeApplicationStatusWithOptions(shared_ptr<DescribeApplicationStatusRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApplicationStatusResponse describeApplicationStatus(shared_ptr<DescribeApplicationStatusRequest> request);
  DescribeChangeOrderResponse describeChangeOrderWithOptions(shared_ptr<DescribeChangeOrderRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeChangeOrderResponse describeChangeOrder(shared_ptr<DescribeChangeOrderRequest> request);
  DescribeComponentsResponse describeComponentsWithOptions(shared_ptr<DescribeComponentsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeComponentsResponse describeComponents(shared_ptr<DescribeComponentsRequest> request);
  DescribeConfigMapResponse describeConfigMapWithOptions(shared_ptr<DescribeConfigMapRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeConfigMapResponse describeConfigMap(shared_ptr<DescribeConfigMapRequest> request);
  DescribeConfigurationPriceResponse describeConfigurationPriceWithOptions(shared_ptr<DescribeConfigurationPriceRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeConfigurationPriceResponse describeConfigurationPrice(shared_ptr<DescribeConfigurationPriceRequest> request);
  DescribeEdasContainersResponse describeEdasContainersWithOptions(shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEdasContainersResponse describeEdasContainers();
  DescribeGreyTagRouteResponse describeGreyTagRouteWithOptions(shared_ptr<DescribeGreyTagRouteRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeGreyTagRouteResponse describeGreyTagRoute(shared_ptr<DescribeGreyTagRouteRequest> request);
  DescribeIngressResponse describeIngressWithOptions(shared_ptr<DescribeIngressRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeIngressResponse describeIngress(shared_ptr<DescribeIngressRequest> request);
  DescribeInstanceLogResponse describeInstanceLogWithOptions(shared_ptr<DescribeInstanceLogRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceLogResponse describeInstanceLog(shared_ptr<DescribeInstanceLogRequest> request);
  DescribeInstanceSpecificationsResponse describeInstanceSpecificationsWithOptions(shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceSpecificationsResponse describeInstanceSpecifications();
  DescribeJobResponse describeJobWithOptions(shared_ptr<DescribeJobRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeJobResponse describeJob(shared_ptr<DescribeJobRequest> request);
  DescribeJobHistoryResponse describeJobHistoryWithOptions(shared_ptr<DescribeJobHistoryRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeJobHistoryResponse describeJobHistory(shared_ptr<DescribeJobHistoryRequest> request);
  DescribeJobStatusResponse describeJobStatusWithOptions(shared_ptr<DescribeJobStatusRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeJobStatusResponse describeJobStatus(shared_ptr<DescribeJobStatusRequest> request);
  DescribeNamespaceResponse describeNamespaceWithOptions(shared_ptr<DescribeNamespaceRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeNamespaceResponse describeNamespace(shared_ptr<DescribeNamespaceRequest> request);
  DescribeNamespaceListResponse describeNamespaceListWithOptions(shared_ptr<DescribeNamespaceListRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeNamespaceListResponse describeNamespaceList(shared_ptr<DescribeNamespaceListRequest> request);
  DescribeNamespaceResourcesResponse describeNamespaceResourcesWithOptions(shared_ptr<DescribeNamespaceResourcesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeNamespaceResourcesResponse describeNamespaceResources(shared_ptr<DescribeNamespaceResourcesRequest> request);
  DescribeNamespacesResponse describeNamespacesWithOptions(shared_ptr<DescribeNamespacesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeNamespacesResponse describeNamespaces(shared_ptr<DescribeNamespacesRequest> request);
  DescribePipelineResponse describePipelineWithOptions(shared_ptr<DescribePipelineRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePipelineResponse describePipeline(shared_ptr<DescribePipelineRequest> request);
  DescribeRegionsResponse describeRegionsWithOptions(shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRegionsResponse describeRegions();
  DescribeSecretResponse describeSecretWithOptions(shared_ptr<DescribeSecretRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSecretResponse describeSecret(shared_ptr<DescribeSecretRequest> request);
  DescribeSwimmingLaneResponse describeSwimmingLaneWithOptions(shared_ptr<DescribeSwimmingLaneRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSwimmingLaneResponse describeSwimmingLane(shared_ptr<DescribeSwimmingLaneRequest> request);
  DescribeWebApplicationResponse describeWebApplicationWithOptions(shared_ptr<string> ApplicationId,
                                                                   shared_ptr<DescribeWebApplicationRequest> request,
                                                                   shared_ptr<map<string, string>> headers,
                                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeWebApplicationResponse describeWebApplication(shared_ptr<string> ApplicationId, shared_ptr<DescribeWebApplicationRequest> request);
  DescribeWebApplicationResourceStaticsResponse describeWebApplicationResourceStaticsWithOptions(shared_ptr<string> ApplicationId,
                                                                                                 shared_ptr<DescribeWebApplicationResourceStaticsRequest> request,
                                                                                                 shared_ptr<map<string, string>> headers,
                                                                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeWebApplicationResourceStaticsResponse describeWebApplicationResourceStatics(shared_ptr<string> ApplicationId, shared_ptr<DescribeWebApplicationResourceStaticsRequest> request);
  DescribeWebApplicationRevisionResponse describeWebApplicationRevisionWithOptions(shared_ptr<string> ApplicationId,
                                                                                   shared_ptr<string> RevisionId,
                                                                                   shared_ptr<DescribeWebApplicationRevisionRequest> request,
                                                                                   shared_ptr<map<string, string>> headers,
                                                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeWebApplicationRevisionResponse describeWebApplicationRevision(shared_ptr<string> ApplicationId, shared_ptr<string> RevisionId, shared_ptr<DescribeWebApplicationRevisionRequest> request);
  DescribeWebApplicationScalingConfigResponse describeWebApplicationScalingConfigWithOptions(shared_ptr<string> ApplicationId,
                                                                                             shared_ptr<DescribeWebApplicationScalingConfigRequest> request,
                                                                                             shared_ptr<map<string, string>> headers,
                                                                                             shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeWebApplicationScalingConfigResponse describeWebApplicationScalingConfig(shared_ptr<string> ApplicationId, shared_ptr<DescribeWebApplicationScalingConfigRequest> request);
  DescribeWebApplicationTrafficConfigResponse describeWebApplicationTrafficConfigWithOptions(shared_ptr<string> ApplicationId,
                                                                                             shared_ptr<DescribeWebApplicationTrafficConfigRequest> request,
                                                                                             shared_ptr<map<string, string>> headers,
                                                                                             shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeWebApplicationTrafficConfigResponse describeWebApplicationTrafficConfig(shared_ptr<string> ApplicationId, shared_ptr<DescribeWebApplicationTrafficConfigRequest> request);
  DescribeWebCustomDomainResponse describeWebCustomDomainWithOptions(shared_ptr<string> DomainName,
                                                                     shared_ptr<DescribeWebCustomDomainRequest> request,
                                                                     shared_ptr<map<string, string>> headers,
                                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeWebCustomDomainResponse describeWebCustomDomain(shared_ptr<string> DomainName, shared_ptr<DescribeWebCustomDomainRequest> request);
  DescribeWebInstanceLogsResponse describeWebInstanceLogsWithOptions(shared_ptr<string> ApplicationId,
                                                                     shared_ptr<string> InstanceId,
                                                                     shared_ptr<DescribeWebInstanceLogsRequest> request,
                                                                     shared_ptr<map<string, string>> headers,
                                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeWebInstanceLogsResponse describeWebInstanceLogs(shared_ptr<string> ApplicationId, shared_ptr<string> InstanceId, shared_ptr<DescribeWebInstanceLogsRequest> request);
  DisableApplicationScalingRuleResponse disableApplicationScalingRuleWithOptions(shared_ptr<DisableApplicationScalingRuleRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableApplicationScalingRuleResponse disableApplicationScalingRule(shared_ptr<DisableApplicationScalingRuleRequest> request);
  DowngradeApplicationApmServiceResponse downgradeApplicationApmServiceWithOptions(shared_ptr<DowngradeApplicationApmServiceRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DowngradeApplicationApmServiceResponse downgradeApplicationApmService(shared_ptr<DowngradeApplicationApmServiceRequest> request);
  EnableApplicationScalingRuleResponse enableApplicationScalingRuleWithOptions(shared_ptr<EnableApplicationScalingRuleRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableApplicationScalingRuleResponse enableApplicationScalingRule(shared_ptr<EnableApplicationScalingRuleRequest> request);
  ExecJobResponse execJobWithOptions(shared_ptr<ExecJobRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExecJobResponse execJob(shared_ptr<ExecJobRequest> request);
  GetApplicationResponse getApplicationWithOptions(shared_ptr<GetApplicationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetApplicationResponse getApplication(shared_ptr<GetApplicationRequest> request);
  GetArmsTopNMetricResponse getArmsTopNMetricWithOptions(shared_ptr<GetArmsTopNMetricRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetArmsTopNMetricResponse getArmsTopNMetric(shared_ptr<GetArmsTopNMetricRequest> request);
  GetAvailabilityMetricResponse getAvailabilityMetricWithOptions(shared_ptr<GetAvailabilityMetricRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAvailabilityMetricResponse getAvailabilityMetric(shared_ptr<GetAvailabilityMetricRequest> request);
  GetChangeOrderMetricResponse getChangeOrderMetricWithOptions(shared_ptr<GetChangeOrderMetricRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetChangeOrderMetricResponse getChangeOrderMetric(shared_ptr<GetChangeOrderMetricRequest> request);
  GetScaleAppMetricResponse getScaleAppMetricWithOptions(shared_ptr<GetScaleAppMetricRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetScaleAppMetricResponse getScaleAppMetric(shared_ptr<GetScaleAppMetricRequest> request);
  GetWarningEventMetricResponse getWarningEventMetricWithOptions(shared_ptr<GetWarningEventMetricRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetWarningEventMetricResponse getWarningEventMetric(shared_ptr<GetWarningEventMetricRequest> request);
  GetWebshellTokenResponse getWebshellTokenWithOptions(shared_ptr<GetWebshellTokenRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetWebshellTokenResponse getWebshellToken(shared_ptr<GetWebshellTokenRequest> request);
  ListAllSwimmingLaneGroupsResponse listAllSwimmingLaneGroupsWithOptions(shared_ptr<ListAllSwimmingLaneGroupsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAllSwimmingLaneGroupsResponse listAllSwimmingLaneGroups(shared_ptr<ListAllSwimmingLaneGroupsRequest> request);
  ListAllSwimmingLanesResponse listAllSwimmingLanesWithOptions(shared_ptr<ListAllSwimmingLanesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAllSwimmingLanesResponse listAllSwimmingLanes(shared_ptr<ListAllSwimmingLanesRequest> request);
  ListAppEventsResponse listAppEventsWithOptions(shared_ptr<ListAppEventsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAppEventsResponse listAppEvents(shared_ptr<ListAppEventsRequest> request);
  ListAppServicesResponse listAppServicesWithOptions(shared_ptr<ListAppServicesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAppServicesResponse listAppServices(shared_ptr<ListAppServicesRequest> request);
  ListAppServicesPageResponse listAppServicesPageWithOptions(shared_ptr<ListAppServicesPageRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAppServicesPageResponse listAppServicesPage(shared_ptr<ListAppServicesPageRequest> request);
  ListAppVersionsResponse listAppVersionsWithOptions(shared_ptr<ListAppVersionsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAppVersionsResponse listAppVersions(shared_ptr<ListAppVersionsRequest> request);
  ListApplicationsResponse listApplicationsWithOptions(shared_ptr<ListApplicationsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListApplicationsResponse listApplications(shared_ptr<ListApplicationsRequest> request);
  ListApplicationsForSwimmingLaneResponse listApplicationsForSwimmingLaneWithOptions(shared_ptr<ListApplicationsForSwimmingLaneRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListApplicationsForSwimmingLaneResponse listApplicationsForSwimmingLane(shared_ptr<ListApplicationsForSwimmingLaneRequest> request);
  ListChangeOrdersResponse listChangeOrdersWithOptions(shared_ptr<ListChangeOrdersRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListChangeOrdersResponse listChangeOrders(shared_ptr<ListChangeOrdersRequest> request);
  ListConsumedServicesResponse listConsumedServicesWithOptions(shared_ptr<ListConsumedServicesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListConsumedServicesResponse listConsumedServices(shared_ptr<ListConsumedServicesRequest> request);
  ListGreyTagRouteResponse listGreyTagRouteWithOptions(shared_ptr<ListGreyTagRouteRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListGreyTagRouteResponse listGreyTagRoute(shared_ptr<ListGreyTagRouteRequest> request);
  ListIngressesResponse listIngressesWithOptions(shared_ptr<ListIngressesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListIngressesResponse listIngresses(shared_ptr<ListIngressesRequest> request);
  ListJobsResponse listJobsWithOptions(shared_ptr<ListJobsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListJobsResponse listJobs(shared_ptr<ListJobsRequest> request);
  ListLogConfigsResponse listLogConfigsWithOptions(shared_ptr<ListLogConfigsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLogConfigsResponse listLogConfigs(shared_ptr<ListLogConfigsRequest> request);
  ListNamespaceChangeOrdersResponse listNamespaceChangeOrdersWithOptions(shared_ptr<ListNamespaceChangeOrdersRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListNamespaceChangeOrdersResponse listNamespaceChangeOrders(shared_ptr<ListNamespaceChangeOrdersRequest> request);
  ListNamespacedConfigMapsResponse listNamespacedConfigMapsWithOptions(shared_ptr<ListNamespacedConfigMapsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListNamespacedConfigMapsResponse listNamespacedConfigMaps(shared_ptr<ListNamespacedConfigMapsRequest> request);
  ListPublishedServicesResponse listPublishedServicesWithOptions(shared_ptr<ListPublishedServicesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPublishedServicesResponse listPublishedServices(shared_ptr<ListPublishedServicesRequest> request);
  ListSecretsResponse listSecretsWithOptions(shared_ptr<ListSecretsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSecretsResponse listSecrets(shared_ptr<ListSecretsRequest> request);
  ListSwimmingLaneGatewayRoutesResponse listSwimmingLaneGatewayRoutesWithOptions(shared_ptr<ListSwimmingLaneGatewayRoutesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSwimmingLaneGatewayRoutesResponse listSwimmingLaneGatewayRoutes(shared_ptr<ListSwimmingLaneGatewayRoutesRequest> request);
  ListSwimmingLaneGroupTagsResponse listSwimmingLaneGroupTagsWithOptions(shared_ptr<ListSwimmingLaneGroupTagsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSwimmingLaneGroupTagsResponse listSwimmingLaneGroupTags(shared_ptr<ListSwimmingLaneGroupTagsRequest> request);
  ListTagResourcesResponse listTagResourcesWithOptions(shared_ptr<ListTagResourcesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTagResourcesResponse listTagResources(shared_ptr<ListTagResourcesRequest> request);
  ListWebApplicationInstancesResponse listWebApplicationInstancesWithOptions(shared_ptr<string> ApplicationId,
                                                                             shared_ptr<ListWebApplicationInstancesRequest> tmpReq,
                                                                             shared_ptr<map<string, string>> headers,
                                                                             shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListWebApplicationInstancesResponse listWebApplicationInstances(shared_ptr<string> ApplicationId, shared_ptr<ListWebApplicationInstancesRequest> request);
  ListWebApplicationRevisionsResponse listWebApplicationRevisionsWithOptions(shared_ptr<string> ApplicationId,
                                                                             shared_ptr<ListWebApplicationRevisionsRequest> request,
                                                                             shared_ptr<map<string, string>> headers,
                                                                             shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListWebApplicationRevisionsResponse listWebApplicationRevisions(shared_ptr<string> ApplicationId, shared_ptr<ListWebApplicationRevisionsRequest> request);
  ListWebApplicationsResponse listWebApplicationsWithOptions(shared_ptr<ListWebApplicationsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListWebApplicationsResponse listWebApplications(shared_ptr<ListWebApplicationsRequest> request);
  ListWebCustomDomainsResponse listWebCustomDomainsWithOptions(shared_ptr<ListWebCustomDomainsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListWebCustomDomainsResponse listWebCustomDomains(shared_ptr<ListWebCustomDomainsRequest> request);
  OpenSaeServiceResponse openSaeServiceWithOptions(shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OpenSaeServiceResponse openSaeService();
  PublishWebApplicationRevisionResponse publishWebApplicationRevisionWithOptions(shared_ptr<string> ApplicationId,
                                                                                 shared_ptr<PublishWebApplicationRevisionRequest> request,
                                                                                 shared_ptr<map<string, string>> headers,
                                                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PublishWebApplicationRevisionResponse publishWebApplicationRevision(shared_ptr<string> ApplicationId, shared_ptr<PublishWebApplicationRevisionRequest> request);
  QueryResourceStaticsResponse queryResourceStaticsWithOptions(shared_ptr<QueryResourceStaticsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryResourceStaticsResponse queryResourceStatics(shared_ptr<QueryResourceStaticsRequest> request);
  ReduceApplicationCapacityByInstanceIdsResponse reduceApplicationCapacityByInstanceIdsWithOptions(shared_ptr<ReduceApplicationCapacityByInstanceIdsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReduceApplicationCapacityByInstanceIdsResponse reduceApplicationCapacityByInstanceIds(shared_ptr<ReduceApplicationCapacityByInstanceIdsRequest> request);
  RescaleApplicationResponse rescaleApplicationWithOptions(shared_ptr<RescaleApplicationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RescaleApplicationResponse rescaleApplication(shared_ptr<RescaleApplicationRequest> request);
  RescaleApplicationVerticallyResponse rescaleApplicationVerticallyWithOptions(shared_ptr<RescaleApplicationVerticallyRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RescaleApplicationVerticallyResponse rescaleApplicationVertically(shared_ptr<RescaleApplicationVerticallyRequest> request);
  RestartApplicationResponse restartApplicationWithOptions(shared_ptr<RestartApplicationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RestartApplicationResponse restartApplication(shared_ptr<RestartApplicationRequest> request);
  RestartInstancesResponse restartInstancesWithOptions(shared_ptr<RestartInstancesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RestartInstancesResponse restartInstances(shared_ptr<RestartInstancesRequest> request);
  RollbackApplicationResponse rollbackApplicationWithOptions(shared_ptr<RollbackApplicationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RollbackApplicationResponse rollbackApplication(shared_ptr<RollbackApplicationRequest> request);
  StartApplicationResponse startApplicationWithOptions(shared_ptr<StartApplicationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartApplicationResponse startApplication(shared_ptr<StartApplicationRequest> request);
  StartWebApplicationResponse startWebApplicationWithOptions(shared_ptr<string> ApplicationId,
                                                             shared_ptr<StartWebApplicationRequest> request,
                                                             shared_ptr<map<string, string>> headers,
                                                             shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartWebApplicationResponse startWebApplication(shared_ptr<string> ApplicationId, shared_ptr<StartWebApplicationRequest> request);
  StopApplicationResponse stopApplicationWithOptions(shared_ptr<StopApplicationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopApplicationResponse stopApplication(shared_ptr<StopApplicationRequest> request);
  StopWebApplicationResponse stopWebApplicationWithOptions(shared_ptr<string> ApplicationId,
                                                           shared_ptr<StopWebApplicationRequest> request,
                                                           shared_ptr<map<string, string>> headers,
                                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopWebApplicationResponse stopWebApplication(shared_ptr<string> ApplicationId, shared_ptr<StopWebApplicationRequest> request);
  SuspendJobResponse suspendJobWithOptions(shared_ptr<SuspendJobRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SuspendJobResponse suspendJob(shared_ptr<SuspendJobRequest> request);
  TagResourcesResponse tagResourcesWithOptions(shared_ptr<TagResourcesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TagResourcesResponse tagResources(shared_ptr<TagResourcesRequest> request);
  UnbindNlbResponse unbindNlbWithOptions(shared_ptr<UnbindNlbRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnbindNlbResponse unbindNlb(shared_ptr<UnbindNlbRequest> request);
  UnbindSlbResponse unbindSlbWithOptions(shared_ptr<UnbindSlbRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnbindSlbResponse unbindSlb(shared_ptr<UnbindSlbRequest> request);
  UntagResourcesResponse untagResourcesWithOptions(shared_ptr<UntagResourcesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UntagResourcesResponse untagResources(shared_ptr<UntagResourcesRequest> request);
  UpdateAppSecurityGroupResponse updateAppSecurityGroupWithOptions(shared_ptr<UpdateAppSecurityGroupRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAppSecurityGroupResponse updateAppSecurityGroup(shared_ptr<UpdateAppSecurityGroupRequest> request);
  UpdateApplicationDescriptionResponse updateApplicationDescriptionWithOptions(shared_ptr<UpdateApplicationDescriptionRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateApplicationDescriptionResponse updateApplicationDescription(shared_ptr<UpdateApplicationDescriptionRequest> request);
  UpdateApplicationScalingRuleResponse updateApplicationScalingRuleWithOptions(shared_ptr<UpdateApplicationScalingRuleRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateApplicationScalingRuleResponse updateApplicationScalingRule(shared_ptr<UpdateApplicationScalingRuleRequest> request);
  UpdateApplicationVswitchesResponse updateApplicationVswitchesWithOptions(shared_ptr<UpdateApplicationVswitchesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateApplicationVswitchesResponse updateApplicationVswitches(shared_ptr<UpdateApplicationVswitchesRequest> request);
  UpdateConfigMapResponse updateConfigMapWithOptions(shared_ptr<UpdateConfigMapRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateConfigMapResponse updateConfigMap(shared_ptr<UpdateConfigMapRequest> request);
  UpdateGreyTagRouteResponse updateGreyTagRouteWithOptions(shared_ptr<UpdateGreyTagRouteRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateGreyTagRouteResponse updateGreyTagRoute(shared_ptr<UpdateGreyTagRouteRequest> request);
  UpdateIngressResponse updateIngressWithOptions(shared_ptr<UpdateIngressRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateIngressResponse updateIngress(shared_ptr<UpdateIngressRequest> request);
  UpdateJobResponse updateJobWithOptions(shared_ptr<UpdateJobRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateJobResponse updateJob(shared_ptr<UpdateJobRequest> request);
  UpdateNamespaceResponse updateNamespaceWithOptions(shared_ptr<UpdateNamespaceRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateNamespaceResponse updateNamespace(shared_ptr<UpdateNamespaceRequest> request);
  UpdateNamespaceVpcResponse updateNamespaceVpcWithOptions(shared_ptr<UpdateNamespaceVpcRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateNamespaceVpcResponse updateNamespaceVpc(shared_ptr<UpdateNamespaceVpcRequest> request);
  UpdateSecretResponse updateSecretWithOptions(shared_ptr<UpdateSecretRequest> tmpReq, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateSecretResponse updateSecret(shared_ptr<UpdateSecretRequest> request);
  UpdateSwimmingLaneEnableAttributeResponse updateSwimmingLaneEnableAttributeWithOptions(shared_ptr<UpdateSwimmingLaneEnableAttributeRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateSwimmingLaneEnableAttributeResponse updateSwimmingLaneEnableAttribute(shared_ptr<UpdateSwimmingLaneEnableAttributeRequest> request);
  UpdateWebApplicationResponse updateWebApplicationWithOptions(shared_ptr<string> ApplicationId,
                                                               shared_ptr<UpdateWebApplicationRequest> request,
                                                               shared_ptr<map<string, string>> headers,
                                                               shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateWebApplicationResponse updateWebApplication(shared_ptr<string> ApplicationId, shared_ptr<UpdateWebApplicationRequest> request);
  UpdateWebApplicationScalingConfigResponse updateWebApplicationScalingConfigWithOptions(shared_ptr<string> ApplicationId,
                                                                                         shared_ptr<UpdateWebApplicationScalingConfigRequest> request,
                                                                                         shared_ptr<map<string, string>> headers,
                                                                                         shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateWebApplicationScalingConfigResponse updateWebApplicationScalingConfig(shared_ptr<string> ApplicationId, shared_ptr<UpdateWebApplicationScalingConfigRequest> request);
  UpdateWebApplicationTrafficConfigResponse updateWebApplicationTrafficConfigWithOptions(shared_ptr<string> ApplicationId,
                                                                                         shared_ptr<UpdateWebApplicationTrafficConfigRequest> request,
                                                                                         shared_ptr<map<string, string>> headers,
                                                                                         shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateWebApplicationTrafficConfigResponse updateWebApplicationTrafficConfig(shared_ptr<string> ApplicationId, shared_ptr<UpdateWebApplicationTrafficConfigRequest> request);
  UpdateWebCustomDomainResponse updateWebCustomDomainWithOptions(shared_ptr<string> DomainName,
                                                                 shared_ptr<UpdateWebCustomDomainRequest> request,
                                                                 shared_ptr<map<string, string>> headers,
                                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateWebCustomDomainResponse updateWebCustomDomain(shared_ptr<string> DomainName, shared_ptr<UpdateWebCustomDomainRequest> request);
  UpgradeApplicationApmServiceResponse upgradeApplicationApmServiceWithOptions(shared_ptr<UpgradeApplicationApmServiceRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpgradeApplicationApmServiceResponse upgradeApplicationApmService(shared_ptr<UpgradeApplicationApmServiceRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Sae20190506

#endif
