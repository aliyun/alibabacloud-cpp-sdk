// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_DDI20200617_H_
#define ALIBABACLOUD_DDI20200617_H_

#include <alibabacloud/open_api.hpp>
#include <boost/throw_exception.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Ddi20200617 {
class CreateFlowRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};
  shared_ptr<long> startSchedule{};
  shared_ptr<long> endSchedule{};
  shared_ptr<string> cronExpression{};
  shared_ptr<bool> createCluster{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> hostName{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> application{};
  shared_ptr<string> alertConf{};
  shared_ptr<string> alertUserGroupBizId{};
  shared_ptr<string> alertDingDingGroupBizId{};
  shared_ptr<string> parentFlowList{};
  shared_ptr<string> parentCategory{};
  shared_ptr<string> clientToken{};

  CreateFlowRequest() {}

  explicit CreateFlowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (startSchedule) {
      res["StartSchedule"] = boost::any(*startSchedule);
    }
    if (endSchedule) {
      res["EndSchedule"] = boost::any(*endSchedule);
    }
    if (cronExpression) {
      res["CronExpression"] = boost::any(*cronExpression);
    }
    if (createCluster) {
      res["CreateCluster"] = boost::any(*createCluster);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (application) {
      res["Application"] = boost::any(*application);
    }
    if (alertConf) {
      res["AlertConf"] = boost::any(*alertConf);
    }
    if (alertUserGroupBizId) {
      res["AlertUserGroupBizId"] = boost::any(*alertUserGroupBizId);
    }
    if (alertDingDingGroupBizId) {
      res["AlertDingDingGroupBizId"] = boost::any(*alertDingDingGroupBizId);
    }
    if (parentFlowList) {
      res["ParentFlowList"] = boost::any(*parentFlowList);
    }
    if (parentCategory) {
      res["ParentCategory"] = boost::any(*parentCategory);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("StartSchedule") != m.end() && !m["StartSchedule"].empty()) {
      startSchedule = make_shared<long>(boost::any_cast<long>(m["StartSchedule"]));
    }
    if (m.find("EndSchedule") != m.end() && !m["EndSchedule"].empty()) {
      endSchedule = make_shared<long>(boost::any_cast<long>(m["EndSchedule"]));
    }
    if (m.find("CronExpression") != m.end() && !m["CronExpression"].empty()) {
      cronExpression = make_shared<string>(boost::any_cast<string>(m["CronExpression"]));
    }
    if (m.find("CreateCluster") != m.end() && !m["CreateCluster"].empty()) {
      createCluster = make_shared<bool>(boost::any_cast<bool>(m["CreateCluster"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Application") != m.end() && !m["Application"].empty()) {
      application = make_shared<string>(boost::any_cast<string>(m["Application"]));
    }
    if (m.find("AlertConf") != m.end() && !m["AlertConf"].empty()) {
      alertConf = make_shared<string>(boost::any_cast<string>(m["AlertConf"]));
    }
    if (m.find("AlertUserGroupBizId") != m.end() && !m["AlertUserGroupBizId"].empty()) {
      alertUserGroupBizId = make_shared<string>(boost::any_cast<string>(m["AlertUserGroupBizId"]));
    }
    if (m.find("AlertDingDingGroupBizId") != m.end() && !m["AlertDingDingGroupBizId"].empty()) {
      alertDingDingGroupBizId = make_shared<string>(boost::any_cast<string>(m["AlertDingDingGroupBizId"]));
    }
    if (m.find("ParentFlowList") != m.end() && !m["ParentFlowList"].empty()) {
      parentFlowList = make_shared<string>(boost::any_cast<string>(m["ParentFlowList"]));
    }
    if (m.find("ParentCategory") != m.end() && !m["ParentCategory"].empty()) {
      parentCategory = make_shared<string>(boost::any_cast<string>(m["ParentCategory"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
  }


  virtual ~CreateFlowRequest() = default;
};
class CreateFlowResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  CreateFlowResponseBody() {}

  explicit CreateFlowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateFlowResponseBody() = default;
};
class CreateFlowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateFlowResponseBody> body{};

  CreateFlowResponse() {}

  explicit CreateFlowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateFlowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateFlowResponseBody>(model1);
      }
    }
  }


  virtual ~CreateFlowResponse() = default;
};
class ListUsersRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> type{};

  ListUsersRequest() {}

  explicit ListUsersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListUsersRequest() = default;
};
class ListUsersResponseBodyUserListUser : public Darabonba::Model {
public:
  shared_ptr<string> linuxStatus{};
  shared_ptr<string> k8sStatus{};
  shared_ptr<string> knoxStatus{};
  shared_ptr<string> groupName{};
  shared_ptr<string> userId{};
  shared_ptr<string> kerberosStatus{};
  shared_ptr<string> userName{};

  ListUsersResponseBodyUserListUser() {}

  explicit ListUsersResponseBodyUserListUser(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (linuxStatus) {
      res["LinuxStatus"] = boost::any(*linuxStatus);
    }
    if (k8sStatus) {
      res["K8sStatus"] = boost::any(*k8sStatus);
    }
    if (knoxStatus) {
      res["KnoxStatus"] = boost::any(*knoxStatus);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (kerberosStatus) {
      res["KerberosStatus"] = boost::any(*kerberosStatus);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LinuxStatus") != m.end() && !m["LinuxStatus"].empty()) {
      linuxStatus = make_shared<string>(boost::any_cast<string>(m["LinuxStatus"]));
    }
    if (m.find("K8sStatus") != m.end() && !m["K8sStatus"].empty()) {
      k8sStatus = make_shared<string>(boost::any_cast<string>(m["K8sStatus"]));
    }
    if (m.find("KnoxStatus") != m.end() && !m["KnoxStatus"].empty()) {
      knoxStatus = make_shared<string>(boost::any_cast<string>(m["KnoxStatus"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("KerberosStatus") != m.end() && !m["KerberosStatus"].empty()) {
      kerberosStatus = make_shared<string>(boost::any_cast<string>(m["KerberosStatus"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~ListUsersResponseBodyUserListUser() = default;
};
class ListUsersResponseBodyUserList : public Darabonba::Model {
public:
  shared_ptr<vector<ListUsersResponseBodyUserListUser>> user{};

  ListUsersResponseBodyUserList() {}

  explicit ListUsersResponseBodyUserList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (user) {
      vector<boost::any> temp1;
      for(auto item1:*user){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["User"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("User") != m.end() && !m["User"].empty()) {
      if (typeid(vector<boost::any>) == m["User"].type()) {
        vector<ListUsersResponseBodyUserListUser> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["User"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUsersResponseBodyUserListUser model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        user = make_shared<vector<ListUsersResponseBodyUserListUser>>(expect1);
      }
    }
  }


  virtual ~ListUsersResponseBodyUserList() = default;
};
class ListUsersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListUsersResponseBodyUserList> userList{};

  ListUsersResponseBody() {}

  explicit ListUsersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (userList) {
      res["UserList"] = userList ? boost::any(userList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UserList") != m.end() && !m["UserList"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserList"].type()) {
        ListUsersResponseBodyUserList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserList"]));
        userList = make_shared<ListUsersResponseBodyUserList>(model1);
      }
    }
  }


  virtual ~ListUsersResponseBody() = default;
};
class ListUsersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListUsersResponseBody> body{};

  ListUsersResponse() {}

  explicit ListUsersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListUsersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListUsersResponseBody>(model1);
      }
    }
  }


  virtual ~ListUsersResponse() = default;
};
class ModifyFlowProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};

  ModifyFlowProjectRequest() {}

  explicit ModifyFlowProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~ModifyFlowProjectRequest() = default;
};
class ModifyFlowProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  ModifyFlowProjectResponseBody() {}

  explicit ModifyFlowProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyFlowProjectResponseBody() = default;
};
class ModifyFlowProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyFlowProjectResponseBody> body{};

  ModifyFlowProjectResponse() {}

  explicit ModifyFlowProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyFlowProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyFlowProjectResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyFlowProjectResponse() = default;
};
class QueryKnoxUserPasswordRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> userId{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> clusterId{};

  QueryKnoxUserPasswordRequest() {}

  explicit QueryKnoxUserPasswordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
  }


  virtual ~QueryKnoxUserPasswordRequest() = default;
};
class QueryKnoxUserPasswordResponseBodyUserInfoListUserInfo : public Darabonba::Model {
public:
  shared_ptr<string> password{};
  shared_ptr<string> userName{};
  shared_ptr<string> userId{};

  QueryKnoxUserPasswordResponseBodyUserInfoListUserInfo() {}

  explicit QueryKnoxUserPasswordResponseBodyUserInfoListUserInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~QueryKnoxUserPasswordResponseBodyUserInfoListUserInfo() = default;
};
class QueryKnoxUserPasswordResponseBodyUserInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryKnoxUserPasswordResponseBodyUserInfoListUserInfo>> userInfo{};

  QueryKnoxUserPasswordResponseBodyUserInfoList() {}

  explicit QueryKnoxUserPasswordResponseBodyUserInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userInfo) {
      vector<boost::any> temp1;
      for(auto item1:*userInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserInfo") != m.end() && !m["UserInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["UserInfo"].type()) {
        vector<QueryKnoxUserPasswordResponseBodyUserInfoListUserInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryKnoxUserPasswordResponseBodyUserInfoListUserInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userInfo = make_shared<vector<QueryKnoxUserPasswordResponseBodyUserInfoListUserInfo>>(expect1);
      }
    }
  }


  virtual ~QueryKnoxUserPasswordResponseBodyUserInfoList() = default;
};
class QueryKnoxUserPasswordResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<QueryKnoxUserPasswordResponseBodyUserInfoList> userInfoList{};

  QueryKnoxUserPasswordResponseBody() {}

  explicit QueryKnoxUserPasswordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (userInfoList) {
      res["UserInfoList"] = userInfoList ? boost::any(userInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UserInfoList") != m.end() && !m["UserInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserInfoList"].type()) {
        QueryKnoxUserPasswordResponseBodyUserInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserInfoList"]));
        userInfoList = make_shared<QueryKnoxUserPasswordResponseBodyUserInfoList>(model1);
      }
    }
  }


  virtual ~QueryKnoxUserPasswordResponseBody() = default;
};
class QueryKnoxUserPasswordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryKnoxUserPasswordResponseBody> body{};

  QueryKnoxUserPasswordResponse() {}

  explicit QueryKnoxUserPasswordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryKnoxUserPasswordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryKnoxUserPasswordResponseBody>(model1);
      }
    }
  }


  virtual ~QueryKnoxUserPasswordResponse() = default;
};
class DescribeFlowNodeInstanceLauncherLogRequest : public Darabonba::Model {
public:
  shared_ptr<long> start{};
  shared_ptr<long> lines{};
  shared_ptr<long> offset{};
  shared_ptr<long> length{};
  shared_ptr<bool> reverse{};
  shared_ptr<long> startTime{};
  shared_ptr<long> endTime{};
  shared_ptr<string> nodeInstanceId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};

  DescribeFlowNodeInstanceLauncherLogRequest() {}

  explicit DescribeFlowNodeInstanceLauncherLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (lines) {
      res["Lines"] = boost::any(*lines);
    }
    if (offset) {
      res["Offset"] = boost::any(*offset);
    }
    if (length) {
      res["Length"] = boost::any(*length);
    }
    if (reverse) {
      res["Reverse"] = boost::any(*reverse);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (nodeInstanceId) {
      res["NodeInstanceId"] = boost::any(*nodeInstanceId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<long>(boost::any_cast<long>(m["Start"]));
    }
    if (m.find("Lines") != m.end() && !m["Lines"].empty()) {
      lines = make_shared<long>(boost::any_cast<long>(m["Lines"]));
    }
    if (m.find("Offset") != m.end() && !m["Offset"].empty()) {
      offset = make_shared<long>(boost::any_cast<long>(m["Offset"]));
    }
    if (m.find("Length") != m.end() && !m["Length"].empty()) {
      length = make_shared<long>(boost::any_cast<long>(m["Length"]));
    }
    if (m.find("Reverse") != m.end() && !m["Reverse"].empty()) {
      reverse = make_shared<bool>(boost::any_cast<bool>(m["Reverse"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("NodeInstanceId") != m.end() && !m["NodeInstanceId"].empty()) {
      nodeInstanceId = make_shared<string>(boost::any_cast<string>(m["NodeInstanceId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeFlowNodeInstanceLauncherLogRequest() = default;
};
class DescribeFlowNodeInstanceLauncherLogResponseBodyLogEntrysLogEntry : public Darabonba::Model {
public:
  shared_ptr<string> content{};

  DescribeFlowNodeInstanceLauncherLogResponseBodyLogEntrysLogEntry() {}

  explicit DescribeFlowNodeInstanceLauncherLogResponseBodyLogEntrysLogEntry(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
  }


  virtual ~DescribeFlowNodeInstanceLauncherLogResponseBodyLogEntrysLogEntry() = default;
};
class DescribeFlowNodeInstanceLauncherLogResponseBodyLogEntrys : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeFlowNodeInstanceLauncherLogResponseBodyLogEntrysLogEntry>> logEntry{};

  DescribeFlowNodeInstanceLauncherLogResponseBodyLogEntrys() {}

  explicit DescribeFlowNodeInstanceLauncherLogResponseBodyLogEntrys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logEntry) {
      vector<boost::any> temp1;
      for(auto item1:*logEntry){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LogEntry"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogEntry") != m.end() && !m["LogEntry"].empty()) {
      if (typeid(vector<boost::any>) == m["LogEntry"].type()) {
        vector<DescribeFlowNodeInstanceLauncherLogResponseBodyLogEntrysLogEntry> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LogEntry"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFlowNodeInstanceLauncherLogResponseBodyLogEntrysLogEntry model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logEntry = make_shared<vector<DescribeFlowNodeInstanceLauncherLogResponseBodyLogEntrysLogEntry>>(expect1);
      }
    }
  }


  virtual ~DescribeFlowNodeInstanceLauncherLogResponseBodyLogEntrys() = default;
};
class DescribeFlowNodeInstanceLauncherLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> logEnd{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeFlowNodeInstanceLauncherLogResponseBodyLogEntrys> logEntrys{};

  DescribeFlowNodeInstanceLauncherLogResponseBody() {}

  explicit DescribeFlowNodeInstanceLauncherLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logEnd) {
      res["LogEnd"] = boost::any(*logEnd);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (logEntrys) {
      res["LogEntrys"] = logEntrys ? boost::any(logEntrys->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogEnd") != m.end() && !m["LogEnd"].empty()) {
      logEnd = make_shared<bool>(boost::any_cast<bool>(m["LogEnd"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("LogEntrys") != m.end() && !m["LogEntrys"].empty()) {
      if (typeid(map<string, boost::any>) == m["LogEntrys"].type()) {
        DescribeFlowNodeInstanceLauncherLogResponseBodyLogEntrys model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LogEntrys"]));
        logEntrys = make_shared<DescribeFlowNodeInstanceLauncherLogResponseBodyLogEntrys>(model1);
      }
    }
  }


  virtual ~DescribeFlowNodeInstanceLauncherLogResponseBody() = default;
};
class DescribeFlowNodeInstanceLauncherLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeFlowNodeInstanceLauncherLogResponseBody> body{};

  DescribeFlowNodeInstanceLauncherLogResponse() {}

  explicit DescribeFlowNodeInstanceLauncherLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFlowNodeInstanceLauncherLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFlowNodeInstanceLauncherLogResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFlowNodeInstanceLauncherLogResponse() = default;
};
class ListFlowRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> name{};
  shared_ptr<string> id{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> status{};
  shared_ptr<bool> periodic{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListFlowRequest() {}

  explicit ListFlowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (periodic) {
      res["Periodic"] = boost::any(*periodic);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Periodic") != m.end() && !m["Periodic"].empty()) {
      periodic = make_shared<bool>(boost::any_cast<bool>(m["Periodic"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListFlowRequest() = default;
};
class ListFlowResponseBodyFlowFlow : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> type{};
  shared_ptr<string> alertUserGroupBizId{};
  shared_ptr<bool> periodic{};
  shared_ptr<string> projectId{};
  shared_ptr<string> hostName{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> description{};
  shared_ptr<bool> createCluster{};
  shared_ptr<long> startSchedule{};
  shared_ptr<long> endSchedule{};
  shared_ptr<string> graph{};
  shared_ptr<string> alertDingDingGroupBizId{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<string> categoryId{};
  shared_ptr<string> cronExpr{};
  shared_ptr<string> name{};
  shared_ptr<string> id{};
  shared_ptr<string> alertConf{};
  shared_ptr<string> clusterId{};

  ListFlowResponseBodyFlowFlow() {}

  explicit ListFlowResponseBodyFlowFlow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (alertUserGroupBizId) {
      res["AlertUserGroupBizId"] = boost::any(*alertUserGroupBizId);
    }
    if (periodic) {
      res["Periodic"] = boost::any(*periodic);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (createCluster) {
      res["CreateCluster"] = boost::any(*createCluster);
    }
    if (startSchedule) {
      res["StartSchedule"] = boost::any(*startSchedule);
    }
    if (endSchedule) {
      res["EndSchedule"] = boost::any(*endSchedule);
    }
    if (graph) {
      res["Graph"] = boost::any(*graph);
    }
    if (alertDingDingGroupBizId) {
      res["AlertDingDingGroupBizId"] = boost::any(*alertDingDingGroupBizId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (cronExpr) {
      res["CronExpr"] = boost::any(*cronExpr);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (alertConf) {
      res["AlertConf"] = boost::any(*alertConf);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("AlertUserGroupBizId") != m.end() && !m["AlertUserGroupBizId"].empty()) {
      alertUserGroupBizId = make_shared<string>(boost::any_cast<string>(m["AlertUserGroupBizId"]));
    }
    if (m.find("Periodic") != m.end() && !m["Periodic"].empty()) {
      periodic = make_shared<bool>(boost::any_cast<bool>(m["Periodic"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("CreateCluster") != m.end() && !m["CreateCluster"].empty()) {
      createCluster = make_shared<bool>(boost::any_cast<bool>(m["CreateCluster"]));
    }
    if (m.find("StartSchedule") != m.end() && !m["StartSchedule"].empty()) {
      startSchedule = make_shared<long>(boost::any_cast<long>(m["StartSchedule"]));
    }
    if (m.find("EndSchedule") != m.end() && !m["EndSchedule"].empty()) {
      endSchedule = make_shared<long>(boost::any_cast<long>(m["EndSchedule"]));
    }
    if (m.find("Graph") != m.end() && !m["Graph"].empty()) {
      graph = make_shared<string>(boost::any_cast<string>(m["Graph"]));
    }
    if (m.find("AlertDingDingGroupBizId") != m.end() && !m["AlertDingDingGroupBizId"].empty()) {
      alertDingDingGroupBizId = make_shared<string>(boost::any_cast<string>(m["AlertDingDingGroupBizId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<string>(boost::any_cast<string>(m["CategoryId"]));
    }
    if (m.find("CronExpr") != m.end() && !m["CronExpr"].empty()) {
      cronExpr = make_shared<string>(boost::any_cast<string>(m["CronExpr"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("AlertConf") != m.end() && !m["AlertConf"].empty()) {
      alertConf = make_shared<string>(boost::any_cast<string>(m["AlertConf"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
  }


  virtual ~ListFlowResponseBodyFlowFlow() = default;
};
class ListFlowResponseBodyFlow : public Darabonba::Model {
public:
  shared_ptr<vector<ListFlowResponseBodyFlowFlow>> flow{};

  ListFlowResponseBodyFlow() {}

  explicit ListFlowResponseBodyFlow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flow) {
      vector<boost::any> temp1;
      for(auto item1:*flow){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Flow"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Flow") != m.end() && !m["Flow"].empty()) {
      if (typeid(vector<boost::any>) == m["Flow"].type()) {
        vector<ListFlowResponseBodyFlowFlow> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Flow"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFlowResponseBodyFlowFlow model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        flow = make_shared<vector<ListFlowResponseBodyFlowFlow>>(expect1);
      }
    }
  }


  virtual ~ListFlowResponseBodyFlow() = default;
};
class ListFlowResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};
  shared_ptr<ListFlowResponseBodyFlow> flow{};

  ListFlowResponseBody() {}

  explicit ListFlowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (flow) {
      res["Flow"] = flow ? boost::any(flow->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("Flow") != m.end() && !m["Flow"].empty()) {
      if (typeid(map<string, boost::any>) == m["Flow"].type()) {
        ListFlowResponseBodyFlow model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Flow"]));
        flow = make_shared<ListFlowResponseBodyFlow>(model1);
      }
    }
  }


  virtual ~ListFlowResponseBody() = default;
};
class ListFlowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListFlowResponseBody> body{};

  ListFlowResponse() {}

  explicit ListFlowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFlowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFlowResponseBody>(model1);
      }
    }
  }


  virtual ~ListFlowResponse() = default;
};
class UntagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<string>> resourceIds{};
  shared_ptr<vector<string>> tagKeys{};
  shared_ptr<bool> all{};

  UntagResourcesRequest() {}

  explicit UntagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (resourceIds) {
      res["ResourceIds"] = boost::any(*resourceIds);
    }
    if (tagKeys) {
      res["TagKeys"] = boost::any(*tagKeys);
    }
    if (all) {
      res["All"] = boost::any(*all);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("ResourceIds") != m.end() && !m["ResourceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TagKeys") != m.end() && !m["TagKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TagKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TagKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tagKeys = make_shared<vector<string>>(toVec1);
    }
    if (m.find("All") != m.end() && !m["All"].empty()) {
      all = make_shared<bool>(boost::any_cast<bool>(m["All"]));
    }
  }


  virtual ~UntagResourcesRequest() = default;
};
class UntagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};

  UntagResourcesResponseBody() {}

  explicit UntagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~UntagResourcesResponseBody() = default;
};
class UntagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UntagResourcesResponseBody> body{};

  UntagResourcesResponse() {}

  explicit UntagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UntagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UntagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~UntagResourcesResponse() = default;
};
class ListFlowClusterHostRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> resourceGroupId{};

  ListFlowClusterHostRequest() {}

  explicit ListFlowClusterHostRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ListFlowClusterHostRequest() = default;
};
class ListFlowClusterHostResponseBodyHostListHost : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> type{};
  shared_ptr<string> serialNumber{};
  shared_ptr<string> privateIp{};
  shared_ptr<string> hostName{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> hostId{};
  shared_ptr<string> hostInstanceId{};
  shared_ptr<long> cpu{};
  shared_ptr<string> publicIp{};
  shared_ptr<long> memory{};
  shared_ptr<string> role{};

  ListFlowClusterHostResponseBodyHostListHost() {}

  explicit ListFlowClusterHostResponseBodyHostListHost(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    if (privateIp) {
      res["PrivateIp"] = boost::any(*privateIp);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (hostId) {
      res["HostId"] = boost::any(*hostId);
    }
    if (hostInstanceId) {
      res["HostInstanceId"] = boost::any(*hostInstanceId);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (publicIp) {
      res["PublicIp"] = boost::any(*publicIp);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["SerialNumber"]));
    }
    if (m.find("PrivateIp") != m.end() && !m["PrivateIp"].empty()) {
      privateIp = make_shared<string>(boost::any_cast<string>(m["PrivateIp"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("HostId") != m.end() && !m["HostId"].empty()) {
      hostId = make_shared<string>(boost::any_cast<string>(m["HostId"]));
    }
    if (m.find("HostInstanceId") != m.end() && !m["HostInstanceId"].empty()) {
      hostInstanceId = make_shared<string>(boost::any_cast<string>(m["HostInstanceId"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("PublicIp") != m.end() && !m["PublicIp"].empty()) {
      publicIp = make_shared<string>(boost::any_cast<string>(m["PublicIp"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
  }


  virtual ~ListFlowClusterHostResponseBodyHostListHost() = default;
};
class ListFlowClusterHostResponseBodyHostList : public Darabonba::Model {
public:
  shared_ptr<vector<ListFlowClusterHostResponseBodyHostListHost>> host{};

  ListFlowClusterHostResponseBodyHostList() {}

  explicit ListFlowClusterHostResponseBodyHostList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (host) {
      vector<boost::any> temp1;
      for(auto item1:*host){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Host"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      if (typeid(vector<boost::any>) == m["Host"].type()) {
        vector<ListFlowClusterHostResponseBodyHostListHost> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Host"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFlowClusterHostResponseBodyHostListHost model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        host = make_shared<vector<ListFlowClusterHostResponseBodyHostListHost>>(expect1);
      }
    }
  }


  virtual ~ListFlowClusterHostResponseBodyHostList() = default;
};
class ListFlowClusterHostResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListFlowClusterHostResponseBodyHostList> hostList{};

  ListFlowClusterHostResponseBody() {}

  explicit ListFlowClusterHostResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (hostList) {
      res["HostList"] = hostList ? boost::any(hostList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HostList") != m.end() && !m["HostList"].empty()) {
      if (typeid(map<string, boost::any>) == m["HostList"].type()) {
        ListFlowClusterHostResponseBodyHostList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HostList"]));
        hostList = make_shared<ListFlowClusterHostResponseBodyHostList>(model1);
      }
    }
  }


  virtual ~ListFlowClusterHostResponseBody() = default;
};
class ListFlowClusterHostResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListFlowClusterHostResponseBody> body{};

  ListFlowClusterHostResponse() {}

  explicit ListFlowClusterHostResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFlowClusterHostResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFlowClusterHostResponseBody>(model1);
      }
    }
  }


  virtual ~ListFlowClusterHostResponse() = default;
};
class ListClusterOperationRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> status{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListClusterOperationRequest() {}

  explicit ListClusterOperationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListClusterOperationRequest() = default;
};
class ListClusterOperationResponseBodyClusterOperationListClusterOperation : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> startTime{};
  shared_ptr<string> comment{};
  shared_ptr<string> operationName{};
  shared_ptr<string> operationId{};
  shared_ptr<string> duration{};
  shared_ptr<string> percentage{};

  ListClusterOperationResponseBodyClusterOperationListClusterOperation() {}

  explicit ListClusterOperationResponseBodyClusterOperationListClusterOperation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (operationName) {
      res["OperationName"] = boost::any(*operationName);
    }
    if (operationId) {
      res["OperationId"] = boost::any(*operationId);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (percentage) {
      res["Percentage"] = boost::any(*percentage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("OperationName") != m.end() && !m["OperationName"].empty()) {
      operationName = make_shared<string>(boost::any_cast<string>(m["OperationName"]));
    }
    if (m.find("OperationId") != m.end() && !m["OperationId"].empty()) {
      operationId = make_shared<string>(boost::any_cast<string>(m["OperationId"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Percentage") != m.end() && !m["Percentage"].empty()) {
      percentage = make_shared<string>(boost::any_cast<string>(m["Percentage"]));
    }
  }


  virtual ~ListClusterOperationResponseBodyClusterOperationListClusterOperation() = default;
};
class ListClusterOperationResponseBodyClusterOperationList : public Darabonba::Model {
public:
  shared_ptr<vector<ListClusterOperationResponseBodyClusterOperationListClusterOperation>> clusterOperation{};

  ListClusterOperationResponseBodyClusterOperationList() {}

  explicit ListClusterOperationResponseBodyClusterOperationList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterOperation) {
      vector<boost::any> temp1;
      for(auto item1:*clusterOperation){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ClusterOperation"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterOperation") != m.end() && !m["ClusterOperation"].empty()) {
      if (typeid(vector<boost::any>) == m["ClusterOperation"].type()) {
        vector<ListClusterOperationResponseBodyClusterOperationListClusterOperation> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ClusterOperation"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClusterOperationResponseBodyClusterOperationListClusterOperation model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clusterOperation = make_shared<vector<ListClusterOperationResponseBodyClusterOperationListClusterOperation>>(expect1);
      }
    }
  }


  virtual ~ListClusterOperationResponseBodyClusterOperationList() = default;
};
class ListClusterOperationResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> totalCount{};
  shared_ptr<ListClusterOperationResponseBodyClusterOperationList> clusterOperationList{};

  ListClusterOperationResponseBody() {}

  explicit ListClusterOperationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (clusterOperationList) {
      res["ClusterOperationList"] = clusterOperationList ? boost::any(clusterOperationList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("ClusterOperationList") != m.end() && !m["ClusterOperationList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClusterOperationList"].type()) {
        ListClusterOperationResponseBodyClusterOperationList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClusterOperationList"]));
        clusterOperationList = make_shared<ListClusterOperationResponseBodyClusterOperationList>(model1);
      }
    }
  }


  virtual ~ListClusterOperationResponseBody() = default;
};
class ListClusterOperationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListClusterOperationResponseBody> body{};

  ListClusterOperationResponse() {}

  explicit ListClusterOperationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListClusterOperationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListClusterOperationResponseBody>(model1);
      }
    }
  }


  virtual ~ListClusterOperationResponse() = default;
};
class ListFlowEntitySnapshotRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> limit{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> currentSize{};
  shared_ptr<long> pageCount{};
  shared_ptr<string> orderField{};
  shared_ptr<string> orderMode{};
  shared_ptr<string> committerId{};
  shared_ptr<string> entityType{};
  shared_ptr<string> entityGroupId{};
  shared_ptr<string> entityId{};
  shared_ptr<string> revision{};

  ListFlowEntitySnapshotRequest() {}

  explicit ListFlowEntitySnapshotRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (limit) {
      res["Limit"] = boost::any(*limit);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentSize) {
      res["CurrentSize"] = boost::any(*currentSize);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (orderField) {
      res["OrderField"] = boost::any(*orderField);
    }
    if (orderMode) {
      res["OrderMode"] = boost::any(*orderMode);
    }
    if (committerId) {
      res["CommitterId"] = boost::any(*committerId);
    }
    if (entityType) {
      res["EntityType"] = boost::any(*entityType);
    }
    if (entityGroupId) {
      res["EntityGroupId"] = boost::any(*entityGroupId);
    }
    if (entityId) {
      res["EntityId"] = boost::any(*entityId);
    }
    if (revision) {
      res["Revision"] = boost::any(*revision);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Limit") != m.end() && !m["Limit"].empty()) {
      limit = make_shared<long>(boost::any_cast<long>(m["Limit"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("CurrentSize") != m.end() && !m["CurrentSize"].empty()) {
      currentSize = make_shared<long>(boost::any_cast<long>(m["CurrentSize"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("OrderField") != m.end() && !m["OrderField"].empty()) {
      orderField = make_shared<string>(boost::any_cast<string>(m["OrderField"]));
    }
    if (m.find("OrderMode") != m.end() && !m["OrderMode"].empty()) {
      orderMode = make_shared<string>(boost::any_cast<string>(m["OrderMode"]));
    }
    if (m.find("CommitterId") != m.end() && !m["CommitterId"].empty()) {
      committerId = make_shared<string>(boost::any_cast<string>(m["CommitterId"]));
    }
    if (m.find("EntityType") != m.end() && !m["EntityType"].empty()) {
      entityType = make_shared<string>(boost::any_cast<string>(m["EntityType"]));
    }
    if (m.find("EntityGroupId") != m.end() && !m["EntityGroupId"].empty()) {
      entityGroupId = make_shared<string>(boost::any_cast<string>(m["EntityGroupId"]));
    }
    if (m.find("EntityId") != m.end() && !m["EntityId"].empty()) {
      entityId = make_shared<string>(boost::any_cast<string>(m["EntityId"]));
    }
    if (m.find("Revision") != m.end() && !m["Revision"].empty()) {
      revision = make_shared<string>(boost::any_cast<string>(m["Revision"]));
    }
  }


  virtual ~ListFlowEntitySnapshotRequest() = default;
};
class ListFlowEntitySnapshotResponseBodyItemsItem : public Darabonba::Model {
public:
  shared_ptr<bool> active{};
  shared_ptr<string> data{};
  shared_ptr<string> entityId{};
  shared_ptr<string> entityType{};
  shared_ptr<string> userId{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<string> message{};
  shared_ptr<string> entityGroupId{};
  shared_ptr<string> committerId{};
  shared_ptr<string> revision{};

  ListFlowEntitySnapshotResponseBodyItemsItem() {}

  explicit ListFlowEntitySnapshotResponseBodyItemsItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (active) {
      res["Active"] = boost::any(*active);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (entityId) {
      res["EntityId"] = boost::any(*entityId);
    }
    if (entityType) {
      res["EntityType"] = boost::any(*entityType);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (entityGroupId) {
      res["EntityGroupId"] = boost::any(*entityGroupId);
    }
    if (committerId) {
      res["CommitterId"] = boost::any(*committerId);
    }
    if (revision) {
      res["Revision"] = boost::any(*revision);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Active") != m.end() && !m["Active"].empty()) {
      active = make_shared<bool>(boost::any_cast<bool>(m["Active"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("EntityId") != m.end() && !m["EntityId"].empty()) {
      entityId = make_shared<string>(boost::any_cast<string>(m["EntityId"]));
    }
    if (m.find("EntityType") != m.end() && !m["EntityType"].empty()) {
      entityType = make_shared<string>(boost::any_cast<string>(m["EntityType"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("EntityGroupId") != m.end() && !m["EntityGroupId"].empty()) {
      entityGroupId = make_shared<string>(boost::any_cast<string>(m["EntityGroupId"]));
    }
    if (m.find("CommitterId") != m.end() && !m["CommitterId"].empty()) {
      committerId = make_shared<string>(boost::any_cast<string>(m["CommitterId"]));
    }
    if (m.find("Revision") != m.end() && !m["Revision"].empty()) {
      revision = make_shared<string>(boost::any_cast<string>(m["Revision"]));
    }
  }


  virtual ~ListFlowEntitySnapshotResponseBodyItemsItem() = default;
};
class ListFlowEntitySnapshotResponseBodyItems : public Darabonba::Model {
public:
  shared_ptr<vector<ListFlowEntitySnapshotResponseBodyItemsItem>> item{};

  ListFlowEntitySnapshotResponseBodyItems() {}

  explicit ListFlowEntitySnapshotResponseBodyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (item) {
      vector<boost::any> temp1;
      for(auto item1:*item){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Item"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Item") != m.end() && !m["Item"].empty()) {
      if (typeid(vector<boost::any>) == m["Item"].type()) {
        vector<ListFlowEntitySnapshotResponseBodyItemsItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Item"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFlowEntitySnapshotResponseBodyItemsItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        item = make_shared<vector<ListFlowEntitySnapshotResponseBodyItemsItem>>(expect1);
      }
    }
  }


  virtual ~ListFlowEntitySnapshotResponseBodyItems() = default;
};
class ListFlowEntitySnapshotResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<ListFlowEntitySnapshotResponseBodyItems> items{};

  ListFlowEntitySnapshotResponseBody() {}

  explicit ListFlowEntitySnapshotResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (items) {
      res["Items"] = items ? boost::any(items->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(map<string, boost::any>) == m["Items"].type()) {
        ListFlowEntitySnapshotResponseBodyItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Items"]));
        items = make_shared<ListFlowEntitySnapshotResponseBodyItems>(model1);
      }
    }
  }


  virtual ~ListFlowEntitySnapshotResponseBody() = default;
};
class ListFlowEntitySnapshotResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListFlowEntitySnapshotResponseBody> body{};

  ListFlowEntitySnapshotResponse() {}

  explicit ListFlowEntitySnapshotResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFlowEntitySnapshotResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFlowEntitySnapshotResponseBody>(model1);
      }
    }
  }


  virtual ~ListFlowEntitySnapshotResponse() = default;
};
class DeleteClusterTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> bizId{};
  shared_ptr<string> resourceGroupId{};

  DeleteClusterTemplateRequest() {}

  explicit DeleteClusterTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~DeleteClusterTemplateRequest() = default;
};
class DeleteClusterTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteClusterTemplateResponseBody() {}

  explicit DeleteClusterTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteClusterTemplateResponseBody() = default;
};
class DeleteClusterTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteClusterTemplateResponseBody> body{};

  DeleteClusterTemplateResponse() {}

  explicit DeleteClusterTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteClusterTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteClusterTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteClusterTemplateResponse() = default;
};
class CancelOrderRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> clusterId{};

  CancelOrderRequest() {}

  explicit CancelOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
  }


  virtual ~CancelOrderRequest() = default;
};
class CancelOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> requestId{};

  CancelOrderResponseBody() {}

  explicit CancelOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["clusterId"] = boost::any(*clusterId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clusterId") != m.end() && !m["clusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["clusterId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CancelOrderResponseBody() = default;
};
class CancelOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CancelOrderResponseBody> body{};

  CancelOrderResponse() {}

  explicit CancelOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelOrderResponseBody>(model1);
      }
    }
  }


  virtual ~CancelOrderResponse() = default;
};
class CloneFlowJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};

  CloneFlowJobRequest() {}

  explicit CloneFlowJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CloneFlowJobRequest() = default;
};
class CloneFlowJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  CloneFlowJobResponseBody() {}

  explicit CloneFlowJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CloneFlowJobResponseBody() = default;
};
class CloneFlowJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CloneFlowJobResponseBody> body{};

  CloneFlowJobResponse() {}

  explicit CloneFlowJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CloneFlowJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CloneFlowJobResponseBody>(model1);
      }
    }
  }


  virtual ~CloneFlowJobResponse() = default;
};
class StartFlowRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> flowInstanceId{};

  StartFlowRequest() {}

  explicit StartFlowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (flowInstanceId) {
      res["FlowInstanceId"] = boost::any(*flowInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("FlowInstanceId") != m.end() && !m["FlowInstanceId"].empty()) {
      flowInstanceId = make_shared<string>(boost::any_cast<string>(m["FlowInstanceId"]));
    }
  }


  virtual ~StartFlowRequest() = default;
};
class StartFlowResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  StartFlowResponseBody() {}

  explicit StartFlowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartFlowResponseBody() = default;
};
class StartFlowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<StartFlowResponseBody> body{};

  StartFlowResponse() {}

  explicit StartFlowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartFlowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartFlowResponseBody>(model1);
      }
    }
  }


  virtual ~StartFlowResponse() = default;
};
class CreateFlowJobRequestResourceList : public Darabonba::Model {
public:
  shared_ptr<string> path{};
  shared_ptr<string> alias{};

  CreateFlowJobRequestResourceList() {}

  explicit CreateFlowJobRequestResourceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
  }


  virtual ~CreateFlowJobRequestResourceList() = default;
};
class CreateFlowJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};
  shared_ptr<string> type{};
  shared_ptr<string> failAct{};
  shared_ptr<string> retryPolicy{};
  shared_ptr<string> params{};
  shared_ptr<string> paramConf{};
  shared_ptr<string> customVariables{};
  shared_ptr<string> envConf{};
  shared_ptr<string> runConf{};
  shared_ptr<string> monitorConf{};
  shared_ptr<string> mode{};
  shared_ptr<string> parentCategory{};
  shared_ptr<bool> adhoc{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> alertConf{};
  shared_ptr<string> clientToken{};
  shared_ptr<vector<CreateFlowJobRequestResourceList>> resourceList{};

  CreateFlowJobRequest() {}

  explicit CreateFlowJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (failAct) {
      res["FailAct"] = boost::any(*failAct);
    }
    if (retryPolicy) {
      res["RetryPolicy"] = boost::any(*retryPolicy);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (paramConf) {
      res["ParamConf"] = boost::any(*paramConf);
    }
    if (customVariables) {
      res["CustomVariables"] = boost::any(*customVariables);
    }
    if (envConf) {
      res["EnvConf"] = boost::any(*envConf);
    }
    if (runConf) {
      res["RunConf"] = boost::any(*runConf);
    }
    if (monitorConf) {
      res["MonitorConf"] = boost::any(*monitorConf);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (parentCategory) {
      res["ParentCategory"] = boost::any(*parentCategory);
    }
    if (adhoc) {
      res["Adhoc"] = boost::any(*adhoc);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (alertConf) {
      res["AlertConf"] = boost::any(*alertConf);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (resourceList) {
      vector<boost::any> temp1;
      for(auto item1:*resourceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourceList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("FailAct") != m.end() && !m["FailAct"].empty()) {
      failAct = make_shared<string>(boost::any_cast<string>(m["FailAct"]));
    }
    if (m.find("RetryPolicy") != m.end() && !m["RetryPolicy"].empty()) {
      retryPolicy = make_shared<string>(boost::any_cast<string>(m["RetryPolicy"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      params = make_shared<string>(boost::any_cast<string>(m["Params"]));
    }
    if (m.find("ParamConf") != m.end() && !m["ParamConf"].empty()) {
      paramConf = make_shared<string>(boost::any_cast<string>(m["ParamConf"]));
    }
    if (m.find("CustomVariables") != m.end() && !m["CustomVariables"].empty()) {
      customVariables = make_shared<string>(boost::any_cast<string>(m["CustomVariables"]));
    }
    if (m.find("EnvConf") != m.end() && !m["EnvConf"].empty()) {
      envConf = make_shared<string>(boost::any_cast<string>(m["EnvConf"]));
    }
    if (m.find("RunConf") != m.end() && !m["RunConf"].empty()) {
      runConf = make_shared<string>(boost::any_cast<string>(m["RunConf"]));
    }
    if (m.find("MonitorConf") != m.end() && !m["MonitorConf"].empty()) {
      monitorConf = make_shared<string>(boost::any_cast<string>(m["MonitorConf"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("ParentCategory") != m.end() && !m["ParentCategory"].empty()) {
      parentCategory = make_shared<string>(boost::any_cast<string>(m["ParentCategory"]));
    }
    if (m.find("Adhoc") != m.end() && !m["Adhoc"].empty()) {
      adhoc = make_shared<bool>(boost::any_cast<bool>(m["Adhoc"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("AlertConf") != m.end() && !m["AlertConf"].empty()) {
      alertConf = make_shared<string>(boost::any_cast<string>(m["AlertConf"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ResourceList") != m.end() && !m["ResourceList"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourceList"].type()) {
        vector<CreateFlowJobRequestResourceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateFlowJobRequestResourceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourceList = make_shared<vector<CreateFlowJobRequestResourceList>>(expect1);
      }
    }
  }


  virtual ~CreateFlowJobRequest() = default;
};
class CreateFlowJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  CreateFlowJobResponseBody() {}

  explicit CreateFlowJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateFlowJobResponseBody() = default;
};
class CreateFlowJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateFlowJobResponseBody> body{};

  CreateFlowJobResponse() {}

  explicit CreateFlowJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateFlowJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateFlowJobResponseBody>(model1);
      }
    }
  }


  virtual ~CreateFlowJobResponse() = default;
};
class DeleteFlowCategoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> regionId{};
  shared_ptr<string> projectId{};

  DeleteFlowCategoryRequest() {}

  explicit DeleteFlowCategoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~DeleteFlowCategoryRequest() = default;
};
class DeleteFlowCategoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  DeleteFlowCategoryResponseBody() {}

  explicit DeleteFlowCategoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteFlowCategoryResponseBody() = default;
};
class DeleteFlowCategoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteFlowCategoryResponseBody> body{};

  DeleteFlowCategoryResponse() {}

  explicit DeleteFlowCategoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteFlowCategoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteFlowCategoryResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteFlowCategoryResponse() = default;
};
class DeleteFlowEditLockRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> entityId{};

  DeleteFlowEditLockRequest() {}

  explicit DeleteFlowEditLockRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (entityId) {
      res["EntityId"] = boost::any(*entityId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("EntityId") != m.end() && !m["EntityId"].empty()) {
      entityId = make_shared<string>(boost::any_cast<string>(m["EntityId"]));
    }
  }


  virtual ~DeleteFlowEditLockRequest() = default;
};
class DeleteFlowEditLockResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  DeleteFlowEditLockResponseBody() {}

  explicit DeleteFlowEditLockResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteFlowEditLockResponseBody() = default;
};
class DeleteFlowEditLockResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteFlowEditLockResponseBody> body{};

  DeleteFlowEditLockResponse() {}

  explicit DeleteFlowEditLockResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteFlowEditLockResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteFlowEditLockResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteFlowEditLockResponse() = default;
};
class ResizeClusterRequestHostComponentInfo : public Darabonba::Model {
public:
  shared_ptr<vector<string>> componentNameList{};
  shared_ptr<string> hostName{};
  shared_ptr<string> serviceName{};

  ResizeClusterRequestHostComponentInfo() {}

  explicit ResizeClusterRequestHostComponentInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (componentNameList) {
      res["ComponentNameList"] = boost::any(*componentNameList);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComponentNameList") != m.end() && !m["ComponentNameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ComponentNameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ComponentNameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      componentNameList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~ResizeClusterRequestHostComponentInfo() = default;
};
class ResizeClusterRequestHostGroup : public Darabonba::Model {
public:
  shared_ptr<long> sysDiskCapacity{};
  shared_ptr<string> hostGroupType{};
  shared_ptr<string> comment{};
  shared_ptr<long> vswitchId{};
  shared_ptr<string> sysDiskType{};
  shared_ptr<bool> autoRenew{};
  shared_ptr<string> chargeType{};
  shared_ptr<string> diskType{};
  shared_ptr<string> hostGroupId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> hostKeyPairName{};
  shared_ptr<long> diskCount{};
  shared_ptr<string> createType{};
  shared_ptr<long> period{};
  shared_ptr<string> hostPassword{};
  shared_ptr<long> diskCapacity{};
  shared_ptr<long> nodeCount{};
  shared_ptr<string> hostGroupName{};
  shared_ptr<string> clusterId{};

  ResizeClusterRequestHostGroup() {}

  explicit ResizeClusterRequestHostGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sysDiskCapacity) {
      res["SysDiskCapacity"] = boost::any(*sysDiskCapacity);
    }
    if (hostGroupType) {
      res["HostGroupType"] = boost::any(*hostGroupType);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (vswitchId) {
      res["VswitchId"] = boost::any(*vswitchId);
    }
    if (sysDiskType) {
      res["SysDiskType"] = boost::any(*sysDiskType);
    }
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (diskType) {
      res["DiskType"] = boost::any(*diskType);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (hostKeyPairName) {
      res["HostKeyPairName"] = boost::any(*hostKeyPairName);
    }
    if (diskCount) {
      res["DiskCount"] = boost::any(*diskCount);
    }
    if (createType) {
      res["CreateType"] = boost::any(*createType);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (hostPassword) {
      res["HostPassword"] = boost::any(*hostPassword);
    }
    if (diskCapacity) {
      res["DiskCapacity"] = boost::any(*diskCapacity);
    }
    if (nodeCount) {
      res["NodeCount"] = boost::any(*nodeCount);
    }
    if (hostGroupName) {
      res["HostGroupName"] = boost::any(*hostGroupName);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SysDiskCapacity") != m.end() && !m["SysDiskCapacity"].empty()) {
      sysDiskCapacity = make_shared<long>(boost::any_cast<long>(m["SysDiskCapacity"]));
    }
    if (m.find("HostGroupType") != m.end() && !m["HostGroupType"].empty()) {
      hostGroupType = make_shared<string>(boost::any_cast<string>(m["HostGroupType"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("VswitchId") != m.end() && !m["VswitchId"].empty()) {
      vswitchId = make_shared<long>(boost::any_cast<long>(m["VswitchId"]));
    }
    if (m.find("SysDiskType") != m.end() && !m["SysDiskType"].empty()) {
      sysDiskType = make_shared<string>(boost::any_cast<string>(m["SysDiskType"]));
    }
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["AutoRenew"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("DiskType") != m.end() && !m["DiskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["DiskType"]));
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("HostKeyPairName") != m.end() && !m["HostKeyPairName"].empty()) {
      hostKeyPairName = make_shared<string>(boost::any_cast<string>(m["HostKeyPairName"]));
    }
    if (m.find("DiskCount") != m.end() && !m["DiskCount"].empty()) {
      diskCount = make_shared<long>(boost::any_cast<long>(m["DiskCount"]));
    }
    if (m.find("CreateType") != m.end() && !m["CreateType"].empty()) {
      createType = make_shared<string>(boost::any_cast<string>(m["CreateType"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("HostPassword") != m.end() && !m["HostPassword"].empty()) {
      hostPassword = make_shared<string>(boost::any_cast<string>(m["HostPassword"]));
    }
    if (m.find("DiskCapacity") != m.end() && !m["DiskCapacity"].empty()) {
      diskCapacity = make_shared<long>(boost::any_cast<long>(m["DiskCapacity"]));
    }
    if (m.find("NodeCount") != m.end() && !m["NodeCount"].empty()) {
      nodeCount = make_shared<long>(boost::any_cast<long>(m["NodeCount"]));
    }
    if (m.find("HostGroupName") != m.end() && !m["HostGroupName"].empty()) {
      hostGroupName = make_shared<string>(boost::any_cast<string>(m["HostGroupName"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
  }


  virtual ~ResizeClusterRequestHostGroup() = default;
};
class ResizeClusterRequestPromotionInfo : public Darabonba::Model {
public:
  shared_ptr<string> promotionOptionNo{};
  shared_ptr<string> promotionOptionCode{};
  shared_ptr<string> productCode{};

  ResizeClusterRequestPromotionInfo() {}

  explicit ResizeClusterRequestPromotionInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (promotionOptionNo) {
      res["PromotionOptionNo"] = boost::any(*promotionOptionNo);
    }
    if (promotionOptionCode) {
      res["PromotionOptionCode"] = boost::any(*promotionOptionCode);
    }
    if (productCode) {
      res["ProductCode"] = boost::any(*productCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PromotionOptionNo") != m.end() && !m["PromotionOptionNo"].empty()) {
      promotionOptionNo = make_shared<string>(boost::any_cast<string>(m["PromotionOptionNo"]));
    }
    if (m.find("PromotionOptionCode") != m.end() && !m["PromotionOptionCode"].empty()) {
      promotionOptionCode = make_shared<string>(boost::any_cast<string>(m["PromotionOptionCode"]));
    }
    if (m.find("ProductCode") != m.end() && !m["ProductCode"].empty()) {
      productCode = make_shared<string>(boost::any_cast<string>(m["ProductCode"]));
    }
  }


  virtual ~ResizeClusterRequestPromotionInfo() = default;
};
class ResizeClusterRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> clusterId{};
  shared_ptr<bool> autoPayOrder{};
  shared_ptr<string> vswitchId{};
  shared_ptr<bool> isOpenPublicIp{};
  shared_ptr<vector<ResizeClusterRequestHostComponentInfo>> hostComponentInfo{};
  shared_ptr<vector<ResizeClusterRequestHostGroup>> hostGroup{};
  shared_ptr<vector<ResizeClusterRequestPromotionInfo>> promotionInfo{};

  ResizeClusterRequest() {}

  explicit ResizeClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (autoPayOrder) {
      res["AutoPayOrder"] = boost::any(*autoPayOrder);
    }
    if (vswitchId) {
      res["VswitchId"] = boost::any(*vswitchId);
    }
    if (isOpenPublicIp) {
      res["IsOpenPublicIp"] = boost::any(*isOpenPublicIp);
    }
    if (hostComponentInfo) {
      vector<boost::any> temp1;
      for(auto item1:*hostComponentInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HostComponentInfo"] = boost::any(temp1);
    }
    if (hostGroup) {
      vector<boost::any> temp1;
      for(auto item1:*hostGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HostGroup"] = boost::any(temp1);
    }
    if (promotionInfo) {
      vector<boost::any> temp1;
      for(auto item1:*promotionInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PromotionInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("AutoPayOrder") != m.end() && !m["AutoPayOrder"].empty()) {
      autoPayOrder = make_shared<bool>(boost::any_cast<bool>(m["AutoPayOrder"]));
    }
    if (m.find("VswitchId") != m.end() && !m["VswitchId"].empty()) {
      vswitchId = make_shared<string>(boost::any_cast<string>(m["VswitchId"]));
    }
    if (m.find("IsOpenPublicIp") != m.end() && !m["IsOpenPublicIp"].empty()) {
      isOpenPublicIp = make_shared<bool>(boost::any_cast<bool>(m["IsOpenPublicIp"]));
    }
    if (m.find("HostComponentInfo") != m.end() && !m["HostComponentInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["HostComponentInfo"].type()) {
        vector<ResizeClusterRequestHostComponentInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HostComponentInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ResizeClusterRequestHostComponentInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hostComponentInfo = make_shared<vector<ResizeClusterRequestHostComponentInfo>>(expect1);
      }
    }
    if (m.find("HostGroup") != m.end() && !m["HostGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["HostGroup"].type()) {
        vector<ResizeClusterRequestHostGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HostGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ResizeClusterRequestHostGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hostGroup = make_shared<vector<ResizeClusterRequestHostGroup>>(expect1);
      }
    }
    if (m.find("PromotionInfo") != m.end() && !m["PromotionInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["PromotionInfo"].type()) {
        vector<ResizeClusterRequestPromotionInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PromotionInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ResizeClusterRequestPromotionInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        promotionInfo = make_shared<vector<ResizeClusterRequestPromotionInfo>>(expect1);
      }
    }
  }


  virtual ~ResizeClusterRequest() = default;
};
class ResizeClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> clusterId{};

  ResizeClusterResponseBody() {}

  explicit ResizeClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
  }


  virtual ~ResizeClusterResponseBody() = default;
};
class ResizeClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ResizeClusterResponseBody> body{};

  ResizeClusterResponse() {}

  explicit ResizeClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResizeClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResizeClusterResponseBody>(model1);
      }
    }
  }


  virtual ~ResizeClusterResponse() = default;
};
class DescribeMetaTablePreviewTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> resourceGroupId{};

  DescribeMetaTablePreviewTaskRequest() {}

  explicit DescribeMetaTablePreviewTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~DescribeMetaTablePreviewTaskRequest() = default;
};
class DescribeMetaTablePreviewTaskResponseBodyDataRowsRowColumns : public Darabonba::Model {
public:
  shared_ptr<vector<string>> column{};

  DescribeMetaTablePreviewTaskResponseBodyDataRowsRowColumns() {}

  explicit DescribeMetaTablePreviewTaskResponseBodyDataRowsRowColumns(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (column) {
      res["Column"] = boost::any(*column);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Column") != m.end() && !m["Column"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Column"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Column"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      column = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeMetaTablePreviewTaskResponseBodyDataRowsRowColumns() = default;
};
class DescribeMetaTablePreviewTaskResponseBodyDataRowsRow : public Darabonba::Model {
public:
  shared_ptr<DescribeMetaTablePreviewTaskResponseBodyDataRowsRowColumns> columns{};

  DescribeMetaTablePreviewTaskResponseBodyDataRowsRow() {}

  explicit DescribeMetaTablePreviewTaskResponseBodyDataRowsRow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columns) {
      res["Columns"] = columns ? boost::any(columns->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Columns") != m.end() && !m["Columns"].empty()) {
      if (typeid(map<string, boost::any>) == m["Columns"].type()) {
        DescribeMetaTablePreviewTaskResponseBodyDataRowsRowColumns model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Columns"]));
        columns = make_shared<DescribeMetaTablePreviewTaskResponseBodyDataRowsRowColumns>(model1);
      }
    }
  }


  virtual ~DescribeMetaTablePreviewTaskResponseBodyDataRowsRow() = default;
};
class DescribeMetaTablePreviewTaskResponseBodyDataRows : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMetaTablePreviewTaskResponseBodyDataRowsRow>> row{};

  DescribeMetaTablePreviewTaskResponseBodyDataRows() {}

  explicit DescribeMetaTablePreviewTaskResponseBodyDataRows(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (row) {
      vector<boost::any> temp1;
      for(auto item1:*row){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Row"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Row") != m.end() && !m["Row"].empty()) {
      if (typeid(vector<boost::any>) == m["Row"].type()) {
        vector<DescribeMetaTablePreviewTaskResponseBodyDataRowsRow> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Row"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMetaTablePreviewTaskResponseBodyDataRowsRow model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        row = make_shared<vector<DescribeMetaTablePreviewTaskResponseBodyDataRowsRow>>(expect1);
      }
    }
  }


  virtual ~DescribeMetaTablePreviewTaskResponseBodyDataRows() = default;
};
class DescribeMetaTablePreviewTaskResponseBodyDataHeaders : public Darabonba::Model {
public:
  shared_ptr<vector<string>> header{};

  DescribeMetaTablePreviewTaskResponseBodyDataHeaders() {}

  explicit DescribeMetaTablePreviewTaskResponseBodyDataHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (header) {
      res["Header"] = boost::any(*header);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Header") != m.end() && !m["Header"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Header"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Header"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      header = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeMetaTablePreviewTaskResponseBodyDataHeaders() = default;
};
class DescribeMetaTablePreviewTaskResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<DescribeMetaTablePreviewTaskResponseBodyDataRows> rows{};
  shared_ptr<DescribeMetaTablePreviewTaskResponseBodyDataHeaders> headers{};

  DescribeMetaTablePreviewTaskResponseBodyData() {}

  explicit DescribeMetaTablePreviewTaskResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rows) {
      res["Rows"] = rows ? boost::any(rows->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (headers) {
      res["Headers"] = headers ? boost::any(headers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Rows") != m.end() && !m["Rows"].empty()) {
      if (typeid(map<string, boost::any>) == m["Rows"].type()) {
        DescribeMetaTablePreviewTaskResponseBodyDataRows model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Rows"]));
        rows = make_shared<DescribeMetaTablePreviewTaskResponseBodyDataRows>(model1);
      }
    }
    if (m.find("Headers") != m.end() && !m["Headers"].empty()) {
      if (typeid(map<string, boost::any>) == m["Headers"].type()) {
        DescribeMetaTablePreviewTaskResponseBodyDataHeaders model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Headers"]));
        headers = make_shared<DescribeMetaTablePreviewTaskResponseBodyDataHeaders>(model1);
      }
    }
  }


  virtual ~DescribeMetaTablePreviewTaskResponseBodyData() = default;
};
class DescribeMetaTablePreviewTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<long> startTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> taskStatus{};
  shared_ptr<long> taskProcess{};
  shared_ptr<long> executeTime{};
  shared_ptr<string> taskId{};
  shared_ptr<DescribeMetaTablePreviewTaskResponseBodyData> data{};

  DescribeMetaTablePreviewTaskResponseBody() {}

  explicit DescribeMetaTablePreviewTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (taskProcess) {
      res["TaskProcess"] = boost::any(*taskProcess);
    }
    if (executeTime) {
      res["ExecuteTime"] = boost::any(*executeTime);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<string>(boost::any_cast<string>(m["TaskStatus"]));
    }
    if (m.find("TaskProcess") != m.end() && !m["TaskProcess"].empty()) {
      taskProcess = make_shared<long>(boost::any_cast<long>(m["TaskProcess"]));
    }
    if (m.find("ExecuteTime") != m.end() && !m["ExecuteTime"].empty()) {
      executeTime = make_shared<long>(boost::any_cast<long>(m["ExecuteTime"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeMetaTablePreviewTaskResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeMetaTablePreviewTaskResponseBodyData>(model1);
      }
    }
  }


  virtual ~DescribeMetaTablePreviewTaskResponseBody() = default;
};
class DescribeMetaTablePreviewTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeMetaTablePreviewTaskResponseBody> body{};

  DescribeMetaTablePreviewTaskResponse() {}

  explicit DescribeMetaTablePreviewTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMetaTablePreviewTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMetaTablePreviewTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMetaTablePreviewTaskResponse() = default;
};
class ListClusterServiceConfigHistoryRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> configVersion{};
  shared_ptr<string> hostGroupId{};
  shared_ptr<string> hostInstanceId{};
  shared_ptr<string> configFileName{};
  shared_ptr<string> configItemKey{};
  shared_ptr<string> author{};
  shared_ptr<string> comment{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListClusterServiceConfigHistoryRequest() {}

  explicit ListClusterServiceConfigHistoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (configVersion) {
      res["ConfigVersion"] = boost::any(*configVersion);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (hostInstanceId) {
      res["HostInstanceId"] = boost::any(*hostInstanceId);
    }
    if (configFileName) {
      res["ConfigFileName"] = boost::any(*configFileName);
    }
    if (configItemKey) {
      res["ConfigItemKey"] = boost::any(*configItemKey);
    }
    if (author) {
      res["Author"] = boost::any(*author);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("ConfigVersion") != m.end() && !m["ConfigVersion"].empty()) {
      configVersion = make_shared<string>(boost::any_cast<string>(m["ConfigVersion"]));
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("HostInstanceId") != m.end() && !m["HostInstanceId"].empty()) {
      hostInstanceId = make_shared<string>(boost::any_cast<string>(m["HostInstanceId"]));
    }
    if (m.find("ConfigFileName") != m.end() && !m["ConfigFileName"].empty()) {
      configFileName = make_shared<string>(boost::any_cast<string>(m["ConfigFileName"]));
    }
    if (m.find("ConfigItemKey") != m.end() && !m["ConfigItemKey"].empty()) {
      configItemKey = make_shared<string>(boost::any_cast<string>(m["ConfigItemKey"]));
    }
    if (m.find("Author") != m.end() && !m["Author"].empty()) {
      author = make_shared<string>(boost::any_cast<string>(m["Author"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListClusterServiceConfigHistoryRequest() = default;
};
class ListClusterServiceConfigHistoryResponseBodyConfigHistoryListConfigHistory : public Darabonba::Model {
public:
  shared_ptr<string> oldValue{};
  shared_ptr<string> comment{};
  shared_ptr<long> createTime{};
  shared_ptr<string> hostName{};
  shared_ptr<string> author{};
  shared_ptr<string> configItemName{};
  shared_ptr<string> hostGroupId{};
  shared_ptr<string> newValue{};
  shared_ptr<string> hostInstanceId{};
  shared_ptr<string> configFileName{};
  shared_ptr<bool> applied{};
  shared_ptr<string> configVersion{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> hostGroupName{};

  ListClusterServiceConfigHistoryResponseBodyConfigHistoryListConfigHistory() {}

  explicit ListClusterServiceConfigHistoryResponseBodyConfigHistoryListConfigHistory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (oldValue) {
      res["OldValue"] = boost::any(*oldValue);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (author) {
      res["Author"] = boost::any(*author);
    }
    if (configItemName) {
      res["ConfigItemName"] = boost::any(*configItemName);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (newValue) {
      res["NewValue"] = boost::any(*newValue);
    }
    if (hostInstanceId) {
      res["HostInstanceId"] = boost::any(*hostInstanceId);
    }
    if (configFileName) {
      res["ConfigFileName"] = boost::any(*configFileName);
    }
    if (applied) {
      res["Applied"] = boost::any(*applied);
    }
    if (configVersion) {
      res["ConfigVersion"] = boost::any(*configVersion);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (hostGroupName) {
      res["HostGroupName"] = boost::any(*hostGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OldValue") != m.end() && !m["OldValue"].empty()) {
      oldValue = make_shared<string>(boost::any_cast<string>(m["OldValue"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("Author") != m.end() && !m["Author"].empty()) {
      author = make_shared<string>(boost::any_cast<string>(m["Author"]));
    }
    if (m.find("ConfigItemName") != m.end() && !m["ConfigItemName"].empty()) {
      configItemName = make_shared<string>(boost::any_cast<string>(m["ConfigItemName"]));
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("NewValue") != m.end() && !m["NewValue"].empty()) {
      newValue = make_shared<string>(boost::any_cast<string>(m["NewValue"]));
    }
    if (m.find("HostInstanceId") != m.end() && !m["HostInstanceId"].empty()) {
      hostInstanceId = make_shared<string>(boost::any_cast<string>(m["HostInstanceId"]));
    }
    if (m.find("ConfigFileName") != m.end() && !m["ConfigFileName"].empty()) {
      configFileName = make_shared<string>(boost::any_cast<string>(m["ConfigFileName"]));
    }
    if (m.find("Applied") != m.end() && !m["Applied"].empty()) {
      applied = make_shared<bool>(boost::any_cast<bool>(m["Applied"]));
    }
    if (m.find("ConfigVersion") != m.end() && !m["ConfigVersion"].empty()) {
      configVersion = make_shared<string>(boost::any_cast<string>(m["ConfigVersion"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("HostGroupName") != m.end() && !m["HostGroupName"].empty()) {
      hostGroupName = make_shared<string>(boost::any_cast<string>(m["HostGroupName"]));
    }
  }


  virtual ~ListClusterServiceConfigHistoryResponseBodyConfigHistoryListConfigHistory() = default;
};
class ListClusterServiceConfigHistoryResponseBodyConfigHistoryList : public Darabonba::Model {
public:
  shared_ptr<vector<ListClusterServiceConfigHistoryResponseBodyConfigHistoryListConfigHistory>> configHistory{};

  ListClusterServiceConfigHistoryResponseBodyConfigHistoryList() {}

  explicit ListClusterServiceConfigHistoryResponseBodyConfigHistoryList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configHistory) {
      vector<boost::any> temp1;
      for(auto item1:*configHistory){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigHistory"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigHistory") != m.end() && !m["ConfigHistory"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigHistory"].type()) {
        vector<ListClusterServiceConfigHistoryResponseBodyConfigHistoryListConfigHistory> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigHistory"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClusterServiceConfigHistoryResponseBodyConfigHistoryListConfigHistory model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configHistory = make_shared<vector<ListClusterServiceConfigHistoryResponseBodyConfigHistoryListConfigHistory>>(expect1);
      }
    }
  }


  virtual ~ListClusterServiceConfigHistoryResponseBodyConfigHistoryList() = default;
};
class ListClusterServiceConfigHistoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> totalCount{};
  shared_ptr<ListClusterServiceConfigHistoryResponseBodyConfigHistoryList> configHistoryList{};

  ListClusterServiceConfigHistoryResponseBody() {}

  explicit ListClusterServiceConfigHistoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (configHistoryList) {
      res["ConfigHistoryList"] = configHistoryList ? boost::any(configHistoryList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("ConfigHistoryList") != m.end() && !m["ConfigHistoryList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConfigHistoryList"].type()) {
        ListClusterServiceConfigHistoryResponseBodyConfigHistoryList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConfigHistoryList"]));
        configHistoryList = make_shared<ListClusterServiceConfigHistoryResponseBodyConfigHistoryList>(model1);
      }
    }
  }


  virtual ~ListClusterServiceConfigHistoryResponseBody() = default;
};
class ListClusterServiceConfigHistoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListClusterServiceConfigHistoryResponseBody> body{};

  ListClusterServiceConfigHistoryResponse() {}

  explicit ListClusterServiceConfigHistoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListClusterServiceConfigHistoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListClusterServiceConfigHistoryResponseBody>(model1);
      }
    }
  }


  virtual ~ListClusterServiceConfigHistoryResponse() = default;
};
class ModifyScalingConfigItemRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> configItemInformation{};
  shared_ptr<string> configItemType{};
  shared_ptr<string> configItemBizId{};
  shared_ptr<string> scalingGroupBizId{};

  ModifyScalingConfigItemRequest() {}

  explicit ModifyScalingConfigItemRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["resourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (configItemInformation) {
      res["ConfigItemInformation"] = boost::any(*configItemInformation);
    }
    if (configItemType) {
      res["ConfigItemType"] = boost::any(*configItemType);
    }
    if (configItemBizId) {
      res["ConfigItemBizId"] = boost::any(*configItemBizId);
    }
    if (scalingGroupBizId) {
      res["ScalingGroupBizId"] = boost::any(*scalingGroupBizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("resourceGroupId") != m.end() && !m["resourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["resourceGroupId"]));
    }
    if (m.find("ConfigItemInformation") != m.end() && !m["ConfigItemInformation"].empty()) {
      configItemInformation = make_shared<string>(boost::any_cast<string>(m["ConfigItemInformation"]));
    }
    if (m.find("ConfigItemType") != m.end() && !m["ConfigItemType"].empty()) {
      configItemType = make_shared<string>(boost::any_cast<string>(m["ConfigItemType"]));
    }
    if (m.find("ConfigItemBizId") != m.end() && !m["ConfigItemBizId"].empty()) {
      configItemBizId = make_shared<string>(boost::any_cast<string>(m["ConfigItemBizId"]));
    }
    if (m.find("ScalingGroupBizId") != m.end() && !m["ScalingGroupBizId"].empty()) {
      scalingGroupBizId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupBizId"]));
    }
  }


  virtual ~ModifyScalingConfigItemRequest() = default;
};
class ModifyScalingConfigItemResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> data{};

  ModifyScalingConfigItemResponseBody() {}

  explicit ModifyScalingConfigItemResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
  }


  virtual ~ModifyScalingConfigItemResponseBody() = default;
};
class ModifyScalingConfigItemResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyScalingConfigItemResponseBody> body{};

  ModifyScalingConfigItemResponse() {}

  explicit ModifyScalingConfigItemResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyScalingConfigItemResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyScalingConfigItemResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyScalingConfigItemResponse() = default;
};
class ListFlowClusterAllRequest : public Darabonba::Model {
public:
  shared_ptr<string> productType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};

  ListFlowClusterAllRequest() {}

  explicit ListFlowClusterAllRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productType) {
      res["ProductType"] = boost::any(*productType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductType") != m.end() && !m["ProductType"].empty()) {
      productType = make_shared<string>(boost::any_cast<string>(m["ProductType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ListFlowClusterAllRequest() = default;
};
class ListFlowClusterAllResponseBodyClustersClusterInfoOrderTaskInfo : public Darabonba::Model {
public:
  shared_ptr<long> targetCount{};
  shared_ptr<long> currentCount{};
  shared_ptr<string> orderIdList{};

  ListFlowClusterAllResponseBodyClustersClusterInfoOrderTaskInfo() {}

  explicit ListFlowClusterAllResponseBodyClustersClusterInfoOrderTaskInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (targetCount) {
      res["TargetCount"] = boost::any(*targetCount);
    }
    if (currentCount) {
      res["CurrentCount"] = boost::any(*currentCount);
    }
    if (orderIdList) {
      res["OrderIdList"] = boost::any(*orderIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TargetCount") != m.end() && !m["TargetCount"].empty()) {
      targetCount = make_shared<long>(boost::any_cast<long>(m["TargetCount"]));
    }
    if (m.find("CurrentCount") != m.end() && !m["CurrentCount"].empty()) {
      currentCount = make_shared<long>(boost::any_cast<long>(m["CurrentCount"]));
    }
    if (m.find("OrderIdList") != m.end() && !m["OrderIdList"].empty()) {
      orderIdList = make_shared<string>(boost::any_cast<string>(m["OrderIdList"]));
    }
  }


  virtual ~ListFlowClusterAllResponseBodyClustersClusterInfoOrderTaskInfo() = default;
};
class ListFlowClusterAllResponseBodyClustersClusterInfoFailReason : public Darabonba::Model {
public:
  shared_ptr<string> errorMsg{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};

  ListFlowClusterAllResponseBodyClustersClusterInfoFailReason() {}

  explicit ListFlowClusterAllResponseBodyClustersClusterInfoFailReason(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
  }


  virtual ~ListFlowClusterAllResponseBodyClustersClusterInfoFailReason() = default;
};
class ListFlowClusterAllResponseBodyClustersClusterInfo : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> status{};
  shared_ptr<long> runningTime{};
  shared_ptr<string> orderList{};
  shared_ptr<long> createTime{};
  shared_ptr<string> chargeType{};
  shared_ptr<long> period{};
  shared_ptr<string> k8sClusterId{};
  shared_ptr<long> expiredTime{};
  shared_ptr<bool> hasUncompletedOrder{};
  shared_ptr<string> name{};
  shared_ptr<string> id{};
  shared_ptr<string> createResource{};
  shared_ptr<ListFlowClusterAllResponseBodyClustersClusterInfoOrderTaskInfo> orderTaskInfo{};
  shared_ptr<ListFlowClusterAllResponseBodyClustersClusterInfoFailReason> failReason{};

  ListFlowClusterAllResponseBodyClustersClusterInfo() {}

  explicit ListFlowClusterAllResponseBodyClustersClusterInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (runningTime) {
      res["RunningTime"] = boost::any(*runningTime);
    }
    if (orderList) {
      res["OrderList"] = boost::any(*orderList);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (k8sClusterId) {
      res["K8sClusterId"] = boost::any(*k8sClusterId);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (hasUncompletedOrder) {
      res["HasUncompletedOrder"] = boost::any(*hasUncompletedOrder);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (createResource) {
      res["CreateResource"] = boost::any(*createResource);
    }
    if (orderTaskInfo) {
      res["OrderTaskInfo"] = orderTaskInfo ? boost::any(orderTaskInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (failReason) {
      res["FailReason"] = failReason ? boost::any(failReason->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("RunningTime") != m.end() && !m["RunningTime"].empty()) {
      runningTime = make_shared<long>(boost::any_cast<long>(m["RunningTime"]));
    }
    if (m.find("OrderList") != m.end() && !m["OrderList"].empty()) {
      orderList = make_shared<string>(boost::any_cast<string>(m["OrderList"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("K8sClusterId") != m.end() && !m["K8sClusterId"].empty()) {
      k8sClusterId = make_shared<string>(boost::any_cast<string>(m["K8sClusterId"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<long>(boost::any_cast<long>(m["ExpiredTime"]));
    }
    if (m.find("HasUncompletedOrder") != m.end() && !m["HasUncompletedOrder"].empty()) {
      hasUncompletedOrder = make_shared<bool>(boost::any_cast<bool>(m["HasUncompletedOrder"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("CreateResource") != m.end() && !m["CreateResource"].empty()) {
      createResource = make_shared<string>(boost::any_cast<string>(m["CreateResource"]));
    }
    if (m.find("OrderTaskInfo") != m.end() && !m["OrderTaskInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["OrderTaskInfo"].type()) {
        ListFlowClusterAllResponseBodyClustersClusterInfoOrderTaskInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OrderTaskInfo"]));
        orderTaskInfo = make_shared<ListFlowClusterAllResponseBodyClustersClusterInfoOrderTaskInfo>(model1);
      }
    }
    if (m.find("FailReason") != m.end() && !m["FailReason"].empty()) {
      if (typeid(map<string, boost::any>) == m["FailReason"].type()) {
        ListFlowClusterAllResponseBodyClustersClusterInfoFailReason model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FailReason"]));
        failReason = make_shared<ListFlowClusterAllResponseBodyClustersClusterInfoFailReason>(model1);
      }
    }
  }


  virtual ~ListFlowClusterAllResponseBodyClustersClusterInfo() = default;
};
class ListFlowClusterAllResponseBodyClusters : public Darabonba::Model {
public:
  shared_ptr<vector<ListFlowClusterAllResponseBodyClustersClusterInfo>> clusterInfo{};

  ListFlowClusterAllResponseBodyClusters() {}

  explicit ListFlowClusterAllResponseBodyClusters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterInfo) {
      vector<boost::any> temp1;
      for(auto item1:*clusterInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ClusterInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterInfo") != m.end() && !m["ClusterInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ClusterInfo"].type()) {
        vector<ListFlowClusterAllResponseBodyClustersClusterInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ClusterInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFlowClusterAllResponseBodyClustersClusterInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clusterInfo = make_shared<vector<ListFlowClusterAllResponseBodyClustersClusterInfo>>(expect1);
      }
    }
  }


  virtual ~ListFlowClusterAllResponseBodyClusters() = default;
};
class ListFlowClusterAllResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> totalCount{};
  shared_ptr<ListFlowClusterAllResponseBodyClusters> clusters{};

  ListFlowClusterAllResponseBody() {}

  explicit ListFlowClusterAllResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (clusters) {
      res["Clusters"] = clusters ? boost::any(clusters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Clusters") != m.end() && !m["Clusters"].empty()) {
      if (typeid(map<string, boost::any>) == m["Clusters"].type()) {
        ListFlowClusterAllResponseBodyClusters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Clusters"]));
        clusters = make_shared<ListFlowClusterAllResponseBodyClusters>(model1);
      }
    }
  }


  virtual ~ListFlowClusterAllResponseBody() = default;
};
class ListFlowClusterAllResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListFlowClusterAllResponseBody> body{};

  ListFlowClusterAllResponse() {}

  explicit ListFlowClusterAllResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFlowClusterAllResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFlowClusterAllResponseBody>(model1);
      }
    }
  }


  virtual ~ListFlowClusterAllResponse() = default;
};
class DescribeScalingGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> scalingGroupBizId{};
  shared_ptr<string> hostGroupBizId{};

  DescribeScalingGroupRequest() {}

  explicit DescribeScalingGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (scalingGroupBizId) {
      res["ScalingGroupBizId"] = boost::any(*scalingGroupBizId);
    }
    if (hostGroupBizId) {
      res["HostGroupBizId"] = boost::any(*hostGroupBizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ScalingGroupBizId") != m.end() && !m["ScalingGroupBizId"].empty()) {
      scalingGroupBizId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupBizId"]));
    }
    if (m.find("HostGroupBizId") != m.end() && !m["HostGroupBizId"].empty()) {
      hostGroupBizId = make_shared<string>(boost::any_cast<string>(m["HostGroupBizId"]));
    }
  }


  virtual ~DescribeScalingGroupRequest() = default;
};
class DescribeScalingGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> scalingGroupId{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};
  shared_ptr<string> activeStatus{};
  shared_ptr<string> hostGroupBizId{};
  shared_ptr<string> scalingInMode{};
  shared_ptr<long> scalingMinSize{};
  shared_ptr<long> scalingMaxSize{};
  shared_ptr<string> configState{};

  DescribeScalingGroupResponseBody() {}

  explicit DescribeScalingGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (activeStatus) {
      res["ActiveStatus"] = boost::any(*activeStatus);
    }
    if (hostGroupBizId) {
      res["HostGroupBizId"] = boost::any(*hostGroupBizId);
    }
    if (scalingInMode) {
      res["ScalingInMode"] = boost::any(*scalingInMode);
    }
    if (scalingMinSize) {
      res["ScalingMinSize"] = boost::any(*scalingMinSize);
    }
    if (scalingMaxSize) {
      res["ScalingMaxSize"] = boost::any(*scalingMaxSize);
    }
    if (configState) {
      res["ConfigState"] = boost::any(*configState);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ActiveStatus") != m.end() && !m["ActiveStatus"].empty()) {
      activeStatus = make_shared<string>(boost::any_cast<string>(m["ActiveStatus"]));
    }
    if (m.find("HostGroupBizId") != m.end() && !m["HostGroupBizId"].empty()) {
      hostGroupBizId = make_shared<string>(boost::any_cast<string>(m["HostGroupBizId"]));
    }
    if (m.find("ScalingInMode") != m.end() && !m["ScalingInMode"].empty()) {
      scalingInMode = make_shared<string>(boost::any_cast<string>(m["ScalingInMode"]));
    }
    if (m.find("ScalingMinSize") != m.end() && !m["ScalingMinSize"].empty()) {
      scalingMinSize = make_shared<long>(boost::any_cast<long>(m["ScalingMinSize"]));
    }
    if (m.find("ScalingMaxSize") != m.end() && !m["ScalingMaxSize"].empty()) {
      scalingMaxSize = make_shared<long>(boost::any_cast<long>(m["ScalingMaxSize"]));
    }
    if (m.find("ConfigState") != m.end() && !m["ConfigState"].empty()) {
      configState = make_shared<string>(boost::any_cast<string>(m["ConfigState"]));
    }
  }


  virtual ~DescribeScalingGroupResponseBody() = default;
};
class DescribeScalingGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeScalingGroupResponseBody> body{};

  DescribeScalingGroupResponse() {}

  explicit DescribeScalingGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeScalingGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeScalingGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeScalingGroupResponse() = default;
};
class ListScalingGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> limit{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> currentSize{};
  shared_ptr<long> pageCount{};
  shared_ptr<string> orderField{};
  shared_ptr<string> orderMode{};
  shared_ptr<string> clusterBizId{};

  ListScalingGroupRequest() {}

  explicit ListScalingGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (limit) {
      res["limit"] = boost::any(*limit);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentSize) {
      res["CurrentSize"] = boost::any(*currentSize);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (orderField) {
      res["OrderField"] = boost::any(*orderField);
    }
    if (orderMode) {
      res["OrderMode"] = boost::any(*orderMode);
    }
    if (clusterBizId) {
      res["ClusterBizId"] = boost::any(*clusterBizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("limit") != m.end() && !m["limit"].empty()) {
      limit = make_shared<long>(boost::any_cast<long>(m["limit"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("CurrentSize") != m.end() && !m["CurrentSize"].empty()) {
      currentSize = make_shared<long>(boost::any_cast<long>(m["CurrentSize"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("OrderField") != m.end() && !m["OrderField"].empty()) {
      orderField = make_shared<string>(boost::any_cast<string>(m["OrderField"]));
    }
    if (m.find("OrderMode") != m.end() && !m["OrderMode"].empty()) {
      orderMode = make_shared<string>(boost::any_cast<string>(m["OrderMode"]));
    }
    if (m.find("ClusterBizId") != m.end() && !m["ClusterBizId"].empty()) {
      clusterBizId = make_shared<string>(boost::any_cast<string>(m["ClusterBizId"]));
    }
  }


  virtual ~ListScalingGroupRequest() = default;
};
class ListScalingGroupResponseBodyItemsItem : public Darabonba::Model {
public:
  shared_ptr<string> scalingGroupId{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};
  shared_ptr<string> activeStatus{};
  shared_ptr<string> hostGroupBizId{};
  shared_ptr<string> scalingInMode{};
  shared_ptr<string> scalingMinSize{};
  shared_ptr<string> scalingMaxSize{};

  ListScalingGroupResponseBodyItemsItem() {}

  explicit ListScalingGroupResponseBodyItemsItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (activeStatus) {
      res["ActiveStatus"] = boost::any(*activeStatus);
    }
    if (hostGroupBizId) {
      res["HostGroupBizId"] = boost::any(*hostGroupBizId);
    }
    if (scalingInMode) {
      res["ScalingInMode"] = boost::any(*scalingInMode);
    }
    if (scalingMinSize) {
      res["ScalingMinSize"] = boost::any(*scalingMinSize);
    }
    if (scalingMaxSize) {
      res["ScalingMaxSize"] = boost::any(*scalingMaxSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ActiveStatus") != m.end() && !m["ActiveStatus"].empty()) {
      activeStatus = make_shared<string>(boost::any_cast<string>(m["ActiveStatus"]));
    }
    if (m.find("HostGroupBizId") != m.end() && !m["HostGroupBizId"].empty()) {
      hostGroupBizId = make_shared<string>(boost::any_cast<string>(m["HostGroupBizId"]));
    }
    if (m.find("ScalingInMode") != m.end() && !m["ScalingInMode"].empty()) {
      scalingInMode = make_shared<string>(boost::any_cast<string>(m["ScalingInMode"]));
    }
    if (m.find("ScalingMinSize") != m.end() && !m["ScalingMinSize"].empty()) {
      scalingMinSize = make_shared<string>(boost::any_cast<string>(m["ScalingMinSize"]));
    }
    if (m.find("ScalingMaxSize") != m.end() && !m["ScalingMaxSize"].empty()) {
      scalingMaxSize = make_shared<string>(boost::any_cast<string>(m["ScalingMaxSize"]));
    }
  }


  virtual ~ListScalingGroupResponseBodyItemsItem() = default;
};
class ListScalingGroupResponseBodyItems : public Darabonba::Model {
public:
  shared_ptr<vector<ListScalingGroupResponseBodyItemsItem>> item{};

  ListScalingGroupResponseBodyItems() {}

  explicit ListScalingGroupResponseBodyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (item) {
      vector<boost::any> temp1;
      for(auto item1:*item){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Item"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Item") != m.end() && !m["Item"].empty()) {
      if (typeid(vector<boost::any>) == m["Item"].type()) {
        vector<ListScalingGroupResponseBodyItemsItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Item"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListScalingGroupResponseBodyItemsItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        item = make_shared<vector<ListScalingGroupResponseBodyItemsItem>>(expect1);
      }
    }
  }


  virtual ~ListScalingGroupResponseBodyItems() = default;
};
class ListScalingGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<string> nextToken{};
  shared_ptr<ListScalingGroupResponseBodyItems> items{};

  ListScalingGroupResponseBody() {}

  explicit ListScalingGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (items) {
      res["Items"] = items ? boost::any(items->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(map<string, boost::any>) == m["Items"].type()) {
        ListScalingGroupResponseBodyItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Items"]));
        items = make_shared<ListScalingGroupResponseBodyItems>(model1);
      }
    }
  }


  virtual ~ListScalingGroupResponseBody() = default;
};
class ListScalingGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListScalingGroupResponseBody> body{};

  ListScalingGroupResponse() {}

  explicit ListScalingGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListScalingGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListScalingGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ListScalingGroupResponse() = default;
};
class ModifyFlowCategoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> parentId{};

  ModifyFlowCategoryRequest() {}

  explicit ModifyFlowCategoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
  }


  virtual ~ModifyFlowCategoryRequest() = default;
};
class ModifyFlowCategoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  ModifyFlowCategoryResponseBody() {}

  explicit ModifyFlowCategoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyFlowCategoryResponseBody() = default;
};
class ModifyFlowCategoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyFlowCategoryResponseBody> body{};

  ModifyFlowCategoryResponse() {}

  explicit ModifyFlowCategoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyFlowCategoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyFlowCategoryResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyFlowCategoryResponse() = default;
};
class ModifyClusterServiceConfigRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> comment{};
  shared_ptr<string> configParams{};
  shared_ptr<string> customConfigParams{};
  shared_ptr<string> groupId{};
  shared_ptr<string> hostInstanceId{};
  shared_ptr<string> configType{};
  shared_ptr<bool> refreshHostConfig{};
  shared_ptr<vector<string>> gatewayClusterIdList{};

  ModifyClusterServiceConfigRequest() {}

  explicit ModifyClusterServiceConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (configParams) {
      res["ConfigParams"] = boost::any(*configParams);
    }
    if (customConfigParams) {
      res["CustomConfigParams"] = boost::any(*customConfigParams);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (hostInstanceId) {
      res["HostInstanceId"] = boost::any(*hostInstanceId);
    }
    if (configType) {
      res["ConfigType"] = boost::any(*configType);
    }
    if (refreshHostConfig) {
      res["RefreshHostConfig"] = boost::any(*refreshHostConfig);
    }
    if (gatewayClusterIdList) {
      res["GatewayClusterIdList"] = boost::any(*gatewayClusterIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("ConfigParams") != m.end() && !m["ConfigParams"].empty()) {
      configParams = make_shared<string>(boost::any_cast<string>(m["ConfigParams"]));
    }
    if (m.find("CustomConfigParams") != m.end() && !m["CustomConfigParams"].empty()) {
      customConfigParams = make_shared<string>(boost::any_cast<string>(m["CustomConfigParams"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("HostInstanceId") != m.end() && !m["HostInstanceId"].empty()) {
      hostInstanceId = make_shared<string>(boost::any_cast<string>(m["HostInstanceId"]));
    }
    if (m.find("ConfigType") != m.end() && !m["ConfigType"].empty()) {
      configType = make_shared<string>(boost::any_cast<string>(m["ConfigType"]));
    }
    if (m.find("RefreshHostConfig") != m.end() && !m["RefreshHostConfig"].empty()) {
      refreshHostConfig = make_shared<bool>(boost::any_cast<bool>(m["RefreshHostConfig"]));
    }
    if (m.find("GatewayClusterIdList") != m.end() && !m["GatewayClusterIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GatewayClusterIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GatewayClusterIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      gatewayClusterIdList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ModifyClusterServiceConfigRequest() = default;
};
class ModifyClusterServiceConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyClusterServiceConfigResponseBody() {}

  explicit ModifyClusterServiceConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyClusterServiceConfigResponseBody() = default;
};
class ModifyClusterServiceConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyClusterServiceConfigResponseBody> body{};

  ModifyClusterServiceConfigResponse() {}

  explicit ModifyClusterServiceConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyClusterServiceConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyClusterServiceConfigResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyClusterServiceConfigResponse() = default;
};
class CloneFlowRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> id{};
  shared_ptr<string> regionId{};

  CloneFlowRequest() {}

  explicit CloneFlowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CloneFlowRequest() = default;
};
class CloneFlowResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  CloneFlowResponseBody() {}

  explicit CloneFlowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CloneFlowResponseBody() = default;
};
class CloneFlowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CloneFlowResponseBody> body{};

  CloneFlowResponse() {}

  explicit CloneFlowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CloneFlowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CloneFlowResponseBody>(model1);
      }
    }
  }


  virtual ~CloneFlowResponse() = default;
};
class CreateClusterTemplateRequestHostGroup : public Darabonba::Model {
public:
  shared_ptr<long> sysDiskCapacity{};
  shared_ptr<string> hostGroupType{};
  shared_ptr<string> comment{};
  shared_ptr<string> multiInstanceTypes{};
  shared_ptr<string> sysDiskType{};
  shared_ptr<bool> autoRenew{};
  shared_ptr<string> chargeType{};
  shared_ptr<string> diskType{};
  shared_ptr<string> hostGroupId{};
  shared_ptr<string> instanceType{};
  shared_ptr<long> diskCount{};
  shared_ptr<string> createType{};
  shared_ptr<long> period{};
  shared_ptr<long> diskCapacity{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<long> nodeCount{};
  shared_ptr<string> hostGroupName{};
  shared_ptr<string> clusterId{};

  CreateClusterTemplateRequestHostGroup() {}

  explicit CreateClusterTemplateRequestHostGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sysDiskCapacity) {
      res["SysDiskCapacity"] = boost::any(*sysDiskCapacity);
    }
    if (hostGroupType) {
      res["HostGroupType"] = boost::any(*hostGroupType);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (multiInstanceTypes) {
      res["MultiInstanceTypes"] = boost::any(*multiInstanceTypes);
    }
    if (sysDiskType) {
      res["SysDiskType"] = boost::any(*sysDiskType);
    }
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (diskType) {
      res["DiskType"] = boost::any(*diskType);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (diskCount) {
      res["DiskCount"] = boost::any(*diskCount);
    }
    if (createType) {
      res["CreateType"] = boost::any(*createType);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (diskCapacity) {
      res["DiskCapacity"] = boost::any(*diskCapacity);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (nodeCount) {
      res["NodeCount"] = boost::any(*nodeCount);
    }
    if (hostGroupName) {
      res["HostGroupName"] = boost::any(*hostGroupName);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SysDiskCapacity") != m.end() && !m["SysDiskCapacity"].empty()) {
      sysDiskCapacity = make_shared<long>(boost::any_cast<long>(m["SysDiskCapacity"]));
    }
    if (m.find("HostGroupType") != m.end() && !m["HostGroupType"].empty()) {
      hostGroupType = make_shared<string>(boost::any_cast<string>(m["HostGroupType"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("MultiInstanceTypes") != m.end() && !m["MultiInstanceTypes"].empty()) {
      multiInstanceTypes = make_shared<string>(boost::any_cast<string>(m["MultiInstanceTypes"]));
    }
    if (m.find("SysDiskType") != m.end() && !m["SysDiskType"].empty()) {
      sysDiskType = make_shared<string>(boost::any_cast<string>(m["SysDiskType"]));
    }
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["AutoRenew"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("DiskType") != m.end() && !m["DiskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["DiskType"]));
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("DiskCount") != m.end() && !m["DiskCount"].empty()) {
      diskCount = make_shared<long>(boost::any_cast<long>(m["DiskCount"]));
    }
    if (m.find("CreateType") != m.end() && !m["CreateType"].empty()) {
      createType = make_shared<string>(boost::any_cast<string>(m["CreateType"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("DiskCapacity") != m.end() && !m["DiskCapacity"].empty()) {
      diskCapacity = make_shared<long>(boost::any_cast<long>(m["DiskCapacity"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("NodeCount") != m.end() && !m["NodeCount"].empty()) {
      nodeCount = make_shared<long>(boost::any_cast<long>(m["NodeCount"]));
    }
    if (m.find("HostGroupName") != m.end() && !m["HostGroupName"].empty()) {
      hostGroupName = make_shared<string>(boost::any_cast<string>(m["HostGroupName"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
  }


  virtual ~CreateClusterTemplateRequestHostGroup() = default;
};
class CreateClusterTemplateRequestBootstrapAction : public Darabonba::Model {
public:
  shared_ptr<string> arg{};
  shared_ptr<string> path{};
  shared_ptr<string> name{};

  CreateClusterTemplateRequestBootstrapAction() {}

  explicit CreateClusterTemplateRequestBootstrapAction(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arg) {
      res["Arg"] = boost::any(*arg);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Arg") != m.end() && !m["Arg"].empty()) {
      arg = make_shared<string>(boost::any_cast<string>(m["Arg"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~CreateClusterTemplateRequestBootstrapAction() = default;
};
class CreateClusterTemplateRequestConfig : public Darabonba::Model {
public:
  shared_ptr<string> configValue{};
  shared_ptr<string> replace{};
  shared_ptr<string> fileName{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> configKey{};
  shared_ptr<string> encrypt{};

  CreateClusterTemplateRequestConfig() {}

  explicit CreateClusterTemplateRequestConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configValue) {
      res["ConfigValue"] = boost::any(*configValue);
    }
    if (replace) {
      res["Replace"] = boost::any(*replace);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (configKey) {
      res["ConfigKey"] = boost::any(*configKey);
    }
    if (encrypt) {
      res["Encrypt"] = boost::any(*encrypt);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigValue") != m.end() && !m["ConfigValue"].empty()) {
      configValue = make_shared<string>(boost::any_cast<string>(m["ConfigValue"]));
    }
    if (m.find("Replace") != m.end() && !m["Replace"].empty()) {
      replace = make_shared<string>(boost::any_cast<string>(m["Replace"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("ConfigKey") != m.end() && !m["ConfigKey"].empty()) {
      configKey = make_shared<string>(boost::any_cast<string>(m["ConfigKey"]));
    }
    if (m.find("Encrypt") != m.end() && !m["Encrypt"].empty()) {
      encrypt = make_shared<string>(boost::any_cast<string>(m["Encrypt"]));
    }
  }


  virtual ~CreateClusterTemplateRequestConfig() = default;
};
class CreateClusterTemplateRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateClusterTemplateRequestTag() {}

  explicit CreateClusterTemplateRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateClusterTemplateRequestTag() = default;
};
class CreateClusterTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> templateName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> logPath{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<bool> isOpenPublicIp{};
  shared_ptr<string> securityGroupName{};
  shared_ptr<long> period{};
  shared_ptr<bool> renewAuto{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> netType{};
  shared_ptr<string> userDefinedEmrEcsRole{};
  shared_ptr<string> emrVer{};
  shared_ptr<string> clusterType{};
  shared_ptr<bool> enableHighAvailability{};
  shared_ptr<bool> useLocalMetaDb{};
  shared_ptr<bool> ioOptimizedOption{};
  shared_ptr<bool> enableSsh{};
  shared_ptr<string> instanceGeneration{};
  shared_ptr<string> masterPwd{};
  shared_ptr<string> keyPairName{};
  shared_ptr<string> metaStoreType{};
  shared_ptr<string> metaStoreConf{};
  shared_ptr<string> configurations{};
  shared_ptr<bool> enableEas{};
  shared_ptr<string> depositType{};
  shared_ptr<string> machineType{};
  shared_ptr<bool> useCustomHiveMetaDb{};
  shared_ptr<bool> initCustomHiveMetaDb{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> clientToken{};
  shared_ptr<vector<string>> optionSoftWareList{};
  shared_ptr<vector<CreateClusterTemplateRequestHostGroup>> hostGroup{};
  shared_ptr<vector<CreateClusterTemplateRequestBootstrapAction>> bootstrapAction{};
  shared_ptr<vector<CreateClusterTemplateRequestConfig>> config{};
  shared_ptr<vector<CreateClusterTemplateRequestTag>> tag{};

  CreateClusterTemplateRequest() {}

  explicit CreateClusterTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (logPath) {
      res["LogPath"] = boost::any(*logPath);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (isOpenPublicIp) {
      res["IsOpenPublicIp"] = boost::any(*isOpenPublicIp);
    }
    if (securityGroupName) {
      res["SecurityGroupName"] = boost::any(*securityGroupName);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (renewAuto) {
      res["RenewAuto"] = boost::any(*renewAuto);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (netType) {
      res["NetType"] = boost::any(*netType);
    }
    if (userDefinedEmrEcsRole) {
      res["UserDefinedEmrEcsRole"] = boost::any(*userDefinedEmrEcsRole);
    }
    if (emrVer) {
      res["EmrVer"] = boost::any(*emrVer);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (enableHighAvailability) {
      res["EnableHighAvailability"] = boost::any(*enableHighAvailability);
    }
    if (useLocalMetaDb) {
      res["UseLocalMetaDb"] = boost::any(*useLocalMetaDb);
    }
    if (ioOptimizedOption) {
      res["IoOptimizedOption"] = boost::any(*ioOptimizedOption);
    }
    if (enableSsh) {
      res["EnableSsh"] = boost::any(*enableSsh);
    }
    if (instanceGeneration) {
      res["InstanceGeneration"] = boost::any(*instanceGeneration);
    }
    if (masterPwd) {
      res["MasterPwd"] = boost::any(*masterPwd);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (metaStoreType) {
      res["MetaStoreType"] = boost::any(*metaStoreType);
    }
    if (metaStoreConf) {
      res["MetaStoreConf"] = boost::any(*metaStoreConf);
    }
    if (configurations) {
      res["Configurations"] = boost::any(*configurations);
    }
    if (enableEas) {
      res["EnableEas"] = boost::any(*enableEas);
    }
    if (depositType) {
      res["DepositType"] = boost::any(*depositType);
    }
    if (machineType) {
      res["MachineType"] = boost::any(*machineType);
    }
    if (useCustomHiveMetaDb) {
      res["UseCustomHiveMetaDb"] = boost::any(*useCustomHiveMetaDb);
    }
    if (initCustomHiveMetaDb) {
      res["InitCustomHiveMetaDb"] = boost::any(*initCustomHiveMetaDb);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (optionSoftWareList) {
      res["OptionSoftWareList"] = boost::any(*optionSoftWareList);
    }
    if (hostGroup) {
      vector<boost::any> temp1;
      for(auto item1:*hostGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HostGroup"] = boost::any(temp1);
    }
    if (bootstrapAction) {
      vector<boost::any> temp1;
      for(auto item1:*bootstrapAction){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BootstrapAction"] = boost::any(temp1);
    }
    if (config) {
      vector<boost::any> temp1;
      for(auto item1:*config){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Config"] = boost::any(temp1);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("LogPath") != m.end() && !m["LogPath"].empty()) {
      logPath = make_shared<string>(boost::any_cast<string>(m["LogPath"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("IsOpenPublicIp") != m.end() && !m["IsOpenPublicIp"].empty()) {
      isOpenPublicIp = make_shared<bool>(boost::any_cast<bool>(m["IsOpenPublicIp"]));
    }
    if (m.find("SecurityGroupName") != m.end() && !m["SecurityGroupName"].empty()) {
      securityGroupName = make_shared<string>(boost::any_cast<string>(m["SecurityGroupName"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("RenewAuto") != m.end() && !m["RenewAuto"].empty()) {
      renewAuto = make_shared<bool>(boost::any_cast<bool>(m["RenewAuto"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("NetType") != m.end() && !m["NetType"].empty()) {
      netType = make_shared<string>(boost::any_cast<string>(m["NetType"]));
    }
    if (m.find("UserDefinedEmrEcsRole") != m.end() && !m["UserDefinedEmrEcsRole"].empty()) {
      userDefinedEmrEcsRole = make_shared<string>(boost::any_cast<string>(m["UserDefinedEmrEcsRole"]));
    }
    if (m.find("EmrVer") != m.end() && !m["EmrVer"].empty()) {
      emrVer = make_shared<string>(boost::any_cast<string>(m["EmrVer"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("EnableHighAvailability") != m.end() && !m["EnableHighAvailability"].empty()) {
      enableHighAvailability = make_shared<bool>(boost::any_cast<bool>(m["EnableHighAvailability"]));
    }
    if (m.find("UseLocalMetaDb") != m.end() && !m["UseLocalMetaDb"].empty()) {
      useLocalMetaDb = make_shared<bool>(boost::any_cast<bool>(m["UseLocalMetaDb"]));
    }
    if (m.find("IoOptimizedOption") != m.end() && !m["IoOptimizedOption"].empty()) {
      ioOptimizedOption = make_shared<bool>(boost::any_cast<bool>(m["IoOptimizedOption"]));
    }
    if (m.find("EnableSsh") != m.end() && !m["EnableSsh"].empty()) {
      enableSsh = make_shared<bool>(boost::any_cast<bool>(m["EnableSsh"]));
    }
    if (m.find("InstanceGeneration") != m.end() && !m["InstanceGeneration"].empty()) {
      instanceGeneration = make_shared<string>(boost::any_cast<string>(m["InstanceGeneration"]));
    }
    if (m.find("MasterPwd") != m.end() && !m["MasterPwd"].empty()) {
      masterPwd = make_shared<string>(boost::any_cast<string>(m["MasterPwd"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("MetaStoreType") != m.end() && !m["MetaStoreType"].empty()) {
      metaStoreType = make_shared<string>(boost::any_cast<string>(m["MetaStoreType"]));
    }
    if (m.find("MetaStoreConf") != m.end() && !m["MetaStoreConf"].empty()) {
      metaStoreConf = make_shared<string>(boost::any_cast<string>(m["MetaStoreConf"]));
    }
    if (m.find("Configurations") != m.end() && !m["Configurations"].empty()) {
      configurations = make_shared<string>(boost::any_cast<string>(m["Configurations"]));
    }
    if (m.find("EnableEas") != m.end() && !m["EnableEas"].empty()) {
      enableEas = make_shared<bool>(boost::any_cast<bool>(m["EnableEas"]));
    }
    if (m.find("DepositType") != m.end() && !m["DepositType"].empty()) {
      depositType = make_shared<string>(boost::any_cast<string>(m["DepositType"]));
    }
    if (m.find("MachineType") != m.end() && !m["MachineType"].empty()) {
      machineType = make_shared<string>(boost::any_cast<string>(m["MachineType"]));
    }
    if (m.find("UseCustomHiveMetaDb") != m.end() && !m["UseCustomHiveMetaDb"].empty()) {
      useCustomHiveMetaDb = make_shared<bool>(boost::any_cast<bool>(m["UseCustomHiveMetaDb"]));
    }
    if (m.find("InitCustomHiveMetaDb") != m.end() && !m["InitCustomHiveMetaDb"].empty()) {
      initCustomHiveMetaDb = make_shared<bool>(boost::any_cast<bool>(m["InitCustomHiveMetaDb"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OptionSoftWareList") != m.end() && !m["OptionSoftWareList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OptionSoftWareList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OptionSoftWareList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      optionSoftWareList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("HostGroup") != m.end() && !m["HostGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["HostGroup"].type()) {
        vector<CreateClusterTemplateRequestHostGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HostGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateClusterTemplateRequestHostGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hostGroup = make_shared<vector<CreateClusterTemplateRequestHostGroup>>(expect1);
      }
    }
    if (m.find("BootstrapAction") != m.end() && !m["BootstrapAction"].empty()) {
      if (typeid(vector<boost::any>) == m["BootstrapAction"].type()) {
        vector<CreateClusterTemplateRequestBootstrapAction> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BootstrapAction"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateClusterTemplateRequestBootstrapAction model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bootstrapAction = make_shared<vector<CreateClusterTemplateRequestBootstrapAction>>(expect1);
      }
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      if (typeid(vector<boost::any>) == m["Config"].type()) {
        vector<CreateClusterTemplateRequestConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Config"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateClusterTemplateRequestConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        config = make_shared<vector<CreateClusterTemplateRequestConfig>>(expect1);
      }
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateClusterTemplateRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateClusterTemplateRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateClusterTemplateRequestTag>>(expect1);
      }
    }
  }


  virtual ~CreateClusterTemplateRequest() = default;
};
class CreateClusterTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> clusterTemplateId{};
  shared_ptr<string> requestId{};

  CreateClusterTemplateResponseBody() {}

  explicit CreateClusterTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterTemplateId) {
      res["ClusterTemplateId"] = boost::any(*clusterTemplateId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterTemplateId") != m.end() && !m["ClusterTemplateId"].empty()) {
      clusterTemplateId = make_shared<string>(boost::any_cast<string>(m["ClusterTemplateId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateClusterTemplateResponseBody() = default;
};
class CreateClusterTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateClusterTemplateResponseBody> body{};

  CreateClusterTemplateResponse() {}

  explicit CreateClusterTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateClusterTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateClusterTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~CreateClusterTemplateResponse() = default;
};
class UpdateLibraryInstallTaskStatusRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> taskBizId{};
  shared_ptr<string> status{};

  UpdateLibraryInstallTaskStatusRequest() {}

  explicit UpdateLibraryInstallTaskStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskBizId) {
      res["TaskBizId"] = boost::any(*taskBizId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskBizId") != m.end() && !m["TaskBizId"].empty()) {
      taskBizId = make_shared<string>(boost::any_cast<string>(m["TaskBizId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~UpdateLibraryInstallTaskStatusRequest() = default;
};
class UpdateLibraryInstallTaskStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  UpdateLibraryInstallTaskStatusResponseBody() {}

  explicit UpdateLibraryInstallTaskStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateLibraryInstallTaskStatusResponseBody() = default;
};
class UpdateLibraryInstallTaskStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateLibraryInstallTaskStatusResponseBody> body{};

  UpdateLibraryInstallTaskStatusResponse() {}

  explicit UpdateLibraryInstallTaskStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateLibraryInstallTaskStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateLibraryInstallTaskStatusResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateLibraryInstallTaskStatusResponse() = default;
};
class ListScalingConfigItemRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> limit{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> currentSize{};
  shared_ptr<long> pageCount{};
  shared_ptr<string> orderField{};
  shared_ptr<string> orderMode{};
  shared_ptr<string> scalingGroupBizId{};
  shared_ptr<string> configItemType{};

  ListScalingConfigItemRequest() {}

  explicit ListScalingConfigItemRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (limit) {
      res["limit"] = boost::any(*limit);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentSize) {
      res["CurrentSize"] = boost::any(*currentSize);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (orderField) {
      res["OrderField"] = boost::any(*orderField);
    }
    if (orderMode) {
      res["OrderMode"] = boost::any(*orderMode);
    }
    if (scalingGroupBizId) {
      res["ScalingGroupBizId"] = boost::any(*scalingGroupBizId);
    }
    if (configItemType) {
      res["ConfigItemType"] = boost::any(*configItemType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("limit") != m.end() && !m["limit"].empty()) {
      limit = make_shared<long>(boost::any_cast<long>(m["limit"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("CurrentSize") != m.end() && !m["CurrentSize"].empty()) {
      currentSize = make_shared<long>(boost::any_cast<long>(m["CurrentSize"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("OrderField") != m.end() && !m["OrderField"].empty()) {
      orderField = make_shared<string>(boost::any_cast<string>(m["OrderField"]));
    }
    if (m.find("OrderMode") != m.end() && !m["OrderMode"].empty()) {
      orderMode = make_shared<string>(boost::any_cast<string>(m["OrderMode"]));
    }
    if (m.find("ScalingGroupBizId") != m.end() && !m["ScalingGroupBizId"].empty()) {
      scalingGroupBizId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupBizId"]));
    }
    if (m.find("ConfigItemType") != m.end() && !m["ConfigItemType"].empty()) {
      configItemType = make_shared<string>(boost::any_cast<string>(m["ConfigItemType"]));
    }
  }


  virtual ~ListScalingConfigItemRequest() = default;
};
class ListScalingConfigItemResponseBodyItemsItems : public Darabonba::Model {
public:
  shared_ptr<string> configItemType{};
  shared_ptr<string> scalingGroupBizId{};
  shared_ptr<string> scalingConfigItemBizId{};
  shared_ptr<string> configItemInformation{};

  ListScalingConfigItemResponseBodyItemsItems() {}

  explicit ListScalingConfigItemResponseBodyItemsItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configItemType) {
      res["ConfigItemType"] = boost::any(*configItemType);
    }
    if (scalingGroupBizId) {
      res["ScalingGroupBizId"] = boost::any(*scalingGroupBizId);
    }
    if (scalingConfigItemBizId) {
      res["ScalingConfigItemBizId"] = boost::any(*scalingConfigItemBizId);
    }
    if (configItemInformation) {
      res["ConfigItemInformation"] = boost::any(*configItemInformation);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigItemType") != m.end() && !m["ConfigItemType"].empty()) {
      configItemType = make_shared<string>(boost::any_cast<string>(m["ConfigItemType"]));
    }
    if (m.find("ScalingGroupBizId") != m.end() && !m["ScalingGroupBizId"].empty()) {
      scalingGroupBizId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupBizId"]));
    }
    if (m.find("ScalingConfigItemBizId") != m.end() && !m["ScalingConfigItemBizId"].empty()) {
      scalingConfigItemBizId = make_shared<string>(boost::any_cast<string>(m["ScalingConfigItemBizId"]));
    }
    if (m.find("ConfigItemInformation") != m.end() && !m["ConfigItemInformation"].empty()) {
      configItemInformation = make_shared<string>(boost::any_cast<string>(m["ConfigItemInformation"]));
    }
  }


  virtual ~ListScalingConfigItemResponseBodyItemsItems() = default;
};
class ListScalingConfigItemResponseBodyItems : public Darabonba::Model {
public:
  shared_ptr<vector<ListScalingConfigItemResponseBodyItemsItems>> items{};

  ListScalingConfigItemResponseBodyItems() {}

  explicit ListScalingConfigItemResponseBodyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["items"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("items") != m.end() && !m["items"].empty()) {
      if (typeid(vector<boost::any>) == m["items"].type()) {
        vector<ListScalingConfigItemResponseBodyItemsItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListScalingConfigItemResponseBodyItemsItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<ListScalingConfigItemResponseBodyItemsItems>>(expect1);
      }
    }
  }


  virtual ~ListScalingConfigItemResponseBodyItems() = default;
};
class ListScalingConfigItemResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<string> nextToken{};
  shared_ptr<ListScalingConfigItemResponseBodyItems> items{};

  ListScalingConfigItemResponseBody() {}

  explicit ListScalingConfigItemResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (items) {
      res["Items"] = items ? boost::any(items->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(map<string, boost::any>) == m["Items"].type()) {
        ListScalingConfigItemResponseBodyItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Items"]));
        items = make_shared<ListScalingConfigItemResponseBodyItems>(model1);
      }
    }
  }


  virtual ~ListScalingConfigItemResponseBody() = default;
};
class ListScalingConfigItemResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListScalingConfigItemResponseBody> body{};

  ListScalingConfigItemResponse() {}

  explicit ListScalingConfigItemResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListScalingConfigItemResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListScalingConfigItemResponseBody>(model1);
      }
    }
  }


  virtual ~ListScalingConfigItemResponse() = default;
};
class ListFlowInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> flowId{};
  shared_ptr<string> flowName{};
  shared_ptr<string> owner{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> timeRange{};
  shared_ptr<string> orderBy{};
  shared_ptr<string> orderType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> projectId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<string>> statusList{};

  ListFlowInstanceRequest() {}

  explicit ListFlowInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (flowId) {
      res["FlowId"] = boost::any(*flowId);
    }
    if (flowName) {
      res["FlowName"] = boost::any(*flowName);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (timeRange) {
      res["TimeRange"] = boost::any(*timeRange);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (statusList) {
      res["StatusList"] = boost::any(*statusList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("FlowId") != m.end() && !m["FlowId"].empty()) {
      flowId = make_shared<string>(boost::any_cast<string>(m["FlowId"]));
    }
    if (m.find("FlowName") != m.end() && !m["FlowName"].empty()) {
      flowName = make_shared<string>(boost::any_cast<string>(m["FlowName"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TimeRange") != m.end() && !m["TimeRange"].empty()) {
      timeRange = make_shared<string>(boost::any_cast<string>(m["TimeRange"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<string>(boost::any_cast<string>(m["OrderType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StatusList") != m.end() && !m["StatusList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["StatusList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["StatusList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      statusList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListFlowInstanceRequest() = default;
};
class ListFlowInstanceResponseBodyFlowInstancesFlowInstance : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> owner{};
  shared_ptr<string> projectId{};
  shared_ptr<string> flowName{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> flowId{};
  shared_ptr<long> endTime{};
  shared_ptr<long> startTime{};
  shared_ptr<bool> hasNodeFailed{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> scheduleTime{};
  shared_ptr<long> duration{};
  shared_ptr<string> id{};
  shared_ptr<string> clusterId{};

  ListFlowInstanceResponseBodyFlowInstancesFlowInstance() {}

  explicit ListFlowInstanceResponseBodyFlowInstancesFlowInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (flowName) {
      res["FlowName"] = boost::any(*flowName);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (flowId) {
      res["FlowId"] = boost::any(*flowId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (hasNodeFailed) {
      res["HasNodeFailed"] = boost::any(*hasNodeFailed);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (scheduleTime) {
      res["ScheduleTime"] = boost::any(*scheduleTime);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("FlowName") != m.end() && !m["FlowName"].empty()) {
      flowName = make_shared<string>(boost::any_cast<string>(m["FlowName"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("FlowId") != m.end() && !m["FlowId"].empty()) {
      flowId = make_shared<string>(boost::any_cast<string>(m["FlowId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("HasNodeFailed") != m.end() && !m["HasNodeFailed"].empty()) {
      hasNodeFailed = make_shared<bool>(boost::any_cast<bool>(m["HasNodeFailed"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("ScheduleTime") != m.end() && !m["ScheduleTime"].empty()) {
      scheduleTime = make_shared<long>(boost::any_cast<long>(m["ScheduleTime"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
  }


  virtual ~ListFlowInstanceResponseBodyFlowInstancesFlowInstance() = default;
};
class ListFlowInstanceResponseBodyFlowInstances : public Darabonba::Model {
public:
  shared_ptr<vector<ListFlowInstanceResponseBodyFlowInstancesFlowInstance>> flowInstance{};

  ListFlowInstanceResponseBodyFlowInstances() {}

  explicit ListFlowInstanceResponseBodyFlowInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flowInstance) {
      vector<boost::any> temp1;
      for(auto item1:*flowInstance){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FlowInstance"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FlowInstance") != m.end() && !m["FlowInstance"].empty()) {
      if (typeid(vector<boost::any>) == m["FlowInstance"].type()) {
        vector<ListFlowInstanceResponseBodyFlowInstancesFlowInstance> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FlowInstance"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFlowInstanceResponseBodyFlowInstancesFlowInstance model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        flowInstance = make_shared<vector<ListFlowInstanceResponseBodyFlowInstancesFlowInstance>>(expect1);
      }
    }
  }


  virtual ~ListFlowInstanceResponseBodyFlowInstances() = default;
};
class ListFlowInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};
  shared_ptr<ListFlowInstanceResponseBodyFlowInstances> flowInstances{};

  ListFlowInstanceResponseBody() {}

  explicit ListFlowInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (flowInstances) {
      res["FlowInstances"] = flowInstances ? boost::any(flowInstances->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("FlowInstances") != m.end() && !m["FlowInstances"].empty()) {
      if (typeid(map<string, boost::any>) == m["FlowInstances"].type()) {
        ListFlowInstanceResponseBodyFlowInstances model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FlowInstances"]));
        flowInstances = make_shared<ListFlowInstanceResponseBodyFlowInstances>(model1);
      }
    }
  }


  virtual ~ListFlowInstanceResponseBody() = default;
};
class ListFlowInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListFlowInstanceResponseBody> body{};

  ListFlowInstanceResponse() {}

  explicit ListFlowInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFlowInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFlowInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~ListFlowInstanceResponse() = default;
};
class DescribeScalingMetricsRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> hostGroupId{};

  DescribeScalingMetricsRequest() {}

  explicit DescribeScalingMetricsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
  }


  virtual ~DescribeScalingMetricsRequest() = default;
};
class DescribeScalingMetricsResponseBodyMetricList : public Darabonba::Model {
public:
  shared_ptr<string> metricName{};
  shared_ptr<string> unit{};
  shared_ptr<string> displayName{};
  shared_ptr<long> minValue{};
  shared_ptr<long> maxValue{};

  DescribeScalingMetricsResponseBodyMetricList() {}

  explicit DescribeScalingMetricsResponseBodyMetricList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (minValue) {
      res["MinValue"] = boost::any(*minValue);
    }
    if (maxValue) {
      res["MaxValue"] = boost::any(*maxValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("MinValue") != m.end() && !m["MinValue"].empty()) {
      minValue = make_shared<long>(boost::any_cast<long>(m["MinValue"]));
    }
    if (m.find("MaxValue") != m.end() && !m["MaxValue"].empty()) {
      maxValue = make_shared<long>(boost::any_cast<long>(m["MaxValue"]));
    }
  }


  virtual ~DescribeScalingMetricsResponseBodyMetricList() = default;
};
class DescribeScalingMetricsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeScalingMetricsResponseBodyMetricList>> metricList{};

  DescribeScalingMetricsResponseBody() {}

  explicit DescribeScalingMetricsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (metricList) {
      vector<boost::any> temp1;
      for(auto item1:*metricList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MetricList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("MetricList") != m.end() && !m["MetricList"].empty()) {
      if (typeid(vector<boost::any>) == m["MetricList"].type()) {
        vector<DescribeScalingMetricsResponseBodyMetricList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MetricList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeScalingMetricsResponseBodyMetricList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        metricList = make_shared<vector<DescribeScalingMetricsResponseBodyMetricList>>(expect1);
      }
    }
  }


  virtual ~DescribeScalingMetricsResponseBody() = default;
};
class DescribeScalingMetricsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeScalingMetricsResponseBody> body{};

  DescribeScalingMetricsResponse() {}

  explicit DescribeScalingMetricsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeScalingMetricsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeScalingMetricsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeScalingMetricsResponse() = default;
};
class UntagResourcesSystemTagsRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceType{};
  shared_ptr<long> tagOwnerUid{};
  shared_ptr<vector<string>> resourceIds{};
  shared_ptr<vector<string>> tagKeys{};
  shared_ptr<bool> all{};

  UntagResourcesSystemTagsRequest() {}

  explicit UntagResourcesSystemTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagOwnerUid) {
      res["TagOwnerUid"] = boost::any(*tagOwnerUid);
    }
    if (resourceIds) {
      res["ResourceIds"] = boost::any(*resourceIds);
    }
    if (tagKeys) {
      res["TagKeys"] = boost::any(*tagKeys);
    }
    if (all) {
      res["All"] = boost::any(*all);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagOwnerUid") != m.end() && !m["TagOwnerUid"].empty()) {
      tagOwnerUid = make_shared<long>(boost::any_cast<long>(m["TagOwnerUid"]));
    }
    if (m.find("ResourceIds") != m.end() && !m["ResourceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TagKeys") != m.end() && !m["TagKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TagKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TagKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tagKeys = make_shared<vector<string>>(toVec1);
    }
    if (m.find("All") != m.end() && !m["All"].empty()) {
      all = make_shared<bool>(boost::any_cast<bool>(m["All"]));
    }
  }


  virtual ~UntagResourcesSystemTagsRequest() = default;
};
class UntagResourcesSystemTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};

  UntagResourcesSystemTagsResponseBody() {}

  explicit UntagResourcesSystemTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~UntagResourcesSystemTagsResponseBody() = default;
};
class UntagResourcesSystemTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UntagResourcesSystemTagsResponseBody> body{};

  UntagResourcesSystemTagsResponse() {}

  explicit UntagResourcesSystemTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UntagResourcesSystemTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UntagResourcesSystemTagsResponseBody>(model1);
      }
    }
  }


  virtual ~UntagResourcesSystemTagsResponse() = default;
};
class DescribeFlowProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};

  DescribeFlowProjectRequest() {}

  explicit DescribeFlowProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeFlowProjectRequest() = default;
};
class DescribeFlowProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> description{};
  shared_ptr<string> userId{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> name{};
  shared_ptr<string> id{};

  DescribeFlowProjectResponseBody() {}

  explicit DescribeFlowProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~DescribeFlowProjectResponseBody() = default;
};
class DescribeFlowProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeFlowProjectResponseBody> body{};

  DescribeFlowProjectResponse() {}

  explicit DescribeFlowProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFlowProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFlowProjectResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFlowProjectResponse() = default;
};
class DeleteSecurityWhiteListRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> portRange{};
  shared_ptr<string> whiteIp{};

  DeleteSecurityWhiteListRequest() {}

  explicit DeleteSecurityWhiteListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (portRange) {
      res["PortRange"] = boost::any(*portRange);
    }
    if (whiteIp) {
      res["WhiteIp"] = boost::any(*whiteIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("PortRange") != m.end() && !m["PortRange"].empty()) {
      portRange = make_shared<string>(boost::any_cast<string>(m["PortRange"]));
    }
    if (m.find("WhiteIp") != m.end() && !m["WhiteIp"].empty()) {
      whiteIp = make_shared<string>(boost::any_cast<string>(m["WhiteIp"]));
    }
  }


  virtual ~DeleteSecurityWhiteListRequest() = default;
};
class DeleteSecurityWhiteListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteSecurityWhiteListResponseBody() {}

  explicit DeleteSecurityWhiteListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteSecurityWhiteListResponseBody() = default;
};
class DeleteSecurityWhiteListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteSecurityWhiteListResponseBody> body{};

  DeleteSecurityWhiteListResponse() {}

  explicit DeleteSecurityWhiteListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSecurityWhiteListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSecurityWhiteListResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSecurityWhiteListResponse() = default;
};
class ListScalingActivityRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> limit{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> currentSize{};
  shared_ptr<long> pageCount{};
  shared_ptr<string> orderField{};
  shared_ptr<string> orderMode{};
  shared_ptr<string> clusterBizId{};
  shared_ptr<string> hostGroupId{};
  shared_ptr<string> scalingGroupBizId{};
  shared_ptr<string> scalingRuleName{};
  shared_ptr<string> hostGroupName{};
  shared_ptr<string> status{};

  ListScalingActivityRequest() {}

  explicit ListScalingActivityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (limit) {
      res["Limit"] = boost::any(*limit);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentSize) {
      res["CurrentSize"] = boost::any(*currentSize);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (orderField) {
      res["OrderField"] = boost::any(*orderField);
    }
    if (orderMode) {
      res["OrderMode"] = boost::any(*orderMode);
    }
    if (clusterBizId) {
      res["ClusterBizId"] = boost::any(*clusterBizId);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (scalingGroupBizId) {
      res["ScalingGroupBizId"] = boost::any(*scalingGroupBizId);
    }
    if (scalingRuleName) {
      res["ScalingRuleName"] = boost::any(*scalingRuleName);
    }
    if (hostGroupName) {
      res["HostGroupName"] = boost::any(*hostGroupName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Limit") != m.end() && !m["Limit"].empty()) {
      limit = make_shared<long>(boost::any_cast<long>(m["Limit"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("CurrentSize") != m.end() && !m["CurrentSize"].empty()) {
      currentSize = make_shared<long>(boost::any_cast<long>(m["CurrentSize"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("OrderField") != m.end() && !m["OrderField"].empty()) {
      orderField = make_shared<string>(boost::any_cast<string>(m["OrderField"]));
    }
    if (m.find("OrderMode") != m.end() && !m["OrderMode"].empty()) {
      orderMode = make_shared<string>(boost::any_cast<string>(m["OrderMode"]));
    }
    if (m.find("ClusterBizId") != m.end() && !m["ClusterBizId"].empty()) {
      clusterBizId = make_shared<string>(boost::any_cast<string>(m["ClusterBizId"]));
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("ScalingGroupBizId") != m.end() && !m["ScalingGroupBizId"].empty()) {
      scalingGroupBizId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupBizId"]));
    }
    if (m.find("ScalingRuleName") != m.end() && !m["ScalingRuleName"].empty()) {
      scalingRuleName = make_shared<string>(boost::any_cast<string>(m["ScalingRuleName"]));
    }
    if (m.find("HostGroupName") != m.end() && !m["HostGroupName"].empty()) {
      hostGroupName = make_shared<string>(boost::any_cast<string>(m["HostGroupName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListScalingActivityRequest() = default;
};
class ListScalingActivityResponseBodyItemsItem : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<long> startTime{};
  shared_ptr<long> endTime{};
  shared_ptr<long> expectNum{};
  shared_ptr<string> instanceIds{};
  shared_ptr<long> totalCapacity{};
  shared_ptr<string> cause{};
  shared_ptr<string> description{};
  shared_ptr<string> transition{};
  shared_ptr<string> status{};
  shared_ptr<string> scalingRuleId{};
  shared_ptr<string> scalingRuleName{};
  shared_ptr<string> hostGroupBizId{};
  shared_ptr<string> hostGroupName{};

  ListScalingActivityResponseBodyItemsItem() {}

  explicit ListScalingActivityResponseBodyItemsItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (expectNum) {
      res["ExpectNum"] = boost::any(*expectNum);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (totalCapacity) {
      res["TotalCapacity"] = boost::any(*totalCapacity);
    }
    if (cause) {
      res["Cause"] = boost::any(*cause);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (transition) {
      res["Transition"] = boost::any(*transition);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (scalingRuleId) {
      res["ScalingRuleId"] = boost::any(*scalingRuleId);
    }
    if (scalingRuleName) {
      res["ScalingRuleName"] = boost::any(*scalingRuleName);
    }
    if (hostGroupBizId) {
      res["HostGroupBizId"] = boost::any(*hostGroupBizId);
    }
    if (hostGroupName) {
      res["HostGroupName"] = boost::any(*hostGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("ExpectNum") != m.end() && !m["ExpectNum"].empty()) {
      expectNum = make_shared<long>(boost::any_cast<long>(m["ExpectNum"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("TotalCapacity") != m.end() && !m["TotalCapacity"].empty()) {
      totalCapacity = make_shared<long>(boost::any_cast<long>(m["TotalCapacity"]));
    }
    if (m.find("Cause") != m.end() && !m["Cause"].empty()) {
      cause = make_shared<string>(boost::any_cast<string>(m["Cause"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Transition") != m.end() && !m["Transition"].empty()) {
      transition = make_shared<string>(boost::any_cast<string>(m["Transition"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("ScalingRuleId") != m.end() && !m["ScalingRuleId"].empty()) {
      scalingRuleId = make_shared<string>(boost::any_cast<string>(m["ScalingRuleId"]));
    }
    if (m.find("ScalingRuleName") != m.end() && !m["ScalingRuleName"].empty()) {
      scalingRuleName = make_shared<string>(boost::any_cast<string>(m["ScalingRuleName"]));
    }
    if (m.find("HostGroupBizId") != m.end() && !m["HostGroupBizId"].empty()) {
      hostGroupBizId = make_shared<string>(boost::any_cast<string>(m["HostGroupBizId"]));
    }
    if (m.find("HostGroupName") != m.end() && !m["HostGroupName"].empty()) {
      hostGroupName = make_shared<string>(boost::any_cast<string>(m["HostGroupName"]));
    }
  }


  virtual ~ListScalingActivityResponseBodyItemsItem() = default;
};
class ListScalingActivityResponseBodyItems : public Darabonba::Model {
public:
  shared_ptr<vector<ListScalingActivityResponseBodyItemsItem>> item{};

  ListScalingActivityResponseBodyItems() {}

  explicit ListScalingActivityResponseBodyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (item) {
      vector<boost::any> temp1;
      for(auto item1:*item){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Item"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Item") != m.end() && !m["Item"].empty()) {
      if (typeid(vector<boost::any>) == m["Item"].type()) {
        vector<ListScalingActivityResponseBodyItemsItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Item"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListScalingActivityResponseBodyItemsItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        item = make_shared<vector<ListScalingActivityResponseBodyItemsItem>>(expect1);
      }
    }
  }


  virtual ~ListScalingActivityResponseBodyItems() = default;
};
class ListScalingActivityResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> nextToken{};
  shared_ptr<ListScalingActivityResponseBodyItems> items{};

  ListScalingActivityResponseBody() {}

  explicit ListScalingActivityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (items) {
      res["Items"] = items ? boost::any(items->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<long>(boost::any_cast<long>(m["NextToken"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(map<string, boost::any>) == m["Items"].type()) {
        ListScalingActivityResponseBodyItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Items"]));
        items = make_shared<ListScalingActivityResponseBodyItems>(model1);
      }
    }
  }


  virtual ~ListScalingActivityResponseBody() = default;
};
class ListScalingActivityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListScalingActivityResponseBody> body{};

  ListScalingActivityResponse() {}

  explicit ListScalingActivityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListScalingActivityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListScalingActivityResponseBody>(model1);
      }
    }
  }


  virtual ~ListScalingActivityResponse() = default;
};
class ListTagValuesRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> scope{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> key{};

  ListTagValuesRequest() {}

  explicit ListTagValuesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
  }


  virtual ~ListTagValuesRequest() = default;
};
class ListTagValuesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<string> nextToken{};
  shared_ptr<vector<string>> items{};

  ListTagValuesResponseBodyData() {}

  explicit ListTagValuesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (items) {
      res["Items"] = boost::any(*items);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Items"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      items = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListTagValuesResponseBodyData() = default;
};
class ListTagValuesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<bool> paging{};
  shared_ptr<vector<ListTagValuesResponseBodyData>> data{};
  shared_ptr<string> code{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};

  ListTagValuesResponseBody() {}

  explicit ListTagValuesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (paging) {
      res["Paging"] = boost::any(*paging);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Paging") != m.end() && !m["Paging"].empty()) {
      paging = make_shared<bool>(boost::any_cast<bool>(m["Paging"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListTagValuesResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagValuesResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListTagValuesResponseBodyData>>(expect1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~ListTagValuesResponseBody() = default;
};
class ListTagValuesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListTagValuesResponseBody> body{};

  ListTagValuesResponse() {}

  explicit ListTagValuesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTagValuesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTagValuesResponseBody>(model1);
      }
    }
  }


  virtual ~ListTagValuesResponse() = default;
};
class ListClusterInstalledServiceRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> clusterId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListClusterInstalledServiceRequest() {}

  explicit ListClusterInstalledServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListClusterInstalledServiceRequest() = default;
};
class ListClusterInstalledServiceResponseBodyClusterInstalledServiceListClusterInstalledServiceServiceActionListServiceAction : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> actionName{};
  shared_ptr<string> componentName{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> command{};

  ListClusterInstalledServiceResponseBodyClusterInstalledServiceListClusterInstalledServiceServiceActionListServiceAction() {}

  explicit ListClusterInstalledServiceResponseBodyClusterInstalledServiceListClusterInstalledServiceServiceActionListServiceAction(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (actionName) {
      res["ActionName"] = boost::any(*actionName);
    }
    if (componentName) {
      res["ComponentName"] = boost::any(*componentName);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (command) {
      res["Command"] = boost::any(*command);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("ActionName") != m.end() && !m["ActionName"].empty()) {
      actionName = make_shared<string>(boost::any_cast<string>(m["ActionName"]));
    }
    if (m.find("ComponentName") != m.end() && !m["ComponentName"].empty()) {
      componentName = make_shared<string>(boost::any_cast<string>(m["ComponentName"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
  }


  virtual ~ListClusterInstalledServiceResponseBodyClusterInstalledServiceListClusterInstalledServiceServiceActionListServiceAction() = default;
};
class ListClusterInstalledServiceResponseBodyClusterInstalledServiceListClusterInstalledServiceServiceActionList : public Darabonba::Model {
public:
  shared_ptr<vector<ListClusterInstalledServiceResponseBodyClusterInstalledServiceListClusterInstalledServiceServiceActionListServiceAction>> serviceAction{};

  ListClusterInstalledServiceResponseBodyClusterInstalledServiceListClusterInstalledServiceServiceActionList() {}

  explicit ListClusterInstalledServiceResponseBodyClusterInstalledServiceListClusterInstalledServiceServiceActionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceAction) {
      vector<boost::any> temp1;
      for(auto item1:*serviceAction){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ServiceAction"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServiceAction") != m.end() && !m["ServiceAction"].empty()) {
      if (typeid(vector<boost::any>) == m["ServiceAction"].type()) {
        vector<ListClusterInstalledServiceResponseBodyClusterInstalledServiceListClusterInstalledServiceServiceActionListServiceAction> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ServiceAction"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClusterInstalledServiceResponseBodyClusterInstalledServiceListClusterInstalledServiceServiceActionListServiceAction model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serviceAction = make_shared<vector<ListClusterInstalledServiceResponseBodyClusterInstalledServiceListClusterInstalledServiceServiceActionListServiceAction>>(expect1);
      }
    }
  }


  virtual ~ListClusterInstalledServiceResponseBodyClusterInstalledServiceListClusterInstalledServiceServiceActionList() = default;
};
class ListClusterInstalledServiceResponseBodyClusterInstalledServiceListClusterInstalledService : public Darabonba::Model {
public:
  shared_ptr<string> serviceEcmVersion{};
  shared_ptr<string> serviceDisplayName{};
  shared_ptr<bool> onlyClient{};
  shared_ptr<string> comment{};
  shared_ptr<long> notStartedNum{};
  shared_ptr<long> needRestartNum{};
  shared_ptr<string> serviceVersion{};
  shared_ptr<string> serviceStatus{};
  shared_ptr<string> serviceName{};
  shared_ptr<long> abnormalNum{};
  shared_ptr<ListClusterInstalledServiceResponseBodyClusterInstalledServiceListClusterInstalledServiceServiceActionList> serviceActionList{};

  ListClusterInstalledServiceResponseBodyClusterInstalledServiceListClusterInstalledService() {}

  explicit ListClusterInstalledServiceResponseBodyClusterInstalledServiceListClusterInstalledService(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceEcmVersion) {
      res["ServiceEcmVersion"] = boost::any(*serviceEcmVersion);
    }
    if (serviceDisplayName) {
      res["ServiceDisplayName"] = boost::any(*serviceDisplayName);
    }
    if (onlyClient) {
      res["OnlyClient"] = boost::any(*onlyClient);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (notStartedNum) {
      res["NotStartedNum"] = boost::any(*notStartedNum);
    }
    if (needRestartNum) {
      res["NeedRestartNum"] = boost::any(*needRestartNum);
    }
    if (serviceVersion) {
      res["ServiceVersion"] = boost::any(*serviceVersion);
    }
    if (serviceStatus) {
      res["ServiceStatus"] = boost::any(*serviceStatus);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (abnormalNum) {
      res["AbnormalNum"] = boost::any(*abnormalNum);
    }
    if (serviceActionList) {
      res["ServiceActionList"] = serviceActionList ? boost::any(serviceActionList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServiceEcmVersion") != m.end() && !m["ServiceEcmVersion"].empty()) {
      serviceEcmVersion = make_shared<string>(boost::any_cast<string>(m["ServiceEcmVersion"]));
    }
    if (m.find("ServiceDisplayName") != m.end() && !m["ServiceDisplayName"].empty()) {
      serviceDisplayName = make_shared<string>(boost::any_cast<string>(m["ServiceDisplayName"]));
    }
    if (m.find("OnlyClient") != m.end() && !m["OnlyClient"].empty()) {
      onlyClient = make_shared<bool>(boost::any_cast<bool>(m["OnlyClient"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("NotStartedNum") != m.end() && !m["NotStartedNum"].empty()) {
      notStartedNum = make_shared<long>(boost::any_cast<long>(m["NotStartedNum"]));
    }
    if (m.find("NeedRestartNum") != m.end() && !m["NeedRestartNum"].empty()) {
      needRestartNum = make_shared<long>(boost::any_cast<long>(m["NeedRestartNum"]));
    }
    if (m.find("ServiceVersion") != m.end() && !m["ServiceVersion"].empty()) {
      serviceVersion = make_shared<string>(boost::any_cast<string>(m["ServiceVersion"]));
    }
    if (m.find("ServiceStatus") != m.end() && !m["ServiceStatus"].empty()) {
      serviceStatus = make_shared<string>(boost::any_cast<string>(m["ServiceStatus"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("AbnormalNum") != m.end() && !m["AbnormalNum"].empty()) {
      abnormalNum = make_shared<long>(boost::any_cast<long>(m["AbnormalNum"]));
    }
    if (m.find("ServiceActionList") != m.end() && !m["ServiceActionList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ServiceActionList"].type()) {
        ListClusterInstalledServiceResponseBodyClusterInstalledServiceListClusterInstalledServiceServiceActionList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ServiceActionList"]));
        serviceActionList = make_shared<ListClusterInstalledServiceResponseBodyClusterInstalledServiceListClusterInstalledServiceServiceActionList>(model1);
      }
    }
  }


  virtual ~ListClusterInstalledServiceResponseBodyClusterInstalledServiceListClusterInstalledService() = default;
};
class ListClusterInstalledServiceResponseBodyClusterInstalledServiceList : public Darabonba::Model {
public:
  shared_ptr<vector<ListClusterInstalledServiceResponseBodyClusterInstalledServiceListClusterInstalledService>> clusterInstalledService{};

  ListClusterInstalledServiceResponseBodyClusterInstalledServiceList() {}

  explicit ListClusterInstalledServiceResponseBodyClusterInstalledServiceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterInstalledService) {
      vector<boost::any> temp1;
      for(auto item1:*clusterInstalledService){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ClusterInstalledService"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterInstalledService") != m.end() && !m["ClusterInstalledService"].empty()) {
      if (typeid(vector<boost::any>) == m["ClusterInstalledService"].type()) {
        vector<ListClusterInstalledServiceResponseBodyClusterInstalledServiceListClusterInstalledService> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ClusterInstalledService"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClusterInstalledServiceResponseBodyClusterInstalledServiceListClusterInstalledService model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clusterInstalledService = make_shared<vector<ListClusterInstalledServiceResponseBodyClusterInstalledServiceListClusterInstalledService>>(expect1);
      }
    }
  }


  virtual ~ListClusterInstalledServiceResponseBodyClusterInstalledServiceList() = default;
};
class ListClusterInstalledServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListClusterInstalledServiceResponseBodyClusterInstalledServiceList> clusterInstalledServiceList{};

  ListClusterInstalledServiceResponseBody() {}

  explicit ListClusterInstalledServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (clusterInstalledServiceList) {
      res["ClusterInstalledServiceList"] = clusterInstalledServiceList ? boost::any(clusterInstalledServiceList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ClusterInstalledServiceList") != m.end() && !m["ClusterInstalledServiceList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClusterInstalledServiceList"].type()) {
        ListClusterInstalledServiceResponseBodyClusterInstalledServiceList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClusterInstalledServiceList"]));
        clusterInstalledServiceList = make_shared<ListClusterInstalledServiceResponseBodyClusterInstalledServiceList>(model1);
      }
    }
  }


  virtual ~ListClusterInstalledServiceResponseBody() = default;
};
class ListClusterInstalledServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListClusterInstalledServiceResponseBody> body{};

  ListClusterInstalledServiceResponse() {}

  explicit ListClusterInstalledServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListClusterInstalledServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListClusterInstalledServiceResponseBody>(model1);
      }
    }
  }


  virtual ~ListClusterInstalledServiceResponse() = default;
};
class RunClusterServiceActionRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> hostIdList{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> serviceActionName{};
  shared_ptr<string> customCommand{};
  shared_ptr<string> componentNameList{};
  shared_ptr<string> comment{};
  shared_ptr<bool> isRolling{};
  shared_ptr<string> executeStrategy{};
  shared_ptr<string> customParams{};
  shared_ptr<long> interval{};
  shared_ptr<long> nodeCountPerBatch{};
  shared_ptr<long> tolerateFailCount{};
  shared_ptr<bool> onlyRestartStaleConfigNodes{};
  shared_ptr<bool> turnOnMaintenanceMode{};
  shared_ptr<vector<string>> hostGroupIdList{};

  RunClusterServiceActionRequest() {}

  explicit RunClusterServiceActionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (hostIdList) {
      res["HostIdList"] = boost::any(*hostIdList);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (serviceActionName) {
      res["ServiceActionName"] = boost::any(*serviceActionName);
    }
    if (customCommand) {
      res["CustomCommand"] = boost::any(*customCommand);
    }
    if (componentNameList) {
      res["ComponentNameList"] = boost::any(*componentNameList);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (isRolling) {
      res["IsRolling"] = boost::any(*isRolling);
    }
    if (executeStrategy) {
      res["ExecuteStrategy"] = boost::any(*executeStrategy);
    }
    if (customParams) {
      res["CustomParams"] = boost::any(*customParams);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (nodeCountPerBatch) {
      res["NodeCountPerBatch"] = boost::any(*nodeCountPerBatch);
    }
    if (tolerateFailCount) {
      res["TolerateFailCount"] = boost::any(*tolerateFailCount);
    }
    if (onlyRestartStaleConfigNodes) {
      res["OnlyRestartStaleConfigNodes"] = boost::any(*onlyRestartStaleConfigNodes);
    }
    if (turnOnMaintenanceMode) {
      res["TurnOnMaintenanceMode"] = boost::any(*turnOnMaintenanceMode);
    }
    if (hostGroupIdList) {
      res["HostGroupIdList"] = boost::any(*hostGroupIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("HostIdList") != m.end() && !m["HostIdList"].empty()) {
      hostIdList = make_shared<string>(boost::any_cast<string>(m["HostIdList"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("ServiceActionName") != m.end() && !m["ServiceActionName"].empty()) {
      serviceActionName = make_shared<string>(boost::any_cast<string>(m["ServiceActionName"]));
    }
    if (m.find("CustomCommand") != m.end() && !m["CustomCommand"].empty()) {
      customCommand = make_shared<string>(boost::any_cast<string>(m["CustomCommand"]));
    }
    if (m.find("ComponentNameList") != m.end() && !m["ComponentNameList"].empty()) {
      componentNameList = make_shared<string>(boost::any_cast<string>(m["ComponentNameList"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("IsRolling") != m.end() && !m["IsRolling"].empty()) {
      isRolling = make_shared<bool>(boost::any_cast<bool>(m["IsRolling"]));
    }
    if (m.find("ExecuteStrategy") != m.end() && !m["ExecuteStrategy"].empty()) {
      executeStrategy = make_shared<string>(boost::any_cast<string>(m["ExecuteStrategy"]));
    }
    if (m.find("CustomParams") != m.end() && !m["CustomParams"].empty()) {
      customParams = make_shared<string>(boost::any_cast<string>(m["CustomParams"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("NodeCountPerBatch") != m.end() && !m["NodeCountPerBatch"].empty()) {
      nodeCountPerBatch = make_shared<long>(boost::any_cast<long>(m["NodeCountPerBatch"]));
    }
    if (m.find("TolerateFailCount") != m.end() && !m["TolerateFailCount"].empty()) {
      tolerateFailCount = make_shared<long>(boost::any_cast<long>(m["TolerateFailCount"]));
    }
    if (m.find("OnlyRestartStaleConfigNodes") != m.end() && !m["OnlyRestartStaleConfigNodes"].empty()) {
      onlyRestartStaleConfigNodes = make_shared<bool>(boost::any_cast<bool>(m["OnlyRestartStaleConfigNodes"]));
    }
    if (m.find("TurnOnMaintenanceMode") != m.end() && !m["TurnOnMaintenanceMode"].empty()) {
      turnOnMaintenanceMode = make_shared<bool>(boost::any_cast<bool>(m["TurnOnMaintenanceMode"]));
    }
    if (m.find("HostGroupIdList") != m.end() && !m["HostGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["HostGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["HostGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      hostGroupIdList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~RunClusterServiceActionRequest() = default;
};
class RunClusterServiceActionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RunClusterServiceActionResponseBody() {}

  explicit RunClusterServiceActionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RunClusterServiceActionResponseBody() = default;
};
class RunClusterServiceActionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RunClusterServiceActionResponseBody> body{};

  RunClusterServiceActionResponse() {}

  explicit RunClusterServiceActionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RunClusterServiceActionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RunClusterServiceActionResponseBody>(model1);
      }
    }
  }


  virtual ~RunClusterServiceActionResponse() = default;
};
class SuspendFlowRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> flowInstanceId{};

  SuspendFlowRequest() {}

  explicit SuspendFlowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (flowInstanceId) {
      res["FlowInstanceId"] = boost::any(*flowInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("FlowInstanceId") != m.end() && !m["FlowInstanceId"].empty()) {
      flowInstanceId = make_shared<string>(boost::any_cast<string>(m["FlowInstanceId"]));
    }
  }


  virtual ~SuspendFlowRequest() = default;
};
class SuspendFlowResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  SuspendFlowResponseBody() {}

  explicit SuspendFlowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SuspendFlowResponseBody() = default;
};
class SuspendFlowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SuspendFlowResponseBody> body{};

  SuspendFlowResponse() {}

  explicit SuspendFlowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SuspendFlowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SuspendFlowResponseBody>(model1);
      }
    }
  }


  virtual ~SuspendFlowResponse() = default;
};
class CreateFlowProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> productType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> clientToken{};

  CreateFlowProjectRequest() {}

  explicit CreateFlowProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productType) {
      res["ProductType"] = boost::any(*productType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductType") != m.end() && !m["ProductType"].empty()) {
      productType = make_shared<string>(boost::any_cast<string>(m["ProductType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
  }


  virtual ~CreateFlowProjectRequest() = default;
};
class CreateFlowProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  CreateFlowProjectResponseBody() {}

  explicit CreateFlowProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateFlowProjectResponseBody() = default;
};
class CreateFlowProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateFlowProjectResponseBody> body{};

  CreateFlowProjectResponse() {}

  explicit CreateFlowProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateFlowProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateFlowProjectResponseBody>(model1);
      }
    }
  }


  virtual ~CreateFlowProjectResponse() = default;
};
class ListFlowNodeInstanceContainerStatusRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> nodeInstanceId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};

  ListFlowNodeInstanceContainerStatusRequest() {}

  explicit ListFlowNodeInstanceContainerStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (nodeInstanceId) {
      res["NodeInstanceId"] = boost::any(*nodeInstanceId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("NodeInstanceId") != m.end() && !m["NodeInstanceId"].empty()) {
      nodeInstanceId = make_shared<string>(boost::any_cast<string>(m["NodeInstanceId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListFlowNodeInstanceContainerStatusRequest() = default;
};
class ListFlowNodeInstanceContainerStatusResponseBodyContainerStatusListContainerStatus : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> hostName{};
  shared_ptr<string> containerId{};
  shared_ptr<string> applicationId{};

  ListFlowNodeInstanceContainerStatusResponseBodyContainerStatusListContainerStatus() {}

  explicit ListFlowNodeInstanceContainerStatusResponseBodyContainerStatusListContainerStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (containerId) {
      res["ContainerId"] = boost::any(*containerId);
    }
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("ContainerId") != m.end() && !m["ContainerId"].empty()) {
      containerId = make_shared<string>(boost::any_cast<string>(m["ContainerId"]));
    }
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
  }


  virtual ~ListFlowNodeInstanceContainerStatusResponseBodyContainerStatusListContainerStatus() = default;
};
class ListFlowNodeInstanceContainerStatusResponseBodyContainerStatusList : public Darabonba::Model {
public:
  shared_ptr<vector<ListFlowNodeInstanceContainerStatusResponseBodyContainerStatusListContainerStatus>> containerStatus{};

  ListFlowNodeInstanceContainerStatusResponseBodyContainerStatusList() {}

  explicit ListFlowNodeInstanceContainerStatusResponseBodyContainerStatusList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (containerStatus) {
      vector<boost::any> temp1;
      for(auto item1:*containerStatus){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ContainerStatus"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContainerStatus") != m.end() && !m["ContainerStatus"].empty()) {
      if (typeid(vector<boost::any>) == m["ContainerStatus"].type()) {
        vector<ListFlowNodeInstanceContainerStatusResponseBodyContainerStatusListContainerStatus> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ContainerStatus"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFlowNodeInstanceContainerStatusResponseBodyContainerStatusListContainerStatus model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        containerStatus = make_shared<vector<ListFlowNodeInstanceContainerStatusResponseBodyContainerStatusListContainerStatus>>(expect1);
      }
    }
  }


  virtual ~ListFlowNodeInstanceContainerStatusResponseBodyContainerStatusList() = default;
};
class ListFlowNodeInstanceContainerStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};
  shared_ptr<ListFlowNodeInstanceContainerStatusResponseBodyContainerStatusList> containerStatusList{};

  ListFlowNodeInstanceContainerStatusResponseBody() {}

  explicit ListFlowNodeInstanceContainerStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (containerStatusList) {
      res["ContainerStatusList"] = containerStatusList ? boost::any(containerStatusList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("ContainerStatusList") != m.end() && !m["ContainerStatusList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ContainerStatusList"].type()) {
        ListFlowNodeInstanceContainerStatusResponseBodyContainerStatusList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ContainerStatusList"]));
        containerStatusList = make_shared<ListFlowNodeInstanceContainerStatusResponseBodyContainerStatusList>(model1);
      }
    }
  }


  virtual ~ListFlowNodeInstanceContainerStatusResponseBody() = default;
};
class ListFlowNodeInstanceContainerStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListFlowNodeInstanceContainerStatusResponseBody> body{};

  ListFlowNodeInstanceContainerStatusResponse() {}

  explicit ListFlowNodeInstanceContainerStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFlowNodeInstanceContainerStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFlowNodeInstanceContainerStatusResponseBody>(model1);
      }
    }
  }


  virtual ~ListFlowNodeInstanceContainerStatusResponse() = default;
};
class ModifyClusterTemplateRequestHostGroup : public Darabonba::Model {
public:
  shared_ptr<long> sysDiskCapacity{};
  shared_ptr<string> hostGroupType{};
  shared_ptr<string> comment{};
  shared_ptr<string> multiInstanceTypes{};
  shared_ptr<string> sysDiskType{};
  shared_ptr<string> chargeType{};
  shared_ptr<string> diskType{};
  shared_ptr<string> hostGroupId{};
  shared_ptr<string> instanceType{};
  shared_ptr<long> diskCount{};
  shared_ptr<string> createType{};
  shared_ptr<long> period{};
  shared_ptr<long> diskCapacity{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<long> nodeCount{};
  shared_ptr<string> hostGroupName{};
  shared_ptr<bool> renewAuto{};
  shared_ptr<string> clusterId{};

  ModifyClusterTemplateRequestHostGroup() {}

  explicit ModifyClusterTemplateRequestHostGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sysDiskCapacity) {
      res["SysDiskCapacity"] = boost::any(*sysDiskCapacity);
    }
    if (hostGroupType) {
      res["HostGroupType"] = boost::any(*hostGroupType);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (multiInstanceTypes) {
      res["MultiInstanceTypes"] = boost::any(*multiInstanceTypes);
    }
    if (sysDiskType) {
      res["SysDiskType"] = boost::any(*sysDiskType);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (diskType) {
      res["DiskType"] = boost::any(*diskType);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (diskCount) {
      res["DiskCount"] = boost::any(*diskCount);
    }
    if (createType) {
      res["CreateType"] = boost::any(*createType);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (diskCapacity) {
      res["DiskCapacity"] = boost::any(*diskCapacity);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (nodeCount) {
      res["NodeCount"] = boost::any(*nodeCount);
    }
    if (hostGroupName) {
      res["HostGroupName"] = boost::any(*hostGroupName);
    }
    if (renewAuto) {
      res["RenewAuto"] = boost::any(*renewAuto);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SysDiskCapacity") != m.end() && !m["SysDiskCapacity"].empty()) {
      sysDiskCapacity = make_shared<long>(boost::any_cast<long>(m["SysDiskCapacity"]));
    }
    if (m.find("HostGroupType") != m.end() && !m["HostGroupType"].empty()) {
      hostGroupType = make_shared<string>(boost::any_cast<string>(m["HostGroupType"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("MultiInstanceTypes") != m.end() && !m["MultiInstanceTypes"].empty()) {
      multiInstanceTypes = make_shared<string>(boost::any_cast<string>(m["MultiInstanceTypes"]));
    }
    if (m.find("SysDiskType") != m.end() && !m["SysDiskType"].empty()) {
      sysDiskType = make_shared<string>(boost::any_cast<string>(m["SysDiskType"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("DiskType") != m.end() && !m["DiskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["DiskType"]));
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("DiskCount") != m.end() && !m["DiskCount"].empty()) {
      diskCount = make_shared<long>(boost::any_cast<long>(m["DiskCount"]));
    }
    if (m.find("CreateType") != m.end() && !m["CreateType"].empty()) {
      createType = make_shared<string>(boost::any_cast<string>(m["CreateType"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("DiskCapacity") != m.end() && !m["DiskCapacity"].empty()) {
      diskCapacity = make_shared<long>(boost::any_cast<long>(m["DiskCapacity"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("NodeCount") != m.end() && !m["NodeCount"].empty()) {
      nodeCount = make_shared<long>(boost::any_cast<long>(m["NodeCount"]));
    }
    if (m.find("HostGroupName") != m.end() && !m["HostGroupName"].empty()) {
      hostGroupName = make_shared<string>(boost::any_cast<string>(m["HostGroupName"]));
    }
    if (m.find("RenewAuto") != m.end() && !m["RenewAuto"].empty()) {
      renewAuto = make_shared<bool>(boost::any_cast<bool>(m["RenewAuto"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
  }


  virtual ~ModifyClusterTemplateRequestHostGroup() = default;
};
class ModifyClusterTemplateRequestBootstrapAction : public Darabonba::Model {
public:
  shared_ptr<string> arg{};
  shared_ptr<string> path{};
  shared_ptr<string> name{};

  ModifyClusterTemplateRequestBootstrapAction() {}

  explicit ModifyClusterTemplateRequestBootstrapAction(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arg) {
      res["Arg"] = boost::any(*arg);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Arg") != m.end() && !m["Arg"].empty()) {
      arg = make_shared<string>(boost::any_cast<string>(m["Arg"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ModifyClusterTemplateRequestBootstrapAction() = default;
};
class ModifyClusterTemplateRequestConfig : public Darabonba::Model {
public:
  shared_ptr<string> configValue{};
  shared_ptr<string> replace{};
  shared_ptr<string> fileName{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> configKey{};
  shared_ptr<string> encrypt{};

  ModifyClusterTemplateRequestConfig() {}

  explicit ModifyClusterTemplateRequestConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configValue) {
      res["ConfigValue"] = boost::any(*configValue);
    }
    if (replace) {
      res["Replace"] = boost::any(*replace);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (configKey) {
      res["ConfigKey"] = boost::any(*configKey);
    }
    if (encrypt) {
      res["Encrypt"] = boost::any(*encrypt);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigValue") != m.end() && !m["ConfigValue"].empty()) {
      configValue = make_shared<string>(boost::any_cast<string>(m["ConfigValue"]));
    }
    if (m.find("Replace") != m.end() && !m["Replace"].empty()) {
      replace = make_shared<string>(boost::any_cast<string>(m["Replace"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("ConfigKey") != m.end() && !m["ConfigKey"].empty()) {
      configKey = make_shared<string>(boost::any_cast<string>(m["ConfigKey"]));
    }
    if (m.find("Encrypt") != m.end() && !m["Encrypt"].empty()) {
      encrypt = make_shared<string>(boost::any_cast<string>(m["Encrypt"]));
    }
  }


  virtual ~ModifyClusterTemplateRequestConfig() = default;
};
class ModifyClusterTemplateRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ModifyClusterTemplateRequestTag() {}

  explicit ModifyClusterTemplateRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ModifyClusterTemplateRequestTag() = default;
};
class ModifyClusterTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> bizId{};
  shared_ptr<string> templateName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> logPath{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<bool> isOpenPublicIp{};
  shared_ptr<string> securityGroupName{};
  shared_ptr<string> chargeType{};
  shared_ptr<long> period{};
  shared_ptr<bool> renewAuto{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> netType{};
  shared_ptr<string> userDefinedEmrEcsRole{};
  shared_ptr<string> emrVer{};
  shared_ptr<string> clusterType{};
  shared_ptr<bool> enableHighAvailability{};
  shared_ptr<bool> useLocalMetaDb{};
  shared_ptr<bool> ioOptimizedOption{};
  shared_ptr<bool> enableSsh{};
  shared_ptr<string> instanceGeneration{};
  shared_ptr<string> masterPwd{};
  shared_ptr<string> keyPairName{};
  shared_ptr<string> metaStoreType{};
  shared_ptr<string> metaStoreConf{};
  shared_ptr<string> configurations{};
  shared_ptr<bool> enableEas{};
  shared_ptr<string> depositType{};
  shared_ptr<string> machineType{};
  shared_ptr<bool> useCustomHiveMetaDb{};
  shared_ptr<bool> initCustomHiveMetaDb{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<string>> optionSoftWareList{};
  shared_ptr<vector<ModifyClusterTemplateRequestHostGroup>> hostGroup{};
  shared_ptr<vector<ModifyClusterTemplateRequestBootstrapAction>> bootstrapAction{};
  shared_ptr<vector<ModifyClusterTemplateRequestConfig>> config{};
  shared_ptr<vector<ModifyClusterTemplateRequestTag>> tag{};

  ModifyClusterTemplateRequest() {}

  explicit ModifyClusterTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (logPath) {
      res["LogPath"] = boost::any(*logPath);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (isOpenPublicIp) {
      res["IsOpenPublicIp"] = boost::any(*isOpenPublicIp);
    }
    if (securityGroupName) {
      res["SecurityGroupName"] = boost::any(*securityGroupName);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (renewAuto) {
      res["RenewAuto"] = boost::any(*renewAuto);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (netType) {
      res["NetType"] = boost::any(*netType);
    }
    if (userDefinedEmrEcsRole) {
      res["UserDefinedEmrEcsRole"] = boost::any(*userDefinedEmrEcsRole);
    }
    if (emrVer) {
      res["EmrVer"] = boost::any(*emrVer);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (enableHighAvailability) {
      res["EnableHighAvailability"] = boost::any(*enableHighAvailability);
    }
    if (useLocalMetaDb) {
      res["UseLocalMetaDb"] = boost::any(*useLocalMetaDb);
    }
    if (ioOptimizedOption) {
      res["IoOptimizedOption"] = boost::any(*ioOptimizedOption);
    }
    if (enableSsh) {
      res["EnableSsh"] = boost::any(*enableSsh);
    }
    if (instanceGeneration) {
      res["InstanceGeneration"] = boost::any(*instanceGeneration);
    }
    if (masterPwd) {
      res["MasterPwd"] = boost::any(*masterPwd);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (metaStoreType) {
      res["MetaStoreType"] = boost::any(*metaStoreType);
    }
    if (metaStoreConf) {
      res["MetaStoreConf"] = boost::any(*metaStoreConf);
    }
    if (configurations) {
      res["Configurations"] = boost::any(*configurations);
    }
    if (enableEas) {
      res["EnableEas"] = boost::any(*enableEas);
    }
    if (depositType) {
      res["DepositType"] = boost::any(*depositType);
    }
    if (machineType) {
      res["MachineType"] = boost::any(*machineType);
    }
    if (useCustomHiveMetaDb) {
      res["UseCustomHiveMetaDb"] = boost::any(*useCustomHiveMetaDb);
    }
    if (initCustomHiveMetaDb) {
      res["InitCustomHiveMetaDb"] = boost::any(*initCustomHiveMetaDb);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (optionSoftWareList) {
      res["OptionSoftWareList"] = boost::any(*optionSoftWareList);
    }
    if (hostGroup) {
      vector<boost::any> temp1;
      for(auto item1:*hostGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HostGroup"] = boost::any(temp1);
    }
    if (bootstrapAction) {
      vector<boost::any> temp1;
      for(auto item1:*bootstrapAction){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BootstrapAction"] = boost::any(temp1);
    }
    if (config) {
      vector<boost::any> temp1;
      for(auto item1:*config){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Config"] = boost::any(temp1);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("LogPath") != m.end() && !m["LogPath"].empty()) {
      logPath = make_shared<string>(boost::any_cast<string>(m["LogPath"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("IsOpenPublicIp") != m.end() && !m["IsOpenPublicIp"].empty()) {
      isOpenPublicIp = make_shared<bool>(boost::any_cast<bool>(m["IsOpenPublicIp"]));
    }
    if (m.find("SecurityGroupName") != m.end() && !m["SecurityGroupName"].empty()) {
      securityGroupName = make_shared<string>(boost::any_cast<string>(m["SecurityGroupName"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("RenewAuto") != m.end() && !m["RenewAuto"].empty()) {
      renewAuto = make_shared<bool>(boost::any_cast<bool>(m["RenewAuto"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("NetType") != m.end() && !m["NetType"].empty()) {
      netType = make_shared<string>(boost::any_cast<string>(m["NetType"]));
    }
    if (m.find("UserDefinedEmrEcsRole") != m.end() && !m["UserDefinedEmrEcsRole"].empty()) {
      userDefinedEmrEcsRole = make_shared<string>(boost::any_cast<string>(m["UserDefinedEmrEcsRole"]));
    }
    if (m.find("EmrVer") != m.end() && !m["EmrVer"].empty()) {
      emrVer = make_shared<string>(boost::any_cast<string>(m["EmrVer"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("EnableHighAvailability") != m.end() && !m["EnableHighAvailability"].empty()) {
      enableHighAvailability = make_shared<bool>(boost::any_cast<bool>(m["EnableHighAvailability"]));
    }
    if (m.find("UseLocalMetaDb") != m.end() && !m["UseLocalMetaDb"].empty()) {
      useLocalMetaDb = make_shared<bool>(boost::any_cast<bool>(m["UseLocalMetaDb"]));
    }
    if (m.find("IoOptimizedOption") != m.end() && !m["IoOptimizedOption"].empty()) {
      ioOptimizedOption = make_shared<bool>(boost::any_cast<bool>(m["IoOptimizedOption"]));
    }
    if (m.find("EnableSsh") != m.end() && !m["EnableSsh"].empty()) {
      enableSsh = make_shared<bool>(boost::any_cast<bool>(m["EnableSsh"]));
    }
    if (m.find("InstanceGeneration") != m.end() && !m["InstanceGeneration"].empty()) {
      instanceGeneration = make_shared<string>(boost::any_cast<string>(m["InstanceGeneration"]));
    }
    if (m.find("MasterPwd") != m.end() && !m["MasterPwd"].empty()) {
      masterPwd = make_shared<string>(boost::any_cast<string>(m["MasterPwd"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("MetaStoreType") != m.end() && !m["MetaStoreType"].empty()) {
      metaStoreType = make_shared<string>(boost::any_cast<string>(m["MetaStoreType"]));
    }
    if (m.find("MetaStoreConf") != m.end() && !m["MetaStoreConf"].empty()) {
      metaStoreConf = make_shared<string>(boost::any_cast<string>(m["MetaStoreConf"]));
    }
    if (m.find("Configurations") != m.end() && !m["Configurations"].empty()) {
      configurations = make_shared<string>(boost::any_cast<string>(m["Configurations"]));
    }
    if (m.find("EnableEas") != m.end() && !m["EnableEas"].empty()) {
      enableEas = make_shared<bool>(boost::any_cast<bool>(m["EnableEas"]));
    }
    if (m.find("DepositType") != m.end() && !m["DepositType"].empty()) {
      depositType = make_shared<string>(boost::any_cast<string>(m["DepositType"]));
    }
    if (m.find("MachineType") != m.end() && !m["MachineType"].empty()) {
      machineType = make_shared<string>(boost::any_cast<string>(m["MachineType"]));
    }
    if (m.find("UseCustomHiveMetaDb") != m.end() && !m["UseCustomHiveMetaDb"].empty()) {
      useCustomHiveMetaDb = make_shared<bool>(boost::any_cast<bool>(m["UseCustomHiveMetaDb"]));
    }
    if (m.find("InitCustomHiveMetaDb") != m.end() && !m["InitCustomHiveMetaDb"].empty()) {
      initCustomHiveMetaDb = make_shared<bool>(boost::any_cast<bool>(m["InitCustomHiveMetaDb"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("OptionSoftWareList") != m.end() && !m["OptionSoftWareList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OptionSoftWareList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OptionSoftWareList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      optionSoftWareList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("HostGroup") != m.end() && !m["HostGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["HostGroup"].type()) {
        vector<ModifyClusterTemplateRequestHostGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HostGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyClusterTemplateRequestHostGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hostGroup = make_shared<vector<ModifyClusterTemplateRequestHostGroup>>(expect1);
      }
    }
    if (m.find("BootstrapAction") != m.end() && !m["BootstrapAction"].empty()) {
      if (typeid(vector<boost::any>) == m["BootstrapAction"].type()) {
        vector<ModifyClusterTemplateRequestBootstrapAction> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BootstrapAction"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyClusterTemplateRequestBootstrapAction model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bootstrapAction = make_shared<vector<ModifyClusterTemplateRequestBootstrapAction>>(expect1);
      }
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      if (typeid(vector<boost::any>) == m["Config"].type()) {
        vector<ModifyClusterTemplateRequestConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Config"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyClusterTemplateRequestConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        config = make_shared<vector<ModifyClusterTemplateRequestConfig>>(expect1);
      }
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<ModifyClusterTemplateRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyClusterTemplateRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<ModifyClusterTemplateRequestTag>>(expect1);
      }
    }
  }


  virtual ~ModifyClusterTemplateRequest() = default;
};
class ModifyClusterTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> clusterTemplateId{};
  shared_ptr<string> requestId{};

  ModifyClusterTemplateResponseBody() {}

  explicit ModifyClusterTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterTemplateId) {
      res["ClusterTemplateId"] = boost::any(*clusterTemplateId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterTemplateId") != m.end() && !m["ClusterTemplateId"].empty()) {
      clusterTemplateId = make_shared<string>(boost::any_cast<string>(m["ClusterTemplateId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyClusterTemplateResponseBody() = default;
};
class ModifyClusterTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyClusterTemplateResponseBody> body{};

  ModifyClusterTemplateResponse() {}

  explicit ModifyClusterTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyClusterTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyClusterTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyClusterTemplateResponse() = default;
};
class AddSecurityWhiteListRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> portRange{};
  shared_ptr<vector<string>> whiteIpList{};
  shared_ptr<string> description{};

  AddSecurityWhiteListRequest() {}

  explicit AddSecurityWhiteListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (portRange) {
      res["PortRange"] = boost::any(*portRange);
    }
    if (whiteIpList) {
      res["WhiteIpList"] = boost::any(*whiteIpList);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("PortRange") != m.end() && !m["PortRange"].empty()) {
      portRange = make_shared<string>(boost::any_cast<string>(m["PortRange"]));
    }
    if (m.find("WhiteIpList") != m.end() && !m["WhiteIpList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["WhiteIpList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["WhiteIpList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      whiteIpList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~AddSecurityWhiteListRequest() = default;
};
class AddSecurityWhiteListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddSecurityWhiteListResponseBody() {}

  explicit AddSecurityWhiteListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddSecurityWhiteListResponseBody() = default;
};
class AddSecurityWhiteListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AddSecurityWhiteListResponseBody> body{};

  AddSecurityWhiteListResponse() {}

  explicit AddSecurityWhiteListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddSecurityWhiteListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddSecurityWhiteListResponseBody>(model1);
      }
    }
  }


  virtual ~AddSecurityWhiteListResponse() = default;
};
class ListMetaClusterRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sourceType{};

  ListMetaClusterRequest() {}

  explicit ListMetaClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
  }


  virtual ~ListMetaClusterRequest() = default;
};
class ListMetaClusterResponseBodyItemsItemSoftwareInfo : public Darabonba::Model {
public:
  shared_ptr<string> clusterType{};
  shared_ptr<string> emrVer{};

  ListMetaClusterResponseBodyItemsItemSoftwareInfo() {}

  explicit ListMetaClusterResponseBodyItemsItemSoftwareInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (emrVer) {
      res["EmrVer"] = boost::any(*emrVer);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("EmrVer") != m.end() && !m["EmrVer"].empty()) {
      emrVer = make_shared<string>(boost::any_cast<string>(m["EmrVer"]));
    }
  }


  virtual ~ListMetaClusterResponseBodyItemsItemSoftwareInfo() = default;
};
class ListMetaClusterResponseBodyItemsItem : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> id{};
  shared_ptr<ListMetaClusterResponseBodyItemsItemSoftwareInfo> softwareInfo{};

  ListMetaClusterResponseBodyItemsItem() {}

  explicit ListMetaClusterResponseBodyItemsItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (softwareInfo) {
      res["SoftwareInfo"] = softwareInfo ? boost::any(softwareInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("SoftwareInfo") != m.end() && !m["SoftwareInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["SoftwareInfo"].type()) {
        ListMetaClusterResponseBodyItemsItemSoftwareInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SoftwareInfo"]));
        softwareInfo = make_shared<ListMetaClusterResponseBodyItemsItemSoftwareInfo>(model1);
      }
    }
  }


  virtual ~ListMetaClusterResponseBodyItemsItem() = default;
};
class ListMetaClusterResponseBodyItems : public Darabonba::Model {
public:
  shared_ptr<vector<ListMetaClusterResponseBodyItemsItem>> item{};

  ListMetaClusterResponseBodyItems() {}

  explicit ListMetaClusterResponseBodyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (item) {
      vector<boost::any> temp1;
      for(auto item1:*item){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Item"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Item") != m.end() && !m["Item"].empty()) {
      if (typeid(vector<boost::any>) == m["Item"].type()) {
        vector<ListMetaClusterResponseBodyItemsItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Item"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMetaClusterResponseBodyItemsItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        item = make_shared<vector<ListMetaClusterResponseBodyItemsItem>>(expect1);
      }
    }
  }


  virtual ~ListMetaClusterResponseBodyItems() = default;
};
class ListMetaClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<ListMetaClusterResponseBodyItems> items{};

  ListMetaClusterResponseBody() {}

  explicit ListMetaClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (items) {
      res["Items"] = items ? boost::any(items->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(map<string, boost::any>) == m["Items"].type()) {
        ListMetaClusterResponseBodyItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Items"]));
        items = make_shared<ListMetaClusterResponseBodyItems>(model1);
      }
    }
  }


  virtual ~ListMetaClusterResponseBody() = default;
};
class ListMetaClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListMetaClusterResponseBody> body{};

  ListMetaClusterResponse() {}

  explicit ListMetaClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMetaClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMetaClusterResponseBody>(model1);
      }
    }
  }


  virtual ~ListMetaClusterResponse() = default;
};
class ListClusterOperationHostRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> operationId{};
  shared_ptr<string> status{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListClusterOperationHostRequest() {}

  explicit ListClusterOperationHostRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (operationId) {
      res["OperationId"] = boost::any(*operationId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("OperationId") != m.end() && !m["OperationId"].empty()) {
      operationId = make_shared<string>(boost::any_cast<string>(m["OperationId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListClusterOperationHostRequest() = default;
};
class ListClusterOperationHostResponseBodyClusterOperationHostListClusterOperationHost : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> hostName{};
  shared_ptr<string> percentage{};
  shared_ptr<string> hostId{};

  ListClusterOperationHostResponseBodyClusterOperationHostListClusterOperationHost() {}

  explicit ListClusterOperationHostResponseBodyClusterOperationHostListClusterOperationHost(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (percentage) {
      res["Percentage"] = boost::any(*percentage);
    }
    if (hostId) {
      res["HostId"] = boost::any(*hostId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("Percentage") != m.end() && !m["Percentage"].empty()) {
      percentage = make_shared<string>(boost::any_cast<string>(m["Percentage"]));
    }
    if (m.find("HostId") != m.end() && !m["HostId"].empty()) {
      hostId = make_shared<string>(boost::any_cast<string>(m["HostId"]));
    }
  }


  virtual ~ListClusterOperationHostResponseBodyClusterOperationHostListClusterOperationHost() = default;
};
class ListClusterOperationHostResponseBodyClusterOperationHostList : public Darabonba::Model {
public:
  shared_ptr<vector<ListClusterOperationHostResponseBodyClusterOperationHostListClusterOperationHost>> clusterOperationHost{};

  ListClusterOperationHostResponseBodyClusterOperationHostList() {}

  explicit ListClusterOperationHostResponseBodyClusterOperationHostList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterOperationHost) {
      vector<boost::any> temp1;
      for(auto item1:*clusterOperationHost){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ClusterOperationHost"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterOperationHost") != m.end() && !m["ClusterOperationHost"].empty()) {
      if (typeid(vector<boost::any>) == m["ClusterOperationHost"].type()) {
        vector<ListClusterOperationHostResponseBodyClusterOperationHostListClusterOperationHost> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ClusterOperationHost"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClusterOperationHostResponseBodyClusterOperationHostListClusterOperationHost model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clusterOperationHost = make_shared<vector<ListClusterOperationHostResponseBodyClusterOperationHostListClusterOperationHost>>(expect1);
      }
    }
  }


  virtual ~ListClusterOperationHostResponseBodyClusterOperationHostList() = default;
};
class ListClusterOperationHostResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> totalCount{};
  shared_ptr<ListClusterOperationHostResponseBodyClusterOperationHostList> clusterOperationHostList{};

  ListClusterOperationHostResponseBody() {}

  explicit ListClusterOperationHostResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (clusterOperationHostList) {
      res["ClusterOperationHostList"] = clusterOperationHostList ? boost::any(clusterOperationHostList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("ClusterOperationHostList") != m.end() && !m["ClusterOperationHostList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClusterOperationHostList"].type()) {
        ListClusterOperationHostResponseBodyClusterOperationHostList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClusterOperationHostList"]));
        clusterOperationHostList = make_shared<ListClusterOperationHostResponseBodyClusterOperationHostList>(model1);
      }
    }
  }


  virtual ~ListClusterOperationHostResponseBody() = default;
};
class ListClusterOperationHostResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListClusterOperationHostResponseBody> body{};

  ListClusterOperationHostResponse() {}

  explicit ListClusterOperationHostResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListClusterOperationHostResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListClusterOperationHostResponseBody>(model1);
      }
    }
  }


  virtual ~ListClusterOperationHostResponse() = default;
};
class ListClusterTemplatesRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> bizId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> productType{};
  shared_ptr<string> resourceGroupId{};

  ListClusterTemplatesRequest() {}

  explicit ListClusterTemplatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productType) {
      res["ProductType"] = boost::any(*productType);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProductType") != m.end() && !m["ProductType"].empty()) {
      productType = make_shared<string>(boost::any_cast<string>(m["ProductType"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ListClusterTemplatesRequest() = default;
};
class ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoBootstrapActionListBootstrapAction : public Darabonba::Model {
public:
  shared_ptr<string> path{};
  shared_ptr<string> name{};
  shared_ptr<string> arg{};

  ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoBootstrapActionListBootstrapAction() {}

  explicit ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoBootstrapActionListBootstrapAction(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (arg) {
      res["Arg"] = boost::any(*arg);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Arg") != m.end() && !m["Arg"].empty()) {
      arg = make_shared<string>(boost::any_cast<string>(m["Arg"]));
    }
  }


  virtual ~ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoBootstrapActionListBootstrapAction() = default;
};
class ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoBootstrapActionList : public Darabonba::Model {
public:
  shared_ptr<vector<ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoBootstrapActionListBootstrapAction>> bootstrapAction{};

  ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoBootstrapActionList() {}

  explicit ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoBootstrapActionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bootstrapAction) {
      vector<boost::any> temp1;
      for(auto item1:*bootstrapAction){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BootstrapAction"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BootstrapAction") != m.end() && !m["BootstrapAction"].empty()) {
      if (typeid(vector<boost::any>) == m["BootstrapAction"].type()) {
        vector<ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoBootstrapActionListBootstrapAction> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BootstrapAction"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoBootstrapActionListBootstrapAction model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bootstrapAction = make_shared<vector<ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoBootstrapActionListBootstrapAction>>(expect1);
      }
    }
  }


  virtual ~ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoBootstrapActionList() = default;
};
class ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoHostGroupListHostGroup : public Darabonba::Model {
public:
  shared_ptr<long> sysDiskCapacity{};
  shared_ptr<string> hostGroupType{};
  shared_ptr<string> multiInstanceTypes{};
  shared_ptr<string> sysDiskType{};
  shared_ptr<string> chargeType{};
  shared_ptr<string> diskType{};
  shared_ptr<string> hostGroupId{};
  shared_ptr<string> instanceType{};
  shared_ptr<long> diskCount{};
  shared_ptr<string> period{};
  shared_ptr<long> diskCapacity{};
  shared_ptr<long> nodeCount{};
  shared_ptr<string> hostGroupName{};

  ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoHostGroupListHostGroup() {}

  explicit ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoHostGroupListHostGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sysDiskCapacity) {
      res["SysDiskCapacity"] = boost::any(*sysDiskCapacity);
    }
    if (hostGroupType) {
      res["HostGroupType"] = boost::any(*hostGroupType);
    }
    if (multiInstanceTypes) {
      res["MultiInstanceTypes"] = boost::any(*multiInstanceTypes);
    }
    if (sysDiskType) {
      res["SysDiskType"] = boost::any(*sysDiskType);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (diskType) {
      res["DiskType"] = boost::any(*diskType);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (diskCount) {
      res["DiskCount"] = boost::any(*diskCount);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (diskCapacity) {
      res["DiskCapacity"] = boost::any(*diskCapacity);
    }
    if (nodeCount) {
      res["NodeCount"] = boost::any(*nodeCount);
    }
    if (hostGroupName) {
      res["HostGroupName"] = boost::any(*hostGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SysDiskCapacity") != m.end() && !m["SysDiskCapacity"].empty()) {
      sysDiskCapacity = make_shared<long>(boost::any_cast<long>(m["SysDiskCapacity"]));
    }
    if (m.find("HostGroupType") != m.end() && !m["HostGroupType"].empty()) {
      hostGroupType = make_shared<string>(boost::any_cast<string>(m["HostGroupType"]));
    }
    if (m.find("MultiInstanceTypes") != m.end() && !m["MultiInstanceTypes"].empty()) {
      multiInstanceTypes = make_shared<string>(boost::any_cast<string>(m["MultiInstanceTypes"]));
    }
    if (m.find("SysDiskType") != m.end() && !m["SysDiskType"].empty()) {
      sysDiskType = make_shared<string>(boost::any_cast<string>(m["SysDiskType"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("DiskType") != m.end() && !m["DiskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["DiskType"]));
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("DiskCount") != m.end() && !m["DiskCount"].empty()) {
      diskCount = make_shared<long>(boost::any_cast<long>(m["DiskCount"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("DiskCapacity") != m.end() && !m["DiskCapacity"].empty()) {
      diskCapacity = make_shared<long>(boost::any_cast<long>(m["DiskCapacity"]));
    }
    if (m.find("NodeCount") != m.end() && !m["NodeCount"].empty()) {
      nodeCount = make_shared<long>(boost::any_cast<long>(m["NodeCount"]));
    }
    if (m.find("HostGroupName") != m.end() && !m["HostGroupName"].empty()) {
      hostGroupName = make_shared<string>(boost::any_cast<string>(m["HostGroupName"]));
    }
  }


  virtual ~ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoHostGroupListHostGroup() = default;
};
class ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoHostGroupList : public Darabonba::Model {
public:
  shared_ptr<vector<ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoHostGroupListHostGroup>> hostGroup{};

  ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoHostGroupList() {}

  explicit ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoHostGroupList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostGroup) {
      vector<boost::any> temp1;
      for(auto item1:*hostGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HostGroup"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostGroup") != m.end() && !m["HostGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["HostGroup"].type()) {
        vector<ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoHostGroupListHostGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HostGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoHostGroupListHostGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hostGroup = make_shared<vector<ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoHostGroupListHostGroup>>(expect1);
      }
    }
  }


  virtual ~ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoHostGroupList() = default;
};
class ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoConfigListConfig : public Darabonba::Model {
public:
  shared_ptr<string> configValue{};
  shared_ptr<string> replace{};
  shared_ptr<string> fileName{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> configKey{};
  shared_ptr<string> encrypt{};

  ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoConfigListConfig() {}

  explicit ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoConfigListConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configValue) {
      res["ConfigValue"] = boost::any(*configValue);
    }
    if (replace) {
      res["Replace"] = boost::any(*replace);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (configKey) {
      res["ConfigKey"] = boost::any(*configKey);
    }
    if (encrypt) {
      res["Encrypt"] = boost::any(*encrypt);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigValue") != m.end() && !m["ConfigValue"].empty()) {
      configValue = make_shared<string>(boost::any_cast<string>(m["ConfigValue"]));
    }
    if (m.find("Replace") != m.end() && !m["Replace"].empty()) {
      replace = make_shared<string>(boost::any_cast<string>(m["Replace"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("ConfigKey") != m.end() && !m["ConfigKey"].empty()) {
      configKey = make_shared<string>(boost::any_cast<string>(m["ConfigKey"]));
    }
    if (m.find("Encrypt") != m.end() && !m["Encrypt"].empty()) {
      encrypt = make_shared<string>(boost::any_cast<string>(m["Encrypt"]));
    }
  }


  virtual ~ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoConfigListConfig() = default;
};
class ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoConfigList : public Darabonba::Model {
public:
  shared_ptr<vector<ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoConfigListConfig>> config{};

  ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoConfigList() {}

  explicit ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      vector<boost::any> temp1;
      for(auto item1:*config){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Config"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      if (typeid(vector<boost::any>) == m["Config"].type()) {
        vector<ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoConfigListConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Config"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoConfigListConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        config = make_shared<vector<ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoConfigListConfig>>(expect1);
      }
    }
  }


  virtual ~ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoConfigList() = default;
};
class ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoSoftwareInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> softwareInfo{};

  ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoSoftwareInfoList() {}

  explicit ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoSoftwareInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (softwareInfo) {
      res["SoftwareInfo"] = boost::any(*softwareInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SoftwareInfo") != m.end() && !m["SoftwareInfo"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SoftwareInfo"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SoftwareInfo"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      softwareInfo = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoSoftwareInfoList() = default;
};
class ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfo : public Darabonba::Model {
public:
  shared_ptr<string> vpcId{};
  shared_ptr<string> keyPairName{};
  shared_ptr<bool> logEnable{};
  shared_ptr<bool> sshEnable{};
  shared_ptr<bool> highAvailabilityEnable{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> userId{};
  shared_ptr<bool> isOpenPublicIp{};
  shared_ptr<bool> allowNotebook{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> templateName{};
  shared_ptr<string> depositType{};
  shared_ptr<string> securityGroupName{};
  shared_ptr<string> createSource{};
  shared_ptr<string> instanceGeneration{};
  shared_ptr<bool> useCustomHiveMetaDb{};
  shared_ptr<bool> easEnable{};
  shared_ptr<string> userDefinedEmrEcsRole{};
  shared_ptr<string> metaStoreType{};
  shared_ptr<string> machineType{};
  shared_ptr<bool> useLocalMetaDb{};
  shared_ptr<long> masterNodeTotal{};
  shared_ptr<bool> initCustomHiveMetaDb{};
  shared_ptr<bool> ioOptimized{};
  shared_ptr<string> metaStoreConf{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> configurations{};
  shared_ptr<string> logPath{};
  shared_ptr<string> clusterType{};
  shared_ptr<string> netType{};
  shared_ptr<string> zoneId{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<string> id{};
  shared_ptr<ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoBootstrapActionList> bootstrapActionList{};
  shared_ptr<ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoHostGroupList> hostGroupList{};
  shared_ptr<ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoConfigList> configList{};
  shared_ptr<ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoSoftwareInfoList> softwareInfoList{};

  ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfo() {}

  explicit ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (logEnable) {
      res["LogEnable"] = boost::any(*logEnable);
    }
    if (sshEnable) {
      res["SshEnable"] = boost::any(*sshEnable);
    }
    if (highAvailabilityEnable) {
      res["HighAvailabilityEnable"] = boost::any(*highAvailabilityEnable);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (isOpenPublicIp) {
      res["IsOpenPublicIp"] = boost::any(*isOpenPublicIp);
    }
    if (allowNotebook) {
      res["AllowNotebook"] = boost::any(*allowNotebook);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (depositType) {
      res["DepositType"] = boost::any(*depositType);
    }
    if (securityGroupName) {
      res["SecurityGroupName"] = boost::any(*securityGroupName);
    }
    if (createSource) {
      res["CreateSource"] = boost::any(*createSource);
    }
    if (instanceGeneration) {
      res["InstanceGeneration"] = boost::any(*instanceGeneration);
    }
    if (useCustomHiveMetaDb) {
      res["UseCustomHiveMetaDb"] = boost::any(*useCustomHiveMetaDb);
    }
    if (easEnable) {
      res["EasEnable"] = boost::any(*easEnable);
    }
    if (userDefinedEmrEcsRole) {
      res["UserDefinedEmrEcsRole"] = boost::any(*userDefinedEmrEcsRole);
    }
    if (metaStoreType) {
      res["MetaStoreType"] = boost::any(*metaStoreType);
    }
    if (machineType) {
      res["MachineType"] = boost::any(*machineType);
    }
    if (useLocalMetaDb) {
      res["UseLocalMetaDb"] = boost::any(*useLocalMetaDb);
    }
    if (masterNodeTotal) {
      res["MasterNodeTotal"] = boost::any(*masterNodeTotal);
    }
    if (initCustomHiveMetaDb) {
      res["InitCustomHiveMetaDb"] = boost::any(*initCustomHiveMetaDb);
    }
    if (ioOptimized) {
      res["IoOptimized"] = boost::any(*ioOptimized);
    }
    if (metaStoreConf) {
      res["MetaStoreConf"] = boost::any(*metaStoreConf);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (configurations) {
      res["Configurations"] = boost::any(*configurations);
    }
    if (logPath) {
      res["LogPath"] = boost::any(*logPath);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (netType) {
      res["NetType"] = boost::any(*netType);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (bootstrapActionList) {
      res["BootstrapActionList"] = bootstrapActionList ? boost::any(bootstrapActionList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hostGroupList) {
      res["HostGroupList"] = hostGroupList ? boost::any(hostGroupList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (configList) {
      res["ConfigList"] = configList ? boost::any(configList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (softwareInfoList) {
      res["SoftwareInfoList"] = softwareInfoList ? boost::any(softwareInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("LogEnable") != m.end() && !m["LogEnable"].empty()) {
      logEnable = make_shared<bool>(boost::any_cast<bool>(m["LogEnable"]));
    }
    if (m.find("SshEnable") != m.end() && !m["SshEnable"].empty()) {
      sshEnable = make_shared<bool>(boost::any_cast<bool>(m["SshEnable"]));
    }
    if (m.find("HighAvailabilityEnable") != m.end() && !m["HighAvailabilityEnable"].empty()) {
      highAvailabilityEnable = make_shared<bool>(boost::any_cast<bool>(m["HighAvailabilityEnable"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("IsOpenPublicIp") != m.end() && !m["IsOpenPublicIp"].empty()) {
      isOpenPublicIp = make_shared<bool>(boost::any_cast<bool>(m["IsOpenPublicIp"]));
    }
    if (m.find("AllowNotebook") != m.end() && !m["AllowNotebook"].empty()) {
      allowNotebook = make_shared<bool>(boost::any_cast<bool>(m["AllowNotebook"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("DepositType") != m.end() && !m["DepositType"].empty()) {
      depositType = make_shared<string>(boost::any_cast<string>(m["DepositType"]));
    }
    if (m.find("SecurityGroupName") != m.end() && !m["SecurityGroupName"].empty()) {
      securityGroupName = make_shared<string>(boost::any_cast<string>(m["SecurityGroupName"]));
    }
    if (m.find("CreateSource") != m.end() && !m["CreateSource"].empty()) {
      createSource = make_shared<string>(boost::any_cast<string>(m["CreateSource"]));
    }
    if (m.find("InstanceGeneration") != m.end() && !m["InstanceGeneration"].empty()) {
      instanceGeneration = make_shared<string>(boost::any_cast<string>(m["InstanceGeneration"]));
    }
    if (m.find("UseCustomHiveMetaDb") != m.end() && !m["UseCustomHiveMetaDb"].empty()) {
      useCustomHiveMetaDb = make_shared<bool>(boost::any_cast<bool>(m["UseCustomHiveMetaDb"]));
    }
    if (m.find("EasEnable") != m.end() && !m["EasEnable"].empty()) {
      easEnable = make_shared<bool>(boost::any_cast<bool>(m["EasEnable"]));
    }
    if (m.find("UserDefinedEmrEcsRole") != m.end() && !m["UserDefinedEmrEcsRole"].empty()) {
      userDefinedEmrEcsRole = make_shared<string>(boost::any_cast<string>(m["UserDefinedEmrEcsRole"]));
    }
    if (m.find("MetaStoreType") != m.end() && !m["MetaStoreType"].empty()) {
      metaStoreType = make_shared<string>(boost::any_cast<string>(m["MetaStoreType"]));
    }
    if (m.find("MachineType") != m.end() && !m["MachineType"].empty()) {
      machineType = make_shared<string>(boost::any_cast<string>(m["MachineType"]));
    }
    if (m.find("UseLocalMetaDb") != m.end() && !m["UseLocalMetaDb"].empty()) {
      useLocalMetaDb = make_shared<bool>(boost::any_cast<bool>(m["UseLocalMetaDb"]));
    }
    if (m.find("MasterNodeTotal") != m.end() && !m["MasterNodeTotal"].empty()) {
      masterNodeTotal = make_shared<long>(boost::any_cast<long>(m["MasterNodeTotal"]));
    }
    if (m.find("InitCustomHiveMetaDb") != m.end() && !m["InitCustomHiveMetaDb"].empty()) {
      initCustomHiveMetaDb = make_shared<bool>(boost::any_cast<bool>(m["InitCustomHiveMetaDb"]));
    }
    if (m.find("IoOptimized") != m.end() && !m["IoOptimized"].empty()) {
      ioOptimized = make_shared<bool>(boost::any_cast<bool>(m["IoOptimized"]));
    }
    if (m.find("MetaStoreConf") != m.end() && !m["MetaStoreConf"].empty()) {
      metaStoreConf = make_shared<string>(boost::any_cast<string>(m["MetaStoreConf"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("Configurations") != m.end() && !m["Configurations"].empty()) {
      configurations = make_shared<string>(boost::any_cast<string>(m["Configurations"]));
    }
    if (m.find("LogPath") != m.end() && !m["LogPath"].empty()) {
      logPath = make_shared<string>(boost::any_cast<string>(m["LogPath"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("NetType") != m.end() && !m["NetType"].empty()) {
      netType = make_shared<string>(boost::any_cast<string>(m["NetType"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("BootstrapActionList") != m.end() && !m["BootstrapActionList"].empty()) {
      if (typeid(map<string, boost::any>) == m["BootstrapActionList"].type()) {
        ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoBootstrapActionList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BootstrapActionList"]));
        bootstrapActionList = make_shared<ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoBootstrapActionList>(model1);
      }
    }
    if (m.find("HostGroupList") != m.end() && !m["HostGroupList"].empty()) {
      if (typeid(map<string, boost::any>) == m["HostGroupList"].type()) {
        ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoHostGroupList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HostGroupList"]));
        hostGroupList = make_shared<ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoHostGroupList>(model1);
      }
    }
    if (m.find("ConfigList") != m.end() && !m["ConfigList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConfigList"].type()) {
        ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoConfigList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConfigList"]));
        configList = make_shared<ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoConfigList>(model1);
      }
    }
    if (m.find("SoftwareInfoList") != m.end() && !m["SoftwareInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SoftwareInfoList"].type()) {
        ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoSoftwareInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SoftwareInfoList"]));
        softwareInfoList = make_shared<ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoSoftwareInfoList>(model1);
      }
    }
  }


  virtual ~ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfo() = default;
};
class ListClusterTemplatesResponseBodyTemplateInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfo>> templateInfo{};

  ListClusterTemplatesResponseBodyTemplateInfoList() {}

  explicit ListClusterTemplatesResponseBodyTemplateInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (templateInfo) {
      vector<boost::any> temp1;
      for(auto item1:*templateInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TemplateInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TemplateInfo") != m.end() && !m["TemplateInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["TemplateInfo"].type()) {
        vector<ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TemplateInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        templateInfo = make_shared<vector<ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfo>>(expect1);
      }
    }
  }


  virtual ~ListClusterTemplatesResponseBodyTemplateInfoList() = default;
};
class ListClusterTemplatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> totalCount{};
  shared_ptr<ListClusterTemplatesResponseBodyTemplateInfoList> templateInfoList{};

  ListClusterTemplatesResponseBody() {}

  explicit ListClusterTemplatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (templateInfoList) {
      res["TemplateInfoList"] = templateInfoList ? boost::any(templateInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("TemplateInfoList") != m.end() && !m["TemplateInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TemplateInfoList"].type()) {
        ListClusterTemplatesResponseBodyTemplateInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TemplateInfoList"]));
        templateInfoList = make_shared<ListClusterTemplatesResponseBodyTemplateInfoList>(model1);
      }
    }
  }


  virtual ~ListClusterTemplatesResponseBody() = default;
};
class ListClusterTemplatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListClusterTemplatesResponseBody> body{};

  ListClusterTemplatesResponse() {}

  explicit ListClusterTemplatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListClusterTemplatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListClusterTemplatesResponseBody>(model1);
      }
    }
  }


  virtual ~ListClusterTemplatesResponse() = default;
};
class ListClustersRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListClustersRequestTag() {}

  explicit ListClustersRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListClustersRequestTag() = default;
};
class ListClustersRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> createType{};
  shared_ptr<string> machineType{};
  shared_ptr<bool> isDesc{};
  shared_ptr<string> depositType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<bool> defaultStatus{};
  shared_ptr<string> name{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<string>> clusterTypeList{};
  shared_ptr<vector<string>> statusList{};
  shared_ptr<vector<ListClustersRequestTag>> tag{};
  shared_ptr<vector<string>> expiredTagList{};

  ListClustersRequest() {}

  explicit ListClustersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (createType) {
      res["CreateType"] = boost::any(*createType);
    }
    if (machineType) {
      res["MachineType"] = boost::any(*machineType);
    }
    if (isDesc) {
      res["IsDesc"] = boost::any(*isDesc);
    }
    if (depositType) {
      res["DepositType"] = boost::any(*depositType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (defaultStatus) {
      res["DefaultStatus"] = boost::any(*defaultStatus);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (clusterTypeList) {
      res["ClusterTypeList"] = boost::any(*clusterTypeList);
    }
    if (statusList) {
      res["StatusList"] = boost::any(*statusList);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (expiredTagList) {
      res["ExpiredTagList"] = boost::any(*expiredTagList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("CreateType") != m.end() && !m["CreateType"].empty()) {
      createType = make_shared<string>(boost::any_cast<string>(m["CreateType"]));
    }
    if (m.find("MachineType") != m.end() && !m["MachineType"].empty()) {
      machineType = make_shared<string>(boost::any_cast<string>(m["MachineType"]));
    }
    if (m.find("IsDesc") != m.end() && !m["IsDesc"].empty()) {
      isDesc = make_shared<bool>(boost::any_cast<bool>(m["IsDesc"]));
    }
    if (m.find("DepositType") != m.end() && !m["DepositType"].empty()) {
      depositType = make_shared<string>(boost::any_cast<string>(m["DepositType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("DefaultStatus") != m.end() && !m["DefaultStatus"].empty()) {
      defaultStatus = make_shared<bool>(boost::any_cast<bool>(m["DefaultStatus"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ClusterTypeList") != m.end() && !m["ClusterTypeList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ClusterTypeList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ClusterTypeList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      clusterTypeList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("StatusList") != m.end() && !m["StatusList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["StatusList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["StatusList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      statusList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<ListClustersRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClustersRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<ListClustersRequestTag>>(expect1);
      }
    }
    if (m.find("ExpiredTagList") != m.end() && !m["ExpiredTagList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ExpiredTagList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExpiredTagList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      expiredTagList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListClustersRequest() = default;
};
class ListClustersResponseBodyClustersClusterInfoTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> tagValue{};
  shared_ptr<string> tagKey{};

  ListClustersResponseBodyClustersClusterInfoTagsTag() {}

  explicit ListClustersResponseBodyClustersClusterInfoTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
  }


  virtual ~ListClustersResponseBodyClustersClusterInfoTagsTag() = default;
};
class ListClustersResponseBodyClustersClusterInfoTags : public Darabonba::Model {
public:
  shared_ptr<vector<ListClustersResponseBodyClustersClusterInfoTagsTag>> tag{};

  ListClustersResponseBodyClustersClusterInfoTags() {}

  explicit ListClustersResponseBodyClustersClusterInfoTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<ListClustersResponseBodyClustersClusterInfoTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClustersResponseBodyClustersClusterInfoTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<ListClustersResponseBodyClustersClusterInfoTagsTag>>(expect1);
      }
    }
  }


  virtual ~ListClustersResponseBodyClustersClusterInfoTags() = default;
};
class ListClustersResponseBodyClustersClusterInfoOrderTaskInfo : public Darabonba::Model {
public:
  shared_ptr<long> targetCount{};
  shared_ptr<long> currentCount{};
  shared_ptr<string> orderIdList{};

  ListClustersResponseBodyClustersClusterInfoOrderTaskInfo() {}

  explicit ListClustersResponseBodyClustersClusterInfoOrderTaskInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (targetCount) {
      res["TargetCount"] = boost::any(*targetCount);
    }
    if (currentCount) {
      res["CurrentCount"] = boost::any(*currentCount);
    }
    if (orderIdList) {
      res["OrderIdList"] = boost::any(*orderIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TargetCount") != m.end() && !m["TargetCount"].empty()) {
      targetCount = make_shared<long>(boost::any_cast<long>(m["TargetCount"]));
    }
    if (m.find("CurrentCount") != m.end() && !m["CurrentCount"].empty()) {
      currentCount = make_shared<long>(boost::any_cast<long>(m["CurrentCount"]));
    }
    if (m.find("OrderIdList") != m.end() && !m["OrderIdList"].empty()) {
      orderIdList = make_shared<string>(boost::any_cast<string>(m["OrderIdList"]));
    }
  }


  virtual ~ListClustersResponseBodyClustersClusterInfoOrderTaskInfo() = default;
};
class ListClustersResponseBodyClustersClusterInfoFailReason : public Darabonba::Model {
public:
  shared_ptr<string> errorMsg{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};

  ListClustersResponseBodyClustersClusterInfoFailReason() {}

  explicit ListClustersResponseBodyClustersClusterInfoFailReason(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
  }


  virtual ~ListClustersResponseBodyClustersClusterInfoFailReason() = default;
};
class ListClustersResponseBodyClustersClusterInfo : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> status{};
  shared_ptr<long> runningTime{};
  shared_ptr<string> metaStoreType{};
  shared_ptr<string> machineType{};
  shared_ptr<string> orderList{};
  shared_ptr<long> createTime{};
  shared_ptr<string> chargeType{};
  shared_ptr<string> depositType{};
  shared_ptr<long> period{};
  shared_ptr<string> k8sClusterId{};
  shared_ptr<long> expiredTime{};
  shared_ptr<bool> hasUncompletedOrder{};
  shared_ptr<string> name{};
  shared_ptr<string> createResource{};
  shared_ptr<string> id{};
  shared_ptr<ListClustersResponseBodyClustersClusterInfoTags> tags{};
  shared_ptr<ListClustersResponseBodyClustersClusterInfoOrderTaskInfo> orderTaskInfo{};
  shared_ptr<ListClustersResponseBodyClustersClusterInfoFailReason> failReason{};

  ListClustersResponseBodyClustersClusterInfo() {}

  explicit ListClustersResponseBodyClustersClusterInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (runningTime) {
      res["RunningTime"] = boost::any(*runningTime);
    }
    if (metaStoreType) {
      res["MetaStoreType"] = boost::any(*metaStoreType);
    }
    if (machineType) {
      res["MachineType"] = boost::any(*machineType);
    }
    if (orderList) {
      res["OrderList"] = boost::any(*orderList);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (depositType) {
      res["DepositType"] = boost::any(*depositType);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (k8sClusterId) {
      res["K8sClusterId"] = boost::any(*k8sClusterId);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (hasUncompletedOrder) {
      res["HasUncompletedOrder"] = boost::any(*hasUncompletedOrder);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (createResource) {
      res["CreateResource"] = boost::any(*createResource);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (orderTaskInfo) {
      res["OrderTaskInfo"] = orderTaskInfo ? boost::any(orderTaskInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (failReason) {
      res["FailReason"] = failReason ? boost::any(failReason->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("RunningTime") != m.end() && !m["RunningTime"].empty()) {
      runningTime = make_shared<long>(boost::any_cast<long>(m["RunningTime"]));
    }
    if (m.find("MetaStoreType") != m.end() && !m["MetaStoreType"].empty()) {
      metaStoreType = make_shared<string>(boost::any_cast<string>(m["MetaStoreType"]));
    }
    if (m.find("MachineType") != m.end() && !m["MachineType"].empty()) {
      machineType = make_shared<string>(boost::any_cast<string>(m["MachineType"]));
    }
    if (m.find("OrderList") != m.end() && !m["OrderList"].empty()) {
      orderList = make_shared<string>(boost::any_cast<string>(m["OrderList"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("DepositType") != m.end() && !m["DepositType"].empty()) {
      depositType = make_shared<string>(boost::any_cast<string>(m["DepositType"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("K8sClusterId") != m.end() && !m["K8sClusterId"].empty()) {
      k8sClusterId = make_shared<string>(boost::any_cast<string>(m["K8sClusterId"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<long>(boost::any_cast<long>(m["ExpiredTime"]));
    }
    if (m.find("HasUncompletedOrder") != m.end() && !m["HasUncompletedOrder"].empty()) {
      hasUncompletedOrder = make_shared<bool>(boost::any_cast<bool>(m["HasUncompletedOrder"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("CreateResource") != m.end() && !m["CreateResource"].empty()) {
      createResource = make_shared<string>(boost::any_cast<string>(m["CreateResource"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        ListClustersResponseBodyClustersClusterInfoTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<ListClustersResponseBodyClustersClusterInfoTags>(model1);
      }
    }
    if (m.find("OrderTaskInfo") != m.end() && !m["OrderTaskInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["OrderTaskInfo"].type()) {
        ListClustersResponseBodyClustersClusterInfoOrderTaskInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OrderTaskInfo"]));
        orderTaskInfo = make_shared<ListClustersResponseBodyClustersClusterInfoOrderTaskInfo>(model1);
      }
    }
    if (m.find("FailReason") != m.end() && !m["FailReason"].empty()) {
      if (typeid(map<string, boost::any>) == m["FailReason"].type()) {
        ListClustersResponseBodyClustersClusterInfoFailReason model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FailReason"]));
        failReason = make_shared<ListClustersResponseBodyClustersClusterInfoFailReason>(model1);
      }
    }
  }


  virtual ~ListClustersResponseBodyClustersClusterInfo() = default;
};
class ListClustersResponseBodyClusters : public Darabonba::Model {
public:
  shared_ptr<vector<ListClustersResponseBodyClustersClusterInfo>> clusterInfo{};

  ListClustersResponseBodyClusters() {}

  explicit ListClustersResponseBodyClusters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterInfo) {
      vector<boost::any> temp1;
      for(auto item1:*clusterInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ClusterInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterInfo") != m.end() && !m["ClusterInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ClusterInfo"].type()) {
        vector<ListClustersResponseBodyClustersClusterInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ClusterInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClustersResponseBodyClustersClusterInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clusterInfo = make_shared<vector<ListClustersResponseBodyClustersClusterInfo>>(expect1);
      }
    }
  }


  virtual ~ListClustersResponseBodyClusters() = default;
};
class ListClustersResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> totalCount{};
  shared_ptr<ListClustersResponseBodyClusters> clusters{};

  ListClustersResponseBody() {}

  explicit ListClustersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (clusters) {
      res["Clusters"] = clusters ? boost::any(clusters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Clusters") != m.end() && !m["Clusters"].empty()) {
      if (typeid(map<string, boost::any>) == m["Clusters"].type()) {
        ListClustersResponseBodyClusters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Clusters"]));
        clusters = make_shared<ListClustersResponseBodyClusters>(model1);
      }
    }
  }


  virtual ~ListClustersResponseBody() = default;
};
class ListClustersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListClustersResponseBody> body{};

  ListClustersResponse() {}

  explicit ListClustersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListClustersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListClustersResponseBody>(model1);
      }
    }
  }


  virtual ~ListClustersResponse() = default;
};
class TagResourcesSystemTagsRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  TagResourcesSystemTagsRequestTags() {}

  explicit TagResourcesSystemTagsRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~TagResourcesSystemTagsRequestTags() = default;
};
class TagResourcesSystemTagsRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceType{};
  shared_ptr<long> tagOwnerUid{};
  shared_ptr<string> scope{};
  shared_ptr<vector<TagResourcesSystemTagsRequestTags>> tags{};
  shared_ptr<vector<string>> resourceIds{};

  TagResourcesSystemTagsRequest() {}

  explicit TagResourcesSystemTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagOwnerUid) {
      res["TagOwnerUid"] = boost::any(*tagOwnerUid);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (resourceIds) {
      res["ResourceIds"] = boost::any(*resourceIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagOwnerUid") != m.end() && !m["TagOwnerUid"].empty()) {
      tagOwnerUid = make_shared<long>(boost::any_cast<long>(m["TagOwnerUid"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<TagResourcesSystemTagsRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TagResourcesSystemTagsRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<TagResourcesSystemTagsRequestTags>>(expect1);
      }
    }
    if (m.find("ResourceIds") != m.end() && !m["ResourceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~TagResourcesSystemTagsRequest() = default;
};
class TagResourcesSystemTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};

  TagResourcesSystemTagsResponseBody() {}

  explicit TagResourcesSystemTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~TagResourcesSystemTagsResponseBody() = default;
};
class TagResourcesSystemTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<TagResourcesSystemTagsResponseBody> body{};

  TagResourcesSystemTagsResponse() {}

  explicit TagResourcesSystemTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TagResourcesSystemTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TagResourcesSystemTagsResponseBody>(model1);
      }
    }
  }


  virtual ~TagResourcesSystemTagsResponse() = default;
};
class ModifyFlowJobRequestResourceList : public Darabonba::Model {
public:
  shared_ptr<string> path{};
  shared_ptr<string> alias{};

  ModifyFlowJobRequestResourceList() {}

  explicit ModifyFlowJobRequestResourceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
  }


  virtual ~ModifyFlowJobRequestResourceList() = default;
};
class ModifyFlowJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};
  shared_ptr<string> failAct{};
  shared_ptr<string> retryPolicy{};
  shared_ptr<string> params{};
  shared_ptr<string> paramConf{};
  shared_ptr<string> customVariables{};
  shared_ptr<string> envConf{};
  shared_ptr<string> runConf{};
  shared_ptr<string> monitorConf{};
  shared_ptr<string> mode{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> alertConf{};
  shared_ptr<vector<ModifyFlowJobRequestResourceList>> resourceList{};

  ModifyFlowJobRequest() {}

  explicit ModifyFlowJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (failAct) {
      res["FailAct"] = boost::any(*failAct);
    }
    if (retryPolicy) {
      res["RetryPolicy"] = boost::any(*retryPolicy);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (paramConf) {
      res["ParamConf"] = boost::any(*paramConf);
    }
    if (customVariables) {
      res["CustomVariables"] = boost::any(*customVariables);
    }
    if (envConf) {
      res["EnvConf"] = boost::any(*envConf);
    }
    if (runConf) {
      res["RunConf"] = boost::any(*runConf);
    }
    if (monitorConf) {
      res["MonitorConf"] = boost::any(*monitorConf);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (alertConf) {
      res["AlertConf"] = boost::any(*alertConf);
    }
    if (resourceList) {
      vector<boost::any> temp1;
      for(auto item1:*resourceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourceList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("FailAct") != m.end() && !m["FailAct"].empty()) {
      failAct = make_shared<string>(boost::any_cast<string>(m["FailAct"]));
    }
    if (m.find("RetryPolicy") != m.end() && !m["RetryPolicy"].empty()) {
      retryPolicy = make_shared<string>(boost::any_cast<string>(m["RetryPolicy"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      params = make_shared<string>(boost::any_cast<string>(m["Params"]));
    }
    if (m.find("ParamConf") != m.end() && !m["ParamConf"].empty()) {
      paramConf = make_shared<string>(boost::any_cast<string>(m["ParamConf"]));
    }
    if (m.find("CustomVariables") != m.end() && !m["CustomVariables"].empty()) {
      customVariables = make_shared<string>(boost::any_cast<string>(m["CustomVariables"]));
    }
    if (m.find("EnvConf") != m.end() && !m["EnvConf"].empty()) {
      envConf = make_shared<string>(boost::any_cast<string>(m["EnvConf"]));
    }
    if (m.find("RunConf") != m.end() && !m["RunConf"].empty()) {
      runConf = make_shared<string>(boost::any_cast<string>(m["RunConf"]));
    }
    if (m.find("MonitorConf") != m.end() && !m["MonitorConf"].empty()) {
      monitorConf = make_shared<string>(boost::any_cast<string>(m["MonitorConf"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("AlertConf") != m.end() && !m["AlertConf"].empty()) {
      alertConf = make_shared<string>(boost::any_cast<string>(m["AlertConf"]));
    }
    if (m.find("ResourceList") != m.end() && !m["ResourceList"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourceList"].type()) {
        vector<ModifyFlowJobRequestResourceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyFlowJobRequestResourceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourceList = make_shared<vector<ModifyFlowJobRequestResourceList>>(expect1);
      }
    }
  }


  virtual ~ModifyFlowJobRequest() = default;
};
class ModifyFlowJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  ModifyFlowJobResponseBody() {}

  explicit ModifyFlowJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyFlowJobResponseBody() = default;
};
class ModifyFlowJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyFlowJobResponseBody> body{};

  ModifyFlowJobResponse() {}

  explicit ModifyFlowJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyFlowJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyFlowJobResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyFlowJobResponse() = default;
};
class DeleteFlowRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};

  DeleteFlowRequest() {}

  explicit DeleteFlowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteFlowRequest() = default;
};
class DeleteFlowResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  DeleteFlowResponseBody() {}

  explicit DeleteFlowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteFlowResponseBody() = default;
};
class DeleteFlowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteFlowResponseBody> body{};

  DeleteFlowResponse() {}

  explicit DeleteFlowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteFlowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteFlowResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteFlowResponse() = default;
};
class CreateFlowEditLockRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> entityId{};
  shared_ptr<bool> force{};

  CreateFlowEditLockRequest() {}

  explicit CreateFlowEditLockRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (entityId) {
      res["EntityId"] = boost::any(*entityId);
    }
    if (force) {
      res["Force"] = boost::any(*force);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("EntityId") != m.end() && !m["EntityId"].empty()) {
      entityId = make_shared<string>(boost::any_cast<string>(m["EntityId"]));
    }
    if (m.find("Force") != m.end() && !m["Force"].empty()) {
      force = make_shared<bool>(boost::any_cast<bool>(m["Force"]));
    }
  }


  virtual ~CreateFlowEditLockRequest() = default;
};
class CreateFlowEditLockResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> requestId{};
  shared_ptr<string> entityId{};
  shared_ptr<string> userId{};
  shared_ptr<string> bizId{};
  shared_ptr<string> ownerId{};

  CreateFlowEditLockResponseBody() {}

  explicit CreateFlowEditLockResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (entityId) {
      res["EntityId"] = boost::any(*entityId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("EntityId") != m.end() && !m["EntityId"].empty()) {
      entityId = make_shared<string>(boost::any_cast<string>(m["EntityId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
  }


  virtual ~CreateFlowEditLockResponseBody() = default;
};
class CreateFlowEditLockResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateFlowEditLockResponseBody> body{};

  CreateFlowEditLockResponse() {}

  explicit CreateFlowEditLockResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateFlowEditLockResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateFlowEditLockResponseBody>(model1);
      }
    }
  }


  virtual ~CreateFlowEditLockResponse() = default;
};
class DescribeFlowNodeInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> id{};
  shared_ptr<string> regionId{};

  DescribeFlowNodeInstanceRequest() {}

  explicit DescribeFlowNodeInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeFlowNodeInstanceRequest() = default;
};
class DescribeFlowNodeInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> type{};
  shared_ptr<string> envConf{};
  shared_ptr<string> projectId{};
  shared_ptr<string> retryInterval{};
  shared_ptr<string> jobType{};
  shared_ptr<string> mode{};
  shared_ptr<string> externalInfo{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> externalChildIds{};
  shared_ptr<string> monitorConf{};
  shared_ptr<string> externalStatus{};
  shared_ptr<string> requestId{};
  shared_ptr<string> jobName{};
  shared_ptr<string> retryPolicy{};
  shared_ptr<bool> adhoc{};
  shared_ptr<string> externalId{};
  shared_ptr<bool> pending{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> maxRetry{};
  shared_ptr<string> failAct{};
  shared_ptr<string> jobParams{};
  shared_ptr<string> flowInstanceId{};
  shared_ptr<string> paramConf{};
  shared_ptr<string> hostName{};
  shared_ptr<string> flowId{};
  shared_ptr<long> retries{};
  shared_ptr<long> endTime{};
  shared_ptr<long> startTime{};
  shared_ptr<string> runConf{};
  shared_ptr<string> externalSubId{};
  shared_ptr<string> nodeName{};
  shared_ptr<string> jobId{};
  shared_ptr<string> clusterName{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> duration{};
  shared_ptr<string> id{};

  DescribeFlowNodeInstanceResponseBody() {}

  explicit DescribeFlowNodeInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (envConf) {
      res["EnvConf"] = boost::any(*envConf);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (retryInterval) {
      res["RetryInterval"] = boost::any(*retryInterval);
    }
    if (jobType) {
      res["JobType"] = boost::any(*jobType);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (externalInfo) {
      res["ExternalInfo"] = boost::any(*externalInfo);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (externalChildIds) {
      res["ExternalChildIds"] = boost::any(*externalChildIds);
    }
    if (monitorConf) {
      res["MonitorConf"] = boost::any(*monitorConf);
    }
    if (externalStatus) {
      res["ExternalStatus"] = boost::any(*externalStatus);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    if (retryPolicy) {
      res["RetryPolicy"] = boost::any(*retryPolicy);
    }
    if (adhoc) {
      res["Adhoc"] = boost::any(*adhoc);
    }
    if (externalId) {
      res["ExternalId"] = boost::any(*externalId);
    }
    if (pending) {
      res["Pending"] = boost::any(*pending);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (maxRetry) {
      res["MaxRetry"] = boost::any(*maxRetry);
    }
    if (failAct) {
      res["FailAct"] = boost::any(*failAct);
    }
    if (jobParams) {
      res["JobParams"] = boost::any(*jobParams);
    }
    if (flowInstanceId) {
      res["FlowInstanceId"] = boost::any(*flowInstanceId);
    }
    if (paramConf) {
      res["ParamConf"] = boost::any(*paramConf);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (flowId) {
      res["FlowId"] = boost::any(*flowId);
    }
    if (retries) {
      res["Retries"] = boost::any(*retries);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (runConf) {
      res["RunConf"] = boost::any(*runConf);
    }
    if (externalSubId) {
      res["ExternalSubId"] = boost::any(*externalSubId);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("EnvConf") != m.end() && !m["EnvConf"].empty()) {
      envConf = make_shared<string>(boost::any_cast<string>(m["EnvConf"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RetryInterval") != m.end() && !m["RetryInterval"].empty()) {
      retryInterval = make_shared<string>(boost::any_cast<string>(m["RetryInterval"]));
    }
    if (m.find("JobType") != m.end() && !m["JobType"].empty()) {
      jobType = make_shared<string>(boost::any_cast<string>(m["JobType"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("ExternalInfo") != m.end() && !m["ExternalInfo"].empty()) {
      externalInfo = make_shared<string>(boost::any_cast<string>(m["ExternalInfo"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("ExternalChildIds") != m.end() && !m["ExternalChildIds"].empty()) {
      externalChildIds = make_shared<string>(boost::any_cast<string>(m["ExternalChildIds"]));
    }
    if (m.find("MonitorConf") != m.end() && !m["MonitorConf"].empty()) {
      monitorConf = make_shared<string>(boost::any_cast<string>(m["MonitorConf"]));
    }
    if (m.find("ExternalStatus") != m.end() && !m["ExternalStatus"].empty()) {
      externalStatus = make_shared<string>(boost::any_cast<string>(m["ExternalStatus"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
    if (m.find("RetryPolicy") != m.end() && !m["RetryPolicy"].empty()) {
      retryPolicy = make_shared<string>(boost::any_cast<string>(m["RetryPolicy"]));
    }
    if (m.find("Adhoc") != m.end() && !m["Adhoc"].empty()) {
      adhoc = make_shared<bool>(boost::any_cast<bool>(m["Adhoc"]));
    }
    if (m.find("ExternalId") != m.end() && !m["ExternalId"].empty()) {
      externalId = make_shared<string>(boost::any_cast<string>(m["ExternalId"]));
    }
    if (m.find("Pending") != m.end() && !m["Pending"].empty()) {
      pending = make_shared<bool>(boost::any_cast<bool>(m["Pending"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("MaxRetry") != m.end() && !m["MaxRetry"].empty()) {
      maxRetry = make_shared<string>(boost::any_cast<string>(m["MaxRetry"]));
    }
    if (m.find("FailAct") != m.end() && !m["FailAct"].empty()) {
      failAct = make_shared<string>(boost::any_cast<string>(m["FailAct"]));
    }
    if (m.find("JobParams") != m.end() && !m["JobParams"].empty()) {
      jobParams = make_shared<string>(boost::any_cast<string>(m["JobParams"]));
    }
    if (m.find("FlowInstanceId") != m.end() && !m["FlowInstanceId"].empty()) {
      flowInstanceId = make_shared<string>(boost::any_cast<string>(m["FlowInstanceId"]));
    }
    if (m.find("ParamConf") != m.end() && !m["ParamConf"].empty()) {
      paramConf = make_shared<string>(boost::any_cast<string>(m["ParamConf"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("FlowId") != m.end() && !m["FlowId"].empty()) {
      flowId = make_shared<string>(boost::any_cast<string>(m["FlowId"]));
    }
    if (m.find("Retries") != m.end() && !m["Retries"].empty()) {
      retries = make_shared<long>(boost::any_cast<long>(m["Retries"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("RunConf") != m.end() && !m["RunConf"].empty()) {
      runConf = make_shared<string>(boost::any_cast<string>(m["RunConf"]));
    }
    if (m.find("ExternalSubId") != m.end() && !m["ExternalSubId"].empty()) {
      externalSubId = make_shared<string>(boost::any_cast<string>(m["ExternalSubId"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~DescribeFlowNodeInstanceResponseBody() = default;
};
class DescribeFlowNodeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeFlowNodeInstanceResponseBody> body{};

  DescribeFlowNodeInstanceResponse() {}

  explicit DescribeFlowNodeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFlowNodeInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFlowNodeInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFlowNodeInstanceResponse() = default;
};
class DetachAndReleaseClusterEniRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> targetClusterId{};
  shared_ptr<string> vswitchId{};

  DetachAndReleaseClusterEniRequest() {}

  explicit DetachAndReleaseClusterEniRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (targetClusterId) {
      res["TargetClusterId"] = boost::any(*targetClusterId);
    }
    if (vswitchId) {
      res["VswitchId"] = boost::any(*vswitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TargetClusterId") != m.end() && !m["TargetClusterId"].empty()) {
      targetClusterId = make_shared<string>(boost::any_cast<string>(m["TargetClusterId"]));
    }
    if (m.find("VswitchId") != m.end() && !m["VswitchId"].empty()) {
      vswitchId = make_shared<string>(boost::any_cast<string>(m["VswitchId"]));
    }
  }


  virtual ~DetachAndReleaseClusterEniRequest() = default;
};
class DetachAndReleaseClusterEniResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DetachAndReleaseClusterEniResponseBody() {}

  explicit DetachAndReleaseClusterEniResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DetachAndReleaseClusterEniResponseBody() = default;
};
class DetachAndReleaseClusterEniResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DetachAndReleaseClusterEniResponseBody> body{};

  DetachAndReleaseClusterEniResponse() {}

  explicit DetachAndReleaseClusterEniResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DetachAndReleaseClusterEniResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DetachAndReleaseClusterEniResponseBody>(model1);
      }
    }
  }


  virtual ~DetachAndReleaseClusterEniResponse() = default;
};
class DescribeScalingGroupInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> scalingGroupBizId{};
  shared_ptr<string> hostGroupBizId{};

  DescribeScalingGroupInstanceRequest() {}

  explicit DescribeScalingGroupInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (scalingGroupBizId) {
      res["ScalingGroupBizId"] = boost::any(*scalingGroupBizId);
    }
    if (hostGroupBizId) {
      res["HostGroupBizId"] = boost::any(*hostGroupBizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ScalingGroupBizId") != m.end() && !m["ScalingGroupBizId"].empty()) {
      scalingGroupBizId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupBizId"]));
    }
    if (m.find("HostGroupBizId") != m.end() && !m["HostGroupBizId"].empty()) {
      hostGroupBizId = make_shared<string>(boost::any_cast<string>(m["HostGroupBizId"]));
    }
  }


  virtual ~DescribeScalingGroupInstanceRequest() = default;
};
class DescribeScalingGroupInstanceResponseBodyScalingConfigInstanceTypeList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceTypeList{};

  DescribeScalingGroupInstanceResponseBodyScalingConfigInstanceTypeList() {}

  explicit DescribeScalingGroupInstanceResponseBodyScalingConfigInstanceTypeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceTypeList) {
      res["instanceTypeList"] = boost::any(*instanceTypeList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("instanceTypeList") != m.end() && !m["instanceTypeList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["instanceTypeList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["instanceTypeList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceTypeList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeScalingGroupInstanceResponseBodyScalingConfigInstanceTypeList() = default;
};
class DescribeScalingGroupInstanceResponseBodyScalingConfigSpotPriceLimitsSpotPriceLimits : public Darabonba::Model {
public:
  shared_ptr<string> instanceType{};
  shared_ptr<double> priceLimit{};

  DescribeScalingGroupInstanceResponseBodyScalingConfigSpotPriceLimitsSpotPriceLimits() {}

  explicit DescribeScalingGroupInstanceResponseBodyScalingConfigSpotPriceLimitsSpotPriceLimits(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (priceLimit) {
      res["PriceLimit"] = boost::any(*priceLimit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("PriceLimit") != m.end() && !m["PriceLimit"].empty()) {
      priceLimit = make_shared<double>(boost::any_cast<double>(m["PriceLimit"]));
    }
  }


  virtual ~DescribeScalingGroupInstanceResponseBodyScalingConfigSpotPriceLimitsSpotPriceLimits() = default;
};
class DescribeScalingGroupInstanceResponseBodyScalingConfigSpotPriceLimits : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeScalingGroupInstanceResponseBodyScalingConfigSpotPriceLimitsSpotPriceLimits>> spotPriceLimits{};

  DescribeScalingGroupInstanceResponseBodyScalingConfigSpotPriceLimits() {}

  explicit DescribeScalingGroupInstanceResponseBodyScalingConfigSpotPriceLimits(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (spotPriceLimits) {
      vector<boost::any> temp1;
      for(auto item1:*spotPriceLimits){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["spotPriceLimits"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("spotPriceLimits") != m.end() && !m["spotPriceLimits"].empty()) {
      if (typeid(vector<boost::any>) == m["spotPriceLimits"].type()) {
        vector<DescribeScalingGroupInstanceResponseBodyScalingConfigSpotPriceLimitsSpotPriceLimits> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["spotPriceLimits"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeScalingGroupInstanceResponseBodyScalingConfigSpotPriceLimitsSpotPriceLimits model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        spotPriceLimits = make_shared<vector<DescribeScalingGroupInstanceResponseBodyScalingConfigSpotPriceLimitsSpotPriceLimits>>(expect1);
      }
    }
  }


  virtual ~DescribeScalingGroupInstanceResponseBodyScalingConfigSpotPriceLimits() = default;
};
class DescribeScalingGroupInstanceResponseBodyScalingConfig : public Darabonba::Model {
public:
  shared_ptr<string> spotStrategy{};
  shared_ptr<string> payType{};
  shared_ptr<string> dataDiskCategory{};
  shared_ptr<long> dataDiskSize{};
  shared_ptr<long> dataDiskCount{};
  shared_ptr<string> sysDiskCategory{};
  shared_ptr<long> sysDiskSize{};
  shared_ptr<DescribeScalingGroupInstanceResponseBodyScalingConfigInstanceTypeList> instanceTypeList{};
  shared_ptr<DescribeScalingGroupInstanceResponseBodyScalingConfigSpotPriceLimits> spotPriceLimits{};

  DescribeScalingGroupInstanceResponseBodyScalingConfig() {}

  explicit DescribeScalingGroupInstanceResponseBodyScalingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (spotStrategy) {
      res["SpotStrategy"] = boost::any(*spotStrategy);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (dataDiskCategory) {
      res["DataDiskCategory"] = boost::any(*dataDiskCategory);
    }
    if (dataDiskSize) {
      res["DataDiskSize"] = boost::any(*dataDiskSize);
    }
    if (dataDiskCount) {
      res["DataDiskCount"] = boost::any(*dataDiskCount);
    }
    if (sysDiskCategory) {
      res["SysDiskCategory"] = boost::any(*sysDiskCategory);
    }
    if (sysDiskSize) {
      res["SysDiskSize"] = boost::any(*sysDiskSize);
    }
    if (instanceTypeList) {
      res["InstanceTypeList"] = instanceTypeList ? boost::any(instanceTypeList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (spotPriceLimits) {
      res["SpotPriceLimits"] = spotPriceLimits ? boost::any(spotPriceLimits->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SpotStrategy") != m.end() && !m["SpotStrategy"].empty()) {
      spotStrategy = make_shared<string>(boost::any_cast<string>(m["SpotStrategy"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("DataDiskCategory") != m.end() && !m["DataDiskCategory"].empty()) {
      dataDiskCategory = make_shared<string>(boost::any_cast<string>(m["DataDiskCategory"]));
    }
    if (m.find("DataDiskSize") != m.end() && !m["DataDiskSize"].empty()) {
      dataDiskSize = make_shared<long>(boost::any_cast<long>(m["DataDiskSize"]));
    }
    if (m.find("DataDiskCount") != m.end() && !m["DataDiskCount"].empty()) {
      dataDiskCount = make_shared<long>(boost::any_cast<long>(m["DataDiskCount"]));
    }
    if (m.find("SysDiskCategory") != m.end() && !m["SysDiskCategory"].empty()) {
      sysDiskCategory = make_shared<string>(boost::any_cast<string>(m["SysDiskCategory"]));
    }
    if (m.find("SysDiskSize") != m.end() && !m["SysDiskSize"].empty()) {
      sysDiskSize = make_shared<long>(boost::any_cast<long>(m["SysDiskSize"]));
    }
    if (m.find("InstanceTypeList") != m.end() && !m["InstanceTypeList"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceTypeList"].type()) {
        DescribeScalingGroupInstanceResponseBodyScalingConfigInstanceTypeList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceTypeList"]));
        instanceTypeList = make_shared<DescribeScalingGroupInstanceResponseBodyScalingConfigInstanceTypeList>(model1);
      }
    }
    if (m.find("SpotPriceLimits") != m.end() && !m["SpotPriceLimits"].empty()) {
      if (typeid(map<string, boost::any>) == m["SpotPriceLimits"].type()) {
        DescribeScalingGroupInstanceResponseBodyScalingConfigSpotPriceLimits model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SpotPriceLimits"]));
        spotPriceLimits = make_shared<DescribeScalingGroupInstanceResponseBodyScalingConfigSpotPriceLimits>(model1);
      }
    }
  }


  virtual ~DescribeScalingGroupInstanceResponseBodyScalingConfig() = default;
};
class DescribeScalingGroupInstanceResponseBodyScalingRuleListScalingRuleSchedulerTrigger : public Darabonba::Model {
public:
  shared_ptr<long> launchTime{};
  shared_ptr<long> launchExpirationTime{};
  shared_ptr<string> recurrenceType{};
  shared_ptr<string> recurrenceValue{};
  shared_ptr<long> recurrenceEndTime{};

  DescribeScalingGroupInstanceResponseBodyScalingRuleListScalingRuleSchedulerTrigger() {}

  explicit DescribeScalingGroupInstanceResponseBodyScalingRuleListScalingRuleSchedulerTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (launchTime) {
      res["LaunchTime"] = boost::any(*launchTime);
    }
    if (launchExpirationTime) {
      res["LaunchExpirationTime"] = boost::any(*launchExpirationTime);
    }
    if (recurrenceType) {
      res["RecurrenceType"] = boost::any(*recurrenceType);
    }
    if (recurrenceValue) {
      res["RecurrenceValue"] = boost::any(*recurrenceValue);
    }
    if (recurrenceEndTime) {
      res["RecurrenceEndTime"] = boost::any(*recurrenceEndTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LaunchTime") != m.end() && !m["LaunchTime"].empty()) {
      launchTime = make_shared<long>(boost::any_cast<long>(m["LaunchTime"]));
    }
    if (m.find("LaunchExpirationTime") != m.end() && !m["LaunchExpirationTime"].empty()) {
      launchExpirationTime = make_shared<long>(boost::any_cast<long>(m["LaunchExpirationTime"]));
    }
    if (m.find("RecurrenceType") != m.end() && !m["RecurrenceType"].empty()) {
      recurrenceType = make_shared<string>(boost::any_cast<string>(m["RecurrenceType"]));
    }
    if (m.find("RecurrenceValue") != m.end() && !m["RecurrenceValue"].empty()) {
      recurrenceValue = make_shared<string>(boost::any_cast<string>(m["RecurrenceValue"]));
    }
    if (m.find("RecurrenceEndTime") != m.end() && !m["RecurrenceEndTime"].empty()) {
      recurrenceEndTime = make_shared<long>(boost::any_cast<long>(m["RecurrenceEndTime"]));
    }
  }


  virtual ~DescribeScalingGroupInstanceResponseBodyScalingRuleListScalingRuleSchedulerTrigger() = default;
};
class DescribeScalingGroupInstanceResponseBodyScalingRuleListScalingRuleCloudWatchTrigger : public Darabonba::Model {
public:
  shared_ptr<string> metricName{};
  shared_ptr<long> period{};
  shared_ptr<string> statistics{};
  shared_ptr<string> comparisonOperator{};
  shared_ptr<string> threshold{};
  shared_ptr<string> evaluationCount{};
  shared_ptr<string> unit{};
  shared_ptr<string> metricDisplayName{};

  DescribeScalingGroupInstanceResponseBodyScalingRuleListScalingRuleCloudWatchTrigger() {}

  explicit DescribeScalingGroupInstanceResponseBodyScalingRuleListScalingRuleCloudWatchTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (comparisonOperator) {
      res["ComparisonOperator"] = boost::any(*comparisonOperator);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    if (evaluationCount) {
      res["EvaluationCount"] = boost::any(*evaluationCount);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (metricDisplayName) {
      res["MetricDisplayName"] = boost::any(*metricDisplayName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("ComparisonOperator") != m.end() && !m["ComparisonOperator"].empty()) {
      comparisonOperator = make_shared<string>(boost::any_cast<string>(m["ComparisonOperator"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<string>(boost::any_cast<string>(m["Threshold"]));
    }
    if (m.find("EvaluationCount") != m.end() && !m["EvaluationCount"].empty()) {
      evaluationCount = make_shared<string>(boost::any_cast<string>(m["EvaluationCount"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("MetricDisplayName") != m.end() && !m["MetricDisplayName"].empty()) {
      metricDisplayName = make_shared<string>(boost::any_cast<string>(m["MetricDisplayName"]));
    }
  }


  virtual ~DescribeScalingGroupInstanceResponseBodyScalingRuleListScalingRuleCloudWatchTrigger() = default;
};
class DescribeScalingGroupInstanceResponseBodyScalingRuleListScalingRule : public Darabonba::Model {
public:
  shared_ptr<string> ruleCategory{};
  shared_ptr<string> essScalingRuleId{};
  shared_ptr<long> scalingGroupId{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> adjustmentType{};
  shared_ptr<long> adjustmentValue{};
  shared_ptr<long> cooldown{};
  shared_ptr<string> status{};
  shared_ptr<string> launchTime{};
  shared_ptr<long> launchExpirationTime{};
  shared_ptr<string> recurrenceType{};
  shared_ptr<string> recurrenceValue{};
  shared_ptr<string> recurrenceEndTime{};
  shared_ptr<bool> withGrace{};
  shared_ptr<long> timeoutWithGrace{};
  shared_ptr<DescribeScalingGroupInstanceResponseBodyScalingRuleListScalingRuleSchedulerTrigger> schedulerTrigger{};
  shared_ptr<DescribeScalingGroupInstanceResponseBodyScalingRuleListScalingRuleCloudWatchTrigger> cloudWatchTrigger{};

  DescribeScalingGroupInstanceResponseBodyScalingRuleListScalingRule() {}

  explicit DescribeScalingGroupInstanceResponseBodyScalingRuleListScalingRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleCategory) {
      res["RuleCategory"] = boost::any(*ruleCategory);
    }
    if (essScalingRuleId) {
      res["EssScalingRuleId"] = boost::any(*essScalingRuleId);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (adjustmentType) {
      res["AdjustmentType"] = boost::any(*adjustmentType);
    }
    if (adjustmentValue) {
      res["AdjustmentValue"] = boost::any(*adjustmentValue);
    }
    if (cooldown) {
      res["Cooldown"] = boost::any(*cooldown);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (launchTime) {
      res["LaunchTime"] = boost::any(*launchTime);
    }
    if (launchExpirationTime) {
      res["LaunchExpirationTime"] = boost::any(*launchExpirationTime);
    }
    if (recurrenceType) {
      res["RecurrenceType"] = boost::any(*recurrenceType);
    }
    if (recurrenceValue) {
      res["RecurrenceValue"] = boost::any(*recurrenceValue);
    }
    if (recurrenceEndTime) {
      res["RecurrenceEndTime"] = boost::any(*recurrenceEndTime);
    }
    if (withGrace) {
      res["WithGrace"] = boost::any(*withGrace);
    }
    if (timeoutWithGrace) {
      res["TimeoutWithGrace"] = boost::any(*timeoutWithGrace);
    }
    if (schedulerTrigger) {
      res["SchedulerTrigger"] = schedulerTrigger ? boost::any(schedulerTrigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (cloudWatchTrigger) {
      res["CloudWatchTrigger"] = cloudWatchTrigger ? boost::any(cloudWatchTrigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RuleCategory") != m.end() && !m["RuleCategory"].empty()) {
      ruleCategory = make_shared<string>(boost::any_cast<string>(m["RuleCategory"]));
    }
    if (m.find("EssScalingRuleId") != m.end() && !m["EssScalingRuleId"].empty()) {
      essScalingRuleId = make_shared<string>(boost::any_cast<string>(m["EssScalingRuleId"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<long>(boost::any_cast<long>(m["ScalingGroupId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("AdjustmentType") != m.end() && !m["AdjustmentType"].empty()) {
      adjustmentType = make_shared<string>(boost::any_cast<string>(m["AdjustmentType"]));
    }
    if (m.find("AdjustmentValue") != m.end() && !m["AdjustmentValue"].empty()) {
      adjustmentValue = make_shared<long>(boost::any_cast<long>(m["AdjustmentValue"]));
    }
    if (m.find("Cooldown") != m.end() && !m["Cooldown"].empty()) {
      cooldown = make_shared<long>(boost::any_cast<long>(m["Cooldown"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("LaunchTime") != m.end() && !m["LaunchTime"].empty()) {
      launchTime = make_shared<string>(boost::any_cast<string>(m["LaunchTime"]));
    }
    if (m.find("LaunchExpirationTime") != m.end() && !m["LaunchExpirationTime"].empty()) {
      launchExpirationTime = make_shared<long>(boost::any_cast<long>(m["LaunchExpirationTime"]));
    }
    if (m.find("RecurrenceType") != m.end() && !m["RecurrenceType"].empty()) {
      recurrenceType = make_shared<string>(boost::any_cast<string>(m["RecurrenceType"]));
    }
    if (m.find("RecurrenceValue") != m.end() && !m["RecurrenceValue"].empty()) {
      recurrenceValue = make_shared<string>(boost::any_cast<string>(m["RecurrenceValue"]));
    }
    if (m.find("RecurrenceEndTime") != m.end() && !m["RecurrenceEndTime"].empty()) {
      recurrenceEndTime = make_shared<string>(boost::any_cast<string>(m["RecurrenceEndTime"]));
    }
    if (m.find("WithGrace") != m.end() && !m["WithGrace"].empty()) {
      withGrace = make_shared<bool>(boost::any_cast<bool>(m["WithGrace"]));
    }
    if (m.find("TimeoutWithGrace") != m.end() && !m["TimeoutWithGrace"].empty()) {
      timeoutWithGrace = make_shared<long>(boost::any_cast<long>(m["TimeoutWithGrace"]));
    }
    if (m.find("SchedulerTrigger") != m.end() && !m["SchedulerTrigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["SchedulerTrigger"].type()) {
        DescribeScalingGroupInstanceResponseBodyScalingRuleListScalingRuleSchedulerTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SchedulerTrigger"]));
        schedulerTrigger = make_shared<DescribeScalingGroupInstanceResponseBodyScalingRuleListScalingRuleSchedulerTrigger>(model1);
      }
    }
    if (m.find("CloudWatchTrigger") != m.end() && !m["CloudWatchTrigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["CloudWatchTrigger"].type()) {
        DescribeScalingGroupInstanceResponseBodyScalingRuleListScalingRuleCloudWatchTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CloudWatchTrigger"]));
        cloudWatchTrigger = make_shared<DescribeScalingGroupInstanceResponseBodyScalingRuleListScalingRuleCloudWatchTrigger>(model1);
      }
    }
  }


  virtual ~DescribeScalingGroupInstanceResponseBodyScalingRuleListScalingRule() = default;
};
class DescribeScalingGroupInstanceResponseBodyScalingRuleList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeScalingGroupInstanceResponseBodyScalingRuleListScalingRule>> scalingRule{};

  DescribeScalingGroupInstanceResponseBodyScalingRuleList() {}

  explicit DescribeScalingGroupInstanceResponseBodyScalingRuleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scalingRule) {
      vector<boost::any> temp1;
      for(auto item1:*scalingRule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScalingRule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ScalingRule") != m.end() && !m["ScalingRule"].empty()) {
      if (typeid(vector<boost::any>) == m["ScalingRule"].type()) {
        vector<DescribeScalingGroupInstanceResponseBodyScalingRuleListScalingRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScalingRule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeScalingGroupInstanceResponseBodyScalingRuleListScalingRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scalingRule = make_shared<vector<DescribeScalingGroupInstanceResponseBodyScalingRuleListScalingRule>>(expect1);
      }
    }
  }


  virtual ~DescribeScalingGroupInstanceResponseBodyScalingRuleList() = default;
};
class DescribeScalingGroupInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> hostGroupId{};
  shared_ptr<string> scalingGroupId{};
  shared_ptr<long> minSize{};
  shared_ptr<long> maxSize{};
  shared_ptr<long> defaultCooldown{};
  shared_ptr<string> activeRuleCategory{};
  shared_ptr<bool> withGrace{};
  shared_ptr<long> timeoutWithGrace{};
  shared_ptr<string> multiAvailablePolicy{};
  shared_ptr<string> multiAvailablePolicyParam{};
  shared_ptr<DescribeScalingGroupInstanceResponseBodyScalingConfig> scalingConfig{};
  shared_ptr<DescribeScalingGroupInstanceResponseBodyScalingRuleList> scalingRuleList{};

  DescribeScalingGroupInstanceResponseBody() {}

  explicit DescribeScalingGroupInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    if (minSize) {
      res["MinSize"] = boost::any(*minSize);
    }
    if (maxSize) {
      res["MaxSize"] = boost::any(*maxSize);
    }
    if (defaultCooldown) {
      res["DefaultCooldown"] = boost::any(*defaultCooldown);
    }
    if (activeRuleCategory) {
      res["ActiveRuleCategory"] = boost::any(*activeRuleCategory);
    }
    if (withGrace) {
      res["WithGrace"] = boost::any(*withGrace);
    }
    if (timeoutWithGrace) {
      res["TimeoutWithGrace"] = boost::any(*timeoutWithGrace);
    }
    if (multiAvailablePolicy) {
      res["MultiAvailablePolicy"] = boost::any(*multiAvailablePolicy);
    }
    if (multiAvailablePolicyParam) {
      res["MultiAvailablePolicyParam"] = boost::any(*multiAvailablePolicyParam);
    }
    if (scalingConfig) {
      res["ScalingConfig"] = scalingConfig ? boost::any(scalingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scalingRuleList) {
      res["ScalingRuleList"] = scalingRuleList ? boost::any(scalingRuleList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
    if (m.find("MinSize") != m.end() && !m["MinSize"].empty()) {
      minSize = make_shared<long>(boost::any_cast<long>(m["MinSize"]));
    }
    if (m.find("MaxSize") != m.end() && !m["MaxSize"].empty()) {
      maxSize = make_shared<long>(boost::any_cast<long>(m["MaxSize"]));
    }
    if (m.find("DefaultCooldown") != m.end() && !m["DefaultCooldown"].empty()) {
      defaultCooldown = make_shared<long>(boost::any_cast<long>(m["DefaultCooldown"]));
    }
    if (m.find("ActiveRuleCategory") != m.end() && !m["ActiveRuleCategory"].empty()) {
      activeRuleCategory = make_shared<string>(boost::any_cast<string>(m["ActiveRuleCategory"]));
    }
    if (m.find("WithGrace") != m.end() && !m["WithGrace"].empty()) {
      withGrace = make_shared<bool>(boost::any_cast<bool>(m["WithGrace"]));
    }
    if (m.find("TimeoutWithGrace") != m.end() && !m["TimeoutWithGrace"].empty()) {
      timeoutWithGrace = make_shared<long>(boost::any_cast<long>(m["TimeoutWithGrace"]));
    }
    if (m.find("MultiAvailablePolicy") != m.end() && !m["MultiAvailablePolicy"].empty()) {
      multiAvailablePolicy = make_shared<string>(boost::any_cast<string>(m["MultiAvailablePolicy"]));
    }
    if (m.find("MultiAvailablePolicyParam") != m.end() && !m["MultiAvailablePolicyParam"].empty()) {
      multiAvailablePolicyParam = make_shared<string>(boost::any_cast<string>(m["MultiAvailablePolicyParam"]));
    }
    if (m.find("ScalingConfig") != m.end() && !m["ScalingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScalingConfig"].type()) {
        DescribeScalingGroupInstanceResponseBodyScalingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScalingConfig"]));
        scalingConfig = make_shared<DescribeScalingGroupInstanceResponseBodyScalingConfig>(model1);
      }
    }
    if (m.find("ScalingRuleList") != m.end() && !m["ScalingRuleList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScalingRuleList"].type()) {
        DescribeScalingGroupInstanceResponseBodyScalingRuleList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScalingRuleList"]));
        scalingRuleList = make_shared<DescribeScalingGroupInstanceResponseBodyScalingRuleList>(model1);
      }
    }
  }


  virtual ~DescribeScalingGroupInstanceResponseBody() = default;
};
class DescribeScalingGroupInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeScalingGroupInstanceResponseBody> body{};

  DescribeScalingGroupInstanceResponse() {}

  explicit DescribeScalingGroupInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeScalingGroupInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeScalingGroupInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeScalingGroupInstanceResponse() = default;
};
class CreateClusterHostGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> hostGroupName{};
  shared_ptr<string> hostGroupType{};
  shared_ptr<string> comment{};
  shared_ptr<string> payType{};
  shared_ptr<string> vswitchId{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> hostGroupParams{};

  CreateClusterHostGroupRequest() {}

  explicit CreateClusterHostGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (hostGroupName) {
      res["HostGroupName"] = boost::any(*hostGroupName);
    }
    if (hostGroupType) {
      res["HostGroupType"] = boost::any(*hostGroupType);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (vswitchId) {
      res["VswitchId"] = boost::any(*vswitchId);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (hostGroupParams) {
      res["HostGroupParams"] = boost::any(*hostGroupParams);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("HostGroupName") != m.end() && !m["HostGroupName"].empty()) {
      hostGroupName = make_shared<string>(boost::any_cast<string>(m["HostGroupName"]));
    }
    if (m.find("HostGroupType") != m.end() && !m["HostGroupType"].empty()) {
      hostGroupType = make_shared<string>(boost::any_cast<string>(m["HostGroupType"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("VswitchId") != m.end() && !m["VswitchId"].empty()) {
      vswitchId = make_shared<string>(boost::any_cast<string>(m["VswitchId"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("HostGroupParams") != m.end() && !m["HostGroupParams"].empty()) {
      hostGroupParams = make_shared<string>(boost::any_cast<string>(m["HostGroupParams"]));
    }
  }


  virtual ~CreateClusterHostGroupRequest() = default;
};
class CreateClusterHostGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> hostGroupId{};

  CreateClusterHostGroupResponseBody() {}

  explicit CreateClusterHostGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
  }


  virtual ~CreateClusterHostGroupResponseBody() = default;
};
class CreateClusterHostGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateClusterHostGroupResponseBody> body{};

  CreateClusterHostGroupResponse() {}

  explicit CreateClusterHostGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateClusterHostGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateClusterHostGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateClusterHostGroupResponse() = default;
};
class DescribeClusterTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> bizId{};
  shared_ptr<string> resourceGroupId{};

  DescribeClusterTemplateRequest() {}

  explicit DescribeClusterTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~DescribeClusterTemplateRequest() = default;
};
class DescribeClusterTemplateResponseBodyTemplateInfoBootstrapActionListBootstrapAction : public Darabonba::Model {
public:
  shared_ptr<string> path{};
  shared_ptr<string> name{};
  shared_ptr<string> arg{};

  DescribeClusterTemplateResponseBodyTemplateInfoBootstrapActionListBootstrapAction() {}

  explicit DescribeClusterTemplateResponseBodyTemplateInfoBootstrapActionListBootstrapAction(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (arg) {
      res["Arg"] = boost::any(*arg);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Arg") != m.end() && !m["Arg"].empty()) {
      arg = make_shared<string>(boost::any_cast<string>(m["Arg"]));
    }
  }


  virtual ~DescribeClusterTemplateResponseBodyTemplateInfoBootstrapActionListBootstrapAction() = default;
};
class DescribeClusterTemplateResponseBodyTemplateInfoBootstrapActionList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeClusterTemplateResponseBodyTemplateInfoBootstrapActionListBootstrapAction>> bootstrapAction{};

  DescribeClusterTemplateResponseBodyTemplateInfoBootstrapActionList() {}

  explicit DescribeClusterTemplateResponseBodyTemplateInfoBootstrapActionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bootstrapAction) {
      vector<boost::any> temp1;
      for(auto item1:*bootstrapAction){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BootstrapAction"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BootstrapAction") != m.end() && !m["BootstrapAction"].empty()) {
      if (typeid(vector<boost::any>) == m["BootstrapAction"].type()) {
        vector<DescribeClusterTemplateResponseBodyTemplateInfoBootstrapActionListBootstrapAction> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BootstrapAction"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterTemplateResponseBodyTemplateInfoBootstrapActionListBootstrapAction model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bootstrapAction = make_shared<vector<DescribeClusterTemplateResponseBodyTemplateInfoBootstrapActionListBootstrapAction>>(expect1);
      }
    }
  }


  virtual ~DescribeClusterTemplateResponseBodyTemplateInfoBootstrapActionList() = default;
};
class DescribeClusterTemplateResponseBodyTemplateInfoHostGroupListHostGroup : public Darabonba::Model {
public:
  shared_ptr<long> sysDiskCapacity{};
  shared_ptr<string> hostGroupType{};
  shared_ptr<string> multiInstanceTypes{};
  shared_ptr<string> sysDiskType{};
  shared_ptr<string> chargeType{};
  shared_ptr<string> diskType{};
  shared_ptr<string> hostGroupId{};
  shared_ptr<string> instanceType{};
  shared_ptr<long> diskCount{};
  shared_ptr<string> period{};
  shared_ptr<long> diskCapacity{};
  shared_ptr<long> nodeCount{};
  shared_ptr<string> hostGroupName{};

  DescribeClusterTemplateResponseBodyTemplateInfoHostGroupListHostGroup() {}

  explicit DescribeClusterTemplateResponseBodyTemplateInfoHostGroupListHostGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sysDiskCapacity) {
      res["SysDiskCapacity"] = boost::any(*sysDiskCapacity);
    }
    if (hostGroupType) {
      res["HostGroupType"] = boost::any(*hostGroupType);
    }
    if (multiInstanceTypes) {
      res["MultiInstanceTypes"] = boost::any(*multiInstanceTypes);
    }
    if (sysDiskType) {
      res["SysDiskType"] = boost::any(*sysDiskType);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (diskType) {
      res["DiskType"] = boost::any(*diskType);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (diskCount) {
      res["DiskCount"] = boost::any(*diskCount);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (diskCapacity) {
      res["DiskCapacity"] = boost::any(*diskCapacity);
    }
    if (nodeCount) {
      res["NodeCount"] = boost::any(*nodeCount);
    }
    if (hostGroupName) {
      res["HostGroupName"] = boost::any(*hostGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SysDiskCapacity") != m.end() && !m["SysDiskCapacity"].empty()) {
      sysDiskCapacity = make_shared<long>(boost::any_cast<long>(m["SysDiskCapacity"]));
    }
    if (m.find("HostGroupType") != m.end() && !m["HostGroupType"].empty()) {
      hostGroupType = make_shared<string>(boost::any_cast<string>(m["HostGroupType"]));
    }
    if (m.find("MultiInstanceTypes") != m.end() && !m["MultiInstanceTypes"].empty()) {
      multiInstanceTypes = make_shared<string>(boost::any_cast<string>(m["MultiInstanceTypes"]));
    }
    if (m.find("SysDiskType") != m.end() && !m["SysDiskType"].empty()) {
      sysDiskType = make_shared<string>(boost::any_cast<string>(m["SysDiskType"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("DiskType") != m.end() && !m["DiskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["DiskType"]));
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("DiskCount") != m.end() && !m["DiskCount"].empty()) {
      diskCount = make_shared<long>(boost::any_cast<long>(m["DiskCount"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("DiskCapacity") != m.end() && !m["DiskCapacity"].empty()) {
      diskCapacity = make_shared<long>(boost::any_cast<long>(m["DiskCapacity"]));
    }
    if (m.find("NodeCount") != m.end() && !m["NodeCount"].empty()) {
      nodeCount = make_shared<long>(boost::any_cast<long>(m["NodeCount"]));
    }
    if (m.find("HostGroupName") != m.end() && !m["HostGroupName"].empty()) {
      hostGroupName = make_shared<string>(boost::any_cast<string>(m["HostGroupName"]));
    }
  }


  virtual ~DescribeClusterTemplateResponseBodyTemplateInfoHostGroupListHostGroup() = default;
};
class DescribeClusterTemplateResponseBodyTemplateInfoHostGroupList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeClusterTemplateResponseBodyTemplateInfoHostGroupListHostGroup>> hostGroup{};

  DescribeClusterTemplateResponseBodyTemplateInfoHostGroupList() {}

  explicit DescribeClusterTemplateResponseBodyTemplateInfoHostGroupList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostGroup) {
      vector<boost::any> temp1;
      for(auto item1:*hostGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HostGroup"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostGroup") != m.end() && !m["HostGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["HostGroup"].type()) {
        vector<DescribeClusterTemplateResponseBodyTemplateInfoHostGroupListHostGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HostGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterTemplateResponseBodyTemplateInfoHostGroupListHostGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hostGroup = make_shared<vector<DescribeClusterTemplateResponseBodyTemplateInfoHostGroupListHostGroup>>(expect1);
      }
    }
  }


  virtual ~DescribeClusterTemplateResponseBodyTemplateInfoHostGroupList() = default;
};
class DescribeClusterTemplateResponseBodyTemplateInfoConfigListConfig : public Darabonba::Model {
public:
  shared_ptr<string> configValue{};
  shared_ptr<string> replace{};
  shared_ptr<string> fileName{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> configKey{};
  shared_ptr<string> encrypt{};

  DescribeClusterTemplateResponseBodyTemplateInfoConfigListConfig() {}

  explicit DescribeClusterTemplateResponseBodyTemplateInfoConfigListConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configValue) {
      res["ConfigValue"] = boost::any(*configValue);
    }
    if (replace) {
      res["Replace"] = boost::any(*replace);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (configKey) {
      res["ConfigKey"] = boost::any(*configKey);
    }
    if (encrypt) {
      res["Encrypt"] = boost::any(*encrypt);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigValue") != m.end() && !m["ConfigValue"].empty()) {
      configValue = make_shared<string>(boost::any_cast<string>(m["ConfigValue"]));
    }
    if (m.find("Replace") != m.end() && !m["Replace"].empty()) {
      replace = make_shared<string>(boost::any_cast<string>(m["Replace"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("ConfigKey") != m.end() && !m["ConfigKey"].empty()) {
      configKey = make_shared<string>(boost::any_cast<string>(m["ConfigKey"]));
    }
    if (m.find("Encrypt") != m.end() && !m["Encrypt"].empty()) {
      encrypt = make_shared<string>(boost::any_cast<string>(m["Encrypt"]));
    }
  }


  virtual ~DescribeClusterTemplateResponseBodyTemplateInfoConfigListConfig() = default;
};
class DescribeClusterTemplateResponseBodyTemplateInfoConfigList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeClusterTemplateResponseBodyTemplateInfoConfigListConfig>> config{};

  DescribeClusterTemplateResponseBodyTemplateInfoConfigList() {}

  explicit DescribeClusterTemplateResponseBodyTemplateInfoConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      vector<boost::any> temp1;
      for(auto item1:*config){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Config"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      if (typeid(vector<boost::any>) == m["Config"].type()) {
        vector<DescribeClusterTemplateResponseBodyTemplateInfoConfigListConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Config"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterTemplateResponseBodyTemplateInfoConfigListConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        config = make_shared<vector<DescribeClusterTemplateResponseBodyTemplateInfoConfigListConfig>>(expect1);
      }
    }
  }


  virtual ~DescribeClusterTemplateResponseBodyTemplateInfoConfigList() = default;
};
class DescribeClusterTemplateResponseBodyTemplateInfoTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> tagValue{};
  shared_ptr<string> tagKey{};

  DescribeClusterTemplateResponseBodyTemplateInfoTagsTag() {}

  explicit DescribeClusterTemplateResponseBodyTemplateInfoTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
  }


  virtual ~DescribeClusterTemplateResponseBodyTemplateInfoTagsTag() = default;
};
class DescribeClusterTemplateResponseBodyTemplateInfoTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeClusterTemplateResponseBodyTemplateInfoTagsTag>> tag{};

  DescribeClusterTemplateResponseBodyTemplateInfoTags() {}

  explicit DescribeClusterTemplateResponseBodyTemplateInfoTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeClusterTemplateResponseBodyTemplateInfoTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterTemplateResponseBodyTemplateInfoTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeClusterTemplateResponseBodyTemplateInfoTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeClusterTemplateResponseBodyTemplateInfoTags() = default;
};
class DescribeClusterTemplateResponseBodyTemplateInfoSoftwareInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> softwareInfo{};

  DescribeClusterTemplateResponseBodyTemplateInfoSoftwareInfoList() {}

  explicit DescribeClusterTemplateResponseBodyTemplateInfoSoftwareInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (softwareInfo) {
      res["SoftwareInfo"] = boost::any(*softwareInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SoftwareInfo") != m.end() && !m["SoftwareInfo"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SoftwareInfo"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SoftwareInfo"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      softwareInfo = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeClusterTemplateResponseBodyTemplateInfoSoftwareInfoList() = default;
};
class DescribeClusterTemplateResponseBodyTemplateInfo : public Darabonba::Model {
public:
  shared_ptr<string> vpcId{};
  shared_ptr<string> keyPairName{};
  shared_ptr<bool> logEnable{};
  shared_ptr<bool> sshEnable{};
  shared_ptr<bool> highAvailabilityEnable{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> masterPwd{};
  shared_ptr<string> userId{};
  shared_ptr<bool> isOpenPublicIp{};
  shared_ptr<bool> allowNotebook{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> templateName{};
  shared_ptr<string> depositType{};
  shared_ptr<string> securityGroupName{};
  shared_ptr<string> createSource{};
  shared_ptr<string> instanceGeneration{};
  shared_ptr<bool> useCustomHiveMetaDb{};
  shared_ptr<bool> easEnable{};
  shared_ptr<string> userDefinedEmrEcsRole{};
  shared_ptr<string> metaStoreType{};
  shared_ptr<string> machineType{};
  shared_ptr<bool> useLocalMetaDb{};
  shared_ptr<long> masterNodeTotal{};
  shared_ptr<bool> initCustomHiveMetaDb{};
  shared_ptr<bool> ioOptimized{};
  shared_ptr<string> metaStoreConf{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> configurations{};
  shared_ptr<string> emrVer{};
  shared_ptr<string> logPath{};
  shared_ptr<string> clusterType{};
  shared_ptr<string> netType{};
  shared_ptr<string> zoneId{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<string> id{};
  shared_ptr<DescribeClusterTemplateResponseBodyTemplateInfoBootstrapActionList> bootstrapActionList{};
  shared_ptr<DescribeClusterTemplateResponseBodyTemplateInfoHostGroupList> hostGroupList{};
  shared_ptr<DescribeClusterTemplateResponseBodyTemplateInfoConfigList> configList{};
  shared_ptr<DescribeClusterTemplateResponseBodyTemplateInfoTags> tags{};
  shared_ptr<DescribeClusterTemplateResponseBodyTemplateInfoSoftwareInfoList> softwareInfoList{};

  DescribeClusterTemplateResponseBodyTemplateInfo() {}

  explicit DescribeClusterTemplateResponseBodyTemplateInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (logEnable) {
      res["LogEnable"] = boost::any(*logEnable);
    }
    if (sshEnable) {
      res["SshEnable"] = boost::any(*sshEnable);
    }
    if (highAvailabilityEnable) {
      res["HighAvailabilityEnable"] = boost::any(*highAvailabilityEnable);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (masterPwd) {
      res["MasterPwd"] = boost::any(*masterPwd);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (isOpenPublicIp) {
      res["IsOpenPublicIp"] = boost::any(*isOpenPublicIp);
    }
    if (allowNotebook) {
      res["AllowNotebook"] = boost::any(*allowNotebook);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (depositType) {
      res["DepositType"] = boost::any(*depositType);
    }
    if (securityGroupName) {
      res["SecurityGroupName"] = boost::any(*securityGroupName);
    }
    if (createSource) {
      res["CreateSource"] = boost::any(*createSource);
    }
    if (instanceGeneration) {
      res["InstanceGeneration"] = boost::any(*instanceGeneration);
    }
    if (useCustomHiveMetaDb) {
      res["UseCustomHiveMetaDb"] = boost::any(*useCustomHiveMetaDb);
    }
    if (easEnable) {
      res["EasEnable"] = boost::any(*easEnable);
    }
    if (userDefinedEmrEcsRole) {
      res["UserDefinedEmrEcsRole"] = boost::any(*userDefinedEmrEcsRole);
    }
    if (metaStoreType) {
      res["MetaStoreType"] = boost::any(*metaStoreType);
    }
    if (machineType) {
      res["MachineType"] = boost::any(*machineType);
    }
    if (useLocalMetaDb) {
      res["UseLocalMetaDb"] = boost::any(*useLocalMetaDb);
    }
    if (masterNodeTotal) {
      res["MasterNodeTotal"] = boost::any(*masterNodeTotal);
    }
    if (initCustomHiveMetaDb) {
      res["InitCustomHiveMetaDb"] = boost::any(*initCustomHiveMetaDb);
    }
    if (ioOptimized) {
      res["IoOptimized"] = boost::any(*ioOptimized);
    }
    if (metaStoreConf) {
      res["MetaStoreConf"] = boost::any(*metaStoreConf);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (configurations) {
      res["Configurations"] = boost::any(*configurations);
    }
    if (emrVer) {
      res["EmrVer"] = boost::any(*emrVer);
    }
    if (logPath) {
      res["LogPath"] = boost::any(*logPath);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (netType) {
      res["NetType"] = boost::any(*netType);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (bootstrapActionList) {
      res["BootstrapActionList"] = bootstrapActionList ? boost::any(bootstrapActionList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hostGroupList) {
      res["HostGroupList"] = hostGroupList ? boost::any(hostGroupList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (configList) {
      res["ConfigList"] = configList ? boost::any(configList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (softwareInfoList) {
      res["SoftwareInfoList"] = softwareInfoList ? boost::any(softwareInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("LogEnable") != m.end() && !m["LogEnable"].empty()) {
      logEnable = make_shared<bool>(boost::any_cast<bool>(m["LogEnable"]));
    }
    if (m.find("SshEnable") != m.end() && !m["SshEnable"].empty()) {
      sshEnable = make_shared<bool>(boost::any_cast<bool>(m["SshEnable"]));
    }
    if (m.find("HighAvailabilityEnable") != m.end() && !m["HighAvailabilityEnable"].empty()) {
      highAvailabilityEnable = make_shared<bool>(boost::any_cast<bool>(m["HighAvailabilityEnable"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("MasterPwd") != m.end() && !m["MasterPwd"].empty()) {
      masterPwd = make_shared<string>(boost::any_cast<string>(m["MasterPwd"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("IsOpenPublicIp") != m.end() && !m["IsOpenPublicIp"].empty()) {
      isOpenPublicIp = make_shared<bool>(boost::any_cast<bool>(m["IsOpenPublicIp"]));
    }
    if (m.find("AllowNotebook") != m.end() && !m["AllowNotebook"].empty()) {
      allowNotebook = make_shared<bool>(boost::any_cast<bool>(m["AllowNotebook"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("DepositType") != m.end() && !m["DepositType"].empty()) {
      depositType = make_shared<string>(boost::any_cast<string>(m["DepositType"]));
    }
    if (m.find("SecurityGroupName") != m.end() && !m["SecurityGroupName"].empty()) {
      securityGroupName = make_shared<string>(boost::any_cast<string>(m["SecurityGroupName"]));
    }
    if (m.find("CreateSource") != m.end() && !m["CreateSource"].empty()) {
      createSource = make_shared<string>(boost::any_cast<string>(m["CreateSource"]));
    }
    if (m.find("InstanceGeneration") != m.end() && !m["InstanceGeneration"].empty()) {
      instanceGeneration = make_shared<string>(boost::any_cast<string>(m["InstanceGeneration"]));
    }
    if (m.find("UseCustomHiveMetaDb") != m.end() && !m["UseCustomHiveMetaDb"].empty()) {
      useCustomHiveMetaDb = make_shared<bool>(boost::any_cast<bool>(m["UseCustomHiveMetaDb"]));
    }
    if (m.find("EasEnable") != m.end() && !m["EasEnable"].empty()) {
      easEnable = make_shared<bool>(boost::any_cast<bool>(m["EasEnable"]));
    }
    if (m.find("UserDefinedEmrEcsRole") != m.end() && !m["UserDefinedEmrEcsRole"].empty()) {
      userDefinedEmrEcsRole = make_shared<string>(boost::any_cast<string>(m["UserDefinedEmrEcsRole"]));
    }
    if (m.find("MetaStoreType") != m.end() && !m["MetaStoreType"].empty()) {
      metaStoreType = make_shared<string>(boost::any_cast<string>(m["MetaStoreType"]));
    }
    if (m.find("MachineType") != m.end() && !m["MachineType"].empty()) {
      machineType = make_shared<string>(boost::any_cast<string>(m["MachineType"]));
    }
    if (m.find("UseLocalMetaDb") != m.end() && !m["UseLocalMetaDb"].empty()) {
      useLocalMetaDb = make_shared<bool>(boost::any_cast<bool>(m["UseLocalMetaDb"]));
    }
    if (m.find("MasterNodeTotal") != m.end() && !m["MasterNodeTotal"].empty()) {
      masterNodeTotal = make_shared<long>(boost::any_cast<long>(m["MasterNodeTotal"]));
    }
    if (m.find("InitCustomHiveMetaDb") != m.end() && !m["InitCustomHiveMetaDb"].empty()) {
      initCustomHiveMetaDb = make_shared<bool>(boost::any_cast<bool>(m["InitCustomHiveMetaDb"]));
    }
    if (m.find("IoOptimized") != m.end() && !m["IoOptimized"].empty()) {
      ioOptimized = make_shared<bool>(boost::any_cast<bool>(m["IoOptimized"]));
    }
    if (m.find("MetaStoreConf") != m.end() && !m["MetaStoreConf"].empty()) {
      metaStoreConf = make_shared<string>(boost::any_cast<string>(m["MetaStoreConf"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("Configurations") != m.end() && !m["Configurations"].empty()) {
      configurations = make_shared<string>(boost::any_cast<string>(m["Configurations"]));
    }
    if (m.find("EmrVer") != m.end() && !m["EmrVer"].empty()) {
      emrVer = make_shared<string>(boost::any_cast<string>(m["EmrVer"]));
    }
    if (m.find("LogPath") != m.end() && !m["LogPath"].empty()) {
      logPath = make_shared<string>(boost::any_cast<string>(m["LogPath"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("NetType") != m.end() && !m["NetType"].empty()) {
      netType = make_shared<string>(boost::any_cast<string>(m["NetType"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("BootstrapActionList") != m.end() && !m["BootstrapActionList"].empty()) {
      if (typeid(map<string, boost::any>) == m["BootstrapActionList"].type()) {
        DescribeClusterTemplateResponseBodyTemplateInfoBootstrapActionList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BootstrapActionList"]));
        bootstrapActionList = make_shared<DescribeClusterTemplateResponseBodyTemplateInfoBootstrapActionList>(model1);
      }
    }
    if (m.find("HostGroupList") != m.end() && !m["HostGroupList"].empty()) {
      if (typeid(map<string, boost::any>) == m["HostGroupList"].type()) {
        DescribeClusterTemplateResponseBodyTemplateInfoHostGroupList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HostGroupList"]));
        hostGroupList = make_shared<DescribeClusterTemplateResponseBodyTemplateInfoHostGroupList>(model1);
      }
    }
    if (m.find("ConfigList") != m.end() && !m["ConfigList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConfigList"].type()) {
        DescribeClusterTemplateResponseBodyTemplateInfoConfigList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConfigList"]));
        configList = make_shared<DescribeClusterTemplateResponseBodyTemplateInfoConfigList>(model1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeClusterTemplateResponseBodyTemplateInfoTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeClusterTemplateResponseBodyTemplateInfoTags>(model1);
      }
    }
    if (m.find("SoftwareInfoList") != m.end() && !m["SoftwareInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SoftwareInfoList"].type()) {
        DescribeClusterTemplateResponseBodyTemplateInfoSoftwareInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SoftwareInfoList"]));
        softwareInfoList = make_shared<DescribeClusterTemplateResponseBodyTemplateInfoSoftwareInfoList>(model1);
      }
    }
  }


  virtual ~DescribeClusterTemplateResponseBodyTemplateInfo() = default;
};
class DescribeClusterTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeClusterTemplateResponseBodyTemplateInfo> templateInfo{};

  DescribeClusterTemplateResponseBody() {}

  explicit DescribeClusterTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templateInfo) {
      res["TemplateInfo"] = templateInfo ? boost::any(templateInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TemplateInfo") != m.end() && !m["TemplateInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["TemplateInfo"].type()) {
        DescribeClusterTemplateResponseBodyTemplateInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TemplateInfo"]));
        templateInfo = make_shared<DescribeClusterTemplateResponseBodyTemplateInfo>(model1);
      }
    }
  }


  virtual ~DescribeClusterTemplateResponseBody() = default;
};
class DescribeClusterTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeClusterTemplateResponseBody> body{};

  DescribeClusterTemplateResponse() {}

  explicit DescribeClusterTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeClusterTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeClusterTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeClusterTemplateResponse() = default;
};
class TagResourcesRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  TagResourcesRequestTags() {}

  explicit TagResourcesRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~TagResourcesRequestTags() = default;
};
class TagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<string>> resourceIds{};
  shared_ptr<vector<TagResourcesRequestTags>> tags{};

  TagResourcesRequest() {}

  explicit TagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (resourceIds) {
      res["ResourceIds"] = boost::any(*resourceIds);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("ResourceIds") != m.end() && !m["ResourceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<TagResourcesRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TagResourcesRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<TagResourcesRequestTags>>(expect1);
      }
    }
  }


  virtual ~TagResourcesRequest() = default;
};
class TagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};

  TagResourcesResponseBody() {}

  explicit TagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~TagResourcesResponseBody() = default;
};
class TagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<TagResourcesResponseBody> body{};

  TagResourcesResponse() {}

  explicit TagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~TagResourcesResponse() = default;
};
class CommitFlowEntitySnapshotRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> entityType{};
  shared_ptr<string> entityId{};
  shared_ptr<string> message{};

  CommitFlowEntitySnapshotRequest() {}

  explicit CommitFlowEntitySnapshotRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (entityType) {
      res["EntityType"] = boost::any(*entityType);
    }
    if (entityId) {
      res["EntityId"] = boost::any(*entityId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("EntityType") != m.end() && !m["EntityType"].empty()) {
      entityType = make_shared<string>(boost::any_cast<string>(m["EntityType"]));
    }
    if (m.find("EntityId") != m.end() && !m["EntityId"].empty()) {
      entityId = make_shared<string>(boost::any_cast<string>(m["EntityId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~CommitFlowEntitySnapshotRequest() = default;
};
class CommitFlowEntitySnapshotResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  CommitFlowEntitySnapshotResponseBody() {}

  explicit CommitFlowEntitySnapshotResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CommitFlowEntitySnapshotResponseBody() = default;
};
class CommitFlowEntitySnapshotResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CommitFlowEntitySnapshotResponseBody> body{};

  CommitFlowEntitySnapshotResponse() {}

  explicit CommitFlowEntitySnapshotResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CommitFlowEntitySnapshotResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CommitFlowEntitySnapshotResponseBody>(model1);
      }
    }
  }


  virtual ~CommitFlowEntitySnapshotResponse() = default;
};
class SubmitFlowJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> hostName{};
  shared_ptr<string> conf{};

  SubmitFlowJobRequest() {}

  explicit SubmitFlowJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (conf) {
      res["Conf"] = boost::any(*conf);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("Conf") != m.end() && !m["Conf"].empty()) {
      conf = make_shared<string>(boost::any_cast<string>(m["Conf"]));
    }
  }


  virtual ~SubmitFlowJobRequest() = default;
};
class SubmitFlowJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  SubmitFlowJobResponseBody() {}

  explicit SubmitFlowJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitFlowJobResponseBody() = default;
};
class SubmitFlowJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SubmitFlowJobResponseBody> body{};

  SubmitFlowJobResponse() {}

  explicit SubmitFlowJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitFlowJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitFlowJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitFlowJobResponse() = default;
};
class ListFlowJobHistoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> id{};
  shared_ptr<string> jobType{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> timeRange{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<string>> statusList{};

  ListFlowJobHistoryRequest() {}

  explicit ListFlowJobHistoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (jobType) {
      res["JobType"] = boost::any(*jobType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (timeRange) {
      res["TimeRange"] = boost::any(*timeRange);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (statusList) {
      res["StatusList"] = boost::any(*statusList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("JobType") != m.end() && !m["JobType"].empty()) {
      jobType = make_shared<string>(boost::any_cast<string>(m["JobType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TimeRange") != m.end() && !m["TimeRange"].empty()) {
      timeRange = make_shared<string>(boost::any_cast<string>(m["TimeRange"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StatusList") != m.end() && !m["StatusList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["StatusList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["StatusList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      statusList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListFlowJobHistoryRequest() = default;
};
class ListFlowJobHistoryResponseBodyNodeInstancesNodeInstance : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> status{};
  shared_ptr<bool> pending{};
  shared_ptr<string> envConf{};
  shared_ptr<long> retryInterval{};
  shared_ptr<string> projectId{};
  shared_ptr<string> jobType{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> externalInfo{};
  shared_ptr<string> externalStatus{};
  shared_ptr<string> jobName{};
  shared_ptr<string> externalId{};
  shared_ptr<long> maxRetry{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> failAct{};
  shared_ptr<string> jobParams{};
  shared_ptr<string> paramConf{};
  shared_ptr<string> hostName{};
  shared_ptr<long> retries{};
  shared_ptr<long> endTime{};
  shared_ptr<long> startTime{};
  shared_ptr<string> runConf{};
  shared_ptr<string> nodeName{};
  shared_ptr<string> jobId{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<string> id{};

  ListFlowJobHistoryResponseBodyNodeInstancesNodeInstance() {}

  explicit ListFlowJobHistoryResponseBodyNodeInstancesNodeInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (pending) {
      res["pending"] = boost::any(*pending);
    }
    if (envConf) {
      res["EnvConf"] = boost::any(*envConf);
    }
    if (retryInterval) {
      res["RetryInterval"] = boost::any(*retryInterval);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (jobType) {
      res["JobType"] = boost::any(*jobType);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (externalInfo) {
      res["ExternalInfo"] = boost::any(*externalInfo);
    }
    if (externalStatus) {
      res["ExternalStatus"] = boost::any(*externalStatus);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    if (externalId) {
      res["ExternalId"] = boost::any(*externalId);
    }
    if (maxRetry) {
      res["MaxRetry"] = boost::any(*maxRetry);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (failAct) {
      res["FailAct"] = boost::any(*failAct);
    }
    if (jobParams) {
      res["JobParams"] = boost::any(*jobParams);
    }
    if (paramConf) {
      res["ParamConf"] = boost::any(*paramConf);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (retries) {
      res["Retries"] = boost::any(*retries);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (runConf) {
      res["RunConf"] = boost::any(*runConf);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("pending") != m.end() && !m["pending"].empty()) {
      pending = make_shared<bool>(boost::any_cast<bool>(m["pending"]));
    }
    if (m.find("EnvConf") != m.end() && !m["EnvConf"].empty()) {
      envConf = make_shared<string>(boost::any_cast<string>(m["EnvConf"]));
    }
    if (m.find("RetryInterval") != m.end() && !m["RetryInterval"].empty()) {
      retryInterval = make_shared<long>(boost::any_cast<long>(m["RetryInterval"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("JobType") != m.end() && !m["JobType"].empty()) {
      jobType = make_shared<string>(boost::any_cast<string>(m["JobType"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("ExternalInfo") != m.end() && !m["ExternalInfo"].empty()) {
      externalInfo = make_shared<string>(boost::any_cast<string>(m["ExternalInfo"]));
    }
    if (m.find("ExternalStatus") != m.end() && !m["ExternalStatus"].empty()) {
      externalStatus = make_shared<string>(boost::any_cast<string>(m["ExternalStatus"]));
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
    if (m.find("ExternalId") != m.end() && !m["ExternalId"].empty()) {
      externalId = make_shared<string>(boost::any_cast<string>(m["ExternalId"]));
    }
    if (m.find("MaxRetry") != m.end() && !m["MaxRetry"].empty()) {
      maxRetry = make_shared<long>(boost::any_cast<long>(m["MaxRetry"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("FailAct") != m.end() && !m["FailAct"].empty()) {
      failAct = make_shared<string>(boost::any_cast<string>(m["FailAct"]));
    }
    if (m.find("JobParams") != m.end() && !m["JobParams"].empty()) {
      jobParams = make_shared<string>(boost::any_cast<string>(m["JobParams"]));
    }
    if (m.find("ParamConf") != m.end() && !m["ParamConf"].empty()) {
      paramConf = make_shared<string>(boost::any_cast<string>(m["ParamConf"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("Retries") != m.end() && !m["Retries"].empty()) {
      retries = make_shared<long>(boost::any_cast<long>(m["Retries"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("RunConf") != m.end() && !m["RunConf"].empty()) {
      runConf = make_shared<string>(boost::any_cast<string>(m["RunConf"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~ListFlowJobHistoryResponseBodyNodeInstancesNodeInstance() = default;
};
class ListFlowJobHistoryResponseBodyNodeInstances : public Darabonba::Model {
public:
  shared_ptr<vector<ListFlowJobHistoryResponseBodyNodeInstancesNodeInstance>> nodeInstance{};

  ListFlowJobHistoryResponseBodyNodeInstances() {}

  explicit ListFlowJobHistoryResponseBodyNodeInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeInstance) {
      vector<boost::any> temp1;
      for(auto item1:*nodeInstance){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NodeInstance"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeInstance") != m.end() && !m["NodeInstance"].empty()) {
      if (typeid(vector<boost::any>) == m["NodeInstance"].type()) {
        vector<ListFlowJobHistoryResponseBodyNodeInstancesNodeInstance> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NodeInstance"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFlowJobHistoryResponseBodyNodeInstancesNodeInstance model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodeInstance = make_shared<vector<ListFlowJobHistoryResponseBodyNodeInstancesNodeInstance>>(expect1);
      }
    }
  }


  virtual ~ListFlowJobHistoryResponseBodyNodeInstances() = default;
};
class ListFlowJobHistoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};
  shared_ptr<ListFlowJobHistoryResponseBodyNodeInstances> nodeInstances{};

  ListFlowJobHistoryResponseBody() {}

  explicit ListFlowJobHistoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (nodeInstances) {
      res["NodeInstances"] = nodeInstances ? boost::any(nodeInstances->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("NodeInstances") != m.end() && !m["NodeInstances"].empty()) {
      if (typeid(map<string, boost::any>) == m["NodeInstances"].type()) {
        ListFlowJobHistoryResponseBodyNodeInstances model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NodeInstances"]));
        nodeInstances = make_shared<ListFlowJobHistoryResponseBodyNodeInstances>(model1);
      }
    }
  }


  virtual ~ListFlowJobHistoryResponseBody() = default;
};
class ListFlowJobHistoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListFlowJobHistoryResponseBody> body{};

  ListFlowJobHistoryResponse() {}

  explicit ListFlowJobHistoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFlowJobHistoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFlowJobHistoryResponseBody>(model1);
      }
    }
  }


  virtual ~ListFlowJobHistoryResponse() = default;
};
class ListTagResourcesRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListTagResourcesRequestTags() {}

  explicit ListTagResourcesRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListTagResourcesRequestTags() = default;
};
class ListTagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<string>> resourceIds{};
  shared_ptr<vector<ListTagResourcesRequestTags>> tags{};
  shared_ptr<string> nextToken{};

  ListTagResourcesRequest() {}

  explicit ListTagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (resourceIds) {
      res["ResourceIds"] = boost::any(*resourceIds);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("ResourceIds") != m.end() && !m["ResourceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListTagResourcesRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagResourcesRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListTagResourcesRequestTags>>(expect1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
  }


  virtual ~ListTagResourcesRequest() = default;
};
class ListTagResourcesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> resourceId{};

  ListTagResourcesResponseBodyData() {}

  explicit ListTagResourcesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
  }


  virtual ~ListTagResourcesResponseBodyData() = default;
};
class ListTagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<ListTagResourcesResponseBodyData>> data{};

  ListTagResourcesResponseBody() {}

  explicit ListTagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListTagResourcesResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagResourcesResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListTagResourcesResponseBodyData>>(expect1);
      }
    }
  }


  virtual ~ListTagResourcesResponseBody() = default;
};
class ListTagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListTagResourcesResponseBody> body{};

  ListTagResourcesResponse() {}

  explicit ListTagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~ListTagResourcesResponse() = default;
};
class ListClusterHostComponentRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> hostInstanceId{};
  shared_ptr<string> hostName{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> componentName{};
  shared_ptr<string> componentStatus{};
  shared_ptr<string> hostRole{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListClusterHostComponentRequest() {}

  explicit ListClusterHostComponentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (hostInstanceId) {
      res["HostInstanceId"] = boost::any(*hostInstanceId);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (componentName) {
      res["ComponentName"] = boost::any(*componentName);
    }
    if (componentStatus) {
      res["ComponentStatus"] = boost::any(*componentStatus);
    }
    if (hostRole) {
      res["HostRole"] = boost::any(*hostRole);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("HostInstanceId") != m.end() && !m["HostInstanceId"].empty()) {
      hostInstanceId = make_shared<string>(boost::any_cast<string>(m["HostInstanceId"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("ComponentName") != m.end() && !m["ComponentName"].empty()) {
      componentName = make_shared<string>(boost::any_cast<string>(m["ComponentName"]));
    }
    if (m.find("ComponentStatus") != m.end() && !m["ComponentStatus"].empty()) {
      componentStatus = make_shared<string>(boost::any_cast<string>(m["ComponentStatus"]));
    }
    if (m.find("HostRole") != m.end() && !m["HostRole"].empty()) {
      hostRole = make_shared<string>(boost::any_cast<string>(m["HostRole"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListClusterHostComponentRequest() = default;
};
class ListClusterHostComponentResponseBodyComponentListComponent : public Darabonba::Model {
public:
  shared_ptr<string> serialNumber{};
  shared_ptr<string> status{};
  shared_ptr<string> serviceDisplayName{};
  shared_ptr<string> privateIp{};
  shared_ptr<string> serverStatus{};
  shared_ptr<string> componentName{};
  shared_ptr<string> commissionStatus{};
  shared_ptr<string> hostName{};
  shared_ptr<string> instanceType{};
  shared_ptr<bool> needRestart{};
  shared_ptr<string> hostId{};
  shared_ptr<string> hostInstanceId{};
  shared_ptr<long> cpu{};
  shared_ptr<string> componentDisplayName{};
  shared_ptr<string> publicIp{};
  shared_ptr<long> memory{};
  shared_ptr<string> role{};
  shared_ptr<string> serviceName{};

  ListClusterHostComponentResponseBodyComponentListComponent() {}

  explicit ListClusterHostComponentResponseBodyComponentListComponent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (serviceDisplayName) {
      res["ServiceDisplayName"] = boost::any(*serviceDisplayName);
    }
    if (privateIp) {
      res["PrivateIp"] = boost::any(*privateIp);
    }
    if (serverStatus) {
      res["ServerStatus"] = boost::any(*serverStatus);
    }
    if (componentName) {
      res["ComponentName"] = boost::any(*componentName);
    }
    if (commissionStatus) {
      res["CommissionStatus"] = boost::any(*commissionStatus);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (needRestart) {
      res["NeedRestart"] = boost::any(*needRestart);
    }
    if (hostId) {
      res["HostId"] = boost::any(*hostId);
    }
    if (hostInstanceId) {
      res["HostInstanceId"] = boost::any(*hostInstanceId);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (componentDisplayName) {
      res["ComponentDisplayName"] = boost::any(*componentDisplayName);
    }
    if (publicIp) {
      res["PublicIp"] = boost::any(*publicIp);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["SerialNumber"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("ServiceDisplayName") != m.end() && !m["ServiceDisplayName"].empty()) {
      serviceDisplayName = make_shared<string>(boost::any_cast<string>(m["ServiceDisplayName"]));
    }
    if (m.find("PrivateIp") != m.end() && !m["PrivateIp"].empty()) {
      privateIp = make_shared<string>(boost::any_cast<string>(m["PrivateIp"]));
    }
    if (m.find("ServerStatus") != m.end() && !m["ServerStatus"].empty()) {
      serverStatus = make_shared<string>(boost::any_cast<string>(m["ServerStatus"]));
    }
    if (m.find("ComponentName") != m.end() && !m["ComponentName"].empty()) {
      componentName = make_shared<string>(boost::any_cast<string>(m["ComponentName"]));
    }
    if (m.find("CommissionStatus") != m.end() && !m["CommissionStatus"].empty()) {
      commissionStatus = make_shared<string>(boost::any_cast<string>(m["CommissionStatus"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("NeedRestart") != m.end() && !m["NeedRestart"].empty()) {
      needRestart = make_shared<bool>(boost::any_cast<bool>(m["NeedRestart"]));
    }
    if (m.find("HostId") != m.end() && !m["HostId"].empty()) {
      hostId = make_shared<string>(boost::any_cast<string>(m["HostId"]));
    }
    if (m.find("HostInstanceId") != m.end() && !m["HostInstanceId"].empty()) {
      hostInstanceId = make_shared<string>(boost::any_cast<string>(m["HostInstanceId"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("ComponentDisplayName") != m.end() && !m["ComponentDisplayName"].empty()) {
      componentDisplayName = make_shared<string>(boost::any_cast<string>(m["ComponentDisplayName"]));
    }
    if (m.find("PublicIp") != m.end() && !m["PublicIp"].empty()) {
      publicIp = make_shared<string>(boost::any_cast<string>(m["PublicIp"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~ListClusterHostComponentResponseBodyComponentListComponent() = default;
};
class ListClusterHostComponentResponseBodyComponentList : public Darabonba::Model {
public:
  shared_ptr<vector<ListClusterHostComponentResponseBodyComponentListComponent>> component{};

  ListClusterHostComponentResponseBodyComponentList() {}

  explicit ListClusterHostComponentResponseBodyComponentList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (component) {
      vector<boost::any> temp1;
      for(auto item1:*component){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Component"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Component") != m.end() && !m["Component"].empty()) {
      if (typeid(vector<boost::any>) == m["Component"].type()) {
        vector<ListClusterHostComponentResponseBodyComponentListComponent> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Component"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClusterHostComponentResponseBodyComponentListComponent model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        component = make_shared<vector<ListClusterHostComponentResponseBodyComponentListComponent>>(expect1);
      }
    }
  }


  virtual ~ListClusterHostComponentResponseBodyComponentList() = default;
};
class ListClusterHostComponentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};
  shared_ptr<ListClusterHostComponentResponseBodyComponentList> componentList{};

  ListClusterHostComponentResponseBody() {}

  explicit ListClusterHostComponentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (componentList) {
      res["ComponentList"] = componentList ? boost::any(componentList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("ComponentList") != m.end() && !m["ComponentList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ComponentList"].type()) {
        ListClusterHostComponentResponseBodyComponentList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ComponentList"]));
        componentList = make_shared<ListClusterHostComponentResponseBodyComponentList>(model1);
      }
    }
  }


  virtual ~ListClusterHostComponentResponseBody() = default;
};
class ListClusterHostComponentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListClusterHostComponentResponseBody> body{};

  ListClusterHostComponentResponse() {}

  explicit ListClusterHostComponentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListClusterHostComponentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListClusterHostComponentResponseBody>(model1);
      }
    }
  }


  virtual ~ListClusterHostComponentResponse() = default;
};
class ModifyScalingGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};
  shared_ptr<string> scalingGroupBizId{};

  ModifyScalingGroupRequest() {}

  explicit ModifyScalingGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (scalingGroupBizId) {
      res["ScalingGroupBizId"] = boost::any(*scalingGroupBizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ScalingGroupBizId") != m.end() && !m["ScalingGroupBizId"].empty()) {
      scalingGroupBizId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupBizId"]));
    }
  }


  virtual ~ModifyScalingGroupRequest() = default;
};
class ModifyScalingGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> data{};

  ModifyScalingGroupResponseBody() {}

  explicit ModifyScalingGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
  }


  virtual ~ModifyScalingGroupResponseBody() = default;
};
class ModifyScalingGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyScalingGroupResponseBody> body{};

  ModifyScalingGroupResponse() {}

  explicit ModifyScalingGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyScalingGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyScalingGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyScalingGroupResponse() = default;
};
class DescribeFlowProjectClusterSettingRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> clusterId{};

  DescribeFlowProjectClusterSettingRequest() {}

  explicit DescribeFlowProjectClusterSettingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
  }


  virtual ~DescribeFlowProjectClusterSettingRequest() = default;
};
class DescribeFlowProjectClusterSettingResponseBodyQueueList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> queue{};

  DescribeFlowProjectClusterSettingResponseBodyQueueList() {}

  explicit DescribeFlowProjectClusterSettingResponseBodyQueueList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (queue) {
      res["Queue"] = boost::any(*queue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Queue") != m.end() && !m["Queue"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Queue"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Queue"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      queue = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeFlowProjectClusterSettingResponseBodyQueueList() = default;
};
class DescribeFlowProjectClusterSettingResponseBodyUserList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> user{};

  DescribeFlowProjectClusterSettingResponseBodyUserList() {}

  explicit DescribeFlowProjectClusterSettingResponseBodyUserList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (user) {
      res["User"] = boost::any(*user);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("User") != m.end() && !m["User"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["User"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["User"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      user = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeFlowProjectClusterSettingResponseBodyUserList() = default;
};
class DescribeFlowProjectClusterSettingResponseBodyHostList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> host{};

  DescribeFlowProjectClusterSettingResponseBodyHostList() {}

  explicit DescribeFlowProjectClusterSettingResponseBodyHostList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (host) {
      res["Host"] = boost::any(*host);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Host"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Host"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      host = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeFlowProjectClusterSettingResponseBodyHostList() = default;
};
class DescribeFlowProjectClusterSettingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> k8sClusterId{};
  shared_ptr<string> defaultQueue{};
  shared_ptr<string> projectId{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<string> defaultUser{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> clusterId{};
  shared_ptr<DescribeFlowProjectClusterSettingResponseBodyQueueList> queueList{};
  shared_ptr<DescribeFlowProjectClusterSettingResponseBodyUserList> userList{};
  shared_ptr<DescribeFlowProjectClusterSettingResponseBodyHostList> hostList{};

  DescribeFlowProjectClusterSettingResponseBody() {}

  explicit DescribeFlowProjectClusterSettingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (k8sClusterId) {
      res["K8sClusterId"] = boost::any(*k8sClusterId);
    }
    if (defaultQueue) {
      res["DefaultQueue"] = boost::any(*defaultQueue);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (defaultUser) {
      res["DefaultUser"] = boost::any(*defaultUser);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (queueList) {
      res["QueueList"] = queueList ? boost::any(queueList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userList) {
      res["UserList"] = userList ? boost::any(userList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hostList) {
      res["HostList"] = hostList ? boost::any(hostList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("K8sClusterId") != m.end() && !m["K8sClusterId"].empty()) {
      k8sClusterId = make_shared<string>(boost::any_cast<string>(m["K8sClusterId"]));
    }
    if (m.find("DefaultQueue") != m.end() && !m["DefaultQueue"].empty()) {
      defaultQueue = make_shared<string>(boost::any_cast<string>(m["DefaultQueue"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("DefaultUser") != m.end() && !m["DefaultUser"].empty()) {
      defaultUser = make_shared<string>(boost::any_cast<string>(m["DefaultUser"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("QueueList") != m.end() && !m["QueueList"].empty()) {
      if (typeid(map<string, boost::any>) == m["QueueList"].type()) {
        DescribeFlowProjectClusterSettingResponseBodyQueueList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["QueueList"]));
        queueList = make_shared<DescribeFlowProjectClusterSettingResponseBodyQueueList>(model1);
      }
    }
    if (m.find("UserList") != m.end() && !m["UserList"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserList"].type()) {
        DescribeFlowProjectClusterSettingResponseBodyUserList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserList"]));
        userList = make_shared<DescribeFlowProjectClusterSettingResponseBodyUserList>(model1);
      }
    }
    if (m.find("HostList") != m.end() && !m["HostList"].empty()) {
      if (typeid(map<string, boost::any>) == m["HostList"].type()) {
        DescribeFlowProjectClusterSettingResponseBodyHostList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HostList"]));
        hostList = make_shared<DescribeFlowProjectClusterSettingResponseBodyHostList>(model1);
      }
    }
  }


  virtual ~DescribeFlowProjectClusterSettingResponseBody() = default;
};
class DescribeFlowProjectClusterSettingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeFlowProjectClusterSettingResponseBody> body{};

  DescribeFlowProjectClusterSettingResponse() {}

  explicit DescribeFlowProjectClusterSettingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFlowProjectClusterSettingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFlowProjectClusterSettingResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFlowProjectClusterSettingResponse() = default;
};
class ListFlowProjectClusterSettingRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> projectId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListFlowProjectClusterSettingRequest() {}

  explicit ListFlowProjectClusterSettingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListFlowProjectClusterSettingRequest() = default;
};
class ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSettingQueueList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> queue{};

  ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSettingQueueList() {}

  explicit ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSettingQueueList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (queue) {
      res["Queue"] = boost::any(*queue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Queue") != m.end() && !m["Queue"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Queue"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Queue"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      queue = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSettingQueueList() = default;
};
class ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSettingUserList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> user{};

  ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSettingUserList() {}

  explicit ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSettingUserList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (user) {
      res["User"] = boost::any(*user);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("User") != m.end() && !m["User"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["User"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["User"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      user = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSettingUserList() = default;
};
class ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSettingHostList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> host{};

  ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSettingHostList() {}

  explicit ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSettingHostList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (host) {
      res["Host"] = boost::any(*host);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Host"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Host"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      host = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSettingHostList() = default;
};
class ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSetting : public Darabonba::Model {
public:
  shared_ptr<string> k8sClusterId{};
  shared_ptr<string> defaultQueue{};
  shared_ptr<string> projectId{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> defaultUser{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> clusterId{};
  shared_ptr<ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSettingQueueList> queueList{};
  shared_ptr<ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSettingUserList> userList{};
  shared_ptr<ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSettingHostList> hostList{};

  ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSetting() {}

  explicit ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSetting(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (k8sClusterId) {
      res["K8sClusterId"] = boost::any(*k8sClusterId);
    }
    if (defaultQueue) {
      res["DefaultQueue"] = boost::any(*defaultQueue);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (defaultUser) {
      res["DefaultUser"] = boost::any(*defaultUser);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (queueList) {
      res["QueueList"] = queueList ? boost::any(queueList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userList) {
      res["UserList"] = userList ? boost::any(userList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hostList) {
      res["HostList"] = hostList ? boost::any(hostList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("K8sClusterId") != m.end() && !m["K8sClusterId"].empty()) {
      k8sClusterId = make_shared<string>(boost::any_cast<string>(m["K8sClusterId"]));
    }
    if (m.find("DefaultQueue") != m.end() && !m["DefaultQueue"].empty()) {
      defaultQueue = make_shared<string>(boost::any_cast<string>(m["DefaultQueue"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("DefaultUser") != m.end() && !m["DefaultUser"].empty()) {
      defaultUser = make_shared<string>(boost::any_cast<string>(m["DefaultUser"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("QueueList") != m.end() && !m["QueueList"].empty()) {
      if (typeid(map<string, boost::any>) == m["QueueList"].type()) {
        ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSettingQueueList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["QueueList"]));
        queueList = make_shared<ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSettingQueueList>(model1);
      }
    }
    if (m.find("UserList") != m.end() && !m["UserList"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserList"].type()) {
        ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSettingUserList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserList"]));
        userList = make_shared<ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSettingUserList>(model1);
      }
    }
    if (m.find("HostList") != m.end() && !m["HostList"].empty()) {
      if (typeid(map<string, boost::any>) == m["HostList"].type()) {
        ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSettingHostList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HostList"]));
        hostList = make_shared<ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSettingHostList>(model1);
      }
    }
  }


  virtual ~ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSetting() = default;
};
class ListFlowProjectClusterSettingResponseBodyClusterSettings : public Darabonba::Model {
public:
  shared_ptr<vector<ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSetting>> clusterSetting{};

  ListFlowProjectClusterSettingResponseBodyClusterSettings() {}

  explicit ListFlowProjectClusterSettingResponseBodyClusterSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterSetting) {
      vector<boost::any> temp1;
      for(auto item1:*clusterSetting){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ClusterSetting"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterSetting") != m.end() && !m["ClusterSetting"].empty()) {
      if (typeid(vector<boost::any>) == m["ClusterSetting"].type()) {
        vector<ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSetting> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ClusterSetting"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSetting model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clusterSetting = make_shared<vector<ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSetting>>(expect1);
      }
    }
  }


  virtual ~ListFlowProjectClusterSettingResponseBodyClusterSettings() = default;
};
class ListFlowProjectClusterSettingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};
  shared_ptr<ListFlowProjectClusterSettingResponseBodyClusterSettings> clusterSettings{};

  ListFlowProjectClusterSettingResponseBody() {}

  explicit ListFlowProjectClusterSettingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (clusterSettings) {
      res["ClusterSettings"] = clusterSettings ? boost::any(clusterSettings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("ClusterSettings") != m.end() && !m["ClusterSettings"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClusterSettings"].type()) {
        ListFlowProjectClusterSettingResponseBodyClusterSettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClusterSettings"]));
        clusterSettings = make_shared<ListFlowProjectClusterSettingResponseBodyClusterSettings>(model1);
      }
    }
  }


  virtual ~ListFlowProjectClusterSettingResponseBody() = default;
};
class ListFlowProjectClusterSettingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListFlowProjectClusterSettingResponseBody> body{};

  ListFlowProjectClusterSettingResponse() {}

  explicit ListFlowProjectClusterSettingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFlowProjectClusterSettingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFlowProjectClusterSettingResponseBody>(model1);
      }
    }
  }


  virtual ~ListFlowProjectClusterSettingResponse() = default;
};
class SubmitFlowRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> flowId{};
  shared_ptr<string> conf{};

  SubmitFlowRequest() {}

  explicit SubmitFlowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (flowId) {
      res["FlowId"] = boost::any(*flowId);
    }
    if (conf) {
      res["Conf"] = boost::any(*conf);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("FlowId") != m.end() && !m["FlowId"].empty()) {
      flowId = make_shared<string>(boost::any_cast<string>(m["FlowId"]));
    }
    if (m.find("Conf") != m.end() && !m["Conf"].empty()) {
      conf = make_shared<string>(boost::any_cast<string>(m["Conf"]));
    }
  }


  virtual ~SubmitFlowRequest() = default;
};
class SubmitFlowResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> id{};

  SubmitFlowResponseBody() {}

  explicit SubmitFlowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~SubmitFlowResponseBody() = default;
};
class SubmitFlowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SubmitFlowResponseBody> body{};

  SubmitFlowResponse() {}

  explicit SubmitFlowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitFlowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitFlowResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitFlowResponse() = default;
};
class DescribeScalingCommonConfigRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};

  DescribeScalingCommonConfigRequest() {}

  explicit DescribeScalingCommonConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~DescribeScalingCommonConfigRequest() = default;
};
class DescribeScalingCommonConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> autoScalingHookHeartbeatDefaultTime{};
  shared_ptr<long> autoScalingCoolDownTime{};
  shared_ptr<long> autoScalingMNSScalingThreadSleepTime{};
  shared_ptr<long> autoScalingGroupMinSizeLimit{};
  shared_ptr<long> autoScalingGroupMaxSizeLimit{};
  shared_ptr<long> autoScalingRuleMinDelayLimit{};
  shared_ptr<long> autoScalingRuleAlarmDelayLimit{};
  shared_ptr<long> autoScalingRuleAlarmSilentTime{};
  shared_ptr<long> autoScalingConfigSystemDiskSize{};
  shared_ptr<long> autoScalingConfigDecommissionQueryInterval{};

  DescribeScalingCommonConfigResponseBody() {}

  explicit DescribeScalingCommonConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (autoScalingHookHeartbeatDefaultTime) {
      res["AutoScalingHookHeartbeatDefaultTime"] = boost::any(*autoScalingHookHeartbeatDefaultTime);
    }
    if (autoScalingCoolDownTime) {
      res["AutoScalingCoolDownTime"] = boost::any(*autoScalingCoolDownTime);
    }
    if (autoScalingMNSScalingThreadSleepTime) {
      res["AutoScalingMNSScalingThreadSleepTime"] = boost::any(*autoScalingMNSScalingThreadSleepTime);
    }
    if (autoScalingGroupMinSizeLimit) {
      res["AutoScalingGroupMinSizeLimit"] = boost::any(*autoScalingGroupMinSizeLimit);
    }
    if (autoScalingGroupMaxSizeLimit) {
      res["AutoScalingGroupMaxSizeLimit"] = boost::any(*autoScalingGroupMaxSizeLimit);
    }
    if (autoScalingRuleMinDelayLimit) {
      res["AutoScalingRuleMinDelayLimit"] = boost::any(*autoScalingRuleMinDelayLimit);
    }
    if (autoScalingRuleAlarmDelayLimit) {
      res["AutoScalingRuleAlarmDelayLimit"] = boost::any(*autoScalingRuleAlarmDelayLimit);
    }
    if (autoScalingRuleAlarmSilentTime) {
      res["AutoScalingRuleAlarmSilentTime"] = boost::any(*autoScalingRuleAlarmSilentTime);
    }
    if (autoScalingConfigSystemDiskSize) {
      res["AutoScalingConfigSystemDiskSize"] = boost::any(*autoScalingConfigSystemDiskSize);
    }
    if (autoScalingConfigDecommissionQueryInterval) {
      res["AutoScalingConfigDecommissionQueryInterval"] = boost::any(*autoScalingConfigDecommissionQueryInterval);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("AutoScalingHookHeartbeatDefaultTime") != m.end() && !m["AutoScalingHookHeartbeatDefaultTime"].empty()) {
      autoScalingHookHeartbeatDefaultTime = make_shared<long>(boost::any_cast<long>(m["AutoScalingHookHeartbeatDefaultTime"]));
    }
    if (m.find("AutoScalingCoolDownTime") != m.end() && !m["AutoScalingCoolDownTime"].empty()) {
      autoScalingCoolDownTime = make_shared<long>(boost::any_cast<long>(m["AutoScalingCoolDownTime"]));
    }
    if (m.find("AutoScalingMNSScalingThreadSleepTime") != m.end() && !m["AutoScalingMNSScalingThreadSleepTime"].empty()) {
      autoScalingMNSScalingThreadSleepTime = make_shared<long>(boost::any_cast<long>(m["AutoScalingMNSScalingThreadSleepTime"]));
    }
    if (m.find("AutoScalingGroupMinSizeLimit") != m.end() && !m["AutoScalingGroupMinSizeLimit"].empty()) {
      autoScalingGroupMinSizeLimit = make_shared<long>(boost::any_cast<long>(m["AutoScalingGroupMinSizeLimit"]));
    }
    if (m.find("AutoScalingGroupMaxSizeLimit") != m.end() && !m["AutoScalingGroupMaxSizeLimit"].empty()) {
      autoScalingGroupMaxSizeLimit = make_shared<long>(boost::any_cast<long>(m["AutoScalingGroupMaxSizeLimit"]));
    }
    if (m.find("AutoScalingRuleMinDelayLimit") != m.end() && !m["AutoScalingRuleMinDelayLimit"].empty()) {
      autoScalingRuleMinDelayLimit = make_shared<long>(boost::any_cast<long>(m["AutoScalingRuleMinDelayLimit"]));
    }
    if (m.find("AutoScalingRuleAlarmDelayLimit") != m.end() && !m["AutoScalingRuleAlarmDelayLimit"].empty()) {
      autoScalingRuleAlarmDelayLimit = make_shared<long>(boost::any_cast<long>(m["AutoScalingRuleAlarmDelayLimit"]));
    }
    if (m.find("AutoScalingRuleAlarmSilentTime") != m.end() && !m["AutoScalingRuleAlarmSilentTime"].empty()) {
      autoScalingRuleAlarmSilentTime = make_shared<long>(boost::any_cast<long>(m["AutoScalingRuleAlarmSilentTime"]));
    }
    if (m.find("AutoScalingConfigSystemDiskSize") != m.end() && !m["AutoScalingConfigSystemDiskSize"].empty()) {
      autoScalingConfigSystemDiskSize = make_shared<long>(boost::any_cast<long>(m["AutoScalingConfigSystemDiskSize"]));
    }
    if (m.find("AutoScalingConfigDecommissionQueryInterval") != m.end() && !m["AutoScalingConfigDecommissionQueryInterval"].empty()) {
      autoScalingConfigDecommissionQueryInterval = make_shared<long>(boost::any_cast<long>(m["AutoScalingConfigDecommissionQueryInterval"]));
    }
  }


  virtual ~DescribeScalingCommonConfigResponseBody() = default;
};
class DescribeScalingCommonConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeScalingCommonConfigResponseBody> body{};

  DescribeScalingCommonConfigResponse() {}

  explicit DescribeScalingCommonConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeScalingCommonConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeScalingCommonConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeScalingCommonConfigResponse() = default;
};
class ResumeFlowRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> flowInstanceId{};

  ResumeFlowRequest() {}

  explicit ResumeFlowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (flowInstanceId) {
      res["FlowInstanceId"] = boost::any(*flowInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("FlowInstanceId") != m.end() && !m["FlowInstanceId"].empty()) {
      flowInstanceId = make_shared<string>(boost::any_cast<string>(m["FlowInstanceId"]));
    }
  }


  virtual ~ResumeFlowRequest() = default;
};
class ResumeFlowResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  ResumeFlowResponseBody() {}

  explicit ResumeFlowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ResumeFlowResponseBody() = default;
};
class ResumeFlowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ResumeFlowResponseBody> body{};

  ResumeFlowResponse() {}

  explicit ResumeFlowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResumeFlowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResumeFlowResponseBody>(model1);
      }
    }
  }


  virtual ~ResumeFlowResponse() = default;
};
class RestoreFlowEntitySnapshotRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> operatorId{};
  shared_ptr<string> entityType{};
  shared_ptr<string> entityId{};
  shared_ptr<string> revision{};

  RestoreFlowEntitySnapshotRequest() {}

  explicit RestoreFlowEntitySnapshotRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (operatorId) {
      res["OperatorId"] = boost::any(*operatorId);
    }
    if (entityType) {
      res["EntityType"] = boost::any(*entityType);
    }
    if (entityId) {
      res["EntityId"] = boost::any(*entityId);
    }
    if (revision) {
      res["Revision"] = boost::any(*revision);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("OperatorId") != m.end() && !m["OperatorId"].empty()) {
      operatorId = make_shared<string>(boost::any_cast<string>(m["OperatorId"]));
    }
    if (m.find("EntityType") != m.end() && !m["EntityType"].empty()) {
      entityType = make_shared<string>(boost::any_cast<string>(m["EntityType"]));
    }
    if (m.find("EntityId") != m.end() && !m["EntityId"].empty()) {
      entityId = make_shared<string>(boost::any_cast<string>(m["EntityId"]));
    }
    if (m.find("Revision") != m.end() && !m["Revision"].empty()) {
      revision = make_shared<string>(boost::any_cast<string>(m["Revision"]));
    }
  }


  virtual ~RestoreFlowEntitySnapshotRequest() = default;
};
class RestoreFlowEntitySnapshotResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  RestoreFlowEntitySnapshotResponseBody() {}

  explicit RestoreFlowEntitySnapshotResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RestoreFlowEntitySnapshotResponseBody() = default;
};
class RestoreFlowEntitySnapshotResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RestoreFlowEntitySnapshotResponseBody> body{};

  RestoreFlowEntitySnapshotResponse() {}

  explicit RestoreFlowEntitySnapshotResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RestoreFlowEntitySnapshotResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RestoreFlowEntitySnapshotResponseBody>(model1);
      }
    }
  }


  virtual ~RestoreFlowEntitySnapshotResponse() = default;
};
class CreateLibraryRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> type{};
  shared_ptr<string> name{};
  shared_ptr<string> libraryVersion{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> sourceLocation{};
  shared_ptr<string> scope{};
  shared_ptr<string> properties{};

  CreateLibraryRequest() {}

  explicit CreateLibraryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (libraryVersion) {
      res["LibraryVersion"] = boost::any(*libraryVersion);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (sourceLocation) {
      res["SourceLocation"] = boost::any(*sourceLocation);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (properties) {
      res["Properties"] = boost::any(*properties);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("LibraryVersion") != m.end() && !m["LibraryVersion"].empty()) {
      libraryVersion = make_shared<string>(boost::any_cast<string>(m["LibraryVersion"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("SourceLocation") != m.end() && !m["SourceLocation"].empty()) {
      sourceLocation = make_shared<string>(boost::any_cast<string>(m["SourceLocation"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("Properties") != m.end() && !m["Properties"].empty()) {
      properties = make_shared<string>(boost::any_cast<string>(m["Properties"]));
    }
  }


  virtual ~CreateLibraryRequest() = default;
};
class CreateLibraryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  CreateLibraryResponseBody() {}

  explicit CreateLibraryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateLibraryResponseBody() = default;
};
class CreateLibraryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateLibraryResponseBody> body{};

  CreateLibraryResponse() {}

  explicit CreateLibraryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateLibraryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateLibraryResponseBody>(model1);
      }
    }
  }


  virtual ~CreateLibraryResponse() = default;
};
class ListVswitchRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> depositType{};
  shared_ptr<string> productType{};

  ListVswitchRequest() {}

  explicit ListVswitchRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (depositType) {
      res["DepositType"] = boost::any(*depositType);
    }
    if (productType) {
      res["ProductType"] = boost::any(*productType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("DepositType") != m.end() && !m["DepositType"].empty()) {
      depositType = make_shared<string>(boost::any_cast<string>(m["DepositType"]));
    }
    if (m.find("ProductType") != m.end() && !m["ProductType"].empty()) {
      productType = make_shared<string>(boost::any_cast<string>(m["ProductType"]));
    }
  }


  virtual ~ListVswitchRequest() = default;
};
class ListVswitchResponseBodyVswitchListVswitch : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> status{};
  shared_ptr<string> vpcId{};
  shared_ptr<bool> isDefault{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> cidrBlock{};
  shared_ptr<string> description{};
  shared_ptr<string> availableIpAddressCount{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> vSwitchName{};

  ListVswitchResponseBodyVswitchListVswitch() {}

  explicit ListVswitchResponseBodyVswitchListVswitch(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (availableIpAddressCount) {
      res["AvailableIpAddressCount"] = boost::any(*availableIpAddressCount);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (vSwitchName) {
      res["VSwitchName"] = boost::any(*vSwitchName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<bool>(boost::any_cast<bool>(m["IsDefault"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("AvailableIpAddressCount") != m.end() && !m["AvailableIpAddressCount"].empty()) {
      availableIpAddressCount = make_shared<string>(boost::any_cast<string>(m["AvailableIpAddressCount"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("VSwitchName") != m.end() && !m["VSwitchName"].empty()) {
      vSwitchName = make_shared<string>(boost::any_cast<string>(m["VSwitchName"]));
    }
  }


  virtual ~ListVswitchResponseBodyVswitchListVswitch() = default;
};
class ListVswitchResponseBodyVswitchList : public Darabonba::Model {
public:
  shared_ptr<vector<ListVswitchResponseBodyVswitchListVswitch>> vswitch{};

  ListVswitchResponseBodyVswitchList() {}

  explicit ListVswitchResponseBodyVswitchList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vswitch) {
      vector<boost::any> temp1;
      for(auto item1:*vswitch){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Vswitch"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Vswitch") != m.end() && !m["Vswitch"].empty()) {
      if (typeid(vector<boost::any>) == m["Vswitch"].type()) {
        vector<ListVswitchResponseBodyVswitchListVswitch> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Vswitch"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListVswitchResponseBodyVswitchListVswitch model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        vswitch = make_shared<vector<ListVswitchResponseBodyVswitchListVswitch>>(expect1);
      }
    }
  }


  virtual ~ListVswitchResponseBodyVswitchList() = default;
};
class ListVswitchResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListVswitchResponseBodyVswitchList> vswitchList{};

  ListVswitchResponseBody() {}

  explicit ListVswitchResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (vswitchList) {
      res["VswitchList"] = vswitchList ? boost::any(vswitchList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VswitchList") != m.end() && !m["VswitchList"].empty()) {
      if (typeid(map<string, boost::any>) == m["VswitchList"].type()) {
        ListVswitchResponseBodyVswitchList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VswitchList"]));
        vswitchList = make_shared<ListVswitchResponseBodyVswitchList>(model1);
      }
    }
  }


  virtual ~ListVswitchResponseBody() = default;
};
class ListVswitchResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListVswitchResponseBody> body{};

  ListVswitchResponse() {}

  explicit ListVswitchResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListVswitchResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListVswitchResponseBody>(model1);
      }
    }
  }


  virtual ~ListVswitchResponse() = default;
};
class DeleteFlowProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> projectId{};

  DeleteFlowProjectRequest() {}

  explicit DeleteFlowProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~DeleteFlowProjectRequest() = default;
};
class DeleteFlowProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  DeleteFlowProjectResponseBody() {}

  explicit DeleteFlowProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteFlowProjectResponseBody() = default;
};
class DeleteFlowProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteFlowProjectResponseBody> body{};

  DeleteFlowProjectResponse() {}

  explicit DeleteFlowProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteFlowProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteFlowProjectResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteFlowProjectResponse() = default;
};
class ReleaseClusterRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> id{};
  shared_ptr<bool> forceRelease{};

  ReleaseClusterRequest() {}

  explicit ReleaseClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (forceRelease) {
      res["ForceRelease"] = boost::any(*forceRelease);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ForceRelease") != m.end() && !m["ForceRelease"].empty()) {
      forceRelease = make_shared<bool>(boost::any_cast<bool>(m["ForceRelease"]));
    }
  }


  virtual ~ReleaseClusterRequest() = default;
};
class ReleaseClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ReleaseClusterResponseBody() {}

  explicit ReleaseClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ReleaseClusterResponseBody() = default;
};
class ReleaseClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ReleaseClusterResponseBody> body{};

  ReleaseClusterResponse() {}

  explicit ReleaseClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReleaseClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReleaseClusterResponseBody>(model1);
      }
    }
  }


  virtual ~ReleaseClusterResponse() = default;
};
class AddScalingConfigItemRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> scalingGroupBizId{};
  shared_ptr<string> configItemType{};
  shared_ptr<string> configItemInformation{};

  AddScalingConfigItemRequest() {}

  explicit AddScalingConfigItemRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (scalingGroupBizId) {
      res["ScalingGroupBizId"] = boost::any(*scalingGroupBizId);
    }
    if (configItemType) {
      res["ConfigItemType"] = boost::any(*configItemType);
    }
    if (configItemInformation) {
      res["ConfigItemInformation"] = boost::any(*configItemInformation);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ScalingGroupBizId") != m.end() && !m["ScalingGroupBizId"].empty()) {
      scalingGroupBizId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupBizId"]));
    }
    if (m.find("ConfigItemType") != m.end() && !m["ConfigItemType"].empty()) {
      configItemType = make_shared<string>(boost::any_cast<string>(m["ConfigItemType"]));
    }
    if (m.find("ConfigItemInformation") != m.end() && !m["ConfigItemInformation"].empty()) {
      configItemInformation = make_shared<string>(boost::any_cast<string>(m["ConfigItemInformation"]));
    }
  }


  virtual ~AddScalingConfigItemRequest() = default;
};
class AddScalingConfigItemResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> data{};

  AddScalingConfigItemResponseBody() {}

  explicit AddScalingConfigItemResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
  }


  virtual ~AddScalingConfigItemResponseBody() = default;
};
class AddScalingConfigItemResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AddScalingConfigItemResponseBody> body{};

  AddScalingConfigItemResponse() {}

  explicit AddScalingConfigItemResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddScalingConfigItemResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddScalingConfigItemResponseBody>(model1);
      }
    }
  }


  virtual ~AddScalingConfigItemResponse() = default;
};
class ResetUserPasswordRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> type{};
  shared_ptr<string> oldPassword{};
  shared_ptr<string> password{};
  shared_ptr<string> userName{};

  ResetUserPasswordRequest() {}

  explicit ResetUserPasswordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (oldPassword) {
      res["OldPassword"] = boost::any(*oldPassword);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("OldPassword") != m.end() && !m["OldPassword"].empty()) {
      oldPassword = make_shared<string>(boost::any_cast<string>(m["OldPassword"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~ResetUserPasswordRequest() = default;
};
class ResetUserPasswordResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ResetUserPasswordResponseBody() {}

  explicit ResetUserPasswordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ResetUserPasswordResponseBody() = default;
};
class ResetUserPasswordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ResetUserPasswordResponseBody> body{};

  ResetUserPasswordResponse() {}

  explicit ResetUserPasswordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResetUserPasswordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResetUserPasswordResponseBody>(model1);
      }
    }
  }


  virtual ~ResetUserPasswordResponse() = default;
};
class ListFlowClusterAllHostsRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> resourceGroupId{};

  ListFlowClusterAllHostsRequest() {}

  explicit ListFlowClusterAllHostsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ListFlowClusterAllHostsRequest() = default;
};
class ListFlowClusterAllHostsResponseBodyHostListHost : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> type{};
  shared_ptr<string> serialNumber{};
  shared_ptr<string> privateIp{};
  shared_ptr<string> hostName{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> hostId{};
  shared_ptr<string> hostInstanceId{};
  shared_ptr<long> cpu{};
  shared_ptr<string> publicIp{};
  shared_ptr<long> memory{};
  shared_ptr<string> role{};

  ListFlowClusterAllHostsResponseBodyHostListHost() {}

  explicit ListFlowClusterAllHostsResponseBodyHostListHost(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    if (privateIp) {
      res["PrivateIp"] = boost::any(*privateIp);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (hostId) {
      res["HostId"] = boost::any(*hostId);
    }
    if (hostInstanceId) {
      res["HostInstanceId"] = boost::any(*hostInstanceId);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (publicIp) {
      res["PublicIp"] = boost::any(*publicIp);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["SerialNumber"]));
    }
    if (m.find("PrivateIp") != m.end() && !m["PrivateIp"].empty()) {
      privateIp = make_shared<string>(boost::any_cast<string>(m["PrivateIp"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("HostId") != m.end() && !m["HostId"].empty()) {
      hostId = make_shared<string>(boost::any_cast<string>(m["HostId"]));
    }
    if (m.find("HostInstanceId") != m.end() && !m["HostInstanceId"].empty()) {
      hostInstanceId = make_shared<string>(boost::any_cast<string>(m["HostInstanceId"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("PublicIp") != m.end() && !m["PublicIp"].empty()) {
      publicIp = make_shared<string>(boost::any_cast<string>(m["PublicIp"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
  }


  virtual ~ListFlowClusterAllHostsResponseBodyHostListHost() = default;
};
class ListFlowClusterAllHostsResponseBodyHostList : public Darabonba::Model {
public:
  shared_ptr<vector<ListFlowClusterAllHostsResponseBodyHostListHost>> host{};

  ListFlowClusterAllHostsResponseBodyHostList() {}

  explicit ListFlowClusterAllHostsResponseBodyHostList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (host) {
      vector<boost::any> temp1;
      for(auto item1:*host){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Host"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      if (typeid(vector<boost::any>) == m["Host"].type()) {
        vector<ListFlowClusterAllHostsResponseBodyHostListHost> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Host"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFlowClusterAllHostsResponseBodyHostListHost model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        host = make_shared<vector<ListFlowClusterAllHostsResponseBodyHostListHost>>(expect1);
      }
    }
  }


  virtual ~ListFlowClusterAllHostsResponseBodyHostList() = default;
};
class ListFlowClusterAllHostsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListFlowClusterAllHostsResponseBodyHostList> hostList{};

  ListFlowClusterAllHostsResponseBody() {}

  explicit ListFlowClusterAllHostsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (hostList) {
      res["HostList"] = hostList ? boost::any(hostList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HostList") != m.end() && !m["HostList"].empty()) {
      if (typeid(map<string, boost::any>) == m["HostList"].type()) {
        ListFlowClusterAllHostsResponseBodyHostList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HostList"]));
        hostList = make_shared<ListFlowClusterAllHostsResponseBodyHostList>(model1);
      }
    }
  }


  virtual ~ListFlowClusterAllHostsResponseBody() = default;
};
class ListFlowClusterAllHostsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListFlowClusterAllHostsResponseBody> body{};

  ListFlowClusterAllHostsResponse() {}

  explicit ListFlowClusterAllHostsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFlowClusterAllHostsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFlowClusterAllHostsResponseBody>(model1);
      }
    }
  }


  virtual ~ListFlowClusterAllHostsResponse() = default;
};
class DeleteLibrariesRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> libraryBizIdList{};

  DeleteLibrariesRequest() {}

  explicit DeleteLibrariesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (libraryBizIdList) {
      res["LibraryBizIdList"] = boost::any(*libraryBizIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("LibraryBizIdList") != m.end() && !m["LibraryBizIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LibraryBizIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LibraryBizIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      libraryBizIdList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DeleteLibrariesRequest() = default;
};
class DeleteLibrariesResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  DeleteLibrariesResponseBody() {}

  explicit DeleteLibrariesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLibrariesResponseBody() = default;
};
class DeleteLibrariesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteLibrariesResponseBody> body{};

  DeleteLibrariesResponse() {}

  explicit DeleteLibrariesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLibrariesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLibrariesResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLibrariesResponse() = default;
};
class DescribeFlowCategoryTreeRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> type{};
  shared_ptr<string> mode{};
  shared_ptr<string> keyword{};
  shared_ptr<string> categoryId{};

  DescribeFlowCategoryTreeRequest() {}

  explicit DescribeFlowCategoryTreeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<string>(boost::any_cast<string>(m["CategoryId"]));
    }
  }


  virtual ~DescribeFlowCategoryTreeRequest() = default;
};
class DescribeFlowCategoryTreeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  DescribeFlowCategoryTreeResponseBody() {}

  explicit DescribeFlowCategoryTreeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeFlowCategoryTreeResponseBody() = default;
};
class DescribeFlowCategoryTreeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeFlowCategoryTreeResponseBody> body{};

  DescribeFlowCategoryTreeResponse() {}

  explicit DescribeFlowCategoryTreeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFlowCategoryTreeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFlowCategoryTreeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFlowCategoryTreeResponse() = default;
};
class ListDatasourceInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> targetClusterId{};
  shared_ptr<string> datasourceType{};

  ListDatasourceInstancesRequest() {}

  explicit ListDatasourceInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (targetClusterId) {
      res["TargetClusterId"] = boost::any(*targetClusterId);
    }
    if (datasourceType) {
      res["DatasourceType"] = boost::any(*datasourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TargetClusterId") != m.end() && !m["TargetClusterId"].empty()) {
      targetClusterId = make_shared<string>(boost::any_cast<string>(m["TargetClusterId"]));
    }
    if (m.find("DatasourceType") != m.end() && !m["DatasourceType"].empty()) {
      datasourceType = make_shared<string>(boost::any_cast<string>(m["DatasourceType"]));
    }
  }


  virtual ~ListDatasourceInstancesRequest() = default;
};
class ListDatasourceInstancesResponseBodyDdiDatasourceInfoListDdiDatasourceInfoPrivateAddressList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> privateAddressList{};

  ListDatasourceInstancesResponseBodyDdiDatasourceInfoListDdiDatasourceInfoPrivateAddressList() {}

  explicit ListDatasourceInstancesResponseBodyDdiDatasourceInfoListDdiDatasourceInfoPrivateAddressList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (privateAddressList) {
      res["privateAddressList"] = boost::any(*privateAddressList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("privateAddressList") != m.end() && !m["privateAddressList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["privateAddressList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["privateAddressList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      privateAddressList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListDatasourceInstancesResponseBodyDdiDatasourceInfoListDdiDatasourceInfoPrivateAddressList() = default;
};
class ListDatasourceInstancesResponseBodyDdiDatasourceInfoListDdiDatasourceInfo : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<long> createTime{};
  shared_ptr<string> datasourceId{};
  shared_ptr<string> descreption{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> name{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};
  shared_ptr<string> vswitchId{};
  shared_ptr<ListDatasourceInstancesResponseBodyDdiDatasourceInfoListDdiDatasourceInfoPrivateAddressList> privateAddressList{};
  shared_ptr<string> securityGroupId{};

  ListDatasourceInstancesResponseBodyDdiDatasourceInfoListDdiDatasourceInfo() {}

  explicit ListDatasourceInstancesResponseBodyDdiDatasourceInfoListDdiDatasourceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (datasourceId) {
      res["DatasourceId"] = boost::any(*datasourceId);
    }
    if (descreption) {
      res["Descreption"] = boost::any(*descreption);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (vswitchId) {
      res["VswitchId"] = boost::any(*vswitchId);
    }
    if (privateAddressList) {
      res["PrivateAddressList"] = privateAddressList ? boost::any(privateAddressList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DatasourceId") != m.end() && !m["DatasourceId"].empty()) {
      datasourceId = make_shared<string>(boost::any_cast<string>(m["DatasourceId"]));
    }
    if (m.find("Descreption") != m.end() && !m["Descreption"].empty()) {
      descreption = make_shared<string>(boost::any_cast<string>(m["Descreption"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("VswitchId") != m.end() && !m["VswitchId"].empty()) {
      vswitchId = make_shared<string>(boost::any_cast<string>(m["VswitchId"]));
    }
    if (m.find("PrivateAddressList") != m.end() && !m["PrivateAddressList"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrivateAddressList"].type()) {
        ListDatasourceInstancesResponseBodyDdiDatasourceInfoListDdiDatasourceInfoPrivateAddressList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrivateAddressList"]));
        privateAddressList = make_shared<ListDatasourceInstancesResponseBodyDdiDatasourceInfoListDdiDatasourceInfoPrivateAddressList>(model1);
      }
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
  }


  virtual ~ListDatasourceInstancesResponseBodyDdiDatasourceInfoListDdiDatasourceInfo() = default;
};
class ListDatasourceInstancesResponseBodyDdiDatasourceInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<ListDatasourceInstancesResponseBodyDdiDatasourceInfoListDdiDatasourceInfo>> ddiDatasourceInfo{};

  ListDatasourceInstancesResponseBodyDdiDatasourceInfoList() {}

  explicit ListDatasourceInstancesResponseBodyDdiDatasourceInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ddiDatasourceInfo) {
      vector<boost::any> temp1;
      for(auto item1:*ddiDatasourceInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DdiDatasourceInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DdiDatasourceInfo") != m.end() && !m["DdiDatasourceInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["DdiDatasourceInfo"].type()) {
        vector<ListDatasourceInstancesResponseBodyDdiDatasourceInfoListDdiDatasourceInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DdiDatasourceInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDatasourceInstancesResponseBodyDdiDatasourceInfoListDdiDatasourceInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ddiDatasourceInfo = make_shared<vector<ListDatasourceInstancesResponseBodyDdiDatasourceInfoListDdiDatasourceInfo>>(expect1);
      }
    }
  }


  virtual ~ListDatasourceInstancesResponseBodyDdiDatasourceInfoList() = default;
};
class ListDatasourceInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListDatasourceInstancesResponseBodyDdiDatasourceInfoList> ddiDatasourceInfoList{};
  shared_ptr<string> requestId{};

  ListDatasourceInstancesResponseBody() {}

  explicit ListDatasourceInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ddiDatasourceInfoList) {
      res["DdiDatasourceInfoList"] = ddiDatasourceInfoList ? boost::any(ddiDatasourceInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DdiDatasourceInfoList") != m.end() && !m["DdiDatasourceInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["DdiDatasourceInfoList"].type()) {
        ListDatasourceInstancesResponseBodyDdiDatasourceInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DdiDatasourceInfoList"]));
        ddiDatasourceInfoList = make_shared<ListDatasourceInstancesResponseBodyDdiDatasourceInfoList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDatasourceInstancesResponseBody() = default;
};
class ListDatasourceInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListDatasourceInstancesResponseBody> body{};

  ListDatasourceInstancesResponse() {}

  explicit ListDatasourceInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDatasourceInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDatasourceInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~ListDatasourceInstancesResponse() = default;
};
class ListFlowNodeSqlResultRequest : public Darabonba::Model {
public:
  shared_ptr<string> nodeInstanceId{};
  shared_ptr<long> sqlIndex{};
  shared_ptr<long> offset{};
  shared_ptr<long> length{};
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};

  ListFlowNodeSqlResultRequest() {}

  explicit ListFlowNodeSqlResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeInstanceId) {
      res["NodeInstanceId"] = boost::any(*nodeInstanceId);
    }
    if (sqlIndex) {
      res["SqlIndex"] = boost::any(*sqlIndex);
    }
    if (offset) {
      res["Offset"] = boost::any(*offset);
    }
    if (length) {
      res["Length"] = boost::any(*length);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeInstanceId") != m.end() && !m["NodeInstanceId"].empty()) {
      nodeInstanceId = make_shared<string>(boost::any_cast<string>(m["NodeInstanceId"]));
    }
    if (m.find("SqlIndex") != m.end() && !m["SqlIndex"].empty()) {
      sqlIndex = make_shared<long>(boost::any_cast<long>(m["SqlIndex"]));
    }
    if (m.find("Offset") != m.end() && !m["Offset"].empty()) {
      offset = make_shared<long>(boost::any_cast<long>(m["Offset"]));
    }
    if (m.find("Length") != m.end() && !m["Length"].empty()) {
      length = make_shared<long>(boost::any_cast<long>(m["Length"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListFlowNodeSqlResultRequest() = default;
};
class ListFlowNodeSqlResultResponseBodyHeaderList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> header{};

  ListFlowNodeSqlResultResponseBodyHeaderList() {}

  explicit ListFlowNodeSqlResultResponseBodyHeaderList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (header) {
      res["Header"] = boost::any(*header);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Header") != m.end() && !m["Header"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Header"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Header"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      header = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListFlowNodeSqlResultResponseBodyHeaderList() = default;
};
class ListFlowNodeSqlResultResponseBodyRowListRowRowItemList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> rowItem{};

  ListFlowNodeSqlResultResponseBodyRowListRowRowItemList() {}

  explicit ListFlowNodeSqlResultResponseBodyRowListRowRowItemList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rowItem) {
      res["RowItem"] = boost::any(*rowItem);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RowItem") != m.end() && !m["RowItem"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RowItem"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RowItem"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      rowItem = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListFlowNodeSqlResultResponseBodyRowListRowRowItemList() = default;
};
class ListFlowNodeSqlResultResponseBodyRowListRow : public Darabonba::Model {
public:
  shared_ptr<long> rowIndex{};
  shared_ptr<ListFlowNodeSqlResultResponseBodyRowListRowRowItemList> rowItemList{};

  ListFlowNodeSqlResultResponseBodyRowListRow() {}

  explicit ListFlowNodeSqlResultResponseBodyRowListRow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rowIndex) {
      res["RowIndex"] = boost::any(*rowIndex);
    }
    if (rowItemList) {
      res["RowItemList"] = rowItemList ? boost::any(rowItemList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RowIndex") != m.end() && !m["RowIndex"].empty()) {
      rowIndex = make_shared<long>(boost::any_cast<long>(m["RowIndex"]));
    }
    if (m.find("RowItemList") != m.end() && !m["RowItemList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RowItemList"].type()) {
        ListFlowNodeSqlResultResponseBodyRowListRowRowItemList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RowItemList"]));
        rowItemList = make_shared<ListFlowNodeSqlResultResponseBodyRowListRowRowItemList>(model1);
      }
    }
  }


  virtual ~ListFlowNodeSqlResultResponseBodyRowListRow() = default;
};
class ListFlowNodeSqlResultResponseBodyRowList : public Darabonba::Model {
public:
  shared_ptr<vector<ListFlowNodeSqlResultResponseBodyRowListRow>> row{};

  ListFlowNodeSqlResultResponseBodyRowList() {}

  explicit ListFlowNodeSqlResultResponseBodyRowList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (row) {
      vector<boost::any> temp1;
      for(auto item1:*row){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Row"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Row") != m.end() && !m["Row"].empty()) {
      if (typeid(vector<boost::any>) == m["Row"].type()) {
        vector<ListFlowNodeSqlResultResponseBodyRowListRow> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Row"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFlowNodeSqlResultResponseBodyRowListRow model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        row = make_shared<vector<ListFlowNodeSqlResultResponseBodyRowListRow>>(expect1);
      }
    }
  }


  virtual ~ListFlowNodeSqlResultResponseBodyRowList() = default;
};
class ListFlowNodeSqlResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> end{};
  shared_ptr<string> requestId{};
  shared_ptr<ListFlowNodeSqlResultResponseBodyHeaderList> headerList{};
  shared_ptr<ListFlowNodeSqlResultResponseBodyRowList> rowList{};

  ListFlowNodeSqlResultResponseBody() {}

  explicit ListFlowNodeSqlResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (headerList) {
      res["HeaderList"] = headerList ? boost::any(headerList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (rowList) {
      res["RowList"] = rowList ? boost::any(rowList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<bool>(boost::any_cast<bool>(m["End"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HeaderList") != m.end() && !m["HeaderList"].empty()) {
      if (typeid(map<string, boost::any>) == m["HeaderList"].type()) {
        ListFlowNodeSqlResultResponseBodyHeaderList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HeaderList"]));
        headerList = make_shared<ListFlowNodeSqlResultResponseBodyHeaderList>(model1);
      }
    }
    if (m.find("RowList") != m.end() && !m["RowList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RowList"].type()) {
        ListFlowNodeSqlResultResponseBodyRowList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RowList"]));
        rowList = make_shared<ListFlowNodeSqlResultResponseBodyRowList>(model1);
      }
    }
  }


  virtual ~ListFlowNodeSqlResultResponseBody() = default;
};
class ListFlowNodeSqlResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListFlowNodeSqlResultResponseBody> body{};

  ListFlowNodeSqlResultResponse() {}

  explicit ListFlowNodeSqlResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFlowNodeSqlResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFlowNodeSqlResultResponseBody>(model1);
      }
    }
  }


  virtual ~ListFlowNodeSqlResultResponse() = default;
};
class DescribeFlowJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> id{};
  shared_ptr<string> regionId{};

  DescribeFlowJobRequest() {}

  explicit DescribeFlowJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeFlowJobRequest() = default;
};
class DescribeFlowJobResponseBodyResourceListResource : public Darabonba::Model {
public:
  shared_ptr<string> path{};
  shared_ptr<string> alias{};

  DescribeFlowJobResponseBodyResourceListResource() {}

  explicit DescribeFlowJobResponseBodyResourceListResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
  }


  virtual ~DescribeFlowJobResponseBodyResourceListResource() = default;
};
class DescribeFlowJobResponseBodyResourceList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeFlowJobResponseBodyResourceListResource>> resource{};

  DescribeFlowJobResponseBodyResourceList() {}

  explicit DescribeFlowJobResponseBodyResourceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resource) {
      vector<boost::any> temp1;
      for(auto item1:*resource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Resource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      if (typeid(vector<boost::any>) == m["Resource"].type()) {
        vector<DescribeFlowJobResponseBodyResourceListResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Resource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFlowJobResponseBodyResourceListResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resource = make_shared<vector<DescribeFlowJobResponseBodyResourceListResource>>(expect1);
      }
    }
  }


  virtual ~DescribeFlowJobResponseBodyResourceList() = default;
};
class DescribeFlowJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> lastInstanceId{};
  shared_ptr<string> envConf{};
  shared_ptr<long> retryInterval{};
  shared_ptr<string> mode{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> monitorConf{};
  shared_ptr<string> params{};
  shared_ptr<string> requestId{};
  shared_ptr<string> description{};
  shared_ptr<string> retryPolicy{};
  shared_ptr<string> adhoc{};
  shared_ptr<string> name{};
  shared_ptr<long> maxRetry{};
  shared_ptr<long> maxRunningTimeSec{};
  shared_ptr<string> failAct{};
  shared_ptr<string> customVariables{};
  shared_ptr<string> editLockDetail{};
  shared_ptr<string> paramConf{};
  shared_ptr<string> runConf{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<string> categoryId{};
  shared_ptr<string> id{};
  shared_ptr<string> alertConf{};
  shared_ptr<DescribeFlowJobResponseBodyResourceList> resourceList{};

  DescribeFlowJobResponseBody() {}

  explicit DescribeFlowJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (lastInstanceId) {
      res["LastInstanceId"] = boost::any(*lastInstanceId);
    }
    if (envConf) {
      res["EnvConf"] = boost::any(*envConf);
    }
    if (retryInterval) {
      res["RetryInterval"] = boost::any(*retryInterval);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (monitorConf) {
      res["MonitorConf"] = boost::any(*monitorConf);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (retryPolicy) {
      res["RetryPolicy"] = boost::any(*retryPolicy);
    }
    if (adhoc) {
      res["Adhoc"] = boost::any(*adhoc);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (maxRetry) {
      res["MaxRetry"] = boost::any(*maxRetry);
    }
    if (maxRunningTimeSec) {
      res["MaxRunningTimeSec"] = boost::any(*maxRunningTimeSec);
    }
    if (failAct) {
      res["FailAct"] = boost::any(*failAct);
    }
    if (customVariables) {
      res["CustomVariables"] = boost::any(*customVariables);
    }
    if (editLockDetail) {
      res["EditLockDetail"] = boost::any(*editLockDetail);
    }
    if (paramConf) {
      res["ParamConf"] = boost::any(*paramConf);
    }
    if (runConf) {
      res["RunConf"] = boost::any(*runConf);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (alertConf) {
      res["AlertConf"] = boost::any(*alertConf);
    }
    if (resourceList) {
      res["ResourceList"] = resourceList ? boost::any(resourceList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("LastInstanceId") != m.end() && !m["LastInstanceId"].empty()) {
      lastInstanceId = make_shared<string>(boost::any_cast<string>(m["LastInstanceId"]));
    }
    if (m.find("EnvConf") != m.end() && !m["EnvConf"].empty()) {
      envConf = make_shared<string>(boost::any_cast<string>(m["EnvConf"]));
    }
    if (m.find("RetryInterval") != m.end() && !m["RetryInterval"].empty()) {
      retryInterval = make_shared<long>(boost::any_cast<long>(m["RetryInterval"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("MonitorConf") != m.end() && !m["MonitorConf"].empty()) {
      monitorConf = make_shared<string>(boost::any_cast<string>(m["MonitorConf"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      params = make_shared<string>(boost::any_cast<string>(m["Params"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RetryPolicy") != m.end() && !m["RetryPolicy"].empty()) {
      retryPolicy = make_shared<string>(boost::any_cast<string>(m["RetryPolicy"]));
    }
    if (m.find("Adhoc") != m.end() && !m["Adhoc"].empty()) {
      adhoc = make_shared<string>(boost::any_cast<string>(m["Adhoc"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("MaxRetry") != m.end() && !m["MaxRetry"].empty()) {
      maxRetry = make_shared<long>(boost::any_cast<long>(m["MaxRetry"]));
    }
    if (m.find("MaxRunningTimeSec") != m.end() && !m["MaxRunningTimeSec"].empty()) {
      maxRunningTimeSec = make_shared<long>(boost::any_cast<long>(m["MaxRunningTimeSec"]));
    }
    if (m.find("FailAct") != m.end() && !m["FailAct"].empty()) {
      failAct = make_shared<string>(boost::any_cast<string>(m["FailAct"]));
    }
    if (m.find("CustomVariables") != m.end() && !m["CustomVariables"].empty()) {
      customVariables = make_shared<string>(boost::any_cast<string>(m["CustomVariables"]));
    }
    if (m.find("EditLockDetail") != m.end() && !m["EditLockDetail"].empty()) {
      editLockDetail = make_shared<string>(boost::any_cast<string>(m["EditLockDetail"]));
    }
    if (m.find("ParamConf") != m.end() && !m["ParamConf"].empty()) {
      paramConf = make_shared<string>(boost::any_cast<string>(m["ParamConf"]));
    }
    if (m.find("RunConf") != m.end() && !m["RunConf"].empty()) {
      runConf = make_shared<string>(boost::any_cast<string>(m["RunConf"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<string>(boost::any_cast<string>(m["CategoryId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("AlertConf") != m.end() && !m["AlertConf"].empty()) {
      alertConf = make_shared<string>(boost::any_cast<string>(m["AlertConf"]));
    }
    if (m.find("ResourceList") != m.end() && !m["ResourceList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourceList"].type()) {
        DescribeFlowJobResponseBodyResourceList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourceList"]));
        resourceList = make_shared<DescribeFlowJobResponseBodyResourceList>(model1);
      }
    }
  }


  virtual ~DescribeFlowJobResponseBody() = default;
};
class DescribeFlowJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeFlowJobResponseBody> body{};

  DescribeFlowJobResponse() {}

  explicit DescribeFlowJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFlowJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFlowJobResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFlowJobResponse() = default;
};
class DescribeLibraryInstallTaskDetailRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> taskBizId{};

  DescribeLibraryInstallTaskDetailRequest() {}

  explicit DescribeLibraryInstallTaskDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskBizId) {
      res["TaskBizId"] = boost::any(*taskBizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskBizId") != m.end() && !m["TaskBizId"].empty()) {
      taskBizId = make_shared<string>(boost::any_cast<string>(m["TaskBizId"]));
    }
  }


  virtual ~DescribeLibraryInstallTaskDetailRequest() = default;
};
class DescribeLibraryInstallTaskDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> libraryBizId{};
  shared_ptr<string> hostname{};
  shared_ptr<long> endTime{};
  shared_ptr<long> startTime{};
  shared_ptr<string> taskType{};
  shared_ptr<string> requestId{};
  shared_ptr<string> taskGroupId{};
  shared_ptr<string> taskStatus{};
  shared_ptr<long> taskProcess{};
  shared_ptr<long> executeTime{};
  shared_ptr<string> clusterBizId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> detail{};

  DescribeLibraryInstallTaskDetailResponseBody() {}

  explicit DescribeLibraryInstallTaskDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (libraryBizId) {
      res["LibraryBizId"] = boost::any(*libraryBizId);
    }
    if (hostname) {
      res["Hostname"] = boost::any(*hostname);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskGroupId) {
      res["TaskGroupId"] = boost::any(*taskGroupId);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (taskProcess) {
      res["TaskProcess"] = boost::any(*taskProcess);
    }
    if (executeTime) {
      res["ExecuteTime"] = boost::any(*executeTime);
    }
    if (clusterBizId) {
      res["ClusterBizId"] = boost::any(*clusterBizId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (detail) {
      res["Detail"] = boost::any(*detail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LibraryBizId") != m.end() && !m["LibraryBizId"].empty()) {
      libraryBizId = make_shared<string>(boost::any_cast<string>(m["LibraryBizId"]));
    }
    if (m.find("Hostname") != m.end() && !m["Hostname"].empty()) {
      hostname = make_shared<string>(boost::any_cast<string>(m["Hostname"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskGroupId") != m.end() && !m["TaskGroupId"].empty()) {
      taskGroupId = make_shared<string>(boost::any_cast<string>(m["TaskGroupId"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<string>(boost::any_cast<string>(m["TaskStatus"]));
    }
    if (m.find("TaskProcess") != m.end() && !m["TaskProcess"].empty()) {
      taskProcess = make_shared<long>(boost::any_cast<long>(m["TaskProcess"]));
    }
    if (m.find("ExecuteTime") != m.end() && !m["ExecuteTime"].empty()) {
      executeTime = make_shared<long>(boost::any_cast<long>(m["ExecuteTime"]));
    }
    if (m.find("ClusterBizId") != m.end() && !m["ClusterBizId"].empty()) {
      clusterBizId = make_shared<string>(boost::any_cast<string>(m["ClusterBizId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      detail = make_shared<string>(boost::any_cast<string>(m["Detail"]));
    }
  }


  virtual ~DescribeLibraryInstallTaskDetailResponseBody() = default;
};
class DescribeLibraryInstallTaskDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeLibraryInstallTaskDetailResponseBody> body{};

  DescribeLibraryInstallTaskDetailResponse() {}

  explicit DescribeLibraryInstallTaskDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLibraryInstallTaskDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLibraryInstallTaskDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLibraryInstallTaskDetailResponse() = default;
};
class ModifyFlowForWebRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> status{};
  shared_ptr<string> description{};
  shared_ptr<bool> periodic{};
  shared_ptr<long> startSchedule{};
  shared_ptr<long> endSchedule{};
  shared_ptr<string> cronExpr{};
  shared_ptr<bool> createCluster{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> hostName{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> graph{};
  shared_ptr<string> alertConf{};
  shared_ptr<string> alertUserGroupBizId{};
  shared_ptr<string> alertDingDingGroupBizId{};
  shared_ptr<string> parentFlowList{};
  shared_ptr<string> parentCategory{};

  ModifyFlowForWebRequest() {}

  explicit ModifyFlowForWebRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (periodic) {
      res["Periodic"] = boost::any(*periodic);
    }
    if (startSchedule) {
      res["StartSchedule"] = boost::any(*startSchedule);
    }
    if (endSchedule) {
      res["EndSchedule"] = boost::any(*endSchedule);
    }
    if (cronExpr) {
      res["CronExpr"] = boost::any(*cronExpr);
    }
    if (createCluster) {
      res["CreateCluster"] = boost::any(*createCluster);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (graph) {
      res["Graph"] = boost::any(*graph);
    }
    if (alertConf) {
      res["AlertConf"] = boost::any(*alertConf);
    }
    if (alertUserGroupBizId) {
      res["AlertUserGroupBizId"] = boost::any(*alertUserGroupBizId);
    }
    if (alertDingDingGroupBizId) {
      res["AlertDingDingGroupBizId"] = boost::any(*alertDingDingGroupBizId);
    }
    if (parentFlowList) {
      res["ParentFlowList"] = boost::any(*parentFlowList);
    }
    if (parentCategory) {
      res["ParentCategory"] = boost::any(*parentCategory);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Periodic") != m.end() && !m["Periodic"].empty()) {
      periodic = make_shared<bool>(boost::any_cast<bool>(m["Periodic"]));
    }
    if (m.find("StartSchedule") != m.end() && !m["StartSchedule"].empty()) {
      startSchedule = make_shared<long>(boost::any_cast<long>(m["StartSchedule"]));
    }
    if (m.find("EndSchedule") != m.end() && !m["EndSchedule"].empty()) {
      endSchedule = make_shared<long>(boost::any_cast<long>(m["EndSchedule"]));
    }
    if (m.find("CronExpr") != m.end() && !m["CronExpr"].empty()) {
      cronExpr = make_shared<string>(boost::any_cast<string>(m["CronExpr"]));
    }
    if (m.find("CreateCluster") != m.end() && !m["CreateCluster"].empty()) {
      createCluster = make_shared<bool>(boost::any_cast<bool>(m["CreateCluster"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Graph") != m.end() && !m["Graph"].empty()) {
      graph = make_shared<string>(boost::any_cast<string>(m["Graph"]));
    }
    if (m.find("AlertConf") != m.end() && !m["AlertConf"].empty()) {
      alertConf = make_shared<string>(boost::any_cast<string>(m["AlertConf"]));
    }
    if (m.find("AlertUserGroupBizId") != m.end() && !m["AlertUserGroupBizId"].empty()) {
      alertUserGroupBizId = make_shared<string>(boost::any_cast<string>(m["AlertUserGroupBizId"]));
    }
    if (m.find("AlertDingDingGroupBizId") != m.end() && !m["AlertDingDingGroupBizId"].empty()) {
      alertDingDingGroupBizId = make_shared<string>(boost::any_cast<string>(m["AlertDingDingGroupBizId"]));
    }
    if (m.find("ParentFlowList") != m.end() && !m["ParentFlowList"].empty()) {
      parentFlowList = make_shared<string>(boost::any_cast<string>(m["ParentFlowList"]));
    }
    if (m.find("ParentCategory") != m.end() && !m["ParentCategory"].empty()) {
      parentCategory = make_shared<string>(boost::any_cast<string>(m["ParentCategory"]));
    }
  }


  virtual ~ModifyFlowForWebRequest() = default;
};
class ModifyFlowForWebResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  ModifyFlowForWebResponseBody() {}

  explicit ModifyFlowForWebResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyFlowForWebResponseBody() = default;
};
class ModifyFlowForWebResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyFlowForWebResponseBody> body{};

  ModifyFlowForWebResponse() {}

  explicit ModifyFlowForWebResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyFlowForWebResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyFlowForWebResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyFlowForWebResponse() = default;
};
class RemoveScalingConfigItemRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> scalingGroupBizId{};
  shared_ptr<string> configItemType{};
  shared_ptr<string> configItemBizId{};

  RemoveScalingConfigItemRequest() {}

  explicit RemoveScalingConfigItemRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (scalingGroupBizId) {
      res["ScalingGroupBizId"] = boost::any(*scalingGroupBizId);
    }
    if (configItemType) {
      res["ConfigItemType"] = boost::any(*configItemType);
    }
    if (configItemBizId) {
      res["ConfigItemBizId"] = boost::any(*configItemBizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ScalingGroupBizId") != m.end() && !m["ScalingGroupBizId"].empty()) {
      scalingGroupBizId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupBizId"]));
    }
    if (m.find("ConfigItemType") != m.end() && !m["ConfigItemType"].empty()) {
      configItemType = make_shared<string>(boost::any_cast<string>(m["ConfigItemType"]));
    }
    if (m.find("ConfigItemBizId") != m.end() && !m["ConfigItemBizId"].empty()) {
      configItemBizId = make_shared<string>(boost::any_cast<string>(m["ConfigItemBizId"]));
    }
  }


  virtual ~RemoveScalingConfigItemRequest() = default;
};
class RemoveScalingConfigItemResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> data{};

  RemoveScalingConfigItemResponseBody() {}

  explicit RemoveScalingConfigItemResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
  }


  virtual ~RemoveScalingConfigItemResponseBody() = default;
};
class RemoveScalingConfigItemResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RemoveScalingConfigItemResponseBody> body{};

  RemoveScalingConfigItemResponse() {}

  explicit RemoveScalingConfigItemResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveScalingConfigItemResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveScalingConfigItemResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveScalingConfigItemResponse() = default;
};
class DescribeSecurityWhiteListRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};

  DescribeSecurityWhiteListRequest() {}

  explicit DescribeSecurityWhiteListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
  }


  virtual ~DescribeSecurityWhiteListRequest() = default;
};
class DescribeSecurityWhiteListResponseBodyDescribeSecurityWhiteList : public Darabonba::Model {
public:
  shared_ptr<string> portRange{};
  shared_ptr<string> whiteIp{};
  shared_ptr<string> description{};
  shared_ptr<string> createTime{};

  DescribeSecurityWhiteListResponseBodyDescribeSecurityWhiteList() {}

  explicit DescribeSecurityWhiteListResponseBodyDescribeSecurityWhiteList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (portRange) {
      res["PortRange"] = boost::any(*portRange);
    }
    if (whiteIp) {
      res["WhiteIp"] = boost::any(*whiteIp);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PortRange") != m.end() && !m["PortRange"].empty()) {
      portRange = make_shared<string>(boost::any_cast<string>(m["PortRange"]));
    }
    if (m.find("WhiteIp") != m.end() && !m["WhiteIp"].empty()) {
      whiteIp = make_shared<string>(boost::any_cast<string>(m["WhiteIp"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
  }


  virtual ~DescribeSecurityWhiteListResponseBodyDescribeSecurityWhiteList() = default;
};
class DescribeSecurityWhiteListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSecurityWhiteListResponseBodyDescribeSecurityWhiteList>> describeSecurityWhiteList{};
  shared_ptr<string> requestId{};

  DescribeSecurityWhiteListResponseBody() {}

  explicit DescribeSecurityWhiteListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (describeSecurityWhiteList) {
      vector<boost::any> temp1;
      for(auto item1:*describeSecurityWhiteList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DescribeSecurityWhiteList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DescribeSecurityWhiteList") != m.end() && !m["DescribeSecurityWhiteList"].empty()) {
      if (typeid(vector<boost::any>) == m["DescribeSecurityWhiteList"].type()) {
        vector<DescribeSecurityWhiteListResponseBodyDescribeSecurityWhiteList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DescribeSecurityWhiteList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSecurityWhiteListResponseBodyDescribeSecurityWhiteList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        describeSecurityWhiteList = make_shared<vector<DescribeSecurityWhiteListResponseBodyDescribeSecurityWhiteList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeSecurityWhiteListResponseBody() = default;
};
class DescribeSecurityWhiteListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSecurityWhiteListResponseBody> body{};

  DescribeSecurityWhiteListResponse() {}

  explicit DescribeSecurityWhiteListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSecurityWhiteListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSecurityWhiteListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSecurityWhiteListResponse() = default;
};
class DescribeFlowNodeInstanceContainerLogRequest : public Darabonba::Model {
public:
  shared_ptr<long> offset{};
  shared_ptr<long> length{};
  shared_ptr<string> nodeInstanceId{};
  shared_ptr<string> appId{};
  shared_ptr<string> containerId{};
  shared_ptr<string> logName{};
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};

  DescribeFlowNodeInstanceContainerLogRequest() {}

  explicit DescribeFlowNodeInstanceContainerLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (offset) {
      res["Offset"] = boost::any(*offset);
    }
    if (length) {
      res["Length"] = boost::any(*length);
    }
    if (nodeInstanceId) {
      res["NodeInstanceId"] = boost::any(*nodeInstanceId);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (containerId) {
      res["ContainerId"] = boost::any(*containerId);
    }
    if (logName) {
      res["LogName"] = boost::any(*logName);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Offset") != m.end() && !m["Offset"].empty()) {
      offset = make_shared<long>(boost::any_cast<long>(m["Offset"]));
    }
    if (m.find("Length") != m.end() && !m["Length"].empty()) {
      length = make_shared<long>(boost::any_cast<long>(m["Length"]));
    }
    if (m.find("NodeInstanceId") != m.end() && !m["NodeInstanceId"].empty()) {
      nodeInstanceId = make_shared<string>(boost::any_cast<string>(m["NodeInstanceId"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ContainerId") != m.end() && !m["ContainerId"].empty()) {
      containerId = make_shared<string>(boost::any_cast<string>(m["ContainerId"]));
    }
    if (m.find("LogName") != m.end() && !m["LogName"].empty()) {
      logName = make_shared<string>(boost::any_cast<string>(m["LogName"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeFlowNodeInstanceContainerLogRequest() = default;
};
class DescribeFlowNodeInstanceContainerLogResponseBodyLogEntrysLogEntry : public Darabonba::Model {
public:
  shared_ptr<string> content{};

  DescribeFlowNodeInstanceContainerLogResponseBodyLogEntrysLogEntry() {}

  explicit DescribeFlowNodeInstanceContainerLogResponseBodyLogEntrysLogEntry(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
  }


  virtual ~DescribeFlowNodeInstanceContainerLogResponseBodyLogEntrysLogEntry() = default;
};
class DescribeFlowNodeInstanceContainerLogResponseBodyLogEntrys : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeFlowNodeInstanceContainerLogResponseBodyLogEntrysLogEntry>> logEntry{};

  DescribeFlowNodeInstanceContainerLogResponseBodyLogEntrys() {}

  explicit DescribeFlowNodeInstanceContainerLogResponseBodyLogEntrys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logEntry) {
      vector<boost::any> temp1;
      for(auto item1:*logEntry){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LogEntry"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogEntry") != m.end() && !m["LogEntry"].empty()) {
      if (typeid(vector<boost::any>) == m["LogEntry"].type()) {
        vector<DescribeFlowNodeInstanceContainerLogResponseBodyLogEntrysLogEntry> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LogEntry"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFlowNodeInstanceContainerLogResponseBodyLogEntrysLogEntry model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logEntry = make_shared<vector<DescribeFlowNodeInstanceContainerLogResponseBodyLogEntrysLogEntry>>(expect1);
      }
    }
  }


  virtual ~DescribeFlowNodeInstanceContainerLogResponseBodyLogEntrys() = default;
};
class DescribeFlowNodeInstanceContainerLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> logEnd{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeFlowNodeInstanceContainerLogResponseBodyLogEntrys> logEntrys{};

  DescribeFlowNodeInstanceContainerLogResponseBody() {}

  explicit DescribeFlowNodeInstanceContainerLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logEnd) {
      res["LogEnd"] = boost::any(*logEnd);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (logEntrys) {
      res["LogEntrys"] = logEntrys ? boost::any(logEntrys->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogEnd") != m.end() && !m["LogEnd"].empty()) {
      logEnd = make_shared<bool>(boost::any_cast<bool>(m["LogEnd"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("LogEntrys") != m.end() && !m["LogEntrys"].empty()) {
      if (typeid(map<string, boost::any>) == m["LogEntrys"].type()) {
        DescribeFlowNodeInstanceContainerLogResponseBodyLogEntrys model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LogEntrys"]));
        logEntrys = make_shared<DescribeFlowNodeInstanceContainerLogResponseBodyLogEntrys>(model1);
      }
    }
  }


  virtual ~DescribeFlowNodeInstanceContainerLogResponseBody() = default;
};
class DescribeFlowNodeInstanceContainerLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeFlowNodeInstanceContainerLogResponseBody> body{};

  DescribeFlowNodeInstanceContainerLogResponse() {}

  explicit DescribeFlowNodeInstanceContainerLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFlowNodeInstanceContainerLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFlowNodeInstanceContainerLogResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFlowNodeInstanceContainerLogResponse() = default;
};
class RerunFlowRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> flowInstanceId{};
  shared_ptr<bool> reRunFail{};

  RerunFlowRequest() {}

  explicit RerunFlowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (flowInstanceId) {
      res["FlowInstanceId"] = boost::any(*flowInstanceId);
    }
    if (reRunFail) {
      res["ReRunFail"] = boost::any(*reRunFail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("FlowInstanceId") != m.end() && !m["FlowInstanceId"].empty()) {
      flowInstanceId = make_shared<string>(boost::any_cast<string>(m["FlowInstanceId"]));
    }
    if (m.find("ReRunFail") != m.end() && !m["ReRunFail"].empty()) {
      reRunFail = make_shared<bool>(boost::any_cast<bool>(m["ReRunFail"]));
    }
  }


  virtual ~RerunFlowRequest() = default;
};
class RerunFlowResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  RerunFlowResponseBody() {}

  explicit RerunFlowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RerunFlowResponseBody() = default;
};
class RerunFlowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RerunFlowResponseBody> body{};

  RerunFlowResponse() {}

  explicit RerunFlowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RerunFlowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RerunFlowResponseBody>(model1);
      }
    }
  }


  virtual ~RerunFlowResponse() = default;
};
class ListTagKeysRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> category{};
  shared_ptr<string> scope{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> pageSize{};

  ListTagKeysRequest() {}

  explicit ListTagKeysRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListTagKeysRequest() = default;
};
class ListTagKeysResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<string> nextToken{};
  shared_ptr<vector<string>> items{};

  ListTagKeysResponseBodyData() {}

  explicit ListTagKeysResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (items) {
      res["Items"] = boost::any(*items);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Items"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      items = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListTagKeysResponseBodyData() = default;
};
class ListTagKeysResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<bool> paging{};
  shared_ptr<vector<ListTagKeysResponseBodyData>> data{};
  shared_ptr<string> code{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};

  ListTagKeysResponseBody() {}

  explicit ListTagKeysResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (paging) {
      res["Paging"] = boost::any(*paging);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Paging") != m.end() && !m["Paging"].empty()) {
      paging = make_shared<bool>(boost::any_cast<bool>(m["Paging"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListTagKeysResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagKeysResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListTagKeysResponseBodyData>>(expect1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~ListTagKeysResponseBody() = default;
};
class ListTagKeysResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListTagKeysResponseBody> body{};

  ListTagKeysResponse() {}

  explicit ListTagKeysResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTagKeysResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTagKeysResponseBody>(model1);
      }
    }
  }


  virtual ~ListTagKeysResponse() = default;
};
class DescribeClusterOperationHostTaskLogRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> operationId{};
  shared_ptr<string> hostId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> status{};

  DescribeClusterOperationHostTaskLogRequest() {}

  explicit DescribeClusterOperationHostTaskLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (operationId) {
      res["OperationId"] = boost::any(*operationId);
    }
    if (hostId) {
      res["HostId"] = boost::any(*hostId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("OperationId") != m.end() && !m["OperationId"].empty()) {
      operationId = make_shared<string>(boost::any_cast<string>(m["OperationId"]));
    }
    if (m.find("HostId") != m.end() && !m["HostId"].empty()) {
      hostId = make_shared<string>(boost::any_cast<string>(m["HostId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeClusterOperationHostTaskLogRequest() = default;
};
class DescribeClusterOperationHostTaskLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> stdout{};
  shared_ptr<string> stderr{};

  DescribeClusterOperationHostTaskLogResponseBody() {}

  explicit DescribeClusterOperationHostTaskLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (stdout) {
      res["Stdout"] = boost::any(*stdout);
    }
    if (stderr) {
      res["Stderr"] = boost::any(*stderr);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Stdout") != m.end() && !m["Stdout"].empty()) {
      stdout = make_shared<string>(boost::any_cast<string>(m["Stdout"]));
    }
    if (m.find("Stderr") != m.end() && !m["Stderr"].empty()) {
      stderr = make_shared<string>(boost::any_cast<string>(m["Stderr"]));
    }
  }


  virtual ~DescribeClusterOperationHostTaskLogResponseBody() = default;
};
class DescribeClusterOperationHostTaskLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeClusterOperationHostTaskLogResponseBody> body{};

  DescribeClusterOperationHostTaskLogResponse() {}

  explicit DescribeClusterOperationHostTaskLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeClusterOperationHostTaskLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeClusterOperationHostTaskLogResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeClusterOperationHostTaskLogResponse() = default;
};
class KillFlowJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> jobInstanceId{};

  KillFlowJobRequest() {}

  explicit KillFlowJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (jobInstanceId) {
      res["JobInstanceId"] = boost::any(*jobInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("JobInstanceId") != m.end() && !m["JobInstanceId"].empty()) {
      jobInstanceId = make_shared<string>(boost::any_cast<string>(m["JobInstanceId"]));
    }
  }


  virtual ~KillFlowJobRequest() = default;
};
class KillFlowJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  KillFlowJobResponseBody() {}

  explicit KillFlowJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~KillFlowJobResponseBody() = default;
};
class KillFlowJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<KillFlowJobResponseBody> body{};

  KillFlowJobResponse() {}

  explicit KillFlowJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        KillFlowJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<KillFlowJobResponseBody>(model1);
      }
    }
  }


  virtual ~KillFlowJobResponse() = default;
};
class UninstallLibrariesRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> clusterBizIdList{};
  shared_ptr<string> libraryBizId{};

  UninstallLibrariesRequest() {}

  explicit UninstallLibrariesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (clusterBizIdList) {
      res["ClusterBizIdList"] = boost::any(*clusterBizIdList);
    }
    if (libraryBizId) {
      res["LibraryBizId"] = boost::any(*libraryBizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ClusterBizIdList") != m.end() && !m["ClusterBizIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ClusterBizIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ClusterBizIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      clusterBizIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LibraryBizId") != m.end() && !m["LibraryBizId"].empty()) {
      libraryBizId = make_shared<string>(boost::any_cast<string>(m["LibraryBizId"]));
    }
  }


  virtual ~UninstallLibrariesRequest() = default;
};
class UninstallLibrariesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  UninstallLibrariesResponseBody() {}

  explicit UninstallLibrariesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UninstallLibrariesResponseBody() = default;
};
class UninstallLibrariesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UninstallLibrariesResponseBody> body{};

  UninstallLibrariesResponse() {}

  explicit UninstallLibrariesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UninstallLibrariesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UninstallLibrariesResponseBody>(model1);
      }
    }
  }


  virtual ~UninstallLibrariesResponse() = default;
};
class DescribeClusterV2Request : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> id{};

  DescribeClusterV2Request() {}

  explicit DescribeClusterV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~DescribeClusterV2Request() = default;
};
class DescribeClusterV2ResponseBodyClusterInfoGatewayClusterInfoListGatewayClusterInfo : public Darabonba::Model {
public:
  shared_ptr<string> clusterName{};
  shared_ptr<string> status{};
  shared_ptr<string> clusterId{};

  DescribeClusterV2ResponseBodyClusterInfoGatewayClusterInfoListGatewayClusterInfo() {}

  explicit DescribeClusterV2ResponseBodyClusterInfoGatewayClusterInfoListGatewayClusterInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
  }


  virtual ~DescribeClusterV2ResponseBodyClusterInfoGatewayClusterInfoListGatewayClusterInfo() = default;
};
class DescribeClusterV2ResponseBodyClusterInfoGatewayClusterInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeClusterV2ResponseBodyClusterInfoGatewayClusterInfoListGatewayClusterInfo>> gatewayClusterInfo{};

  DescribeClusterV2ResponseBodyClusterInfoGatewayClusterInfoList() {}

  explicit DescribeClusterV2ResponseBodyClusterInfoGatewayClusterInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gatewayClusterInfo) {
      vector<boost::any> temp1;
      for(auto item1:*gatewayClusterInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GatewayClusterInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GatewayClusterInfo") != m.end() && !m["GatewayClusterInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["GatewayClusterInfo"].type()) {
        vector<DescribeClusterV2ResponseBodyClusterInfoGatewayClusterInfoListGatewayClusterInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GatewayClusterInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterV2ResponseBodyClusterInfoGatewayClusterInfoListGatewayClusterInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        gatewayClusterInfo = make_shared<vector<DescribeClusterV2ResponseBodyClusterInfoGatewayClusterInfoListGatewayClusterInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeClusterV2ResponseBodyClusterInfoGatewayClusterInfoList() = default;
};
class DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDaemonInfosDaemonInfo : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDaemonInfosDaemonInfo() {}

  explicit DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDaemonInfosDaemonInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDaemonInfosDaemonInfo() = default;
};
class DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDaemonInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDaemonInfosDaemonInfo>> daemonInfo{};

  DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDaemonInfos() {}

  explicit DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDaemonInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (daemonInfo) {
      vector<boost::any> temp1;
      for(auto item1:*daemonInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DaemonInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DaemonInfo") != m.end() && !m["DaemonInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["DaemonInfo"].type()) {
        vector<DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDaemonInfosDaemonInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DaemonInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDaemonInfosDaemonInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        daemonInfo = make_shared<vector<DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDaemonInfosDaemonInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDaemonInfos() = default;
};
class DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDiskInfosDiskInfo : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> diskId{};
  shared_ptr<long> size{};
  shared_ptr<string> device{};
  shared_ptr<string> diskName{};

  DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDiskInfosDiskInfo() {}

  explicit DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDiskInfosDiskInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (device) {
      res["Device"] = boost::any(*device);
    }
    if (diskName) {
      res["DiskName"] = boost::any(*diskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      diskId = make_shared<string>(boost::any_cast<string>(m["DiskId"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Device") != m.end() && !m["Device"].empty()) {
      device = make_shared<string>(boost::any_cast<string>(m["Device"]));
    }
    if (m.find("DiskName") != m.end() && !m["DiskName"].empty()) {
      diskName = make_shared<string>(boost::any_cast<string>(m["DiskName"]));
    }
  }


  virtual ~DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDiskInfosDiskInfo() = default;
};
class DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDiskInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDiskInfosDiskInfo>> diskInfo{};

  DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDiskInfos() {}

  explicit DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDiskInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diskInfo) {
      vector<boost::any> temp1;
      for(auto item1:*diskInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DiskInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiskInfo") != m.end() && !m["DiskInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["DiskInfo"].type()) {
        vector<DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDiskInfosDiskInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DiskInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDiskInfosDiskInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        diskInfo = make_shared<vector<DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDiskInfosDiskInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDiskInfos() = default;
};
class DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNode : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<bool> supportIpV6{};
  shared_ptr<string> innerIp{};
  shared_ptr<string> expiredTime{};
  shared_ptr<string> createTime{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> emrExpiredTime{};
  shared_ptr<string> pubIp{};
  shared_ptr<DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDaemonInfos> daemonInfos{};
  shared_ptr<DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDiskInfos> diskInfos{};

  DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNode() {}

  explicit DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (supportIpV6) {
      res["SupportIpV6"] = boost::any(*supportIpV6);
    }
    if (innerIp) {
      res["InnerIp"] = boost::any(*innerIp);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (emrExpiredTime) {
      res["EmrExpiredTime"] = boost::any(*emrExpiredTime);
    }
    if (pubIp) {
      res["PubIp"] = boost::any(*pubIp);
    }
    if (daemonInfos) {
      res["DaemonInfos"] = daemonInfos ? boost::any(daemonInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (diskInfos) {
      res["DiskInfos"] = diskInfos ? boost::any(diskInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SupportIpV6") != m.end() && !m["SupportIpV6"].empty()) {
      supportIpV6 = make_shared<bool>(boost::any_cast<bool>(m["SupportIpV6"]));
    }
    if (m.find("InnerIp") != m.end() && !m["InnerIp"].empty()) {
      innerIp = make_shared<string>(boost::any_cast<string>(m["InnerIp"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<string>(boost::any_cast<string>(m["ExpiredTime"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("EmrExpiredTime") != m.end() && !m["EmrExpiredTime"].empty()) {
      emrExpiredTime = make_shared<string>(boost::any_cast<string>(m["EmrExpiredTime"]));
    }
    if (m.find("PubIp") != m.end() && !m["PubIp"].empty()) {
      pubIp = make_shared<string>(boost::any_cast<string>(m["PubIp"]));
    }
    if (m.find("DaemonInfos") != m.end() && !m["DaemonInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["DaemonInfos"].type()) {
        DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDaemonInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DaemonInfos"]));
        daemonInfos = make_shared<DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDaemonInfos>(model1);
      }
    }
    if (m.find("DiskInfos") != m.end() && !m["DiskInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["DiskInfos"].type()) {
        DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDiskInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DiskInfos"]));
        diskInfos = make_shared<DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDiskInfos>(model1);
      }
    }
  }


  virtual ~DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNode() = default;
};
class DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodes : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNode>> node{};

  DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodes() {}

  explicit DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (node) {
      vector<boost::any> temp1;
      for(auto item1:*node){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Node"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Node") != m.end() && !m["Node"].empty()) {
      if (typeid(vector<boost::any>) == m["Node"].type()) {
        vector<DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNode> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Node"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNode model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        node = make_shared<vector<DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNode>>(expect1);
      }
    }
  }


  virtual ~DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodes() = default;
};
class DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroup : public Darabonba::Model {
public:
  shared_ptr<string> lockType{};
  shared_ptr<string> hostGroupSubType{};
  shared_ptr<string> hostGroupType{};
  shared_ptr<string> hostGroupChangeStatus{};
  shared_ptr<string> chargeType{};
  shared_ptr<string> lockReason{};
  shared_ptr<string> diskType{};
  shared_ptr<string> hostGroupId{};
  shared_ptr<string> bandWidth{};
  shared_ptr<string> instanceType{};
  shared_ptr<long> diskCount{};
  shared_ptr<string> period{};
  shared_ptr<long> diskCapacity{};
  shared_ptr<long> cpuCore{};
  shared_ptr<long> memoryCapacity{};
  shared_ptr<long> nodeCount{};
  shared_ptr<string> hostGroupChangeType{};
  shared_ptr<string> hostGroupName{};
  shared_ptr<DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodes> nodes{};

  DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroup() {}

  explicit DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lockType) {
      res["LockType"] = boost::any(*lockType);
    }
    if (hostGroupSubType) {
      res["HostGroupSubType"] = boost::any(*hostGroupSubType);
    }
    if (hostGroupType) {
      res["HostGroupType"] = boost::any(*hostGroupType);
    }
    if (hostGroupChangeStatus) {
      res["HostGroupChangeStatus"] = boost::any(*hostGroupChangeStatus);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (lockReason) {
      res["LockReason"] = boost::any(*lockReason);
    }
    if (diskType) {
      res["DiskType"] = boost::any(*diskType);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (bandWidth) {
      res["BandWidth"] = boost::any(*bandWidth);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (diskCount) {
      res["DiskCount"] = boost::any(*diskCount);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (diskCapacity) {
      res["DiskCapacity"] = boost::any(*diskCapacity);
    }
    if (cpuCore) {
      res["CpuCore"] = boost::any(*cpuCore);
    }
    if (memoryCapacity) {
      res["MemoryCapacity"] = boost::any(*memoryCapacity);
    }
    if (nodeCount) {
      res["NodeCount"] = boost::any(*nodeCount);
    }
    if (hostGroupChangeType) {
      res["HostGroupChangeType"] = boost::any(*hostGroupChangeType);
    }
    if (hostGroupName) {
      res["HostGroupName"] = boost::any(*hostGroupName);
    }
    if (nodes) {
      res["Nodes"] = nodes ? boost::any(nodes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LockType") != m.end() && !m["LockType"].empty()) {
      lockType = make_shared<string>(boost::any_cast<string>(m["LockType"]));
    }
    if (m.find("HostGroupSubType") != m.end() && !m["HostGroupSubType"].empty()) {
      hostGroupSubType = make_shared<string>(boost::any_cast<string>(m["HostGroupSubType"]));
    }
    if (m.find("HostGroupType") != m.end() && !m["HostGroupType"].empty()) {
      hostGroupType = make_shared<string>(boost::any_cast<string>(m["HostGroupType"]));
    }
    if (m.find("HostGroupChangeStatus") != m.end() && !m["HostGroupChangeStatus"].empty()) {
      hostGroupChangeStatus = make_shared<string>(boost::any_cast<string>(m["HostGroupChangeStatus"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("LockReason") != m.end() && !m["LockReason"].empty()) {
      lockReason = make_shared<string>(boost::any_cast<string>(m["LockReason"]));
    }
    if (m.find("DiskType") != m.end() && !m["DiskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["DiskType"]));
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("BandWidth") != m.end() && !m["BandWidth"].empty()) {
      bandWidth = make_shared<string>(boost::any_cast<string>(m["BandWidth"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("DiskCount") != m.end() && !m["DiskCount"].empty()) {
      diskCount = make_shared<long>(boost::any_cast<long>(m["DiskCount"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("DiskCapacity") != m.end() && !m["DiskCapacity"].empty()) {
      diskCapacity = make_shared<long>(boost::any_cast<long>(m["DiskCapacity"]));
    }
    if (m.find("CpuCore") != m.end() && !m["CpuCore"].empty()) {
      cpuCore = make_shared<long>(boost::any_cast<long>(m["CpuCore"]));
    }
    if (m.find("MemoryCapacity") != m.end() && !m["MemoryCapacity"].empty()) {
      memoryCapacity = make_shared<long>(boost::any_cast<long>(m["MemoryCapacity"]));
    }
    if (m.find("NodeCount") != m.end() && !m["NodeCount"].empty()) {
      nodeCount = make_shared<long>(boost::any_cast<long>(m["NodeCount"]));
    }
    if (m.find("HostGroupChangeType") != m.end() && !m["HostGroupChangeType"].empty()) {
      hostGroupChangeType = make_shared<string>(boost::any_cast<string>(m["HostGroupChangeType"]));
    }
    if (m.find("HostGroupName") != m.end() && !m["HostGroupName"].empty()) {
      hostGroupName = make_shared<string>(boost::any_cast<string>(m["HostGroupName"]));
    }
    if (m.find("Nodes") != m.end() && !m["Nodes"].empty()) {
      if (typeid(map<string, boost::any>) == m["Nodes"].type()) {
        DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Nodes"]));
        nodes = make_shared<DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodes>(model1);
      }
    }
  }


  virtual ~DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroup() = default;
};
class DescribeClusterV2ResponseBodyClusterInfoHostGroupList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroup>> hostGroup{};

  DescribeClusterV2ResponseBodyClusterInfoHostGroupList() {}

  explicit DescribeClusterV2ResponseBodyClusterInfoHostGroupList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostGroup) {
      vector<boost::any> temp1;
      for(auto item1:*hostGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HostGroup"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostGroup") != m.end() && !m["HostGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["HostGroup"].type()) {
        vector<DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HostGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hostGroup = make_shared<vector<DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroup>>(expect1);
      }
    }
  }


  virtual ~DescribeClusterV2ResponseBodyClusterInfoHostGroupList() = default;
};
class DescribeClusterV2ResponseBodyClusterInfoBootstrapActionListBootstrapAction : public Darabonba::Model {
public:
  shared_ptr<string> path{};
  shared_ptr<string> name{};
  shared_ptr<string> arg{};

  DescribeClusterV2ResponseBodyClusterInfoBootstrapActionListBootstrapAction() {}

  explicit DescribeClusterV2ResponseBodyClusterInfoBootstrapActionListBootstrapAction(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (arg) {
      res["Arg"] = boost::any(*arg);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Arg") != m.end() && !m["Arg"].empty()) {
      arg = make_shared<string>(boost::any_cast<string>(m["Arg"]));
    }
  }


  virtual ~DescribeClusterV2ResponseBodyClusterInfoBootstrapActionListBootstrapAction() = default;
};
class DescribeClusterV2ResponseBodyClusterInfoBootstrapActionList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeClusterV2ResponseBodyClusterInfoBootstrapActionListBootstrapAction>> bootstrapAction{};

  DescribeClusterV2ResponseBodyClusterInfoBootstrapActionList() {}

  explicit DescribeClusterV2ResponseBodyClusterInfoBootstrapActionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bootstrapAction) {
      vector<boost::any> temp1;
      for(auto item1:*bootstrapAction){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BootstrapAction"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BootstrapAction") != m.end() && !m["BootstrapAction"].empty()) {
      if (typeid(vector<boost::any>) == m["BootstrapAction"].type()) {
        vector<DescribeClusterV2ResponseBodyClusterInfoBootstrapActionListBootstrapAction> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BootstrapAction"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterV2ResponseBodyClusterInfoBootstrapActionListBootstrapAction model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bootstrapAction = make_shared<vector<DescribeClusterV2ResponseBodyClusterInfoBootstrapActionListBootstrapAction>>(expect1);
      }
    }
  }


  virtual ~DescribeClusterV2ResponseBodyClusterInfoBootstrapActionList() = default;
};
class DescribeClusterV2ResponseBodyClusterInfoRelateClusterInfo : public Darabonba::Model {
public:
  shared_ptr<string> clusterName{};
  shared_ptr<string> status{};
  shared_ptr<string> clusterId{};

  DescribeClusterV2ResponseBodyClusterInfoRelateClusterInfo() {}

  explicit DescribeClusterV2ResponseBodyClusterInfoRelateClusterInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
  }


  virtual ~DescribeClusterV2ResponseBodyClusterInfoRelateClusterInfo() = default;
};
class DescribeClusterV2ResponseBodyClusterInfoHostPoolInfo : public Darabonba::Model {
public:
  shared_ptr<string> hpName{};
  shared_ptr<string> hpBizId{};

  DescribeClusterV2ResponseBodyClusterInfoHostPoolInfo() {}

  explicit DescribeClusterV2ResponseBodyClusterInfoHostPoolInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hpName) {
      res["HpName"] = boost::any(*hpName);
    }
    if (hpBizId) {
      res["HpBizId"] = boost::any(*hpBizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HpName") != m.end() && !m["HpName"].empty()) {
      hpName = make_shared<string>(boost::any_cast<string>(m["HpName"]));
    }
    if (m.find("HpBizId") != m.end() && !m["HpBizId"].empty()) {
      hpBizId = make_shared<string>(boost::any_cast<string>(m["HpBizId"]));
    }
  }


  virtual ~DescribeClusterV2ResponseBodyClusterInfoHostPoolInfo() = default;
};
class DescribeClusterV2ResponseBodyClusterInfoFailReason : public Darabonba::Model {
public:
  shared_ptr<string> errorMsg{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};

  DescribeClusterV2ResponseBodyClusterInfoFailReason() {}

  explicit DescribeClusterV2ResponseBodyClusterInfoFailReason(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
  }


  virtual ~DescribeClusterV2ResponseBodyClusterInfoFailReason() = default;
};
class DescribeClusterV2ResponseBodyClusterInfoSoftwareInfoSoftwaresSoftware : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<bool> onlyDisplay{};
  shared_ptr<long> startTpe{};
  shared_ptr<string> name{};
  shared_ptr<string> version{};

  DescribeClusterV2ResponseBodyClusterInfoSoftwareInfoSoftwaresSoftware() {}

  explicit DescribeClusterV2ResponseBodyClusterInfoSoftwareInfoSoftwaresSoftware(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (onlyDisplay) {
      res["OnlyDisplay"] = boost::any(*onlyDisplay);
    }
    if (startTpe) {
      res["StartTpe"] = boost::any(*startTpe);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("OnlyDisplay") != m.end() && !m["OnlyDisplay"].empty()) {
      onlyDisplay = make_shared<bool>(boost::any_cast<bool>(m["OnlyDisplay"]));
    }
    if (m.find("StartTpe") != m.end() && !m["StartTpe"].empty()) {
      startTpe = make_shared<long>(boost::any_cast<long>(m["StartTpe"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeClusterV2ResponseBodyClusterInfoSoftwareInfoSoftwaresSoftware() = default;
};
class DescribeClusterV2ResponseBodyClusterInfoSoftwareInfoSoftwares : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeClusterV2ResponseBodyClusterInfoSoftwareInfoSoftwaresSoftware>> software{};

  DescribeClusterV2ResponseBodyClusterInfoSoftwareInfoSoftwares() {}

  explicit DescribeClusterV2ResponseBodyClusterInfoSoftwareInfoSoftwares(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (software) {
      vector<boost::any> temp1;
      for(auto item1:*software){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Software"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Software") != m.end() && !m["Software"].empty()) {
      if (typeid(vector<boost::any>) == m["Software"].type()) {
        vector<DescribeClusterV2ResponseBodyClusterInfoSoftwareInfoSoftwaresSoftware> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Software"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterV2ResponseBodyClusterInfoSoftwareInfoSoftwaresSoftware model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        software = make_shared<vector<DescribeClusterV2ResponseBodyClusterInfoSoftwareInfoSoftwaresSoftware>>(expect1);
      }
    }
  }


  virtual ~DescribeClusterV2ResponseBodyClusterInfoSoftwareInfoSoftwares() = default;
};
class DescribeClusterV2ResponseBodyClusterInfoSoftwareInfo : public Darabonba::Model {
public:
  shared_ptr<string> clusterType{};
  shared_ptr<string> emrVer{};
  shared_ptr<DescribeClusterV2ResponseBodyClusterInfoSoftwareInfoSoftwares> softwares{};

  DescribeClusterV2ResponseBodyClusterInfoSoftwareInfo() {}

  explicit DescribeClusterV2ResponseBodyClusterInfoSoftwareInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (emrVer) {
      res["EmrVer"] = boost::any(*emrVer);
    }
    if (softwares) {
      res["Softwares"] = softwares ? boost::any(softwares->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("EmrVer") != m.end() && !m["EmrVer"].empty()) {
      emrVer = make_shared<string>(boost::any_cast<string>(m["EmrVer"]));
    }
    if (m.find("Softwares") != m.end() && !m["Softwares"].empty()) {
      if (typeid(map<string, boost::any>) == m["Softwares"].type()) {
        DescribeClusterV2ResponseBodyClusterInfoSoftwareInfoSoftwares model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Softwares"]));
        softwares = make_shared<DescribeClusterV2ResponseBodyClusterInfoSoftwareInfoSoftwares>(model1);
      }
    }
  }


  virtual ~DescribeClusterV2ResponseBodyClusterInfoSoftwareInfo() = default;
};
class DescribeClusterV2ResponseBodyClusterInfoAccessInfoZKLinksZKLink : public Darabonba::Model {
public:
  shared_ptr<string> port{};
  shared_ptr<string> link{};

  DescribeClusterV2ResponseBodyClusterInfoAccessInfoZKLinksZKLink() {}

  explicit DescribeClusterV2ResponseBodyClusterInfoAccessInfoZKLinksZKLink(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (link) {
      res["Link"] = boost::any(*link);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("Link") != m.end() && !m["Link"].empty()) {
      link = make_shared<string>(boost::any_cast<string>(m["Link"]));
    }
  }


  virtual ~DescribeClusterV2ResponseBodyClusterInfoAccessInfoZKLinksZKLink() = default;
};
class DescribeClusterV2ResponseBodyClusterInfoAccessInfoZKLinks : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeClusterV2ResponseBodyClusterInfoAccessInfoZKLinksZKLink>> ZKLink{};

  DescribeClusterV2ResponseBodyClusterInfoAccessInfoZKLinks() {}

  explicit DescribeClusterV2ResponseBodyClusterInfoAccessInfoZKLinks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ZKLink) {
      vector<boost::any> temp1;
      for(auto item1:*ZKLink){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ZKLink"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ZKLink") != m.end() && !m["ZKLink"].empty()) {
      if (typeid(vector<boost::any>) == m["ZKLink"].type()) {
        vector<DescribeClusterV2ResponseBodyClusterInfoAccessInfoZKLinksZKLink> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ZKLink"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterV2ResponseBodyClusterInfoAccessInfoZKLinksZKLink model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ZKLink = make_shared<vector<DescribeClusterV2ResponseBodyClusterInfoAccessInfoZKLinksZKLink>>(expect1);
      }
    }
  }


  virtual ~DescribeClusterV2ResponseBodyClusterInfoAccessInfoZKLinks() = default;
};
class DescribeClusterV2ResponseBodyClusterInfoAccessInfo : public Darabonba::Model {
public:
  shared_ptr<DescribeClusterV2ResponseBodyClusterInfoAccessInfoZKLinks> ZKLinks{};

  DescribeClusterV2ResponseBodyClusterInfoAccessInfo() {}

  explicit DescribeClusterV2ResponseBodyClusterInfoAccessInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ZKLinks) {
      res["ZKLinks"] = ZKLinks ? boost::any(ZKLinks->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ZKLinks") != m.end() && !m["ZKLinks"].empty()) {
      if (typeid(map<string, boost::any>) == m["ZKLinks"].type()) {
        DescribeClusterV2ResponseBodyClusterInfoAccessInfoZKLinks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ZKLinks"]));
        ZKLinks = make_shared<DescribeClusterV2ResponseBodyClusterInfoAccessInfoZKLinks>(model1);
      }
    }
  }


  virtual ~DescribeClusterV2ResponseBodyClusterInfoAccessInfo() = default;
};
class DescribeClusterV2ResponseBodyClusterInfo : public Darabonba::Model {
public:
  shared_ptr<string> vpcId{};
  shared_ptr<bool> logEnable{};
  shared_ptr<long> taskNodeInService{};
  shared_ptr<bool> autoScalingSpotWithLimitAllowed{};
  shared_ptr<string> userId{};
  shared_ptr<string> chargeType{};
  shared_ptr<long> stopTime{};
  shared_ptr<string> depositType{};
  shared_ptr<string> createType{};
  shared_ptr<string> relateClusterId{};
  shared_ptr<string> securityGroupName{};
  shared_ptr<bool> resizeDiskEnable{};
  shared_ptr<string> imageId{};
  shared_ptr<string> userDefinedEmrEcsRole{};
  shared_ptr<string> metaStoreType{};
  shared_ptr<long> startTime{};
  shared_ptr<string> configurations{};
  shared_ptr<string> logPath{};
  shared_ptr<string> autoScalingVersion{};
  shared_ptr<string> netType{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> createResource{};
  shared_ptr<string> status{};
  shared_ptr<long> runningTime{};
  shared_ptr<bool> highAvailabilityEnable{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<bool> autoScalingAllowed{};
  shared_ptr<long> masterNodeInService{};
  shared_ptr<bool> autoScalingEnable{};
  shared_ptr<bool> autoScalingWithGraceAllowed{};
  shared_ptr<long> coreNodeInService{};
  shared_ptr<bool> showSoftwareInterface{};
  shared_ptr<string> k8sClusterId{};
  shared_ptr<bool> autoScalingByLoadAllowed{};
  shared_ptr<bool> localMetaDb{};
  shared_ptr<string> instanceGeneration{};
  shared_ptr<string> name{};
  shared_ptr<bool> easEnable{};
  shared_ptr<string> machineType{};
  shared_ptr<long> masterNodeTotal{};
  shared_ptr<string> regionId{};
  shared_ptr<long> period{};
  shared_ptr<string> extraInfo{};
  shared_ptr<bool> ioOptimized{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<long> expiredTime{};
  shared_ptr<long> coreNodeTotal{};
  shared_ptr<string> gatewayClusterIds{};
  shared_ptr<bool> bootstrapFailed{};
  shared_ptr<string> id{};
  shared_ptr<long> taskNodeTotal{};
  shared_ptr<DescribeClusterV2ResponseBodyClusterInfoGatewayClusterInfoList> gatewayClusterInfoList{};
  shared_ptr<DescribeClusterV2ResponseBodyClusterInfoHostGroupList> hostGroupList{};
  shared_ptr<DescribeClusterV2ResponseBodyClusterInfoBootstrapActionList> bootstrapActionList{};
  shared_ptr<DescribeClusterV2ResponseBodyClusterInfoRelateClusterInfo> relateClusterInfo{};
  shared_ptr<DescribeClusterV2ResponseBodyClusterInfoHostPoolInfo> hostPoolInfo{};
  shared_ptr<DescribeClusterV2ResponseBodyClusterInfoFailReason> failReason{};
  shared_ptr<DescribeClusterV2ResponseBodyClusterInfoSoftwareInfo> softwareInfo{};
  shared_ptr<DescribeClusterV2ResponseBodyClusterInfoAccessInfo> accessInfo{};

  DescribeClusterV2ResponseBodyClusterInfo() {}

  explicit DescribeClusterV2ResponseBodyClusterInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (logEnable) {
      res["LogEnable"] = boost::any(*logEnable);
    }
    if (taskNodeInService) {
      res["TaskNodeInService"] = boost::any(*taskNodeInService);
    }
    if (autoScalingSpotWithLimitAllowed) {
      res["AutoScalingSpotWithLimitAllowed"] = boost::any(*autoScalingSpotWithLimitAllowed);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (stopTime) {
      res["StopTime"] = boost::any(*stopTime);
    }
    if (depositType) {
      res["DepositType"] = boost::any(*depositType);
    }
    if (createType) {
      res["CreateType"] = boost::any(*createType);
    }
    if (relateClusterId) {
      res["RelateClusterId"] = boost::any(*relateClusterId);
    }
    if (securityGroupName) {
      res["SecurityGroupName"] = boost::any(*securityGroupName);
    }
    if (resizeDiskEnable) {
      res["ResizeDiskEnable"] = boost::any(*resizeDiskEnable);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (userDefinedEmrEcsRole) {
      res["UserDefinedEmrEcsRole"] = boost::any(*userDefinedEmrEcsRole);
    }
    if (metaStoreType) {
      res["MetaStoreType"] = boost::any(*metaStoreType);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (configurations) {
      res["Configurations"] = boost::any(*configurations);
    }
    if (logPath) {
      res["LogPath"] = boost::any(*logPath);
    }
    if (autoScalingVersion) {
      res["AutoScalingVersion"] = boost::any(*autoScalingVersion);
    }
    if (netType) {
      res["NetType"] = boost::any(*netType);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (createResource) {
      res["CreateResource"] = boost::any(*createResource);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (runningTime) {
      res["RunningTime"] = boost::any(*runningTime);
    }
    if (highAvailabilityEnable) {
      res["HighAvailabilityEnable"] = boost::any(*highAvailabilityEnable);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (autoScalingAllowed) {
      res["AutoScalingAllowed"] = boost::any(*autoScalingAllowed);
    }
    if (masterNodeInService) {
      res["MasterNodeInService"] = boost::any(*masterNodeInService);
    }
    if (autoScalingEnable) {
      res["AutoScalingEnable"] = boost::any(*autoScalingEnable);
    }
    if (autoScalingWithGraceAllowed) {
      res["AutoScalingWithGraceAllowed"] = boost::any(*autoScalingWithGraceAllowed);
    }
    if (coreNodeInService) {
      res["CoreNodeInService"] = boost::any(*coreNodeInService);
    }
    if (showSoftwareInterface) {
      res["ShowSoftwareInterface"] = boost::any(*showSoftwareInterface);
    }
    if (k8sClusterId) {
      res["K8sClusterId"] = boost::any(*k8sClusterId);
    }
    if (autoScalingByLoadAllowed) {
      res["AutoScalingByLoadAllowed"] = boost::any(*autoScalingByLoadAllowed);
    }
    if (localMetaDb) {
      res["LocalMetaDb"] = boost::any(*localMetaDb);
    }
    if (instanceGeneration) {
      res["InstanceGeneration"] = boost::any(*instanceGeneration);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (easEnable) {
      res["EasEnable"] = boost::any(*easEnable);
    }
    if (machineType) {
      res["MachineType"] = boost::any(*machineType);
    }
    if (masterNodeTotal) {
      res["MasterNodeTotal"] = boost::any(*masterNodeTotal);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (extraInfo) {
      res["ExtraInfo"] = boost::any(*extraInfo);
    }
    if (ioOptimized) {
      res["IoOptimized"] = boost::any(*ioOptimized);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (coreNodeTotal) {
      res["CoreNodeTotal"] = boost::any(*coreNodeTotal);
    }
    if (gatewayClusterIds) {
      res["GatewayClusterIds"] = boost::any(*gatewayClusterIds);
    }
    if (bootstrapFailed) {
      res["BootstrapFailed"] = boost::any(*bootstrapFailed);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (taskNodeTotal) {
      res["TaskNodeTotal"] = boost::any(*taskNodeTotal);
    }
    if (gatewayClusterInfoList) {
      res["GatewayClusterInfoList"] = gatewayClusterInfoList ? boost::any(gatewayClusterInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hostGroupList) {
      res["HostGroupList"] = hostGroupList ? boost::any(hostGroupList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bootstrapActionList) {
      res["BootstrapActionList"] = bootstrapActionList ? boost::any(bootstrapActionList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (relateClusterInfo) {
      res["RelateClusterInfo"] = relateClusterInfo ? boost::any(relateClusterInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hostPoolInfo) {
      res["HostPoolInfo"] = hostPoolInfo ? boost::any(hostPoolInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (failReason) {
      res["FailReason"] = failReason ? boost::any(failReason->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (softwareInfo) {
      res["SoftwareInfo"] = softwareInfo ? boost::any(softwareInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (accessInfo) {
      res["AccessInfo"] = accessInfo ? boost::any(accessInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("LogEnable") != m.end() && !m["LogEnable"].empty()) {
      logEnable = make_shared<bool>(boost::any_cast<bool>(m["LogEnable"]));
    }
    if (m.find("TaskNodeInService") != m.end() && !m["TaskNodeInService"].empty()) {
      taskNodeInService = make_shared<long>(boost::any_cast<long>(m["TaskNodeInService"]));
    }
    if (m.find("AutoScalingSpotWithLimitAllowed") != m.end() && !m["AutoScalingSpotWithLimitAllowed"].empty()) {
      autoScalingSpotWithLimitAllowed = make_shared<bool>(boost::any_cast<bool>(m["AutoScalingSpotWithLimitAllowed"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("StopTime") != m.end() && !m["StopTime"].empty()) {
      stopTime = make_shared<long>(boost::any_cast<long>(m["StopTime"]));
    }
    if (m.find("DepositType") != m.end() && !m["DepositType"].empty()) {
      depositType = make_shared<string>(boost::any_cast<string>(m["DepositType"]));
    }
    if (m.find("CreateType") != m.end() && !m["CreateType"].empty()) {
      createType = make_shared<string>(boost::any_cast<string>(m["CreateType"]));
    }
    if (m.find("RelateClusterId") != m.end() && !m["RelateClusterId"].empty()) {
      relateClusterId = make_shared<string>(boost::any_cast<string>(m["RelateClusterId"]));
    }
    if (m.find("SecurityGroupName") != m.end() && !m["SecurityGroupName"].empty()) {
      securityGroupName = make_shared<string>(boost::any_cast<string>(m["SecurityGroupName"]));
    }
    if (m.find("ResizeDiskEnable") != m.end() && !m["ResizeDiskEnable"].empty()) {
      resizeDiskEnable = make_shared<bool>(boost::any_cast<bool>(m["ResizeDiskEnable"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("UserDefinedEmrEcsRole") != m.end() && !m["UserDefinedEmrEcsRole"].empty()) {
      userDefinedEmrEcsRole = make_shared<string>(boost::any_cast<string>(m["UserDefinedEmrEcsRole"]));
    }
    if (m.find("MetaStoreType") != m.end() && !m["MetaStoreType"].empty()) {
      metaStoreType = make_shared<string>(boost::any_cast<string>(m["MetaStoreType"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Configurations") != m.end() && !m["Configurations"].empty()) {
      configurations = make_shared<string>(boost::any_cast<string>(m["Configurations"]));
    }
    if (m.find("LogPath") != m.end() && !m["LogPath"].empty()) {
      logPath = make_shared<string>(boost::any_cast<string>(m["LogPath"]));
    }
    if (m.find("AutoScalingVersion") != m.end() && !m["AutoScalingVersion"].empty()) {
      autoScalingVersion = make_shared<string>(boost::any_cast<string>(m["AutoScalingVersion"]));
    }
    if (m.find("NetType") != m.end() && !m["NetType"].empty()) {
      netType = make_shared<string>(boost::any_cast<string>(m["NetType"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("CreateResource") != m.end() && !m["CreateResource"].empty()) {
      createResource = make_shared<string>(boost::any_cast<string>(m["CreateResource"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("RunningTime") != m.end() && !m["RunningTime"].empty()) {
      runningTime = make_shared<long>(boost::any_cast<long>(m["RunningTime"]));
    }
    if (m.find("HighAvailabilityEnable") != m.end() && !m["HighAvailabilityEnable"].empty()) {
      highAvailabilityEnable = make_shared<bool>(boost::any_cast<bool>(m["HighAvailabilityEnable"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("AutoScalingAllowed") != m.end() && !m["AutoScalingAllowed"].empty()) {
      autoScalingAllowed = make_shared<bool>(boost::any_cast<bool>(m["AutoScalingAllowed"]));
    }
    if (m.find("MasterNodeInService") != m.end() && !m["MasterNodeInService"].empty()) {
      masterNodeInService = make_shared<long>(boost::any_cast<long>(m["MasterNodeInService"]));
    }
    if (m.find("AutoScalingEnable") != m.end() && !m["AutoScalingEnable"].empty()) {
      autoScalingEnable = make_shared<bool>(boost::any_cast<bool>(m["AutoScalingEnable"]));
    }
    if (m.find("AutoScalingWithGraceAllowed") != m.end() && !m["AutoScalingWithGraceAllowed"].empty()) {
      autoScalingWithGraceAllowed = make_shared<bool>(boost::any_cast<bool>(m["AutoScalingWithGraceAllowed"]));
    }
    if (m.find("CoreNodeInService") != m.end() && !m["CoreNodeInService"].empty()) {
      coreNodeInService = make_shared<long>(boost::any_cast<long>(m["CoreNodeInService"]));
    }
    if (m.find("ShowSoftwareInterface") != m.end() && !m["ShowSoftwareInterface"].empty()) {
      showSoftwareInterface = make_shared<bool>(boost::any_cast<bool>(m["ShowSoftwareInterface"]));
    }
    if (m.find("K8sClusterId") != m.end() && !m["K8sClusterId"].empty()) {
      k8sClusterId = make_shared<string>(boost::any_cast<string>(m["K8sClusterId"]));
    }
    if (m.find("AutoScalingByLoadAllowed") != m.end() && !m["AutoScalingByLoadAllowed"].empty()) {
      autoScalingByLoadAllowed = make_shared<bool>(boost::any_cast<bool>(m["AutoScalingByLoadAllowed"]));
    }
    if (m.find("LocalMetaDb") != m.end() && !m["LocalMetaDb"].empty()) {
      localMetaDb = make_shared<bool>(boost::any_cast<bool>(m["LocalMetaDb"]));
    }
    if (m.find("InstanceGeneration") != m.end() && !m["InstanceGeneration"].empty()) {
      instanceGeneration = make_shared<string>(boost::any_cast<string>(m["InstanceGeneration"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("EasEnable") != m.end() && !m["EasEnable"].empty()) {
      easEnable = make_shared<bool>(boost::any_cast<bool>(m["EasEnable"]));
    }
    if (m.find("MachineType") != m.end() && !m["MachineType"].empty()) {
      machineType = make_shared<string>(boost::any_cast<string>(m["MachineType"]));
    }
    if (m.find("MasterNodeTotal") != m.end() && !m["MasterNodeTotal"].empty()) {
      masterNodeTotal = make_shared<long>(boost::any_cast<long>(m["MasterNodeTotal"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("ExtraInfo") != m.end() && !m["ExtraInfo"].empty()) {
      extraInfo = make_shared<string>(boost::any_cast<string>(m["ExtraInfo"]));
    }
    if (m.find("IoOptimized") != m.end() && !m["IoOptimized"].empty()) {
      ioOptimized = make_shared<bool>(boost::any_cast<bool>(m["IoOptimized"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<long>(boost::any_cast<long>(m["ExpiredTime"]));
    }
    if (m.find("CoreNodeTotal") != m.end() && !m["CoreNodeTotal"].empty()) {
      coreNodeTotal = make_shared<long>(boost::any_cast<long>(m["CoreNodeTotal"]));
    }
    if (m.find("GatewayClusterIds") != m.end() && !m["GatewayClusterIds"].empty()) {
      gatewayClusterIds = make_shared<string>(boost::any_cast<string>(m["GatewayClusterIds"]));
    }
    if (m.find("BootstrapFailed") != m.end() && !m["BootstrapFailed"].empty()) {
      bootstrapFailed = make_shared<bool>(boost::any_cast<bool>(m["BootstrapFailed"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("TaskNodeTotal") != m.end() && !m["TaskNodeTotal"].empty()) {
      taskNodeTotal = make_shared<long>(boost::any_cast<long>(m["TaskNodeTotal"]));
    }
    if (m.find("GatewayClusterInfoList") != m.end() && !m["GatewayClusterInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["GatewayClusterInfoList"].type()) {
        DescribeClusterV2ResponseBodyClusterInfoGatewayClusterInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GatewayClusterInfoList"]));
        gatewayClusterInfoList = make_shared<DescribeClusterV2ResponseBodyClusterInfoGatewayClusterInfoList>(model1);
      }
    }
    if (m.find("HostGroupList") != m.end() && !m["HostGroupList"].empty()) {
      if (typeid(map<string, boost::any>) == m["HostGroupList"].type()) {
        DescribeClusterV2ResponseBodyClusterInfoHostGroupList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HostGroupList"]));
        hostGroupList = make_shared<DescribeClusterV2ResponseBodyClusterInfoHostGroupList>(model1);
      }
    }
    if (m.find("BootstrapActionList") != m.end() && !m["BootstrapActionList"].empty()) {
      if (typeid(map<string, boost::any>) == m["BootstrapActionList"].type()) {
        DescribeClusterV2ResponseBodyClusterInfoBootstrapActionList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BootstrapActionList"]));
        bootstrapActionList = make_shared<DescribeClusterV2ResponseBodyClusterInfoBootstrapActionList>(model1);
      }
    }
    if (m.find("RelateClusterInfo") != m.end() && !m["RelateClusterInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["RelateClusterInfo"].type()) {
        DescribeClusterV2ResponseBodyClusterInfoRelateClusterInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RelateClusterInfo"]));
        relateClusterInfo = make_shared<DescribeClusterV2ResponseBodyClusterInfoRelateClusterInfo>(model1);
      }
    }
    if (m.find("HostPoolInfo") != m.end() && !m["HostPoolInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["HostPoolInfo"].type()) {
        DescribeClusterV2ResponseBodyClusterInfoHostPoolInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HostPoolInfo"]));
        hostPoolInfo = make_shared<DescribeClusterV2ResponseBodyClusterInfoHostPoolInfo>(model1);
      }
    }
    if (m.find("FailReason") != m.end() && !m["FailReason"].empty()) {
      if (typeid(map<string, boost::any>) == m["FailReason"].type()) {
        DescribeClusterV2ResponseBodyClusterInfoFailReason model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FailReason"]));
        failReason = make_shared<DescribeClusterV2ResponseBodyClusterInfoFailReason>(model1);
      }
    }
    if (m.find("SoftwareInfo") != m.end() && !m["SoftwareInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["SoftwareInfo"].type()) {
        DescribeClusterV2ResponseBodyClusterInfoSoftwareInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SoftwareInfo"]));
        softwareInfo = make_shared<DescribeClusterV2ResponseBodyClusterInfoSoftwareInfo>(model1);
      }
    }
    if (m.find("AccessInfo") != m.end() && !m["AccessInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccessInfo"].type()) {
        DescribeClusterV2ResponseBodyClusterInfoAccessInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccessInfo"]));
        accessInfo = make_shared<DescribeClusterV2ResponseBodyClusterInfoAccessInfo>(model1);
      }
    }
  }


  virtual ~DescribeClusterV2ResponseBodyClusterInfo() = default;
};
class DescribeClusterV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeClusterV2ResponseBodyClusterInfo> clusterInfo{};

  DescribeClusterV2ResponseBody() {}

  explicit DescribeClusterV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (clusterInfo) {
      res["ClusterInfo"] = clusterInfo ? boost::any(clusterInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ClusterInfo") != m.end() && !m["ClusterInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClusterInfo"].type()) {
        DescribeClusterV2ResponseBodyClusterInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClusterInfo"]));
        clusterInfo = make_shared<DescribeClusterV2ResponseBodyClusterInfo>(model1);
      }
    }
  }


  virtual ~DescribeClusterV2ResponseBody() = default;
};
class DescribeClusterV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeClusterV2ResponseBody> body{};

  DescribeClusterV2Response() {}

  explicit DescribeClusterV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeClusterV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeClusterV2ResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeClusterV2Response() = default;
};
class DescribeFlowRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> id{};
  shared_ptr<string> regionId{};

  DescribeFlowRequest() {}

  explicit DescribeFlowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeFlowRequest() = default;
};
class DescribeFlowResponseBodyParentFlowListParentFlow : public Darabonba::Model {
public:
  shared_ptr<string> parentFlowName{};
  shared_ptr<string> parentFlowId{};
  shared_ptr<string> projectName{};
  shared_ptr<string> projectId{};

  DescribeFlowResponseBodyParentFlowListParentFlow() {}

  explicit DescribeFlowResponseBodyParentFlowListParentFlow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parentFlowName) {
      res["ParentFlowName"] = boost::any(*parentFlowName);
    }
    if (parentFlowId) {
      res["ParentFlowId"] = boost::any(*parentFlowId);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParentFlowName") != m.end() && !m["ParentFlowName"].empty()) {
      parentFlowName = make_shared<string>(boost::any_cast<string>(m["ParentFlowName"]));
    }
    if (m.find("ParentFlowId") != m.end() && !m["ParentFlowId"].empty()) {
      parentFlowId = make_shared<string>(boost::any_cast<string>(m["ParentFlowId"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~DescribeFlowResponseBodyParentFlowListParentFlow() = default;
};
class DescribeFlowResponseBodyParentFlowList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeFlowResponseBodyParentFlowListParentFlow>> parentFlow{};

  DescribeFlowResponseBodyParentFlowList() {}

  explicit DescribeFlowResponseBodyParentFlowList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parentFlow) {
      vector<boost::any> temp1;
      for(auto item1:*parentFlow){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ParentFlow"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParentFlow") != m.end() && !m["ParentFlow"].empty()) {
      if (typeid(vector<boost::any>) == m["ParentFlow"].type()) {
        vector<DescribeFlowResponseBodyParentFlowListParentFlow> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ParentFlow"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFlowResponseBodyParentFlowListParentFlow model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        parentFlow = make_shared<vector<DescribeFlowResponseBodyParentFlowListParentFlow>>(expect1);
      }
    }
  }


  virtual ~DescribeFlowResponseBodyParentFlowList() = default;
};
class DescribeFlowResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> type{};
  shared_ptr<string> alertUserGroupBizId{};
  shared_ptr<bool> periodic{};
  shared_ptr<string> editLockDetail{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> hostName{};
  shared_ptr<string> application{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> requestId{};
  shared_ptr<string> description{};
  shared_ptr<bool> createCluster{};
  shared_ptr<long> startSchedule{};
  shared_ptr<long> endSchedule{};
  shared_ptr<string> graph{};
  shared_ptr<string> alertDingDingGroupBizId{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<string> categoryId{};
  shared_ptr<string> cronExpr{};
  shared_ptr<string> name{};
  shared_ptr<string> id{};
  shared_ptr<string> alertConf{};
  shared_ptr<string> clusterId{};
  shared_ptr<DescribeFlowResponseBodyParentFlowList> parentFlowList{};

  DescribeFlowResponseBody() {}

  explicit DescribeFlowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (alertUserGroupBizId) {
      res["AlertUserGroupBizId"] = boost::any(*alertUserGroupBizId);
    }
    if (periodic) {
      res["Periodic"] = boost::any(*periodic);
    }
    if (editLockDetail) {
      res["EditLockDetail"] = boost::any(*editLockDetail);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (application) {
      res["Application"] = boost::any(*application);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (createCluster) {
      res["CreateCluster"] = boost::any(*createCluster);
    }
    if (startSchedule) {
      res["StartSchedule"] = boost::any(*startSchedule);
    }
    if (endSchedule) {
      res["EndSchedule"] = boost::any(*endSchedule);
    }
    if (graph) {
      res["Graph"] = boost::any(*graph);
    }
    if (alertDingDingGroupBizId) {
      res["AlertDingDingGroupBizId"] = boost::any(*alertDingDingGroupBizId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (cronExpr) {
      res["CronExpr"] = boost::any(*cronExpr);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (alertConf) {
      res["AlertConf"] = boost::any(*alertConf);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (parentFlowList) {
      res["ParentFlowList"] = parentFlowList ? boost::any(parentFlowList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("AlertUserGroupBizId") != m.end() && !m["AlertUserGroupBizId"].empty()) {
      alertUserGroupBizId = make_shared<string>(boost::any_cast<string>(m["AlertUserGroupBizId"]));
    }
    if (m.find("Periodic") != m.end() && !m["Periodic"].empty()) {
      periodic = make_shared<bool>(boost::any_cast<bool>(m["Periodic"]));
    }
    if (m.find("EditLockDetail") != m.end() && !m["EditLockDetail"].empty()) {
      editLockDetail = make_shared<string>(boost::any_cast<string>(m["EditLockDetail"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("Application") != m.end() && !m["Application"].empty()) {
      application = make_shared<string>(boost::any_cast<string>(m["Application"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("CreateCluster") != m.end() && !m["CreateCluster"].empty()) {
      createCluster = make_shared<bool>(boost::any_cast<bool>(m["CreateCluster"]));
    }
    if (m.find("StartSchedule") != m.end() && !m["StartSchedule"].empty()) {
      startSchedule = make_shared<long>(boost::any_cast<long>(m["StartSchedule"]));
    }
    if (m.find("EndSchedule") != m.end() && !m["EndSchedule"].empty()) {
      endSchedule = make_shared<long>(boost::any_cast<long>(m["EndSchedule"]));
    }
    if (m.find("Graph") != m.end() && !m["Graph"].empty()) {
      graph = make_shared<string>(boost::any_cast<string>(m["Graph"]));
    }
    if (m.find("AlertDingDingGroupBizId") != m.end() && !m["AlertDingDingGroupBizId"].empty()) {
      alertDingDingGroupBizId = make_shared<string>(boost::any_cast<string>(m["AlertDingDingGroupBizId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<string>(boost::any_cast<string>(m["CategoryId"]));
    }
    if (m.find("CronExpr") != m.end() && !m["CronExpr"].empty()) {
      cronExpr = make_shared<string>(boost::any_cast<string>(m["CronExpr"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("AlertConf") != m.end() && !m["AlertConf"].empty()) {
      alertConf = make_shared<string>(boost::any_cast<string>(m["AlertConf"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ParentFlowList") != m.end() && !m["ParentFlowList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ParentFlowList"].type()) {
        DescribeFlowResponseBodyParentFlowList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ParentFlowList"]));
        parentFlowList = make_shared<DescribeFlowResponseBodyParentFlowList>(model1);
      }
    }
  }


  virtual ~DescribeFlowResponseBody() = default;
};
class DescribeFlowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeFlowResponseBody> body{};

  DescribeFlowResponse() {}

  explicit DescribeFlowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFlowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFlowResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFlowResponse() = default;
};
class ListFlowClusterRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> projectId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceGroupId{};

  ListFlowClusterRequest() {}

  explicit ListFlowClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ListFlowClusterRequest() = default;
};
class ListFlowClusterResponseBodyClustersClusterInfoOrderTaskInfo : public Darabonba::Model {
public:
  shared_ptr<long> targetCount{};
  shared_ptr<long> currentCount{};
  shared_ptr<string> orderIdList{};

  ListFlowClusterResponseBodyClustersClusterInfoOrderTaskInfo() {}

  explicit ListFlowClusterResponseBodyClustersClusterInfoOrderTaskInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (targetCount) {
      res["TargetCount"] = boost::any(*targetCount);
    }
    if (currentCount) {
      res["CurrentCount"] = boost::any(*currentCount);
    }
    if (orderIdList) {
      res["OrderIdList"] = boost::any(*orderIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TargetCount") != m.end() && !m["TargetCount"].empty()) {
      targetCount = make_shared<long>(boost::any_cast<long>(m["TargetCount"]));
    }
    if (m.find("CurrentCount") != m.end() && !m["CurrentCount"].empty()) {
      currentCount = make_shared<long>(boost::any_cast<long>(m["CurrentCount"]));
    }
    if (m.find("OrderIdList") != m.end() && !m["OrderIdList"].empty()) {
      orderIdList = make_shared<string>(boost::any_cast<string>(m["OrderIdList"]));
    }
  }


  virtual ~ListFlowClusterResponseBodyClustersClusterInfoOrderTaskInfo() = default;
};
class ListFlowClusterResponseBodyClustersClusterInfoFailReason : public Darabonba::Model {
public:
  shared_ptr<string> errorMsg{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};

  ListFlowClusterResponseBodyClustersClusterInfoFailReason() {}

  explicit ListFlowClusterResponseBodyClustersClusterInfoFailReason(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
  }


  virtual ~ListFlowClusterResponseBodyClustersClusterInfoFailReason() = default;
};
class ListFlowClusterResponseBodyClustersClusterInfo : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> status{};
  shared_ptr<long> runningTime{};
  shared_ptr<string> orderList{};
  shared_ptr<long> createTime{};
  shared_ptr<string> chargeType{};
  shared_ptr<long> period{};
  shared_ptr<string> k8sClusterId{};
  shared_ptr<long> expiredTime{};
  shared_ptr<bool> hasUncompletedOrder{};
  shared_ptr<string> name{};
  shared_ptr<string> id{};
  shared_ptr<string> createResource{};
  shared_ptr<ListFlowClusterResponseBodyClustersClusterInfoOrderTaskInfo> orderTaskInfo{};
  shared_ptr<ListFlowClusterResponseBodyClustersClusterInfoFailReason> failReason{};

  ListFlowClusterResponseBodyClustersClusterInfo() {}

  explicit ListFlowClusterResponseBodyClustersClusterInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (runningTime) {
      res["RunningTime"] = boost::any(*runningTime);
    }
    if (orderList) {
      res["OrderList"] = boost::any(*orderList);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (k8sClusterId) {
      res["K8sClusterId"] = boost::any(*k8sClusterId);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (hasUncompletedOrder) {
      res["HasUncompletedOrder"] = boost::any(*hasUncompletedOrder);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (createResource) {
      res["CreateResource"] = boost::any(*createResource);
    }
    if (orderTaskInfo) {
      res["OrderTaskInfo"] = orderTaskInfo ? boost::any(orderTaskInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (failReason) {
      res["FailReason"] = failReason ? boost::any(failReason->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("RunningTime") != m.end() && !m["RunningTime"].empty()) {
      runningTime = make_shared<long>(boost::any_cast<long>(m["RunningTime"]));
    }
    if (m.find("OrderList") != m.end() && !m["OrderList"].empty()) {
      orderList = make_shared<string>(boost::any_cast<string>(m["OrderList"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("K8sClusterId") != m.end() && !m["K8sClusterId"].empty()) {
      k8sClusterId = make_shared<string>(boost::any_cast<string>(m["K8sClusterId"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<long>(boost::any_cast<long>(m["ExpiredTime"]));
    }
    if (m.find("HasUncompletedOrder") != m.end() && !m["HasUncompletedOrder"].empty()) {
      hasUncompletedOrder = make_shared<bool>(boost::any_cast<bool>(m["HasUncompletedOrder"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("CreateResource") != m.end() && !m["CreateResource"].empty()) {
      createResource = make_shared<string>(boost::any_cast<string>(m["CreateResource"]));
    }
    if (m.find("OrderTaskInfo") != m.end() && !m["OrderTaskInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["OrderTaskInfo"].type()) {
        ListFlowClusterResponseBodyClustersClusterInfoOrderTaskInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OrderTaskInfo"]));
        orderTaskInfo = make_shared<ListFlowClusterResponseBodyClustersClusterInfoOrderTaskInfo>(model1);
      }
    }
    if (m.find("FailReason") != m.end() && !m["FailReason"].empty()) {
      if (typeid(map<string, boost::any>) == m["FailReason"].type()) {
        ListFlowClusterResponseBodyClustersClusterInfoFailReason model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FailReason"]));
        failReason = make_shared<ListFlowClusterResponseBodyClustersClusterInfoFailReason>(model1);
      }
    }
  }


  virtual ~ListFlowClusterResponseBodyClustersClusterInfo() = default;
};
class ListFlowClusterResponseBodyClusters : public Darabonba::Model {
public:
  shared_ptr<vector<ListFlowClusterResponseBodyClustersClusterInfo>> clusterInfo{};

  ListFlowClusterResponseBodyClusters() {}

  explicit ListFlowClusterResponseBodyClusters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterInfo) {
      vector<boost::any> temp1;
      for(auto item1:*clusterInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ClusterInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterInfo") != m.end() && !m["ClusterInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ClusterInfo"].type()) {
        vector<ListFlowClusterResponseBodyClustersClusterInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ClusterInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFlowClusterResponseBodyClustersClusterInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clusterInfo = make_shared<vector<ListFlowClusterResponseBodyClustersClusterInfo>>(expect1);
      }
    }
  }


  virtual ~ListFlowClusterResponseBodyClusters() = default;
};
class ListFlowClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> totalCount{};
  shared_ptr<ListFlowClusterResponseBodyClusters> clusters{};

  ListFlowClusterResponseBody() {}

  explicit ListFlowClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (clusters) {
      res["Clusters"] = clusters ? boost::any(clusters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Clusters") != m.end() && !m["Clusters"].empty()) {
      if (typeid(map<string, boost::any>) == m["Clusters"].type()) {
        ListFlowClusterResponseBodyClusters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Clusters"]));
        clusters = make_shared<ListFlowClusterResponseBodyClusters>(model1);
      }
    }
  }


  virtual ~ListFlowClusterResponseBody() = default;
};
class ListFlowClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListFlowClusterResponseBody> body{};

  ListFlowClusterResponse() {}

  explicit ListFlowClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFlowClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFlowClusterResponseBody>(model1);
      }
    }
  }


  virtual ~ListFlowClusterResponse() = default;
};
class ListLdapUsersRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> userNameSearch{};

  ListLdapUsersRequest() {}

  explicit ListLdapUsersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (userNameSearch) {
      res["UserNameSearch"] = boost::any(*userNameSearch);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("UserNameSearch") != m.end() && !m["UserNameSearch"].empty()) {
      userNameSearch = make_shared<string>(boost::any_cast<string>(m["UserNameSearch"]));
    }
  }


  virtual ~ListLdapUsersRequest() = default;
};
class ListLdapUsersResponseBodyUserListUser : public Darabonba::Model {
public:
  shared_ptr<long> userCreateTime{};
  shared_ptr<string> groupName{};
  shared_ptr<string> userId{};
  shared_ptr<string> note{};
  shared_ptr<string> keytabHex{};
  shared_ptr<string> userName{};

  ListLdapUsersResponseBodyUserListUser() {}

  explicit ListLdapUsersResponseBodyUserListUser(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userCreateTime) {
      res["UserCreateTime"] = boost::any(*userCreateTime);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (note) {
      res["Note"] = boost::any(*note);
    }
    if (keytabHex) {
      res["KeytabHex"] = boost::any(*keytabHex);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserCreateTime") != m.end() && !m["UserCreateTime"].empty()) {
      userCreateTime = make_shared<long>(boost::any_cast<long>(m["UserCreateTime"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("Note") != m.end() && !m["Note"].empty()) {
      note = make_shared<string>(boost::any_cast<string>(m["Note"]));
    }
    if (m.find("KeytabHex") != m.end() && !m["KeytabHex"].empty()) {
      keytabHex = make_shared<string>(boost::any_cast<string>(m["KeytabHex"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~ListLdapUsersResponseBodyUserListUser() = default;
};
class ListLdapUsersResponseBodyUserList : public Darabonba::Model {
public:
  shared_ptr<vector<ListLdapUsersResponseBodyUserListUser>> user{};

  ListLdapUsersResponseBodyUserList() {}

  explicit ListLdapUsersResponseBodyUserList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (user) {
      vector<boost::any> temp1;
      for(auto item1:*user){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["User"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("User") != m.end() && !m["User"].empty()) {
      if (typeid(vector<boost::any>) == m["User"].type()) {
        vector<ListLdapUsersResponseBodyUserListUser> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["User"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLdapUsersResponseBodyUserListUser model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        user = make_shared<vector<ListLdapUsersResponseBodyUserListUser>>(expect1);
      }
    }
  }


  virtual ~ListLdapUsersResponseBodyUserList() = default;
};
class ListLdapUsersResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> isAdmin{};
  shared_ptr<string> requestId{};
  shared_ptr<ListLdapUsersResponseBodyUserList> userList{};

  ListLdapUsersResponseBody() {}

  explicit ListLdapUsersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isAdmin) {
      res["IsAdmin"] = boost::any(*isAdmin);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (userList) {
      res["UserList"] = userList ? boost::any(userList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsAdmin") != m.end() && !m["IsAdmin"].empty()) {
      isAdmin = make_shared<bool>(boost::any_cast<bool>(m["IsAdmin"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UserList") != m.end() && !m["UserList"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserList"].type()) {
        ListLdapUsersResponseBodyUserList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserList"]));
        userList = make_shared<ListLdapUsersResponseBodyUserList>(model1);
      }
    }
  }


  virtual ~ListLdapUsersResponseBody() = default;
};
class ListLdapUsersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListLdapUsersResponseBody> body{};

  ListLdapUsersResponse() {}

  explicit ListLdapUsersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLdapUsersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLdapUsersResponseBody>(model1);
      }
    }
  }


  virtual ~ListLdapUsersResponse() = default;
};
class DeleteUserRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> userId{};
  shared_ptr<string> type{};

  DeleteUserRequest() {}

  explicit DeleteUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DeleteUserRequest() = default;
};
class DeleteUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteUserResponseBody() {}

  explicit DeleteUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteUserResponseBody() = default;
};
class DeleteUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteUserResponseBody> body{};

  DeleteUserResponse() {}

  explicit DeleteUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteUserResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteUserResponse() = default;
};
class CreateFlowProjectClusterSettingRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> defaultUser{};
  shared_ptr<string> defaultQueue{};
  shared_ptr<string> clientToken{};
  shared_ptr<vector<string>> userList{};
  shared_ptr<vector<string>> queueList{};
  shared_ptr<vector<string>> hostList{};

  CreateFlowProjectClusterSettingRequest() {}

  explicit CreateFlowProjectClusterSettingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (defaultUser) {
      res["DefaultUser"] = boost::any(*defaultUser);
    }
    if (defaultQueue) {
      res["DefaultQueue"] = boost::any(*defaultQueue);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (userList) {
      res["UserList"] = boost::any(*userList);
    }
    if (queueList) {
      res["QueueList"] = boost::any(*queueList);
    }
    if (hostList) {
      res["HostList"] = boost::any(*hostList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DefaultUser") != m.end() && !m["DefaultUser"].empty()) {
      defaultUser = make_shared<string>(boost::any_cast<string>(m["DefaultUser"]));
    }
    if (m.find("DefaultQueue") != m.end() && !m["DefaultQueue"].empty()) {
      defaultQueue = make_shared<string>(boost::any_cast<string>(m["DefaultQueue"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("UserList") != m.end() && !m["UserList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("QueueList") != m.end() && !m["QueueList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["QueueList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["QueueList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      queueList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("HostList") != m.end() && !m["HostList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["HostList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["HostList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      hostList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateFlowProjectClusterSettingRequest() = default;
};
class CreateFlowProjectClusterSettingResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  CreateFlowProjectClusterSettingResponseBody() {}

  explicit CreateFlowProjectClusterSettingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateFlowProjectClusterSettingResponseBody() = default;
};
class CreateFlowProjectClusterSettingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateFlowProjectClusterSettingResponseBody> body{};

  CreateFlowProjectClusterSettingResponse() {}

  explicit CreateFlowProjectClusterSettingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateFlowProjectClusterSettingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateFlowProjectClusterSettingResponseBody>(model1);
      }
    }
  }


  virtual ~CreateFlowProjectClusterSettingResponse() = default;
};
class DescribeFlowInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> id{};
  shared_ptr<string> regionId{};

  DescribeFlowInstanceRequest() {}

  explicit DescribeFlowInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeFlowInstanceRequest() = default;
};
class DescribeFlowInstanceResponseBodyDependencyFlowListParentFlow : public Darabonba::Model {
public:
  shared_ptr<string> scheduleKey{};
  shared_ptr<long> bizDate{};
  shared_ptr<string> dependencyInstanceId{};
  shared_ptr<string> dependencyFlowId{};
  shared_ptr<bool> meet{};
  shared_ptr<string> flowInstanceId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> flowId{};

  DescribeFlowInstanceResponseBodyDependencyFlowListParentFlow() {}

  explicit DescribeFlowInstanceResponseBodyDependencyFlowListParentFlow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scheduleKey) {
      res["ScheduleKey"] = boost::any(*scheduleKey);
    }
    if (bizDate) {
      res["BizDate"] = boost::any(*bizDate);
    }
    if (dependencyInstanceId) {
      res["DependencyInstanceId"] = boost::any(*dependencyInstanceId);
    }
    if (dependencyFlowId) {
      res["DependencyFlowId"] = boost::any(*dependencyFlowId);
    }
    if (meet) {
      res["Meet"] = boost::any(*meet);
    }
    if (flowInstanceId) {
      res["FlowInstanceId"] = boost::any(*flowInstanceId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (flowId) {
      res["FlowId"] = boost::any(*flowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ScheduleKey") != m.end() && !m["ScheduleKey"].empty()) {
      scheduleKey = make_shared<string>(boost::any_cast<string>(m["ScheduleKey"]));
    }
    if (m.find("BizDate") != m.end() && !m["BizDate"].empty()) {
      bizDate = make_shared<long>(boost::any_cast<long>(m["BizDate"]));
    }
    if (m.find("DependencyInstanceId") != m.end() && !m["DependencyInstanceId"].empty()) {
      dependencyInstanceId = make_shared<string>(boost::any_cast<string>(m["DependencyInstanceId"]));
    }
    if (m.find("DependencyFlowId") != m.end() && !m["DependencyFlowId"].empty()) {
      dependencyFlowId = make_shared<string>(boost::any_cast<string>(m["DependencyFlowId"]));
    }
    if (m.find("Meet") != m.end() && !m["Meet"].empty()) {
      meet = make_shared<bool>(boost::any_cast<bool>(m["Meet"]));
    }
    if (m.find("FlowInstanceId") != m.end() && !m["FlowInstanceId"].empty()) {
      flowInstanceId = make_shared<string>(boost::any_cast<string>(m["FlowInstanceId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("FlowId") != m.end() && !m["FlowId"].empty()) {
      flowId = make_shared<string>(boost::any_cast<string>(m["FlowId"]));
    }
  }


  virtual ~DescribeFlowInstanceResponseBodyDependencyFlowListParentFlow() = default;
};
class DescribeFlowInstanceResponseBodyDependencyFlowList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeFlowInstanceResponseBodyDependencyFlowListParentFlow>> parentFlow{};

  DescribeFlowInstanceResponseBodyDependencyFlowList() {}

  explicit DescribeFlowInstanceResponseBodyDependencyFlowList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parentFlow) {
      vector<boost::any> temp1;
      for(auto item1:*parentFlow){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ParentFlow"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParentFlow") != m.end() && !m["ParentFlow"].empty()) {
      if (typeid(vector<boost::any>) == m["ParentFlow"].type()) {
        vector<DescribeFlowInstanceResponseBodyDependencyFlowListParentFlow> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ParentFlow"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFlowInstanceResponseBodyDependencyFlowListParentFlow model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        parentFlow = make_shared<vector<DescribeFlowInstanceResponseBodyDependencyFlowListParentFlow>>(expect1);
      }
    }
  }


  virtual ~DescribeFlowInstanceResponseBodyDependencyFlowList() = default;
};
class DescribeFlowInstanceResponseBodyNodeInstanceNodeInstance : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> type{};
  shared_ptr<string> failAct{};
  shared_ptr<string> projectId{};
  shared_ptr<string> retryInterval{};
  shared_ptr<string> jobType{};
  shared_ptr<string> hostName{};
  shared_ptr<string> externalInfo{};
  shared_ptr<long> gmtModified{};
  shared_ptr<long> retries{};
  shared_ptr<long> endTime{};
  shared_ptr<long> startTime{};
  shared_ptr<string> externalStatus{};
  shared_ptr<string> jobName{};
  shared_ptr<string> nodeName{};
  shared_ptr<string> jobId{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<string> externalId{};
  shared_ptr<long> duration{};
  shared_ptr<string> id{};
  shared_ptr<bool> pending{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> maxRetry{};

  DescribeFlowInstanceResponseBodyNodeInstanceNodeInstance() {}

  explicit DescribeFlowInstanceResponseBodyNodeInstanceNodeInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (failAct) {
      res["FailAct"] = boost::any(*failAct);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (retryInterval) {
      res["RetryInterval"] = boost::any(*retryInterval);
    }
    if (jobType) {
      res["JobType"] = boost::any(*jobType);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (externalInfo) {
      res["ExternalInfo"] = boost::any(*externalInfo);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (retries) {
      res["Retries"] = boost::any(*retries);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (externalStatus) {
      res["ExternalStatus"] = boost::any(*externalStatus);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (externalId) {
      res["ExternalId"] = boost::any(*externalId);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (pending) {
      res["Pending"] = boost::any(*pending);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (maxRetry) {
      res["MaxRetry"] = boost::any(*maxRetry);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("FailAct") != m.end() && !m["FailAct"].empty()) {
      failAct = make_shared<string>(boost::any_cast<string>(m["FailAct"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RetryInterval") != m.end() && !m["RetryInterval"].empty()) {
      retryInterval = make_shared<string>(boost::any_cast<string>(m["RetryInterval"]));
    }
    if (m.find("JobType") != m.end() && !m["JobType"].empty()) {
      jobType = make_shared<string>(boost::any_cast<string>(m["JobType"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("ExternalInfo") != m.end() && !m["ExternalInfo"].empty()) {
      externalInfo = make_shared<string>(boost::any_cast<string>(m["ExternalInfo"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("Retries") != m.end() && !m["Retries"].empty()) {
      retries = make_shared<long>(boost::any_cast<long>(m["Retries"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("ExternalStatus") != m.end() && !m["ExternalStatus"].empty()) {
      externalStatus = make_shared<string>(boost::any_cast<string>(m["ExternalStatus"]));
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("ExternalId") != m.end() && !m["ExternalId"].empty()) {
      externalId = make_shared<string>(boost::any_cast<string>(m["ExternalId"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Pending") != m.end() && !m["Pending"].empty()) {
      pending = make_shared<bool>(boost::any_cast<bool>(m["Pending"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("MaxRetry") != m.end() && !m["MaxRetry"].empty()) {
      maxRetry = make_shared<string>(boost::any_cast<string>(m["MaxRetry"]));
    }
  }


  virtual ~DescribeFlowInstanceResponseBodyNodeInstanceNodeInstance() = default;
};
class DescribeFlowInstanceResponseBodyNodeInstance : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeFlowInstanceResponseBodyNodeInstanceNodeInstance>> nodeInstance{};

  DescribeFlowInstanceResponseBodyNodeInstance() {}

  explicit DescribeFlowInstanceResponseBodyNodeInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeInstance) {
      vector<boost::any> temp1;
      for(auto item1:*nodeInstance){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NodeInstance"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeInstance") != m.end() && !m["NodeInstance"].empty()) {
      if (typeid(vector<boost::any>) == m["NodeInstance"].type()) {
        vector<DescribeFlowInstanceResponseBodyNodeInstanceNodeInstance> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NodeInstance"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFlowInstanceResponseBodyNodeInstanceNodeInstance model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodeInstance = make_shared<vector<DescribeFlowInstanceResponseBodyNodeInstanceNodeInstance>>(expect1);
      }
    }
  }


  virtual ~DescribeFlowInstanceResponseBodyNodeInstance() = default;
};
class DescribeFlowInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> projectId{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> flowName{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> flowId{};
  shared_ptr<string> cronExpression{};
  shared_ptr<long> endTime{};
  shared_ptr<long> startTime{};
  shared_ptr<bool> hasNodeFailed{};
  shared_ptr<string> requestId{};
  shared_ptr<string> graph{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> scheduleTime{};
  shared_ptr<long> duration{};
  shared_ptr<string> id{};
  shared_ptr<string> clusterId{};
  shared_ptr<DescribeFlowInstanceResponseBodyDependencyFlowList> dependencyFlowList{};
  shared_ptr<DescribeFlowInstanceResponseBodyNodeInstance> nodeInstance{};

  DescribeFlowInstanceResponseBody() {}

  explicit DescribeFlowInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (flowName) {
      res["FlowName"] = boost::any(*flowName);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (flowId) {
      res["FlowId"] = boost::any(*flowId);
    }
    if (cronExpression) {
      res["CronExpression"] = boost::any(*cronExpression);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (hasNodeFailed) {
      res["HasNodeFailed"] = boost::any(*hasNodeFailed);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (graph) {
      res["Graph"] = boost::any(*graph);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (scheduleTime) {
      res["ScheduleTime"] = boost::any(*scheduleTime);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (dependencyFlowList) {
      res["DependencyFlowList"] = dependencyFlowList ? boost::any(dependencyFlowList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nodeInstance) {
      res["NodeInstance"] = nodeInstance ? boost::any(nodeInstance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("FlowName") != m.end() && !m["FlowName"].empty()) {
      flowName = make_shared<string>(boost::any_cast<string>(m["FlowName"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("FlowId") != m.end() && !m["FlowId"].empty()) {
      flowId = make_shared<string>(boost::any_cast<string>(m["FlowId"]));
    }
    if (m.find("CronExpression") != m.end() && !m["CronExpression"].empty()) {
      cronExpression = make_shared<string>(boost::any_cast<string>(m["CronExpression"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("HasNodeFailed") != m.end() && !m["HasNodeFailed"].empty()) {
      hasNodeFailed = make_shared<bool>(boost::any_cast<bool>(m["HasNodeFailed"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Graph") != m.end() && !m["Graph"].empty()) {
      graph = make_shared<string>(boost::any_cast<string>(m["Graph"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("ScheduleTime") != m.end() && !m["ScheduleTime"].empty()) {
      scheduleTime = make_shared<long>(boost::any_cast<long>(m["ScheduleTime"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DependencyFlowList") != m.end() && !m["DependencyFlowList"].empty()) {
      if (typeid(map<string, boost::any>) == m["DependencyFlowList"].type()) {
        DescribeFlowInstanceResponseBodyDependencyFlowList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DependencyFlowList"]));
        dependencyFlowList = make_shared<DescribeFlowInstanceResponseBodyDependencyFlowList>(model1);
      }
    }
    if (m.find("NodeInstance") != m.end() && !m["NodeInstance"].empty()) {
      if (typeid(map<string, boost::any>) == m["NodeInstance"].type()) {
        DescribeFlowInstanceResponseBodyNodeInstance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NodeInstance"]));
        nodeInstance = make_shared<DescribeFlowInstanceResponseBodyNodeInstance>(model1);
      }
    }
  }


  virtual ~DescribeFlowInstanceResponseBody() = default;
};
class DescribeFlowInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeFlowInstanceResponseBody> body{};

  DescribeFlowInstanceResponse() {}

  explicit DescribeFlowInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFlowInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFlowInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFlowInstanceResponse() = default;
};
class CreateFlowProjectUserRequestUser : public Darabonba::Model {
public:
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  CreateFlowProjectUserRequestUser() {}

  explicit CreateFlowProjectUserRequestUser(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~CreateFlowProjectUserRequestUser() = default;
};
class CreateFlowProjectUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> clientToken{};
  shared_ptr<vector<CreateFlowProjectUserRequestUser>> user{};

  CreateFlowProjectUserRequest() {}

  explicit CreateFlowProjectUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (user) {
      vector<boost::any> temp1;
      for(auto item1:*user){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["User"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      if (typeid(vector<boost::any>) == m["User"].type()) {
        vector<CreateFlowProjectUserRequestUser> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["User"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateFlowProjectUserRequestUser model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        user = make_shared<vector<CreateFlowProjectUserRequestUser>>(expect1);
      }
    }
  }


  virtual ~CreateFlowProjectUserRequest() = default;
};
class CreateFlowProjectUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  CreateFlowProjectUserResponseBody() {}

  explicit CreateFlowProjectUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateFlowProjectUserResponseBody() = default;
};
class CreateFlowProjectUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateFlowProjectUserResponseBody> body{};

  CreateFlowProjectUserResponse() {}

  explicit CreateFlowProjectUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateFlowProjectUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateFlowProjectUserResponseBody>(model1);
      }
    }
  }


  virtual ~CreateFlowProjectUserResponse() = default;
};
class CreateFlowCategoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> parentId{};
  shared_ptr<string> clientToken{};

  CreateFlowCategoryRequest() {}

  explicit CreateFlowCategoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
  }


  virtual ~CreateFlowCategoryRequest() = default;
};
class CreateFlowCategoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  CreateFlowCategoryResponseBody() {}

  explicit CreateFlowCategoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateFlowCategoryResponseBody() = default;
};
class CreateFlowCategoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateFlowCategoryResponseBody> body{};

  CreateFlowCategoryResponse() {}

  explicit CreateFlowCategoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateFlowCategoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateFlowCategoryResponseBody>(model1);
      }
    }
  }


  virtual ~CreateFlowCategoryResponse() = default;
};
class DeleteFlowProjectClusterSettingRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> clusterId{};

  DeleteFlowProjectClusterSettingRequest() {}

  explicit DeleteFlowProjectClusterSettingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
  }


  virtual ~DeleteFlowProjectClusterSettingRequest() = default;
};
class DeleteFlowProjectClusterSettingResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  DeleteFlowProjectClusterSettingResponseBody() {}

  explicit DeleteFlowProjectClusterSettingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteFlowProjectClusterSettingResponseBody() = default;
};
class DeleteFlowProjectClusterSettingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteFlowProjectClusterSettingResponseBody> body{};

  DeleteFlowProjectClusterSettingResponse() {}

  explicit DeleteFlowProjectClusterSettingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteFlowProjectClusterSettingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteFlowProjectClusterSettingResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteFlowProjectClusterSettingResponse() = default;
};
class ListLibrariesRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> limit{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> currentSize{};
  shared_ptr<long> pageCount{};
  shared_ptr<string> orderField{};
  shared_ptr<string> orderMode{};
  shared_ptr<string> clusterBizId{};

  ListLibrariesRequest() {}

  explicit ListLibrariesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (limit) {
      res["Limit"] = boost::any(*limit);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentSize) {
      res["CurrentSize"] = boost::any(*currentSize);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (orderField) {
      res["OrderField"] = boost::any(*orderField);
    }
    if (orderMode) {
      res["OrderMode"] = boost::any(*orderMode);
    }
    if (clusterBizId) {
      res["ClusterBizId"] = boost::any(*clusterBizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Limit") != m.end() && !m["Limit"].empty()) {
      limit = make_shared<long>(boost::any_cast<long>(m["Limit"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("CurrentSize") != m.end() && !m["CurrentSize"].empty()) {
      currentSize = make_shared<long>(boost::any_cast<long>(m["CurrentSize"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("OrderField") != m.end() && !m["OrderField"].empty()) {
      orderField = make_shared<string>(boost::any_cast<string>(m["OrderField"]));
    }
    if (m.find("OrderMode") != m.end() && !m["OrderMode"].empty()) {
      orderMode = make_shared<string>(boost::any_cast<string>(m["OrderMode"]));
    }
    if (m.find("ClusterBizId") != m.end() && !m["ClusterBizId"].empty()) {
      clusterBizId = make_shared<string>(boost::any_cast<string>(m["ClusterBizId"]));
    }
  }


  virtual ~ListLibrariesRequest() = default;
};
class ListLibrariesResponseBodyItemsItem : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<long> createTime{};
  shared_ptr<string> userId{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> bizId{};
  shared_ptr<string> scope{};
  shared_ptr<string> libraryVersion{};
  shared_ptr<string> name{};
  shared_ptr<string> properties{};
  shared_ptr<string> sourceLocation{};

  ListLibrariesResponseBodyItemsItem() {}

  explicit ListLibrariesResponseBodyItemsItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (libraryVersion) {
      res["LibraryVersion"] = boost::any(*libraryVersion);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (properties) {
      res["Properties"] = boost::any(*properties);
    }
    if (sourceLocation) {
      res["SourceLocation"] = boost::any(*sourceLocation);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("LibraryVersion") != m.end() && !m["LibraryVersion"].empty()) {
      libraryVersion = make_shared<string>(boost::any_cast<string>(m["LibraryVersion"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Properties") != m.end() && !m["Properties"].empty()) {
      properties = make_shared<string>(boost::any_cast<string>(m["Properties"]));
    }
    if (m.find("SourceLocation") != m.end() && !m["SourceLocation"].empty()) {
      sourceLocation = make_shared<string>(boost::any_cast<string>(m["SourceLocation"]));
    }
  }


  virtual ~ListLibrariesResponseBodyItemsItem() = default;
};
class ListLibrariesResponseBodyItems : public Darabonba::Model {
public:
  shared_ptr<vector<ListLibrariesResponseBodyItemsItem>> item{};

  ListLibrariesResponseBodyItems() {}

  explicit ListLibrariesResponseBodyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (item) {
      vector<boost::any> temp1;
      for(auto item1:*item){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Item"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Item") != m.end() && !m["Item"].empty()) {
      if (typeid(vector<boost::any>) == m["Item"].type()) {
        vector<ListLibrariesResponseBodyItemsItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Item"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLibrariesResponseBodyItemsItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        item = make_shared<vector<ListLibrariesResponseBodyItemsItem>>(expect1);
      }
    }
  }


  virtual ~ListLibrariesResponseBodyItems() = default;
};
class ListLibrariesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<ListLibrariesResponseBodyItems> items{};

  ListLibrariesResponseBody() {}

  explicit ListLibrariesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (items) {
      res["Items"] = items ? boost::any(items->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(map<string, boost::any>) == m["Items"].type()) {
        ListLibrariesResponseBodyItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Items"]));
        items = make_shared<ListLibrariesResponseBodyItems>(model1);
      }
    }
  }


  virtual ~ListLibrariesResponseBody() = default;
};
class ListLibrariesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListLibrariesResponseBody> body{};

  ListLibrariesResponse() {}

  explicit ListLibrariesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLibrariesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLibrariesResponseBody>(model1);
      }
    }
  }


  virtual ~ListLibrariesResponse() = default;
};
class RunScalingActionRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> scalingActionType{};
  shared_ptr<string> scalingGroupBizId{};
  shared_ptr<string> actionParam{};

  RunScalingActionRequest() {}

  explicit RunScalingActionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (scalingActionType) {
      res["ScalingActionType"] = boost::any(*scalingActionType);
    }
    if (scalingGroupBizId) {
      res["ScalingGroupBizId"] = boost::any(*scalingGroupBizId);
    }
    if (actionParam) {
      res["ActionParam"] = boost::any(*actionParam);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ScalingActionType") != m.end() && !m["ScalingActionType"].empty()) {
      scalingActionType = make_shared<string>(boost::any_cast<string>(m["ScalingActionType"]));
    }
    if (m.find("ScalingGroupBizId") != m.end() && !m["ScalingGroupBizId"].empty()) {
      scalingGroupBizId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupBizId"]));
    }
    if (m.find("ActionParam") != m.end() && !m["ActionParam"].empty()) {
      actionParam = make_shared<string>(boost::any_cast<string>(m["ActionParam"]));
    }
  }


  virtual ~RunScalingActionRequest() = default;
};
class RunScalingActionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> data{};

  RunScalingActionResponseBody() {}

  explicit RunScalingActionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
  }


  virtual ~RunScalingActionResponseBody() = default;
};
class RunScalingActionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RunScalingActionResponseBody> body{};

  RunScalingActionResponse() {}

  explicit RunScalingActionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RunScalingActionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RunScalingActionResponseBody>(model1);
      }
    }
  }


  virtual ~RunScalingActionResponse() = default;
};
class InstallLibrariesRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> clusterBizIdList{};
  shared_ptr<string> libraryBizId{};

  InstallLibrariesRequest() {}

  explicit InstallLibrariesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (clusterBizIdList) {
      res["ClusterBizIdList"] = boost::any(*clusterBizIdList);
    }
    if (libraryBizId) {
      res["LibraryBizId"] = boost::any(*libraryBizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ClusterBizIdList") != m.end() && !m["ClusterBizIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ClusterBizIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ClusterBizIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      clusterBizIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LibraryBizId") != m.end() && !m["LibraryBizId"].empty()) {
      libraryBizId = make_shared<string>(boost::any_cast<string>(m["LibraryBizId"]));
    }
  }


  virtual ~InstallLibrariesRequest() = default;
};
class InstallLibrariesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  InstallLibrariesResponseBody() {}

  explicit InstallLibrariesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~InstallLibrariesResponseBody() = default;
};
class InstallLibrariesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<InstallLibrariesResponseBody> body{};

  InstallLibrariesResponse() {}

  explicit InstallLibrariesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InstallLibrariesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InstallLibrariesResponseBody>(model1);
      }
    }
  }


  virtual ~InstallLibrariesResponse() = default;
};
class ListFlowJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<bool> adhoc{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListFlowJobsRequest() {}

  explicit ListFlowJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (adhoc) {
      res["Adhoc"] = boost::any(*adhoc);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Adhoc") != m.end() && !m["Adhoc"].empty()) {
      adhoc = make_shared<bool>(boost::any_cast<bool>(m["Adhoc"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListFlowJobsRequest() = default;
};
class ListFlowJobsResponseBodyJobListJobResourceListResource : public Darabonba::Model {
public:
  shared_ptr<string> path{};
  shared_ptr<string> alias{};

  ListFlowJobsResponseBodyJobListJobResourceListResource() {}

  explicit ListFlowJobsResponseBodyJobListJobResourceListResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
  }


  virtual ~ListFlowJobsResponseBodyJobListJobResourceListResource() = default;
};
class ListFlowJobsResponseBodyJobListJobResourceList : public Darabonba::Model {
public:
  shared_ptr<vector<ListFlowJobsResponseBodyJobListJobResourceListResource>> resource{};

  ListFlowJobsResponseBodyJobListJobResourceList() {}

  explicit ListFlowJobsResponseBodyJobListJobResourceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resource) {
      vector<boost::any> temp1;
      for(auto item1:*resource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Resource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      if (typeid(vector<boost::any>) == m["Resource"].type()) {
        vector<ListFlowJobsResponseBodyJobListJobResourceListResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Resource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFlowJobsResponseBodyJobListJobResourceListResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resource = make_shared<vector<ListFlowJobsResponseBodyJobListJobResourceListResource>>(expect1);
      }
    }
  }


  virtual ~ListFlowJobsResponseBodyJobListJobResourceList() = default;
};
class ListFlowJobsResponseBodyJobListJob : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> failAct{};
  shared_ptr<string> customVariables{};
  shared_ptr<long> retryInterval{};
  shared_ptr<string> envConf{};
  shared_ptr<string> paramConf{};
  shared_ptr<string> mode{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> monitorConf{};
  shared_ptr<string> lastInstanceDetail{};
  shared_ptr<string> runConf{};
  shared_ptr<string> params{};
  shared_ptr<string> description{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<string> categoryId{};
  shared_ptr<string> adhoc{};
  shared_ptr<string> name{};
  shared_ptr<string> id{};
  shared_ptr<long> maxRetry{};
  shared_ptr<string> alertConf{};
  shared_ptr<ListFlowJobsResponseBodyJobListJobResourceList> resourceList{};

  ListFlowJobsResponseBodyJobListJob() {}

  explicit ListFlowJobsResponseBodyJobListJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (failAct) {
      res["FailAct"] = boost::any(*failAct);
    }
    if (customVariables) {
      res["CustomVariables"] = boost::any(*customVariables);
    }
    if (retryInterval) {
      res["RetryInterval"] = boost::any(*retryInterval);
    }
    if (envConf) {
      res["EnvConf"] = boost::any(*envConf);
    }
    if (paramConf) {
      res["ParamConf"] = boost::any(*paramConf);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (monitorConf) {
      res["MonitorConf"] = boost::any(*monitorConf);
    }
    if (lastInstanceDetail) {
      res["LastInstanceDetail"] = boost::any(*lastInstanceDetail);
    }
    if (runConf) {
      res["RunConf"] = boost::any(*runConf);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (adhoc) {
      res["Adhoc"] = boost::any(*adhoc);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (maxRetry) {
      res["MaxRetry"] = boost::any(*maxRetry);
    }
    if (alertConf) {
      res["AlertConf"] = boost::any(*alertConf);
    }
    if (resourceList) {
      res["ResourceList"] = resourceList ? boost::any(resourceList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("FailAct") != m.end() && !m["FailAct"].empty()) {
      failAct = make_shared<string>(boost::any_cast<string>(m["FailAct"]));
    }
    if (m.find("CustomVariables") != m.end() && !m["CustomVariables"].empty()) {
      customVariables = make_shared<string>(boost::any_cast<string>(m["CustomVariables"]));
    }
    if (m.find("RetryInterval") != m.end() && !m["RetryInterval"].empty()) {
      retryInterval = make_shared<long>(boost::any_cast<long>(m["RetryInterval"]));
    }
    if (m.find("EnvConf") != m.end() && !m["EnvConf"].empty()) {
      envConf = make_shared<string>(boost::any_cast<string>(m["EnvConf"]));
    }
    if (m.find("ParamConf") != m.end() && !m["ParamConf"].empty()) {
      paramConf = make_shared<string>(boost::any_cast<string>(m["ParamConf"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("MonitorConf") != m.end() && !m["MonitorConf"].empty()) {
      monitorConf = make_shared<string>(boost::any_cast<string>(m["MonitorConf"]));
    }
    if (m.find("LastInstanceDetail") != m.end() && !m["LastInstanceDetail"].empty()) {
      lastInstanceDetail = make_shared<string>(boost::any_cast<string>(m["LastInstanceDetail"]));
    }
    if (m.find("RunConf") != m.end() && !m["RunConf"].empty()) {
      runConf = make_shared<string>(boost::any_cast<string>(m["RunConf"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      params = make_shared<string>(boost::any_cast<string>(m["Params"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<string>(boost::any_cast<string>(m["CategoryId"]));
    }
    if (m.find("Adhoc") != m.end() && !m["Adhoc"].empty()) {
      adhoc = make_shared<string>(boost::any_cast<string>(m["Adhoc"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MaxRetry") != m.end() && !m["MaxRetry"].empty()) {
      maxRetry = make_shared<long>(boost::any_cast<long>(m["MaxRetry"]));
    }
    if (m.find("AlertConf") != m.end() && !m["AlertConf"].empty()) {
      alertConf = make_shared<string>(boost::any_cast<string>(m["AlertConf"]));
    }
    if (m.find("ResourceList") != m.end() && !m["ResourceList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourceList"].type()) {
        ListFlowJobsResponseBodyJobListJobResourceList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourceList"]));
        resourceList = make_shared<ListFlowJobsResponseBodyJobListJobResourceList>(model1);
      }
    }
  }


  virtual ~ListFlowJobsResponseBodyJobListJob() = default;
};
class ListFlowJobsResponseBodyJobList : public Darabonba::Model {
public:
  shared_ptr<vector<ListFlowJobsResponseBodyJobListJob>> job{};

  ListFlowJobsResponseBodyJobList() {}

  explicit ListFlowJobsResponseBodyJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (job) {
      vector<boost::any> temp1;
      for(auto item1:*job){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Job"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Job") != m.end() && !m["Job"].empty()) {
      if (typeid(vector<boost::any>) == m["Job"].type()) {
        vector<ListFlowJobsResponseBodyJobListJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Job"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFlowJobsResponseBodyJobListJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        job = make_shared<vector<ListFlowJobsResponseBodyJobListJob>>(expect1);
      }
    }
  }


  virtual ~ListFlowJobsResponseBodyJobList() = default;
};
class ListFlowJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};
  shared_ptr<ListFlowJobsResponseBodyJobList> jobList{};

  ListFlowJobsResponseBody() {}

  explicit ListFlowJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (jobList) {
      res["JobList"] = jobList ? boost::any(jobList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("JobList") != m.end() && !m["JobList"].empty()) {
      if (typeid(map<string, boost::any>) == m["JobList"].type()) {
        ListFlowJobsResponseBodyJobList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JobList"]));
        jobList = make_shared<ListFlowJobsResponseBodyJobList>(model1);
      }
    }
  }


  virtual ~ListFlowJobsResponseBody() = default;
};
class ListFlowJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListFlowJobsResponseBody> body{};

  ListFlowJobsResponse() {}

  explicit ListFlowJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFlowJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFlowJobsResponseBody>(model1);
      }
    }
  }


  virtual ~ListFlowJobsResponse() = default;
};
class ModifyFlowRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> status{};
  shared_ptr<string> description{};
  shared_ptr<bool> periodic{};
  shared_ptr<long> startSchedule{};
  shared_ptr<long> endSchedule{};
  shared_ptr<string> cronExpr{};
  shared_ptr<bool> createCluster{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> hostName{};
  shared_ptr<string> application{};
  shared_ptr<string> alertConf{};
  shared_ptr<string> alertUserGroupBizId{};
  shared_ptr<string> alertDingDingGroupBizId{};
  shared_ptr<string> parentFlowList{};
  shared_ptr<string> parentCategory{};

  ModifyFlowRequest() {}

  explicit ModifyFlowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (periodic) {
      res["Periodic"] = boost::any(*periodic);
    }
    if (startSchedule) {
      res["StartSchedule"] = boost::any(*startSchedule);
    }
    if (endSchedule) {
      res["EndSchedule"] = boost::any(*endSchedule);
    }
    if (cronExpr) {
      res["CronExpr"] = boost::any(*cronExpr);
    }
    if (createCluster) {
      res["CreateCluster"] = boost::any(*createCluster);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (application) {
      res["Application"] = boost::any(*application);
    }
    if (alertConf) {
      res["AlertConf"] = boost::any(*alertConf);
    }
    if (alertUserGroupBizId) {
      res["AlertUserGroupBizId"] = boost::any(*alertUserGroupBizId);
    }
    if (alertDingDingGroupBizId) {
      res["AlertDingDingGroupBizId"] = boost::any(*alertDingDingGroupBizId);
    }
    if (parentFlowList) {
      res["ParentFlowList"] = boost::any(*parentFlowList);
    }
    if (parentCategory) {
      res["ParentCategory"] = boost::any(*parentCategory);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Periodic") != m.end() && !m["Periodic"].empty()) {
      periodic = make_shared<bool>(boost::any_cast<bool>(m["Periodic"]));
    }
    if (m.find("StartSchedule") != m.end() && !m["StartSchedule"].empty()) {
      startSchedule = make_shared<long>(boost::any_cast<long>(m["StartSchedule"]));
    }
    if (m.find("EndSchedule") != m.end() && !m["EndSchedule"].empty()) {
      endSchedule = make_shared<long>(boost::any_cast<long>(m["EndSchedule"]));
    }
    if (m.find("CronExpr") != m.end() && !m["CronExpr"].empty()) {
      cronExpr = make_shared<string>(boost::any_cast<string>(m["CronExpr"]));
    }
    if (m.find("CreateCluster") != m.end() && !m["CreateCluster"].empty()) {
      createCluster = make_shared<bool>(boost::any_cast<bool>(m["CreateCluster"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("Application") != m.end() && !m["Application"].empty()) {
      application = make_shared<string>(boost::any_cast<string>(m["Application"]));
    }
    if (m.find("AlertConf") != m.end() && !m["AlertConf"].empty()) {
      alertConf = make_shared<string>(boost::any_cast<string>(m["AlertConf"]));
    }
    if (m.find("AlertUserGroupBizId") != m.end() && !m["AlertUserGroupBizId"].empty()) {
      alertUserGroupBizId = make_shared<string>(boost::any_cast<string>(m["AlertUserGroupBizId"]));
    }
    if (m.find("AlertDingDingGroupBizId") != m.end() && !m["AlertDingDingGroupBizId"].empty()) {
      alertDingDingGroupBizId = make_shared<string>(boost::any_cast<string>(m["AlertDingDingGroupBizId"]));
    }
    if (m.find("ParentFlowList") != m.end() && !m["ParentFlowList"].empty()) {
      parentFlowList = make_shared<string>(boost::any_cast<string>(m["ParentFlowList"]));
    }
    if (m.find("ParentCategory") != m.end() && !m["ParentCategory"].empty()) {
      parentCategory = make_shared<string>(boost::any_cast<string>(m["ParentCategory"]));
    }
  }


  virtual ~ModifyFlowRequest() = default;
};
class ModifyFlowResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  ModifyFlowResponseBody() {}

  explicit ModifyFlowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyFlowResponseBody() = default;
};
class ModifyFlowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyFlowResponseBody> body{};

  ModifyFlowResponse() {}

  explicit ModifyFlowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyFlowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyFlowResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyFlowResponse() = default;
};
class DescribeRegionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};

  DescribeRegionsRequest() {}

  explicit DescribeRegionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeRegionsRequest() = default;
};
class DescribeRegionsResponseBodyBusinessLocationsDistrict : public Darabonba::Model {
public:
  shared_ptr<string> ordering{};
  shared_ptr<string> cnName{};
  shared_ptr<string> showName{};
  shared_ptr<string> districtId{};
  shared_ptr<string> enName{};

  DescribeRegionsResponseBodyBusinessLocationsDistrict() {}

  explicit DescribeRegionsResponseBodyBusinessLocationsDistrict(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ordering) {
      res["Ordering"] = boost::any(*ordering);
    }
    if (cnName) {
      res["CnName"] = boost::any(*cnName);
    }
    if (showName) {
      res["ShowName"] = boost::any(*showName);
    }
    if (districtId) {
      res["DistrictId"] = boost::any(*districtId);
    }
    if (enName) {
      res["EnName"] = boost::any(*enName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ordering") != m.end() && !m["Ordering"].empty()) {
      ordering = make_shared<string>(boost::any_cast<string>(m["Ordering"]));
    }
    if (m.find("CnName") != m.end() && !m["CnName"].empty()) {
      cnName = make_shared<string>(boost::any_cast<string>(m["CnName"]));
    }
    if (m.find("ShowName") != m.end() && !m["ShowName"].empty()) {
      showName = make_shared<string>(boost::any_cast<string>(m["ShowName"]));
    }
    if (m.find("DistrictId") != m.end() && !m["DistrictId"].empty()) {
      districtId = make_shared<string>(boost::any_cast<string>(m["DistrictId"]));
    }
    if (m.find("EnName") != m.end() && !m["EnName"].empty()) {
      enName = make_shared<string>(boost::any_cast<string>(m["EnName"]));
    }
  }


  virtual ~DescribeRegionsResponseBodyBusinessLocationsDistrict() = default;
};
class DescribeRegionsResponseBodyBusinessLocations : public Darabonba::Model {
public:
  shared_ptr<string> ordering{};
  shared_ptr<string> type{};
  shared_ptr<string> showName{};
  shared_ptr<string> description{};
  shared_ptr<string> enDescription{};
  shared_ptr<string> enName{};
  shared_ptr<string> cnName{};
  shared_ptr<string> name{};
  shared_ptr<DescribeRegionsResponseBodyBusinessLocationsDistrict> district{};

  DescribeRegionsResponseBodyBusinessLocations() {}

  explicit DescribeRegionsResponseBodyBusinessLocations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ordering) {
      res["Ordering"] = boost::any(*ordering);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (showName) {
      res["ShowName"] = boost::any(*showName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enDescription) {
      res["EnDescription"] = boost::any(*enDescription);
    }
    if (enName) {
      res["EnName"] = boost::any(*enName);
    }
    if (cnName) {
      res["CnName"] = boost::any(*cnName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (district) {
      res["District"] = district ? boost::any(district->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ordering") != m.end() && !m["Ordering"].empty()) {
      ordering = make_shared<string>(boost::any_cast<string>(m["Ordering"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("ShowName") != m.end() && !m["ShowName"].empty()) {
      showName = make_shared<string>(boost::any_cast<string>(m["ShowName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnDescription") != m.end() && !m["EnDescription"].empty()) {
      enDescription = make_shared<string>(boost::any_cast<string>(m["EnDescription"]));
    }
    if (m.find("EnName") != m.end() && !m["EnName"].empty()) {
      enName = make_shared<string>(boost::any_cast<string>(m["EnName"]));
    }
    if (m.find("CnName") != m.end() && !m["CnName"].empty()) {
      cnName = make_shared<string>(boost::any_cast<string>(m["CnName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("District") != m.end() && !m["District"].empty()) {
      if (typeid(map<string, boost::any>) == m["District"].type()) {
        DescribeRegionsResponseBodyBusinessLocationsDistrict model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["District"]));
        district = make_shared<DescribeRegionsResponseBodyBusinessLocationsDistrict>(model1);
      }
    }
  }


  virtual ~DescribeRegionsResponseBodyBusinessLocations() = default;
};
class DescribeRegionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeRegionsResponseBodyBusinessLocations>> businessLocations{};

  DescribeRegionsResponseBody() {}

  explicit DescribeRegionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (businessLocations) {
      vector<boost::any> temp1;
      for(auto item1:*businessLocations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BusinessLocations"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("BusinessLocations") != m.end() && !m["BusinessLocations"].empty()) {
      if (typeid(vector<boost::any>) == m["BusinessLocations"].type()) {
        vector<DescribeRegionsResponseBodyBusinessLocations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BusinessLocations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRegionsResponseBodyBusinessLocations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        businessLocations = make_shared<vector<DescribeRegionsResponseBodyBusinessLocations>>(expect1);
      }
    }
  }


  virtual ~DescribeRegionsResponseBody() = default;
};
class DescribeRegionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeRegionsResponseBody> body{};

  DescribeRegionsResponse() {}

  explicit DescribeRegionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRegionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRegionsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRegionsResponse() = default;
};
class ListLibraryStatusRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> limit{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> currentSize{};
  shared_ptr<long> pageCount{};
  shared_ptr<string> orderField{};
  shared_ptr<string> orderMode{};
  shared_ptr<string> libraryBizId{};
  shared_ptr<string> clusterBizId{};

  ListLibraryStatusRequest() {}

  explicit ListLibraryStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (limit) {
      res["Limit"] = boost::any(*limit);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentSize) {
      res["CurrentSize"] = boost::any(*currentSize);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (orderField) {
      res["OrderField"] = boost::any(*orderField);
    }
    if (orderMode) {
      res["OrderMode"] = boost::any(*orderMode);
    }
    if (libraryBizId) {
      res["LibraryBizId"] = boost::any(*libraryBizId);
    }
    if (clusterBizId) {
      res["ClusterBizId"] = boost::any(*clusterBizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Limit") != m.end() && !m["Limit"].empty()) {
      limit = make_shared<long>(boost::any_cast<long>(m["Limit"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("CurrentSize") != m.end() && !m["CurrentSize"].empty()) {
      currentSize = make_shared<long>(boost::any_cast<long>(m["CurrentSize"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("OrderField") != m.end() && !m["OrderField"].empty()) {
      orderField = make_shared<string>(boost::any_cast<string>(m["OrderField"]));
    }
    if (m.find("OrderMode") != m.end() && !m["OrderMode"].empty()) {
      orderMode = make_shared<string>(boost::any_cast<string>(m["OrderMode"]));
    }
    if (m.find("LibraryBizId") != m.end() && !m["LibraryBizId"].empty()) {
      libraryBizId = make_shared<string>(boost::any_cast<string>(m["LibraryBizId"]));
    }
    if (m.find("ClusterBizId") != m.end() && !m["ClusterBizId"].empty()) {
      clusterBizId = make_shared<string>(boost::any_cast<string>(m["ClusterBizId"]));
    }
  }


  virtual ~ListLibraryStatusRequest() = default;
};
class ListLibraryStatusResponseBodyItemsItem : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> clusterBizId{};
  shared_ptr<string> libraryBizId{};
  shared_ptr<string> libraryName{};

  ListLibraryStatusResponseBodyItemsItem() {}

  explicit ListLibraryStatusResponseBodyItemsItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (clusterBizId) {
      res["ClusterBizId"] = boost::any(*clusterBizId);
    }
    if (libraryBizId) {
      res["LibraryBizId"] = boost::any(*libraryBizId);
    }
    if (libraryName) {
      res["LibraryName"] = boost::any(*libraryName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("ClusterBizId") != m.end() && !m["ClusterBizId"].empty()) {
      clusterBizId = make_shared<string>(boost::any_cast<string>(m["ClusterBizId"]));
    }
    if (m.find("LibraryBizId") != m.end() && !m["LibraryBizId"].empty()) {
      libraryBizId = make_shared<string>(boost::any_cast<string>(m["LibraryBizId"]));
    }
    if (m.find("LibraryName") != m.end() && !m["LibraryName"].empty()) {
      libraryName = make_shared<string>(boost::any_cast<string>(m["LibraryName"]));
    }
  }


  virtual ~ListLibraryStatusResponseBodyItemsItem() = default;
};
class ListLibraryStatusResponseBodyItems : public Darabonba::Model {
public:
  shared_ptr<vector<ListLibraryStatusResponseBodyItemsItem>> item{};

  ListLibraryStatusResponseBodyItems() {}

  explicit ListLibraryStatusResponseBodyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (item) {
      vector<boost::any> temp1;
      for(auto item1:*item){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Item"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Item") != m.end() && !m["Item"].empty()) {
      if (typeid(vector<boost::any>) == m["Item"].type()) {
        vector<ListLibraryStatusResponseBodyItemsItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Item"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLibraryStatusResponseBodyItemsItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        item = make_shared<vector<ListLibraryStatusResponseBodyItemsItem>>(expect1);
      }
    }
  }


  virtual ~ListLibraryStatusResponseBodyItems() = default;
};
class ListLibraryStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<ListLibraryStatusResponseBodyItems> items{};

  ListLibraryStatusResponseBody() {}

  explicit ListLibraryStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (items) {
      res["Items"] = items ? boost::any(items->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(map<string, boost::any>) == m["Items"].type()) {
        ListLibraryStatusResponseBodyItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Items"]));
        items = make_shared<ListLibraryStatusResponseBodyItems>(model1);
      }
    }
  }


  virtual ~ListLibraryStatusResponseBody() = default;
};
class ListLibraryStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListLibraryStatusResponseBody> body{};

  ListLibraryStatusResponse() {}

  explicit ListLibraryStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLibraryStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLibraryStatusResponseBody>(model1);
      }
    }
  }


  virtual ~ListLibraryStatusResponse() = default;
};
class DescribeClusterServiceConfigRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> configVersion{};
  shared_ptr<string> groupId{};
  shared_ptr<string> hostInstanceId{};
  shared_ptr<string> tagValue{};

  DescribeClusterServiceConfigRequest() {}

  explicit DescribeClusterServiceConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (configVersion) {
      res["ConfigVersion"] = boost::any(*configVersion);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (hostInstanceId) {
      res["HostInstanceId"] = boost::any(*hostInstanceId);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("ConfigVersion") != m.end() && !m["ConfigVersion"].empty()) {
      configVersion = make_shared<string>(boost::any_cast<string>(m["ConfigVersion"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("HostInstanceId") != m.end() && !m["HostInstanceId"].empty()) {
      hostInstanceId = make_shared<string>(boost::any_cast<string>(m["HostInstanceId"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~DescribeClusterServiceConfigRequest() = default;
};
class DescribeClusterServiceConfigResponseBodyConfigConfigValueListConfigValueConfigItemValueListConfigItemValue : public Darabonba::Model {
public:
  shared_ptr<string> value{};
  shared_ptr<string> description{};
  shared_ptr<string> itemName{};
  shared_ptr<bool> isCustom{};

  DescribeClusterServiceConfigResponseBodyConfigConfigValueListConfigValueConfigItemValueListConfigItemValue() {}

  explicit DescribeClusterServiceConfigResponseBodyConfigConfigValueListConfigValueConfigItemValueListConfigItemValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (itemName) {
      res["ItemName"] = boost::any(*itemName);
    }
    if (isCustom) {
      res["IsCustom"] = boost::any(*isCustom);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ItemName") != m.end() && !m["ItemName"].empty()) {
      itemName = make_shared<string>(boost::any_cast<string>(m["ItemName"]));
    }
    if (m.find("IsCustom") != m.end() && !m["IsCustom"].empty()) {
      isCustom = make_shared<bool>(boost::any_cast<bool>(m["IsCustom"]));
    }
  }


  virtual ~DescribeClusterServiceConfigResponseBodyConfigConfigValueListConfigValueConfigItemValueListConfigItemValue() = default;
};
class DescribeClusterServiceConfigResponseBodyConfigConfigValueListConfigValueConfigItemValueList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeClusterServiceConfigResponseBodyConfigConfigValueListConfigValueConfigItemValueListConfigItemValue>> configItemValue{};

  DescribeClusterServiceConfigResponseBodyConfigConfigValueListConfigValueConfigItemValueList() {}

  explicit DescribeClusterServiceConfigResponseBodyConfigConfigValueListConfigValueConfigItemValueList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configItemValue) {
      vector<boost::any> temp1;
      for(auto item1:*configItemValue){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigItemValue"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigItemValue") != m.end() && !m["ConfigItemValue"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigItemValue"].type()) {
        vector<DescribeClusterServiceConfigResponseBodyConfigConfigValueListConfigValueConfigItemValueListConfigItemValue> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigItemValue"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterServiceConfigResponseBodyConfigConfigValueListConfigValueConfigItemValueListConfigItemValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configItemValue = make_shared<vector<DescribeClusterServiceConfigResponseBodyConfigConfigValueListConfigValueConfigItemValueListConfigItemValue>>(expect1);
      }
    }
  }


  virtual ~DescribeClusterServiceConfigResponseBodyConfigConfigValueListConfigValueConfigItemValueList() = default;
};
class DescribeClusterServiceConfigResponseBodyConfigConfigValueListConfigValue : public Darabonba::Model {
public:
  shared_ptr<string> configName{};
  shared_ptr<long> scopeId{};
  shared_ptr<string> scope{};
  shared_ptr<bool> allowCustom{};
  shared_ptr<DescribeClusterServiceConfigResponseBodyConfigConfigValueListConfigValueConfigItemValueList> configItemValueList{};

  DescribeClusterServiceConfigResponseBodyConfigConfigValueListConfigValue() {}

  explicit DescribeClusterServiceConfigResponseBodyConfigConfigValueListConfigValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configName) {
      res["ConfigName"] = boost::any(*configName);
    }
    if (scopeId) {
      res["ScopeId"] = boost::any(*scopeId);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (allowCustom) {
      res["AllowCustom"] = boost::any(*allowCustom);
    }
    if (configItemValueList) {
      res["ConfigItemValueList"] = configItemValueList ? boost::any(configItemValueList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigName") != m.end() && !m["ConfigName"].empty()) {
      configName = make_shared<string>(boost::any_cast<string>(m["ConfigName"]));
    }
    if (m.find("ScopeId") != m.end() && !m["ScopeId"].empty()) {
      scopeId = make_shared<long>(boost::any_cast<long>(m["ScopeId"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("AllowCustom") != m.end() && !m["AllowCustom"].empty()) {
      allowCustom = make_shared<bool>(boost::any_cast<bool>(m["AllowCustom"]));
    }
    if (m.find("ConfigItemValueList") != m.end() && !m["ConfigItemValueList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConfigItemValueList"].type()) {
        DescribeClusterServiceConfigResponseBodyConfigConfigValueListConfigValueConfigItemValueList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConfigItemValueList"]));
        configItemValueList = make_shared<DescribeClusterServiceConfigResponseBodyConfigConfigValueListConfigValueConfigItemValueList>(model1);
      }
    }
  }


  virtual ~DescribeClusterServiceConfigResponseBodyConfigConfigValueListConfigValue() = default;
};
class DescribeClusterServiceConfigResponseBodyConfigConfigValueList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeClusterServiceConfigResponseBodyConfigConfigValueListConfigValue>> configValue{};

  DescribeClusterServiceConfigResponseBodyConfigConfigValueList() {}

  explicit DescribeClusterServiceConfigResponseBodyConfigConfigValueList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configValue) {
      vector<boost::any> temp1;
      for(auto item1:*configValue){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigValue"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigValue") != m.end() && !m["ConfigValue"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigValue"].type()) {
        vector<DescribeClusterServiceConfigResponseBodyConfigConfigValueListConfigValue> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigValue"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterServiceConfigResponseBodyConfigConfigValueListConfigValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configValue = make_shared<vector<DescribeClusterServiceConfigResponseBodyConfigConfigValueListConfigValue>>(expect1);
      }
    }
  }


  virtual ~DescribeClusterServiceConfigResponseBodyConfigConfigValueList() = default;
};
class DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyTypes : public Darabonba::Model {
public:
  shared_ptr<vector<string>> propertyType{};

  DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyTypes() {}

  explicit DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyTypes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (propertyType) {
      res["PropertyType"] = boost::any(*propertyType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PropertyType") != m.end() && !m["PropertyType"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PropertyType"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PropertyType"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      propertyType = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyTypes() = default;
};
class DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyValueAttributesEntriesValueEntryInfo : public Darabonba::Model {
public:
  shared_ptr<string> value{};
  shared_ptr<string> label{};
  shared_ptr<string> description{};

  DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyValueAttributesEntriesValueEntryInfo() {}

  explicit DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyValueAttributesEntriesValueEntryInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyValueAttributesEntriesValueEntryInfo() = default;
};
class DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyValueAttributesEntries : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyValueAttributesEntriesValueEntryInfo>> valueEntryInfo{};

  DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyValueAttributesEntries() {}

  explicit DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyValueAttributesEntries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (valueEntryInfo) {
      vector<boost::any> temp1;
      for(auto item1:*valueEntryInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ValueEntryInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ValueEntryInfo") != m.end() && !m["ValueEntryInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ValueEntryInfo"].type()) {
        vector<DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyValueAttributesEntriesValueEntryInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ValueEntryInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyValueAttributesEntriesValueEntryInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        valueEntryInfo = make_shared<vector<DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyValueAttributesEntriesValueEntryInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyValueAttributesEntries() = default;
};
class DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyValueAttributes : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> maximum{};
  shared_ptr<string> unit{};
  shared_ptr<bool> hidden{};
  shared_ptr<string> incrememtStep{};
  shared_ptr<bool> readOnly{};
  shared_ptr<string> mimimum{};
  shared_ptr<DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyValueAttributesEntries> entries{};

  DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyValueAttributes() {}

  explicit DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyValueAttributes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (maximum) {
      res["Maximum"] = boost::any(*maximum);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (hidden) {
      res["Hidden"] = boost::any(*hidden);
    }
    if (incrememtStep) {
      res["IncrememtStep"] = boost::any(*incrememtStep);
    }
    if (readOnly) {
      res["ReadOnly"] = boost::any(*readOnly);
    }
    if (mimimum) {
      res["Mimimum"] = boost::any(*mimimum);
    }
    if (entries) {
      res["Entries"] = entries ? boost::any(entries->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Maximum") != m.end() && !m["Maximum"].empty()) {
      maximum = make_shared<string>(boost::any_cast<string>(m["Maximum"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Hidden") != m.end() && !m["Hidden"].empty()) {
      hidden = make_shared<bool>(boost::any_cast<bool>(m["Hidden"]));
    }
    if (m.find("IncrememtStep") != m.end() && !m["IncrememtStep"].empty()) {
      incrememtStep = make_shared<string>(boost::any_cast<string>(m["IncrememtStep"]));
    }
    if (m.find("ReadOnly") != m.end() && !m["ReadOnly"].empty()) {
      readOnly = make_shared<bool>(boost::any_cast<bool>(m["ReadOnly"]));
    }
    if (m.find("Mimimum") != m.end() && !m["Mimimum"].empty()) {
      mimimum = make_shared<string>(boost::any_cast<string>(m["Mimimum"]));
    }
    if (m.find("Entries") != m.end() && !m["Entries"].empty()) {
      if (typeid(map<string, boost::any>) == m["Entries"].type()) {
        DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyValueAttributesEntries model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Entries"]));
        entries = make_shared<DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyValueAttributesEntries>(model1);
      }
    }
  }


  virtual ~DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyValueAttributes() = default;
};
class DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoEffectWay : public Darabonba::Model {
public:
  shared_ptr<string> effectType{};
  shared_ptr<string> invokeServiceName{};

  DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoEffectWay() {}

  explicit DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoEffectWay(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (effectType) {
      res["EffectType"] = boost::any(*effectType);
    }
    if (invokeServiceName) {
      res["InvokeServiceName"] = boost::any(*invokeServiceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EffectType") != m.end() && !m["EffectType"].empty()) {
      effectType = make_shared<string>(boost::any_cast<string>(m["EffectType"]));
    }
    if (m.find("InvokeServiceName") != m.end() && !m["InvokeServiceName"].empty()) {
      invokeServiceName = make_shared<string>(boost::any_cast<string>(m["InvokeServiceName"]));
    }
  }


  virtual ~DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoEffectWay() = default;
};
class DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfo : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> value{};
  shared_ptr<string> description{};
  shared_ptr<string> component{};
  shared_ptr<string> fileName{};
  shared_ptr<string> name{};
  shared_ptr<string> serviceName{};
  shared_ptr<DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyTypes> propertyTypes{};
  shared_ptr<DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyValueAttributes> propertyValueAttributes{};
  shared_ptr<DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoEffectWay> effectWay{};

  DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfo() {}

  explicit DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (component) {
      res["Component"] = boost::any(*component);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (propertyTypes) {
      res["PropertyTypes"] = propertyTypes ? boost::any(propertyTypes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (propertyValueAttributes) {
      res["PropertyValueAttributes"] = propertyValueAttributes ? boost::any(propertyValueAttributes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (effectWay) {
      res["EffectWay"] = effectWay ? boost::any(effectWay->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Component") != m.end() && !m["Component"].empty()) {
      component = make_shared<string>(boost::any_cast<string>(m["Component"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("PropertyTypes") != m.end() && !m["PropertyTypes"].empty()) {
      if (typeid(map<string, boost::any>) == m["PropertyTypes"].type()) {
        DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyTypes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PropertyTypes"]));
        propertyTypes = make_shared<DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyTypes>(model1);
      }
    }
    if (m.find("PropertyValueAttributes") != m.end() && !m["PropertyValueAttributes"].empty()) {
      if (typeid(map<string, boost::any>) == m["PropertyValueAttributes"].type()) {
        DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyValueAttributes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PropertyValueAttributes"]));
        propertyValueAttributes = make_shared<DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyValueAttributes>(model1);
      }
    }
    if (m.find("EffectWay") != m.end() && !m["EffectWay"].empty()) {
      if (typeid(map<string, boost::any>) == m["EffectWay"].type()) {
        DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoEffectWay model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EffectWay"]));
        effectWay = make_shared<DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoEffectWay>(model1);
      }
    }
  }


  virtual ~DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfo() = default;
};
class DescribeClusterServiceConfigResponseBodyConfigPropertyInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfo>> propertyInfo{};

  DescribeClusterServiceConfigResponseBodyConfigPropertyInfoList() {}

  explicit DescribeClusterServiceConfigResponseBodyConfigPropertyInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (propertyInfo) {
      vector<boost::any> temp1;
      for(auto item1:*propertyInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PropertyInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PropertyInfo") != m.end() && !m["PropertyInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["PropertyInfo"].type()) {
        vector<DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PropertyInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        propertyInfo = make_shared<vector<DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeClusterServiceConfigResponseBodyConfigPropertyInfoList() = default;
};
class DescribeClusterServiceConfigResponseBodyConfig : public Darabonba::Model {
public:
  shared_ptr<string> applied{};
  shared_ptr<string> comment{};
  shared_ptr<string> createTime{};
  shared_ptr<string> configVersion{};
  shared_ptr<string> author{};
  shared_ptr<string> serviceName{};
  shared_ptr<DescribeClusterServiceConfigResponseBodyConfigConfigValueList> configValueList{};
  shared_ptr<DescribeClusterServiceConfigResponseBodyConfigPropertyInfoList> propertyInfoList{};

  DescribeClusterServiceConfigResponseBodyConfig() {}

  explicit DescribeClusterServiceConfigResponseBodyConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applied) {
      res["Applied"] = boost::any(*applied);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (configVersion) {
      res["ConfigVersion"] = boost::any(*configVersion);
    }
    if (author) {
      res["Author"] = boost::any(*author);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (configValueList) {
      res["ConfigValueList"] = configValueList ? boost::any(configValueList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (propertyInfoList) {
      res["PropertyInfoList"] = propertyInfoList ? boost::any(propertyInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Applied") != m.end() && !m["Applied"].empty()) {
      applied = make_shared<string>(boost::any_cast<string>(m["Applied"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("ConfigVersion") != m.end() && !m["ConfigVersion"].empty()) {
      configVersion = make_shared<string>(boost::any_cast<string>(m["ConfigVersion"]));
    }
    if (m.find("Author") != m.end() && !m["Author"].empty()) {
      author = make_shared<string>(boost::any_cast<string>(m["Author"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("ConfigValueList") != m.end() && !m["ConfigValueList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConfigValueList"].type()) {
        DescribeClusterServiceConfigResponseBodyConfigConfigValueList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConfigValueList"]));
        configValueList = make_shared<DescribeClusterServiceConfigResponseBodyConfigConfigValueList>(model1);
      }
    }
    if (m.find("PropertyInfoList") != m.end() && !m["PropertyInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["PropertyInfoList"].type()) {
        DescribeClusterServiceConfigResponseBodyConfigPropertyInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PropertyInfoList"]));
        propertyInfoList = make_shared<DescribeClusterServiceConfigResponseBodyConfigPropertyInfoList>(model1);
      }
    }
  }


  virtual ~DescribeClusterServiceConfigResponseBodyConfig() = default;
};
class DescribeClusterServiceConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeClusterServiceConfigResponseBodyConfig> config{};

  DescribeClusterServiceConfigResponseBody() {}

  explicit DescribeClusterServiceConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (config) {
      res["Config"] = config ? boost::any(config->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      if (typeid(map<string, boost::any>) == m["Config"].type()) {
        DescribeClusterServiceConfigResponseBodyConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Config"]));
        config = make_shared<DescribeClusterServiceConfigResponseBodyConfig>(model1);
      }
    }
  }


  virtual ~DescribeClusterServiceConfigResponseBody() = default;
};
class DescribeClusterServiceConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeClusterServiceConfigResponseBody> body{};

  DescribeClusterServiceConfigResponse() {}

  explicit DescribeClusterServiceConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeClusterServiceConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeClusterServiceConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeClusterServiceConfigResponse() = default;
};
class ModifyFlowProjectClusterSettingRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> defaultUser{};
  shared_ptr<string> defaultQueue{};
  shared_ptr<vector<string>> userList{};
  shared_ptr<vector<string>> queueList{};
  shared_ptr<vector<string>> hostList{};

  ModifyFlowProjectClusterSettingRequest() {}

  explicit ModifyFlowProjectClusterSettingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (defaultUser) {
      res["DefaultUser"] = boost::any(*defaultUser);
    }
    if (defaultQueue) {
      res["DefaultQueue"] = boost::any(*defaultQueue);
    }
    if (userList) {
      res["UserList"] = boost::any(*userList);
    }
    if (queueList) {
      res["QueueList"] = boost::any(*queueList);
    }
    if (hostList) {
      res["HostList"] = boost::any(*hostList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DefaultUser") != m.end() && !m["DefaultUser"].empty()) {
      defaultUser = make_shared<string>(boost::any_cast<string>(m["DefaultUser"]));
    }
    if (m.find("DefaultQueue") != m.end() && !m["DefaultQueue"].empty()) {
      defaultQueue = make_shared<string>(boost::any_cast<string>(m["DefaultQueue"]));
    }
    if (m.find("UserList") != m.end() && !m["UserList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("QueueList") != m.end() && !m["QueueList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["QueueList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["QueueList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      queueList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("HostList") != m.end() && !m["HostList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["HostList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["HostList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      hostList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ModifyFlowProjectClusterSettingRequest() = default;
};
class ModifyFlowProjectClusterSettingResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  ModifyFlowProjectClusterSettingResponseBody() {}

  explicit ModifyFlowProjectClusterSettingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyFlowProjectClusterSettingResponseBody() = default;
};
class ModifyFlowProjectClusterSettingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyFlowProjectClusterSettingResponseBody> body{};

  ModifyFlowProjectClusterSettingResponse() {}

  explicit ModifyFlowProjectClusterSettingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyFlowProjectClusterSettingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyFlowProjectClusterSettingResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyFlowProjectClusterSettingResponse() = default;
};
class DeleteFlowProjectUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> userName{};

  DeleteFlowProjectUserRequest() {}

  explicit DeleteFlowProjectUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~DeleteFlowProjectUserRequest() = default;
};
class DeleteFlowProjectUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  DeleteFlowProjectUserResponseBody() {}

  explicit DeleteFlowProjectUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteFlowProjectUserResponseBody() = default;
};
class DeleteFlowProjectUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteFlowProjectUserResponseBody> body{};

  DeleteFlowProjectUserResponse() {}

  explicit DeleteFlowProjectUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteFlowProjectUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteFlowProjectUserResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteFlowProjectUserResponse() = default;
};
class CreateClusterV2RequestUserInfo : public Darabonba::Model {
public:
  shared_ptr<string> password{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  CreateClusterV2RequestUserInfo() {}

  explicit CreateClusterV2RequestUserInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~CreateClusterV2RequestUserInfo() = default;
};
class CreateClusterV2RequestHostComponentInfo : public Darabonba::Model {
public:
  shared_ptr<vector<string>> componentNameList{};
  shared_ptr<string> hostName{};
  shared_ptr<string> serviceName{};

  CreateClusterV2RequestHostComponentInfo() {}

  explicit CreateClusterV2RequestHostComponentInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (componentNameList) {
      res["ComponentNameList"] = boost::any(*componentNameList);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComponentNameList") != m.end() && !m["ComponentNameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ComponentNameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ComponentNameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      componentNameList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~CreateClusterV2RequestHostComponentInfo() = default;
};
class CreateClusterV2RequestServiceInfo : public Darabonba::Model {
public:
  shared_ptr<string> serviceName{};
  shared_ptr<string> serviceVersion{};

  CreateClusterV2RequestServiceInfo() {}

  explicit CreateClusterV2RequestServiceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (serviceVersion) {
      res["ServiceVersion"] = boost::any(*serviceVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("ServiceVersion") != m.end() && !m["ServiceVersion"].empty()) {
      serviceVersion = make_shared<string>(boost::any_cast<string>(m["ServiceVersion"]));
    }
  }


  virtual ~CreateClusterV2RequestServiceInfo() = default;
};
class CreateClusterV2RequestPromotionInfo : public Darabonba::Model {
public:
  shared_ptr<string> productCode{};
  shared_ptr<string> promotionOptionCode{};
  shared_ptr<string> promotionOptionNo{};

  CreateClusterV2RequestPromotionInfo() {}

  explicit CreateClusterV2RequestPromotionInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productCode) {
      res["ProductCode"] = boost::any(*productCode);
    }
    if (promotionOptionCode) {
      res["PromotionOptionCode"] = boost::any(*promotionOptionCode);
    }
    if (promotionOptionNo) {
      res["PromotionOptionNo"] = boost::any(*promotionOptionNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductCode") != m.end() && !m["ProductCode"].empty()) {
      productCode = make_shared<string>(boost::any_cast<string>(m["ProductCode"]));
    }
    if (m.find("PromotionOptionCode") != m.end() && !m["PromotionOptionCode"].empty()) {
      promotionOptionCode = make_shared<string>(boost::any_cast<string>(m["PromotionOptionCode"]));
    }
    if (m.find("PromotionOptionNo") != m.end() && !m["PromotionOptionNo"].empty()) {
      promotionOptionNo = make_shared<string>(boost::any_cast<string>(m["PromotionOptionNo"]));
    }
  }


  virtual ~CreateClusterV2RequestPromotionInfo() = default;
};
class CreateClusterV2RequestHostGroup : public Darabonba::Model {
public:
  shared_ptr<bool> autoRenew{};
  shared_ptr<string> chargeType{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> comment{};
  shared_ptr<string> createType{};
  shared_ptr<long> diskCapacity{};
  shared_ptr<long> diskCount{};
  shared_ptr<string> diskType{};
  shared_ptr<string> gpuDriver{};
  shared_ptr<string> hostGroupId{};
  shared_ptr<string> hostGroupName{};
  shared_ptr<string> hostGroupType{};
  shared_ptr<string> instanceType{};
  shared_ptr<long> nodeCount{};
  shared_ptr<long> period{};
  shared_ptr<long> sysDiskCapacity{};
  shared_ptr<string> sysDiskType{};
  shared_ptr<string> vSwitchId{};

  CreateClusterV2RequestHostGroup() {}

  explicit CreateClusterV2RequestHostGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (createType) {
      res["CreateType"] = boost::any(*createType);
    }
    if (diskCapacity) {
      res["DiskCapacity"] = boost::any(*diskCapacity);
    }
    if (diskCount) {
      res["DiskCount"] = boost::any(*diskCount);
    }
    if (diskType) {
      res["DiskType"] = boost::any(*diskType);
    }
    if (gpuDriver) {
      res["GpuDriver"] = boost::any(*gpuDriver);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (hostGroupName) {
      res["HostGroupName"] = boost::any(*hostGroupName);
    }
    if (hostGroupType) {
      res["HostGroupType"] = boost::any(*hostGroupType);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (nodeCount) {
      res["NodeCount"] = boost::any(*nodeCount);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (sysDiskCapacity) {
      res["SysDiskCapacity"] = boost::any(*sysDiskCapacity);
    }
    if (sysDiskType) {
      res["SysDiskType"] = boost::any(*sysDiskType);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["AutoRenew"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("CreateType") != m.end() && !m["CreateType"].empty()) {
      createType = make_shared<string>(boost::any_cast<string>(m["CreateType"]));
    }
    if (m.find("DiskCapacity") != m.end() && !m["DiskCapacity"].empty()) {
      diskCapacity = make_shared<long>(boost::any_cast<long>(m["DiskCapacity"]));
    }
    if (m.find("DiskCount") != m.end() && !m["DiskCount"].empty()) {
      diskCount = make_shared<long>(boost::any_cast<long>(m["DiskCount"]));
    }
    if (m.find("DiskType") != m.end() && !m["DiskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["DiskType"]));
    }
    if (m.find("GpuDriver") != m.end() && !m["GpuDriver"].empty()) {
      gpuDriver = make_shared<string>(boost::any_cast<string>(m["GpuDriver"]));
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("HostGroupName") != m.end() && !m["HostGroupName"].empty()) {
      hostGroupName = make_shared<string>(boost::any_cast<string>(m["HostGroupName"]));
    }
    if (m.find("HostGroupType") != m.end() && !m["HostGroupType"].empty()) {
      hostGroupType = make_shared<string>(boost::any_cast<string>(m["HostGroupType"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("NodeCount") != m.end() && !m["NodeCount"].empty()) {
      nodeCount = make_shared<long>(boost::any_cast<long>(m["NodeCount"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("SysDiskCapacity") != m.end() && !m["SysDiskCapacity"].empty()) {
      sysDiskCapacity = make_shared<long>(boost::any_cast<long>(m["SysDiskCapacity"]));
    }
    if (m.find("SysDiskType") != m.end() && !m["SysDiskType"].empty()) {
      sysDiskType = make_shared<string>(boost::any_cast<string>(m["SysDiskType"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~CreateClusterV2RequestHostGroup() = default;
};
class CreateClusterV2RequestBootstrapAction : public Darabonba::Model {
public:
  shared_ptr<string> arg{};
  shared_ptr<string> name{};
  shared_ptr<string> path{};

  CreateClusterV2RequestBootstrapAction() {}

  explicit CreateClusterV2RequestBootstrapAction(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arg) {
      res["Arg"] = boost::any(*arg);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Arg") != m.end() && !m["Arg"].empty()) {
      arg = make_shared<string>(boost::any_cast<string>(m["Arg"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~CreateClusterV2RequestBootstrapAction() = default;
};
class CreateClusterV2RequestConfig : public Darabonba::Model {
public:
  shared_ptr<string> configKey{};
  shared_ptr<string> configValue{};
  shared_ptr<string> encrypt{};
  shared_ptr<string> fileName{};
  shared_ptr<string> replace{};
  shared_ptr<string> serviceName{};

  CreateClusterV2RequestConfig() {}

  explicit CreateClusterV2RequestConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configKey) {
      res["ConfigKey"] = boost::any(*configKey);
    }
    if (configValue) {
      res["ConfigValue"] = boost::any(*configValue);
    }
    if (encrypt) {
      res["Encrypt"] = boost::any(*encrypt);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (replace) {
      res["Replace"] = boost::any(*replace);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigKey") != m.end() && !m["ConfigKey"].empty()) {
      configKey = make_shared<string>(boost::any_cast<string>(m["ConfigKey"]));
    }
    if (m.find("ConfigValue") != m.end() && !m["ConfigValue"].empty()) {
      configValue = make_shared<string>(boost::any_cast<string>(m["ConfigValue"]));
    }
    if (m.find("Encrypt") != m.end() && !m["Encrypt"].empty()) {
      encrypt = make_shared<string>(boost::any_cast<string>(m["Encrypt"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("Replace") != m.end() && !m["Replace"].empty()) {
      replace = make_shared<string>(boost::any_cast<string>(m["Replace"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~CreateClusterV2RequestConfig() = default;
};
class CreateClusterV2RequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateClusterV2RequestTag() {}

  explicit CreateClusterV2RequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateClusterV2RequestTag() = default;
};
class CreateClusterV2Request : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> logPath{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<bool> isOpenPublicIp{};
  shared_ptr<string> securityGroupName{};
  shared_ptr<string> chargeType{};
  shared_ptr<long> period{};
  shared_ptr<bool> auto_{};
  shared_ptr<bool> autoPayOrder{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> netType{};
  shared_ptr<string> userDefinedEmrEcsRole{};
  shared_ptr<string> emrVer{};
  shared_ptr<string> clusterType{};
  shared_ptr<bool> enableHighAvailability{};
  shared_ptr<bool> useLocalMetaDb{};
  shared_ptr<bool> enableSsh{};
  shared_ptr<string> instanceGeneration{};
  shared_ptr<string> masterPwd{};
  shared_ptr<string> keyPairName{};
  shared_ptr<string> metaStoreType{};
  shared_ptr<string> metaStoreConf{};
  shared_ptr<string> clickHouseConf{};
  shared_ptr<string> extraAttributes{};
  shared_ptr<string> depositType{};
  shared_ptr<string> machineType{};
  shared_ptr<bool> useCustomHiveMetaDB{};
  shared_ptr<bool> initCustomHiveMetaDB{};
  shared_ptr<string> configurations{};
  shared_ptr<bool> enableEas{};
  shared_ptr<string> relatedClusterId{};
  shared_ptr<string> whiteListType{};
  shared_ptr<string> authorizeContent{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> clientToken{};
  shared_ptr<vector<CreateClusterV2RequestUserInfo>> userInfo{};
  shared_ptr<vector<CreateClusterV2RequestHostComponentInfo>> hostComponentInfo{};
  shared_ptr<vector<CreateClusterV2RequestServiceInfo>> serviceInfo{};
  shared_ptr<vector<CreateClusterV2RequestPromotionInfo>> promotionInfo{};
  shared_ptr<vector<CreateClusterV2RequestHostGroup>> hostGroup{};
  shared_ptr<vector<CreateClusterV2RequestBootstrapAction>> bootstrapAction{};
  shared_ptr<vector<CreateClusterV2RequestConfig>> config{};
  shared_ptr<vector<CreateClusterV2RequestTag>> tag{};

  CreateClusterV2Request() {}

  explicit CreateClusterV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (logPath) {
      res["LogPath"] = boost::any(*logPath);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (isOpenPublicIp) {
      res["IsOpenPublicIp"] = boost::any(*isOpenPublicIp);
    }
    if (securityGroupName) {
      res["SecurityGroupName"] = boost::any(*securityGroupName);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (auto_) {
      res["Auto"] = boost::any(*auto_);
    }
    if (autoPayOrder) {
      res["AutoPayOrder"] = boost::any(*autoPayOrder);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (netType) {
      res["NetType"] = boost::any(*netType);
    }
    if (userDefinedEmrEcsRole) {
      res["UserDefinedEmrEcsRole"] = boost::any(*userDefinedEmrEcsRole);
    }
    if (emrVer) {
      res["EmrVer"] = boost::any(*emrVer);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (enableHighAvailability) {
      res["EnableHighAvailability"] = boost::any(*enableHighAvailability);
    }
    if (useLocalMetaDb) {
      res["UseLocalMetaDb"] = boost::any(*useLocalMetaDb);
    }
    if (enableSsh) {
      res["EnableSsh"] = boost::any(*enableSsh);
    }
    if (instanceGeneration) {
      res["InstanceGeneration"] = boost::any(*instanceGeneration);
    }
    if (masterPwd) {
      res["MasterPwd"] = boost::any(*masterPwd);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (metaStoreType) {
      res["MetaStoreType"] = boost::any(*metaStoreType);
    }
    if (metaStoreConf) {
      res["MetaStoreConf"] = boost::any(*metaStoreConf);
    }
    if (clickHouseConf) {
      res["ClickHouseConf"] = boost::any(*clickHouseConf);
    }
    if (extraAttributes) {
      res["ExtraAttributes"] = boost::any(*extraAttributes);
    }
    if (depositType) {
      res["DepositType"] = boost::any(*depositType);
    }
    if (machineType) {
      res["MachineType"] = boost::any(*machineType);
    }
    if (useCustomHiveMetaDB) {
      res["UseCustomHiveMetaDB"] = boost::any(*useCustomHiveMetaDB);
    }
    if (initCustomHiveMetaDB) {
      res["InitCustomHiveMetaDB"] = boost::any(*initCustomHiveMetaDB);
    }
    if (configurations) {
      res["Configurations"] = boost::any(*configurations);
    }
    if (enableEas) {
      res["EnableEas"] = boost::any(*enableEas);
    }
    if (relatedClusterId) {
      res["RelatedClusterId"] = boost::any(*relatedClusterId);
    }
    if (whiteListType) {
      res["WhiteListType"] = boost::any(*whiteListType);
    }
    if (authorizeContent) {
      res["AuthorizeContent"] = boost::any(*authorizeContent);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (userInfo) {
      vector<boost::any> temp1;
      for(auto item1:*userInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserInfo"] = boost::any(temp1);
    }
    if (hostComponentInfo) {
      vector<boost::any> temp1;
      for(auto item1:*hostComponentInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HostComponentInfo"] = boost::any(temp1);
    }
    if (serviceInfo) {
      vector<boost::any> temp1;
      for(auto item1:*serviceInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ServiceInfo"] = boost::any(temp1);
    }
    if (promotionInfo) {
      vector<boost::any> temp1;
      for(auto item1:*promotionInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PromotionInfo"] = boost::any(temp1);
    }
    if (hostGroup) {
      vector<boost::any> temp1;
      for(auto item1:*hostGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HostGroup"] = boost::any(temp1);
    }
    if (bootstrapAction) {
      vector<boost::any> temp1;
      for(auto item1:*bootstrapAction){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BootstrapAction"] = boost::any(temp1);
    }
    if (config) {
      vector<boost::any> temp1;
      for(auto item1:*config){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Config"] = boost::any(temp1);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("LogPath") != m.end() && !m["LogPath"].empty()) {
      logPath = make_shared<string>(boost::any_cast<string>(m["LogPath"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("IsOpenPublicIp") != m.end() && !m["IsOpenPublicIp"].empty()) {
      isOpenPublicIp = make_shared<bool>(boost::any_cast<bool>(m["IsOpenPublicIp"]));
    }
    if (m.find("SecurityGroupName") != m.end() && !m["SecurityGroupName"].empty()) {
      securityGroupName = make_shared<string>(boost::any_cast<string>(m["SecurityGroupName"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("Auto") != m.end() && !m["Auto"].empty()) {
      auto_ = make_shared<bool>(boost::any_cast<bool>(m["Auto"]));
    }
    if (m.find("AutoPayOrder") != m.end() && !m["AutoPayOrder"].empty()) {
      autoPayOrder = make_shared<bool>(boost::any_cast<bool>(m["AutoPayOrder"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("NetType") != m.end() && !m["NetType"].empty()) {
      netType = make_shared<string>(boost::any_cast<string>(m["NetType"]));
    }
    if (m.find("UserDefinedEmrEcsRole") != m.end() && !m["UserDefinedEmrEcsRole"].empty()) {
      userDefinedEmrEcsRole = make_shared<string>(boost::any_cast<string>(m["UserDefinedEmrEcsRole"]));
    }
    if (m.find("EmrVer") != m.end() && !m["EmrVer"].empty()) {
      emrVer = make_shared<string>(boost::any_cast<string>(m["EmrVer"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("EnableHighAvailability") != m.end() && !m["EnableHighAvailability"].empty()) {
      enableHighAvailability = make_shared<bool>(boost::any_cast<bool>(m["EnableHighAvailability"]));
    }
    if (m.find("UseLocalMetaDb") != m.end() && !m["UseLocalMetaDb"].empty()) {
      useLocalMetaDb = make_shared<bool>(boost::any_cast<bool>(m["UseLocalMetaDb"]));
    }
    if (m.find("EnableSsh") != m.end() && !m["EnableSsh"].empty()) {
      enableSsh = make_shared<bool>(boost::any_cast<bool>(m["EnableSsh"]));
    }
    if (m.find("InstanceGeneration") != m.end() && !m["InstanceGeneration"].empty()) {
      instanceGeneration = make_shared<string>(boost::any_cast<string>(m["InstanceGeneration"]));
    }
    if (m.find("MasterPwd") != m.end() && !m["MasterPwd"].empty()) {
      masterPwd = make_shared<string>(boost::any_cast<string>(m["MasterPwd"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("MetaStoreType") != m.end() && !m["MetaStoreType"].empty()) {
      metaStoreType = make_shared<string>(boost::any_cast<string>(m["MetaStoreType"]));
    }
    if (m.find("MetaStoreConf") != m.end() && !m["MetaStoreConf"].empty()) {
      metaStoreConf = make_shared<string>(boost::any_cast<string>(m["MetaStoreConf"]));
    }
    if (m.find("ClickHouseConf") != m.end() && !m["ClickHouseConf"].empty()) {
      clickHouseConf = make_shared<string>(boost::any_cast<string>(m["ClickHouseConf"]));
    }
    if (m.find("ExtraAttributes") != m.end() && !m["ExtraAttributes"].empty()) {
      extraAttributes = make_shared<string>(boost::any_cast<string>(m["ExtraAttributes"]));
    }
    if (m.find("DepositType") != m.end() && !m["DepositType"].empty()) {
      depositType = make_shared<string>(boost::any_cast<string>(m["DepositType"]));
    }
    if (m.find("MachineType") != m.end() && !m["MachineType"].empty()) {
      machineType = make_shared<string>(boost::any_cast<string>(m["MachineType"]));
    }
    if (m.find("UseCustomHiveMetaDB") != m.end() && !m["UseCustomHiveMetaDB"].empty()) {
      useCustomHiveMetaDB = make_shared<bool>(boost::any_cast<bool>(m["UseCustomHiveMetaDB"]));
    }
    if (m.find("InitCustomHiveMetaDB") != m.end() && !m["InitCustomHiveMetaDB"].empty()) {
      initCustomHiveMetaDB = make_shared<bool>(boost::any_cast<bool>(m["InitCustomHiveMetaDB"]));
    }
    if (m.find("Configurations") != m.end() && !m["Configurations"].empty()) {
      configurations = make_shared<string>(boost::any_cast<string>(m["Configurations"]));
    }
    if (m.find("EnableEas") != m.end() && !m["EnableEas"].empty()) {
      enableEas = make_shared<bool>(boost::any_cast<bool>(m["EnableEas"]));
    }
    if (m.find("RelatedClusterId") != m.end() && !m["RelatedClusterId"].empty()) {
      relatedClusterId = make_shared<string>(boost::any_cast<string>(m["RelatedClusterId"]));
    }
    if (m.find("WhiteListType") != m.end() && !m["WhiteListType"].empty()) {
      whiteListType = make_shared<string>(boost::any_cast<string>(m["WhiteListType"]));
    }
    if (m.find("AuthorizeContent") != m.end() && !m["AuthorizeContent"].empty()) {
      authorizeContent = make_shared<string>(boost::any_cast<string>(m["AuthorizeContent"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("UserInfo") != m.end() && !m["UserInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["UserInfo"].type()) {
        vector<CreateClusterV2RequestUserInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateClusterV2RequestUserInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userInfo = make_shared<vector<CreateClusterV2RequestUserInfo>>(expect1);
      }
    }
    if (m.find("HostComponentInfo") != m.end() && !m["HostComponentInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["HostComponentInfo"].type()) {
        vector<CreateClusterV2RequestHostComponentInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HostComponentInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateClusterV2RequestHostComponentInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hostComponentInfo = make_shared<vector<CreateClusterV2RequestHostComponentInfo>>(expect1);
      }
    }
    if (m.find("ServiceInfo") != m.end() && !m["ServiceInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ServiceInfo"].type()) {
        vector<CreateClusterV2RequestServiceInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ServiceInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateClusterV2RequestServiceInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serviceInfo = make_shared<vector<CreateClusterV2RequestServiceInfo>>(expect1);
      }
    }
    if (m.find("PromotionInfo") != m.end() && !m["PromotionInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["PromotionInfo"].type()) {
        vector<CreateClusterV2RequestPromotionInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PromotionInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateClusterV2RequestPromotionInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        promotionInfo = make_shared<vector<CreateClusterV2RequestPromotionInfo>>(expect1);
      }
    }
    if (m.find("HostGroup") != m.end() && !m["HostGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["HostGroup"].type()) {
        vector<CreateClusterV2RequestHostGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HostGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateClusterV2RequestHostGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hostGroup = make_shared<vector<CreateClusterV2RequestHostGroup>>(expect1);
      }
    }
    if (m.find("BootstrapAction") != m.end() && !m["BootstrapAction"].empty()) {
      if (typeid(vector<boost::any>) == m["BootstrapAction"].type()) {
        vector<CreateClusterV2RequestBootstrapAction> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BootstrapAction"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateClusterV2RequestBootstrapAction model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bootstrapAction = make_shared<vector<CreateClusterV2RequestBootstrapAction>>(expect1);
      }
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      if (typeid(vector<boost::any>) == m["Config"].type()) {
        vector<CreateClusterV2RequestConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Config"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateClusterV2RequestConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        config = make_shared<vector<CreateClusterV2RequestConfig>>(expect1);
      }
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateClusterV2RequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateClusterV2RequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateClusterV2RequestTag>>(expect1);
      }
    }
  }


  virtual ~CreateClusterV2Request() = default;
};
class CreateClusterV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> coreOrderId{};
  shared_ptr<string> emrOrderId{};
  shared_ptr<string> masterOrderId{};
  shared_ptr<string> requestId{};

  CreateClusterV2ResponseBody() {}

  explicit CreateClusterV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (coreOrderId) {
      res["CoreOrderId"] = boost::any(*coreOrderId);
    }
    if (emrOrderId) {
      res["EmrOrderId"] = boost::any(*emrOrderId);
    }
    if (masterOrderId) {
      res["MasterOrderId"] = boost::any(*masterOrderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("CoreOrderId") != m.end() && !m["CoreOrderId"].empty()) {
      coreOrderId = make_shared<string>(boost::any_cast<string>(m["CoreOrderId"]));
    }
    if (m.find("EmrOrderId") != m.end() && !m["EmrOrderId"].empty()) {
      emrOrderId = make_shared<string>(boost::any_cast<string>(m["EmrOrderId"]));
    }
    if (m.find("MasterOrderId") != m.end() && !m["MasterOrderId"].empty()) {
      masterOrderId = make_shared<string>(boost::any_cast<string>(m["MasterOrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateClusterV2ResponseBody() = default;
};
class CreateClusterV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateClusterV2ResponseBody> body{};

  CreateClusterV2Response() {}

  explicit CreateClusterV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateClusterV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateClusterV2ResponseBody>(model1);
      }
    }
  }


  virtual ~CreateClusterV2Response() = default;
};
class ModifyClusterNameRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  ModifyClusterNameRequest() {}

  explicit ModifyClusterNameRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ModifyClusterNameRequest() = default;
};
class ModifyClusterNameResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyClusterNameResponseBody() {}

  explicit ModifyClusterNameResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyClusterNameResponseBody() = default;
};
class ModifyClusterNameResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyClusterNameResponseBody> body{};

  ModifyClusterNameResponse() {}

  explicit ModifyClusterNameResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyClusterNameResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyClusterNameResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyClusterNameResponse() = default;
};
class ListClusterOperationHostTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> operationId{};
  shared_ptr<string> hostId{};
  shared_ptr<string> status{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListClusterOperationHostTaskRequest() {}

  explicit ListClusterOperationHostTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (operationId) {
      res["OperationId"] = boost::any(*operationId);
    }
    if (hostId) {
      res["HostId"] = boost::any(*hostId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("OperationId") != m.end() && !m["OperationId"].empty()) {
      operationId = make_shared<string>(boost::any_cast<string>(m["OperationId"]));
    }
    if (m.find("HostId") != m.end() && !m["HostId"].empty()) {
      hostId = make_shared<string>(boost::any_cast<string>(m["HostId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListClusterOperationHostTaskRequest() = default;
};
class ListClusterOperationHostTaskResponseBodyClusterOperationHostTaskListClusterOperationHostTask : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> percentage{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskName{};

  ListClusterOperationHostTaskResponseBodyClusterOperationHostTaskListClusterOperationHostTask() {}

  explicit ListClusterOperationHostTaskResponseBodyClusterOperationHostTaskListClusterOperationHostTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (percentage) {
      res["Percentage"] = boost::any(*percentage);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Percentage") != m.end() && !m["Percentage"].empty()) {
      percentage = make_shared<string>(boost::any_cast<string>(m["Percentage"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
  }


  virtual ~ListClusterOperationHostTaskResponseBodyClusterOperationHostTaskListClusterOperationHostTask() = default;
};
class ListClusterOperationHostTaskResponseBodyClusterOperationHostTaskList : public Darabonba::Model {
public:
  shared_ptr<vector<ListClusterOperationHostTaskResponseBodyClusterOperationHostTaskListClusterOperationHostTask>> clusterOperationHostTask{};

  ListClusterOperationHostTaskResponseBodyClusterOperationHostTaskList() {}

  explicit ListClusterOperationHostTaskResponseBodyClusterOperationHostTaskList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterOperationHostTask) {
      vector<boost::any> temp1;
      for(auto item1:*clusterOperationHostTask){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ClusterOperationHostTask"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterOperationHostTask") != m.end() && !m["ClusterOperationHostTask"].empty()) {
      if (typeid(vector<boost::any>) == m["ClusterOperationHostTask"].type()) {
        vector<ListClusterOperationHostTaskResponseBodyClusterOperationHostTaskListClusterOperationHostTask> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ClusterOperationHostTask"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClusterOperationHostTaskResponseBodyClusterOperationHostTaskListClusterOperationHostTask model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clusterOperationHostTask = make_shared<vector<ListClusterOperationHostTaskResponseBodyClusterOperationHostTaskListClusterOperationHostTask>>(expect1);
      }
    }
  }


  virtual ~ListClusterOperationHostTaskResponseBodyClusterOperationHostTaskList() = default;
};
class ListClusterOperationHostTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> totalCount{};
  shared_ptr<ListClusterOperationHostTaskResponseBodyClusterOperationHostTaskList> clusterOperationHostTaskList{};

  ListClusterOperationHostTaskResponseBody() {}

  explicit ListClusterOperationHostTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (clusterOperationHostTaskList) {
      res["ClusterOperationHostTaskList"] = clusterOperationHostTaskList ? boost::any(clusterOperationHostTaskList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("ClusterOperationHostTaskList") != m.end() && !m["ClusterOperationHostTaskList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClusterOperationHostTaskList"].type()) {
        ListClusterOperationHostTaskResponseBodyClusterOperationHostTaskList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClusterOperationHostTaskList"]));
        clusterOperationHostTaskList = make_shared<ListClusterOperationHostTaskResponseBodyClusterOperationHostTaskList>(model1);
      }
    }
  }


  virtual ~ListClusterOperationHostTaskResponseBody() = default;
};
class ListClusterOperationHostTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListClusterOperationHostTaskResponseBody> body{};

  ListClusterOperationHostTaskResponse() {}

  explicit ListClusterOperationHostTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListClusterOperationHostTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListClusterOperationHostTaskResponseBody>(model1);
      }
    }
  }


  virtual ~ListClusterOperationHostTaskResponse() = default;
};
class DescribeScalingConfigItemRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> scalingConfigItemId{};
  shared_ptr<string> scalingGroupBizId{};
  shared_ptr<string> configItemType{};

  DescribeScalingConfigItemRequest() {}

  explicit DescribeScalingConfigItemRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (scalingConfigItemId) {
      res["ScalingConfigItemId"] = boost::any(*scalingConfigItemId);
    }
    if (scalingGroupBizId) {
      res["ScalingGroupBizId"] = boost::any(*scalingGroupBizId);
    }
    if (configItemType) {
      res["ConfigItemType"] = boost::any(*configItemType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ScalingConfigItemId") != m.end() && !m["ScalingConfigItemId"].empty()) {
      scalingConfigItemId = make_shared<string>(boost::any_cast<string>(m["ScalingConfigItemId"]));
    }
    if (m.find("ScalingGroupBizId") != m.end() && !m["ScalingGroupBizId"].empty()) {
      scalingGroupBizId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupBizId"]));
    }
    if (m.find("ConfigItemType") != m.end() && !m["ConfigItemType"].empty()) {
      configItemType = make_shared<string>(boost::any_cast<string>(m["ConfigItemType"]));
    }
  }


  virtual ~DescribeScalingConfigItemRequest() = default;
};
class DescribeScalingConfigItemResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> configItemType{};
  shared_ptr<string> scalingGroupBizId{};
  shared_ptr<string> scalingConfigItemBizId{};
  shared_ptr<string> configItemInformation{};

  DescribeScalingConfigItemResponseBody() {}

  explicit DescribeScalingConfigItemResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (configItemType) {
      res["ConfigItemType"] = boost::any(*configItemType);
    }
    if (scalingGroupBizId) {
      res["ScalingGroupBizId"] = boost::any(*scalingGroupBizId);
    }
    if (scalingConfigItemBizId) {
      res["ScalingConfigItemBizId"] = boost::any(*scalingConfigItemBizId);
    }
    if (configItemInformation) {
      res["ConfigItemInformation"] = boost::any(*configItemInformation);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ConfigItemType") != m.end() && !m["ConfigItemType"].empty()) {
      configItemType = make_shared<string>(boost::any_cast<string>(m["ConfigItemType"]));
    }
    if (m.find("ScalingGroupBizId") != m.end() && !m["ScalingGroupBizId"].empty()) {
      scalingGroupBizId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupBizId"]));
    }
    if (m.find("ScalingConfigItemBizId") != m.end() && !m["ScalingConfigItemBizId"].empty()) {
      scalingConfigItemBizId = make_shared<string>(boost::any_cast<string>(m["ScalingConfigItemBizId"]));
    }
    if (m.find("ConfigItemInformation") != m.end() && !m["ConfigItemInformation"].empty()) {
      configItemInformation = make_shared<string>(boost::any_cast<string>(m["ConfigItemInformation"]));
    }
  }


  virtual ~DescribeScalingConfigItemResponseBody() = default;
};
class DescribeScalingConfigItemResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeScalingConfigItemResponseBody> body{};

  DescribeScalingConfigItemResponse() {}

  explicit DescribeScalingConfigItemResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeScalingConfigItemResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeScalingConfigItemResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeScalingConfigItemResponse() = default;
};
class ListClusterHostRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> hostInstanceId{};
  shared_ptr<string> hostGroupId{};
  shared_ptr<string> hostName{};
  shared_ptr<string> privateIp{};
  shared_ptr<string> publicIp{};
  shared_ptr<string> groupType{};
  shared_ptr<string> componentName{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<string>> statusList{};

  ListClusterHostRequest() {}

  explicit ListClusterHostRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (hostInstanceId) {
      res["HostInstanceId"] = boost::any(*hostInstanceId);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (privateIp) {
      res["PrivateIp"] = boost::any(*privateIp);
    }
    if (publicIp) {
      res["PublicIp"] = boost::any(*publicIp);
    }
    if (groupType) {
      res["GroupType"] = boost::any(*groupType);
    }
    if (componentName) {
      res["ComponentName"] = boost::any(*componentName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (statusList) {
      res["StatusList"] = boost::any(*statusList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("HostInstanceId") != m.end() && !m["HostInstanceId"].empty()) {
      hostInstanceId = make_shared<string>(boost::any_cast<string>(m["HostInstanceId"]));
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("PrivateIp") != m.end() && !m["PrivateIp"].empty()) {
      privateIp = make_shared<string>(boost::any_cast<string>(m["PrivateIp"]));
    }
    if (m.find("PublicIp") != m.end() && !m["PublicIp"].empty()) {
      publicIp = make_shared<string>(boost::any_cast<string>(m["PublicIp"]));
    }
    if (m.find("GroupType") != m.end() && !m["GroupType"].empty()) {
      groupType = make_shared<string>(boost::any_cast<string>(m["GroupType"]));
    }
    if (m.find("ComponentName") != m.end() && !m["ComponentName"].empty()) {
      componentName = make_shared<string>(boost::any_cast<string>(m["ComponentName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StatusList") != m.end() && !m["StatusList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["StatusList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["StatusList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      statusList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListClusterHostRequest() = default;
};
class ListClusterHostResponseBodyHostListHostDiskListDisk : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> diskType{};
  shared_ptr<string> diskId{};
  shared_ptr<string> device{};
  shared_ptr<long> diskSize{};

  ListClusterHostResponseBodyHostListHostDiskListDisk() {}

  explicit ListClusterHostResponseBodyHostListHostDiskListDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (diskType) {
      res["DiskType"] = boost::any(*diskType);
    }
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    if (device) {
      res["Device"] = boost::any(*device);
    }
    if (diskSize) {
      res["DiskSize"] = boost::any(*diskSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("DiskType") != m.end() && !m["DiskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["DiskType"]));
    }
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      diskId = make_shared<string>(boost::any_cast<string>(m["DiskId"]));
    }
    if (m.find("Device") != m.end() && !m["Device"].empty()) {
      device = make_shared<string>(boost::any_cast<string>(m["Device"]));
    }
    if (m.find("DiskSize") != m.end() && !m["DiskSize"].empty()) {
      diskSize = make_shared<long>(boost::any_cast<long>(m["DiskSize"]));
    }
  }


  virtual ~ListClusterHostResponseBodyHostListHostDiskListDisk() = default;
};
class ListClusterHostResponseBodyHostListHostDiskList : public Darabonba::Model {
public:
  shared_ptr<vector<ListClusterHostResponseBodyHostListHostDiskListDisk>> disk{};

  ListClusterHostResponseBodyHostListHostDiskList() {}

  explicit ListClusterHostResponseBodyHostListHostDiskList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disk) {
      vector<boost::any> temp1;
      for(auto item1:*disk){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Disk"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Disk") != m.end() && !m["Disk"].empty()) {
      if (typeid(vector<boost::any>) == m["Disk"].type()) {
        vector<ListClusterHostResponseBodyHostListHostDiskListDisk> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Disk"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClusterHostResponseBodyHostListHostDiskListDisk model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        disk = make_shared<vector<ListClusterHostResponseBodyHostListHostDiskListDisk>>(expect1);
      }
    }
  }


  virtual ~ListClusterHostResponseBodyHostListHostDiskList() = default;
};
class ListClusterHostResponseBodyHostListHost : public Darabonba::Model {
public:
  shared_ptr<string> serialNumber{};
  shared_ptr<string> type{};
  shared_ptr<string> status{};
  shared_ptr<string> privateIp{};
  shared_ptr<string> createTime{};
  shared_ptr<string> chargeType{};
  shared_ptr<string> hostName{};
  shared_ptr<string> hostGroupId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> hostInstanceId{};
  shared_ptr<bool> supportIpV6{};
  shared_ptr<long> cpu{};
  shared_ptr<long> expiredTime{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> publicIp{};
  shared_ptr<string> instanceStatus{};
  shared_ptr<long> memory{};
  shared_ptr<string> emrExpiredTime{};
  shared_ptr<string> role{};
  shared_ptr<ListClusterHostResponseBodyHostListHostDiskList> diskList{};

  ListClusterHostResponseBodyHostListHost() {}

  explicit ListClusterHostResponseBodyHostListHost(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (privateIp) {
      res["PrivateIp"] = boost::any(*privateIp);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (hostInstanceId) {
      res["HostInstanceId"] = boost::any(*hostInstanceId);
    }
    if (supportIpV6) {
      res["SupportIpV6"] = boost::any(*supportIpV6);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (publicIp) {
      res["PublicIp"] = boost::any(*publicIp);
    }
    if (instanceStatus) {
      res["InstanceStatus"] = boost::any(*instanceStatus);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (emrExpiredTime) {
      res["EmrExpiredTime"] = boost::any(*emrExpiredTime);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (diskList) {
      res["DiskList"] = diskList ? boost::any(diskList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["SerialNumber"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("PrivateIp") != m.end() && !m["PrivateIp"].empty()) {
      privateIp = make_shared<string>(boost::any_cast<string>(m["PrivateIp"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("HostInstanceId") != m.end() && !m["HostInstanceId"].empty()) {
      hostInstanceId = make_shared<string>(boost::any_cast<string>(m["HostInstanceId"]));
    }
    if (m.find("SupportIpV6") != m.end() && !m["SupportIpV6"].empty()) {
      supportIpV6 = make_shared<bool>(boost::any_cast<bool>(m["SupportIpV6"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<long>(boost::any_cast<long>(m["ExpiredTime"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("PublicIp") != m.end() && !m["PublicIp"].empty()) {
      publicIp = make_shared<string>(boost::any_cast<string>(m["PublicIp"]));
    }
    if (m.find("InstanceStatus") != m.end() && !m["InstanceStatus"].empty()) {
      instanceStatus = make_shared<string>(boost::any_cast<string>(m["InstanceStatus"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
    if (m.find("EmrExpiredTime") != m.end() && !m["EmrExpiredTime"].empty()) {
      emrExpiredTime = make_shared<string>(boost::any_cast<string>(m["EmrExpiredTime"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("DiskList") != m.end() && !m["DiskList"].empty()) {
      if (typeid(map<string, boost::any>) == m["DiskList"].type()) {
        ListClusterHostResponseBodyHostListHostDiskList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DiskList"]));
        diskList = make_shared<ListClusterHostResponseBodyHostListHostDiskList>(model1);
      }
    }
  }


  virtual ~ListClusterHostResponseBodyHostListHost() = default;
};
class ListClusterHostResponseBodyHostList : public Darabonba::Model {
public:
  shared_ptr<vector<ListClusterHostResponseBodyHostListHost>> host{};

  ListClusterHostResponseBodyHostList() {}

  explicit ListClusterHostResponseBodyHostList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (host) {
      vector<boost::any> temp1;
      for(auto item1:*host){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Host"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      if (typeid(vector<boost::any>) == m["Host"].type()) {
        vector<ListClusterHostResponseBodyHostListHost> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Host"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClusterHostResponseBodyHostListHost model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        host = make_shared<vector<ListClusterHostResponseBodyHostListHost>>(expect1);
      }
    }
  }


  virtual ~ListClusterHostResponseBodyHostList() = default;
};
class ListClusterHostResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};
  shared_ptr<ListClusterHostResponseBodyHostList> hostList{};

  ListClusterHostResponseBody() {}

  explicit ListClusterHostResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (hostList) {
      res["HostList"] = hostList ? boost::any(hostList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("HostList") != m.end() && !m["HostList"].empty()) {
      if (typeid(map<string, boost::any>) == m["HostList"].type()) {
        ListClusterHostResponseBodyHostList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HostList"]));
        hostList = make_shared<ListClusterHostResponseBodyHostList>(model1);
      }
    }
  }


  virtual ~ListClusterHostResponseBody() = default;
};
class ListClusterHostResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListClusterHostResponseBody> body{};

  ListClusterHostResponse() {}

  explicit ListClusterHostResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListClusterHostResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListClusterHostResponseBody>(model1);
      }
    }
  }


  virtual ~ListClusterHostResponse() = default;
};
class CreateScalingGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};
  shared_ptr<string> hostGroupId{};

  CreateScalingGroupRequest() {}

  explicit CreateScalingGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
  }


  virtual ~CreateScalingGroupRequest() = default;
};
class CreateScalingGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> data{};

  CreateScalingGroupResponseBody() {}

  explicit CreateScalingGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
  }


  virtual ~CreateScalingGroupResponseBody() = default;
};
class CreateScalingGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateScalingGroupResponseBody> body{};

  CreateScalingGroupResponse() {}

  explicit CreateScalingGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateScalingGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateScalingGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateScalingGroupResponse() = default;
};
class DescribeClusterServiceRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> serviceName{};

  DescribeClusterServiceRequest() {}

  explicit DescribeClusterServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~DescribeClusterServiceRequest() = default;
};
class DescribeClusterServiceResponseBodyServiceInfoServiceActionListServiceAction : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> actionName{};
  shared_ptr<string> componentName{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> command{};

  DescribeClusterServiceResponseBodyServiceInfoServiceActionListServiceAction() {}

  explicit DescribeClusterServiceResponseBodyServiceInfoServiceActionListServiceAction(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (actionName) {
      res["ActionName"] = boost::any(*actionName);
    }
    if (componentName) {
      res["ComponentName"] = boost::any(*componentName);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (command) {
      res["Command"] = boost::any(*command);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("ActionName") != m.end() && !m["ActionName"].empty()) {
      actionName = make_shared<string>(boost::any_cast<string>(m["ActionName"]));
    }
    if (m.find("ComponentName") != m.end() && !m["ComponentName"].empty()) {
      componentName = make_shared<string>(boost::any_cast<string>(m["ComponentName"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
  }


  virtual ~DescribeClusterServiceResponseBodyServiceInfoServiceActionListServiceAction() = default;
};
class DescribeClusterServiceResponseBodyServiceInfoServiceActionList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeClusterServiceResponseBodyServiceInfoServiceActionListServiceAction>> serviceAction{};

  DescribeClusterServiceResponseBodyServiceInfoServiceActionList() {}

  explicit DescribeClusterServiceResponseBodyServiceInfoServiceActionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceAction) {
      vector<boost::any> temp1;
      for(auto item1:*serviceAction){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ServiceAction"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServiceAction") != m.end() && !m["ServiceAction"].empty()) {
      if (typeid(vector<boost::any>) == m["ServiceAction"].type()) {
        vector<DescribeClusterServiceResponseBodyServiceInfoServiceActionListServiceAction> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ServiceAction"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterServiceResponseBodyServiceInfoServiceActionListServiceAction model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serviceAction = make_shared<vector<DescribeClusterServiceResponseBodyServiceInfoServiceActionListServiceAction>>(expect1);
      }
    }
  }


  virtual ~DescribeClusterServiceResponseBodyServiceInfoServiceActionList() = default;
};
class DescribeClusterServiceResponseBodyServiceInfoClusterServiceSummaryListClusterServiceSummary : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> displayName{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};
  shared_ptr<long> desiredStoppedValue{};
  shared_ptr<string> alertInfo{};
  shared_ptr<string> category{};

  DescribeClusterServiceResponseBodyServiceInfoClusterServiceSummaryListClusterServiceSummary() {}

  explicit DescribeClusterServiceResponseBodyServiceInfoClusterServiceSummaryListClusterServiceSummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (desiredStoppedValue) {
      res["DesiredStoppedValue"] = boost::any(*desiredStoppedValue);
    }
    if (alertInfo) {
      res["AlertInfo"] = boost::any(*alertInfo);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("DesiredStoppedValue") != m.end() && !m["DesiredStoppedValue"].empty()) {
      desiredStoppedValue = make_shared<long>(boost::any_cast<long>(m["DesiredStoppedValue"]));
    }
    if (m.find("AlertInfo") != m.end() && !m["AlertInfo"].empty()) {
      alertInfo = make_shared<string>(boost::any_cast<string>(m["AlertInfo"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
  }


  virtual ~DescribeClusterServiceResponseBodyServiceInfoClusterServiceSummaryListClusterServiceSummary() = default;
};
class DescribeClusterServiceResponseBodyServiceInfoClusterServiceSummaryList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeClusterServiceResponseBodyServiceInfoClusterServiceSummaryListClusterServiceSummary>> clusterServiceSummary{};

  DescribeClusterServiceResponseBodyServiceInfoClusterServiceSummaryList() {}

  explicit DescribeClusterServiceResponseBodyServiceInfoClusterServiceSummaryList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterServiceSummary) {
      vector<boost::any> temp1;
      for(auto item1:*clusterServiceSummary){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ClusterServiceSummary"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterServiceSummary") != m.end() && !m["ClusterServiceSummary"].empty()) {
      if (typeid(vector<boost::any>) == m["ClusterServiceSummary"].type()) {
        vector<DescribeClusterServiceResponseBodyServiceInfoClusterServiceSummaryListClusterServiceSummary> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ClusterServiceSummary"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterServiceResponseBodyServiceInfoClusterServiceSummaryListClusterServiceSummary model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clusterServiceSummary = make_shared<vector<DescribeClusterServiceResponseBodyServiceInfoClusterServiceSummaryListClusterServiceSummary>>(expect1);
      }
    }
  }


  virtual ~DescribeClusterServiceResponseBodyServiceInfoClusterServiceSummaryList() = default;
};
class DescribeClusterServiceResponseBodyServiceInfoNeedRestartHostIdList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> service{};

  DescribeClusterServiceResponseBodyServiceInfoNeedRestartHostIdList() {}

  explicit DescribeClusterServiceResponseBodyServiceInfoNeedRestartHostIdList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (service) {
      res["Service"] = boost::any(*service);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Service") != m.end() && !m["Service"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Service"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Service"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      service = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeClusterServiceResponseBodyServiceInfoNeedRestartHostIdList() = default;
};
class DescribeClusterServiceResponseBodyServiceInfoNeedRestartComponentNameList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> service{};

  DescribeClusterServiceResponseBodyServiceInfoNeedRestartComponentNameList() {}

  explicit DescribeClusterServiceResponseBodyServiceInfoNeedRestartComponentNameList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (service) {
      res["Service"] = boost::any(*service);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Service") != m.end() && !m["Service"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Service"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Service"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      service = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeClusterServiceResponseBodyServiceInfoNeedRestartComponentNameList() = default;
};
class DescribeClusterServiceResponseBodyServiceInfo : public Darabonba::Model {
public:
  shared_ptr<string> needRestartInfo{};
  shared_ptr<string> serviceVersion{};
  shared_ptr<string> serviceStatus{};
  shared_ptr<string> serviceName{};
  shared_ptr<long> needRestartNum{};
  shared_ptr<DescribeClusterServiceResponseBodyServiceInfoServiceActionList> serviceActionList{};
  shared_ptr<DescribeClusterServiceResponseBodyServiceInfoClusterServiceSummaryList> clusterServiceSummaryList{};
  shared_ptr<DescribeClusterServiceResponseBodyServiceInfoNeedRestartHostIdList> needRestartHostIdList{};
  shared_ptr<DescribeClusterServiceResponseBodyServiceInfoNeedRestartComponentNameList> needRestartComponentNameList{};

  DescribeClusterServiceResponseBodyServiceInfo() {}

  explicit DescribeClusterServiceResponseBodyServiceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (needRestartInfo) {
      res["NeedRestartInfo"] = boost::any(*needRestartInfo);
    }
    if (serviceVersion) {
      res["ServiceVersion"] = boost::any(*serviceVersion);
    }
    if (serviceStatus) {
      res["ServiceStatus"] = boost::any(*serviceStatus);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (needRestartNum) {
      res["NeedRestartNum"] = boost::any(*needRestartNum);
    }
    if (serviceActionList) {
      res["ServiceActionList"] = serviceActionList ? boost::any(serviceActionList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (clusterServiceSummaryList) {
      res["ClusterServiceSummaryList"] = clusterServiceSummaryList ? boost::any(clusterServiceSummaryList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (needRestartHostIdList) {
      res["NeedRestartHostIdList"] = needRestartHostIdList ? boost::any(needRestartHostIdList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (needRestartComponentNameList) {
      res["NeedRestartComponentNameList"] = needRestartComponentNameList ? boost::any(needRestartComponentNameList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NeedRestartInfo") != m.end() && !m["NeedRestartInfo"].empty()) {
      needRestartInfo = make_shared<string>(boost::any_cast<string>(m["NeedRestartInfo"]));
    }
    if (m.find("ServiceVersion") != m.end() && !m["ServiceVersion"].empty()) {
      serviceVersion = make_shared<string>(boost::any_cast<string>(m["ServiceVersion"]));
    }
    if (m.find("ServiceStatus") != m.end() && !m["ServiceStatus"].empty()) {
      serviceStatus = make_shared<string>(boost::any_cast<string>(m["ServiceStatus"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("NeedRestartNum") != m.end() && !m["NeedRestartNum"].empty()) {
      needRestartNum = make_shared<long>(boost::any_cast<long>(m["NeedRestartNum"]));
    }
    if (m.find("ServiceActionList") != m.end() && !m["ServiceActionList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ServiceActionList"].type()) {
        DescribeClusterServiceResponseBodyServiceInfoServiceActionList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ServiceActionList"]));
        serviceActionList = make_shared<DescribeClusterServiceResponseBodyServiceInfoServiceActionList>(model1);
      }
    }
    if (m.find("ClusterServiceSummaryList") != m.end() && !m["ClusterServiceSummaryList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClusterServiceSummaryList"].type()) {
        DescribeClusterServiceResponseBodyServiceInfoClusterServiceSummaryList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClusterServiceSummaryList"]));
        clusterServiceSummaryList = make_shared<DescribeClusterServiceResponseBodyServiceInfoClusterServiceSummaryList>(model1);
      }
    }
    if (m.find("NeedRestartHostIdList") != m.end() && !m["NeedRestartHostIdList"].empty()) {
      if (typeid(map<string, boost::any>) == m["NeedRestartHostIdList"].type()) {
        DescribeClusterServiceResponseBodyServiceInfoNeedRestartHostIdList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NeedRestartHostIdList"]));
        needRestartHostIdList = make_shared<DescribeClusterServiceResponseBodyServiceInfoNeedRestartHostIdList>(model1);
      }
    }
    if (m.find("NeedRestartComponentNameList") != m.end() && !m["NeedRestartComponentNameList"].empty()) {
      if (typeid(map<string, boost::any>) == m["NeedRestartComponentNameList"].type()) {
        DescribeClusterServiceResponseBodyServiceInfoNeedRestartComponentNameList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NeedRestartComponentNameList"]));
        needRestartComponentNameList = make_shared<DescribeClusterServiceResponseBodyServiceInfoNeedRestartComponentNameList>(model1);
      }
    }
  }


  virtual ~DescribeClusterServiceResponseBodyServiceInfo() = default;
};
class DescribeClusterServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeClusterServiceResponseBodyServiceInfo> serviceInfo{};

  DescribeClusterServiceResponseBody() {}

  explicit DescribeClusterServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (serviceInfo) {
      res["ServiceInfo"] = serviceInfo ? boost::any(serviceInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ServiceInfo") != m.end() && !m["ServiceInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ServiceInfo"].type()) {
        DescribeClusterServiceResponseBodyServiceInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ServiceInfo"]));
        serviceInfo = make_shared<DescribeClusterServiceResponseBodyServiceInfo>(model1);
      }
    }
  }


  virtual ~DescribeClusterServiceResponseBody() = default;
};
class DescribeClusterServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeClusterServiceResponseBody> body{};

  DescribeClusterServiceResponse() {}

  explicit DescribeClusterServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeClusterServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeClusterServiceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeClusterServiceResponse() = default;
};
class ListFlowProjectsRequest : public Darabonba::Model {
public:
  shared_ptr<string> productType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> name{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceGroupId{};

  ListFlowProjectsRequest() {}

  explicit ListFlowProjectsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productType) {
      res["ProductType"] = boost::any(*productType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductType") != m.end() && !m["ProductType"].empty()) {
      productType = make_shared<string>(boost::any_cast<string>(m["ProductType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ListFlowProjectsRequest() = default;
};
class ListFlowProjectsResponseBodyProjectsProject : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> userId{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> name{};
  shared_ptr<string> id{};

  ListFlowProjectsResponseBodyProjectsProject() {}

  explicit ListFlowProjectsResponseBodyProjectsProject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~ListFlowProjectsResponseBodyProjectsProject() = default;
};
class ListFlowProjectsResponseBodyProjects : public Darabonba::Model {
public:
  shared_ptr<vector<ListFlowProjectsResponseBodyProjectsProject>> project{};

  ListFlowProjectsResponseBodyProjects() {}

  explicit ListFlowProjectsResponseBodyProjects(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (project) {
      vector<boost::any> temp1;
      for(auto item1:*project){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Project"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      if (typeid(vector<boost::any>) == m["Project"].type()) {
        vector<ListFlowProjectsResponseBodyProjectsProject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Project"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFlowProjectsResponseBodyProjectsProject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        project = make_shared<vector<ListFlowProjectsResponseBodyProjectsProject>>(expect1);
      }
    }
  }


  virtual ~ListFlowProjectsResponseBodyProjects() = default;
};
class ListFlowProjectsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};
  shared_ptr<ListFlowProjectsResponseBodyProjects> projects{};

  ListFlowProjectsResponseBody() {}

  explicit ListFlowProjectsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (projects) {
      res["Projects"] = projects ? boost::any(projects->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("Projects") != m.end() && !m["Projects"].empty()) {
      if (typeid(map<string, boost::any>) == m["Projects"].type()) {
        ListFlowProjectsResponseBodyProjects model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Projects"]));
        projects = make_shared<ListFlowProjectsResponseBodyProjects>(model1);
      }
    }
  }


  virtual ~ListFlowProjectsResponseBody() = default;
};
class ListFlowProjectsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListFlowProjectsResponseBody> body{};

  ListFlowProjectsResponse() {}

  explicit ListFlowProjectsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFlowProjectsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFlowProjectsResponseBody>(model1);
      }
    }
  }


  virtual ~ListFlowProjectsResponse() = default;
};
class CreateMetaTablePreviewTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> databaseId{};
  shared_ptr<string> tableId{};
  shared_ptr<string> user{};
  shared_ptr<string> password{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> clientToken{};

  CreateMetaTablePreviewTaskRequest() {}

  explicit CreateMetaTablePreviewTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (databaseId) {
      res["DatabaseId"] = boost::any(*databaseId);
    }
    if (tableId) {
      res["TableId"] = boost::any(*tableId);
    }
    if (user) {
      res["User"] = boost::any(*user);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DatabaseId") != m.end() && !m["DatabaseId"].empty()) {
      databaseId = make_shared<string>(boost::any_cast<string>(m["DatabaseId"]));
    }
    if (m.find("TableId") != m.end() && !m["TableId"].empty()) {
      tableId = make_shared<string>(boost::any_cast<string>(m["TableId"]));
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      user = make_shared<string>(boost::any_cast<string>(m["User"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
  }


  virtual ~CreateMetaTablePreviewTaskRequest() = default;
};
class CreateMetaTablePreviewTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> taskId{};
  shared_ptr<string> requestId{};

  CreateMetaTablePreviewTaskResponseBody() {}

  explicit CreateMetaTablePreviewTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateMetaTablePreviewTaskResponseBody() = default;
};
class CreateMetaTablePreviewTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateMetaTablePreviewTaskResponseBody> body{};

  CreateMetaTablePreviewTaskResponse() {}

  explicit CreateMetaTablePreviewTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMetaTablePreviewTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMetaTablePreviewTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMetaTablePreviewTaskResponse() = default;
};
class ListFlowProjectUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> projectId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListFlowProjectUserRequest() {}

  explicit ListFlowProjectUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListFlowProjectUserRequest() = default;
};
class ListFlowProjectUserResponseBodyUsersUser : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> userName{};
  shared_ptr<string> accountUserId{};
  shared_ptr<string> ownerId{};

  ListFlowProjectUserResponseBodyUsersUser() {}

  explicit ListFlowProjectUserResponseBodyUsersUser(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (accountUserId) {
      res["AccountUserId"] = boost::any(*accountUserId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("AccountUserId") != m.end() && !m["AccountUserId"].empty()) {
      accountUserId = make_shared<string>(boost::any_cast<string>(m["AccountUserId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
  }


  virtual ~ListFlowProjectUserResponseBodyUsersUser() = default;
};
class ListFlowProjectUserResponseBodyUsers : public Darabonba::Model {
public:
  shared_ptr<vector<ListFlowProjectUserResponseBodyUsersUser>> user{};

  ListFlowProjectUserResponseBodyUsers() {}

  explicit ListFlowProjectUserResponseBodyUsers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (user) {
      vector<boost::any> temp1;
      for(auto item1:*user){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["User"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("User") != m.end() && !m["User"].empty()) {
      if (typeid(vector<boost::any>) == m["User"].type()) {
        vector<ListFlowProjectUserResponseBodyUsersUser> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["User"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFlowProjectUserResponseBodyUsersUser model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        user = make_shared<vector<ListFlowProjectUserResponseBodyUsersUser>>(expect1);
      }
    }
  }


  virtual ~ListFlowProjectUserResponseBodyUsers() = default;
};
class ListFlowProjectUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};
  shared_ptr<ListFlowProjectUserResponseBodyUsers> users{};

  ListFlowProjectUserResponseBody() {}

  explicit ListFlowProjectUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (users) {
      res["Users"] = users ? boost::any(users->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("Users") != m.end() && !m["Users"].empty()) {
      if (typeid(map<string, boost::any>) == m["Users"].type()) {
        ListFlowProjectUserResponseBodyUsers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Users"]));
        users = make_shared<ListFlowProjectUserResponseBodyUsers>(model1);
      }
    }
  }


  virtual ~ListFlowProjectUserResponseBody() = default;
};
class ListFlowProjectUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListFlowProjectUserResponseBody> body{};

  ListFlowProjectUserResponse() {}

  explicit ListFlowProjectUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFlowProjectUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFlowProjectUserResponseBody>(model1);
      }
    }
  }


  virtual ~ListFlowProjectUserResponse() = default;
};
class DeleteClusterHostGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> hostGroupId{};
  shared_ptr<string> comment{};

  DeleteClusterHostGroupRequest() {}

  explicit DeleteClusterHostGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
  }


  virtual ~DeleteClusterHostGroupRequest() = default;
};
class DeleteClusterHostGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteClusterHostGroupResponseBody() {}

  explicit DeleteClusterHostGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteClusterHostGroupResponseBody() = default;
};
class DeleteClusterHostGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteClusterHostGroupResponseBody> body{};

  DeleteClusterHostGroupResponse() {}

  explicit DeleteClusterHostGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteClusterHostGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteClusterHostGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteClusterHostGroupResponse() = default;
};
class DescribeLibraryDetailRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> libraryBizId{};

  DescribeLibraryDetailRequest() {}

  explicit DescribeLibraryDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (libraryBizId) {
      res["LibraryBizId"] = boost::any(*libraryBizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("LibraryBizId") != m.end() && !m["LibraryBizId"].empty()) {
      libraryBizId = make_shared<string>(boost::any_cast<string>(m["LibraryBizId"]));
    }
  }


  virtual ~DescribeLibraryDetailRequest() = default;
};
class DescribeLibraryDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> requestId{};
  shared_ptr<long> createTime{};
  shared_ptr<string> userId{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> bizId{};
  shared_ptr<string> scope{};
  shared_ptr<string> libraryVersion{};
  shared_ptr<string> name{};
  shared_ptr<string> properties{};
  shared_ptr<string> sourceLocation{};

  DescribeLibraryDetailResponseBody() {}

  explicit DescribeLibraryDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (libraryVersion) {
      res["LibraryVersion"] = boost::any(*libraryVersion);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (properties) {
      res["Properties"] = boost::any(*properties);
    }
    if (sourceLocation) {
      res["SourceLocation"] = boost::any(*sourceLocation);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("LibraryVersion") != m.end() && !m["LibraryVersion"].empty()) {
      libraryVersion = make_shared<string>(boost::any_cast<string>(m["LibraryVersion"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Properties") != m.end() && !m["Properties"].empty()) {
      properties = make_shared<string>(boost::any_cast<string>(m["Properties"]));
    }
    if (m.find("SourceLocation") != m.end() && !m["SourceLocation"].empty()) {
      sourceLocation = make_shared<string>(boost::any_cast<string>(m["SourceLocation"]));
    }
  }


  virtual ~DescribeLibraryDetailResponseBody() = default;
};
class DescribeLibraryDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeLibraryDetailResponseBody> body{};

  DescribeLibraryDetailResponse() {}

  explicit DescribeLibraryDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLibraryDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLibraryDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLibraryDetailResponse() = default;
};
class ListFlowsRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> name{};
  shared_ptr<string> id{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> status{};
  shared_ptr<bool> periodic{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListFlowsRequest() {}

  explicit ListFlowsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (periodic) {
      res["Periodic"] = boost::any(*periodic);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Periodic") != m.end() && !m["Periodic"].empty()) {
      periodic = make_shared<bool>(boost::any_cast<bool>(m["Periodic"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListFlowsRequest() = default;
};
class ListFlowsResponseBodyFlowFlow : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> status{};
  shared_ptr<string> alertUserGroupBizId{};
  shared_ptr<bool> periodic{};
  shared_ptr<string> projectId{};
  shared_ptr<string> hostName{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> description{};
  shared_ptr<long> startSchedule{};
  shared_ptr<bool> createCluster{};
  shared_ptr<long> endSchedule{};
  shared_ptr<string> graph{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<string> alertDingDingGroupBizId{};
  shared_ptr<string> cronExpr{};
  shared_ptr<string> categoryId{};
  shared_ptr<string> name{};
  shared_ptr<string> id{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> alertConf{};

  ListFlowsResponseBodyFlowFlow() {}

  explicit ListFlowsResponseBodyFlowFlow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (alertUserGroupBizId) {
      res["AlertUserGroupBizId"] = boost::any(*alertUserGroupBizId);
    }
    if (periodic) {
      res["Periodic"] = boost::any(*periodic);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (startSchedule) {
      res["StartSchedule"] = boost::any(*startSchedule);
    }
    if (createCluster) {
      res["CreateCluster"] = boost::any(*createCluster);
    }
    if (endSchedule) {
      res["EndSchedule"] = boost::any(*endSchedule);
    }
    if (graph) {
      res["Graph"] = boost::any(*graph);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (alertDingDingGroupBizId) {
      res["AlertDingDingGroupBizId"] = boost::any(*alertDingDingGroupBizId);
    }
    if (cronExpr) {
      res["CronExpr"] = boost::any(*cronExpr);
    }
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (alertConf) {
      res["AlertConf"] = boost::any(*alertConf);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("AlertUserGroupBizId") != m.end() && !m["AlertUserGroupBizId"].empty()) {
      alertUserGroupBizId = make_shared<string>(boost::any_cast<string>(m["AlertUserGroupBizId"]));
    }
    if (m.find("Periodic") != m.end() && !m["Periodic"].empty()) {
      periodic = make_shared<bool>(boost::any_cast<bool>(m["Periodic"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("StartSchedule") != m.end() && !m["StartSchedule"].empty()) {
      startSchedule = make_shared<long>(boost::any_cast<long>(m["StartSchedule"]));
    }
    if (m.find("CreateCluster") != m.end() && !m["CreateCluster"].empty()) {
      createCluster = make_shared<bool>(boost::any_cast<bool>(m["CreateCluster"]));
    }
    if (m.find("EndSchedule") != m.end() && !m["EndSchedule"].empty()) {
      endSchedule = make_shared<long>(boost::any_cast<long>(m["EndSchedule"]));
    }
    if (m.find("Graph") != m.end() && !m["Graph"].empty()) {
      graph = make_shared<string>(boost::any_cast<string>(m["Graph"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("AlertDingDingGroupBizId") != m.end() && !m["AlertDingDingGroupBizId"].empty()) {
      alertDingDingGroupBizId = make_shared<string>(boost::any_cast<string>(m["AlertDingDingGroupBizId"]));
    }
    if (m.find("CronExpr") != m.end() && !m["CronExpr"].empty()) {
      cronExpr = make_shared<string>(boost::any_cast<string>(m["CronExpr"]));
    }
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<string>(boost::any_cast<string>(m["CategoryId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("AlertConf") != m.end() && !m["AlertConf"].empty()) {
      alertConf = make_shared<string>(boost::any_cast<string>(m["AlertConf"]));
    }
  }


  virtual ~ListFlowsResponseBodyFlowFlow() = default;
};
class ListFlowsResponseBodyFlow : public Darabonba::Model {
public:
  shared_ptr<vector<ListFlowsResponseBodyFlowFlow>> flow{};

  ListFlowsResponseBodyFlow() {}

  explicit ListFlowsResponseBodyFlow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flow) {
      vector<boost::any> temp1;
      for(auto item1:*flow){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Flow"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Flow") != m.end() && !m["Flow"].empty()) {
      if (typeid(vector<boost::any>) == m["Flow"].type()) {
        vector<ListFlowsResponseBodyFlowFlow> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Flow"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFlowsResponseBodyFlowFlow model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        flow = make_shared<vector<ListFlowsResponseBodyFlowFlow>>(expect1);
      }
    }
  }


  virtual ~ListFlowsResponseBodyFlow() = default;
};
class ListFlowsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};
  shared_ptr<ListFlowsResponseBodyFlow> flow{};

  ListFlowsResponseBody() {}

  explicit ListFlowsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (flow) {
      res["Flow"] = flow ? boost::any(flow->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("Flow") != m.end() && !m["Flow"].empty()) {
      if (typeid(map<string, boost::any>) == m["Flow"].type()) {
        ListFlowsResponseBodyFlow model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Flow"]));
        flow = make_shared<ListFlowsResponseBodyFlow>(model1);
      }
    }
  }


  virtual ~ListFlowsResponseBody() = default;
};
class ListFlowsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListFlowsResponseBody> body{};

  ListFlowsResponse() {}

  explicit ListFlowsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFlowsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFlowsResponseBody>(model1);
      }
    }
  }


  virtual ~ListFlowsResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  CreateFlowResponse createFlowWithOptions(shared_ptr<CreateFlowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFlowResponse createFlow(shared_ptr<CreateFlowRequest> request);
  ListUsersResponse listUsersWithOptions(shared_ptr<ListUsersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListUsersResponse listUsers(shared_ptr<ListUsersRequest> request);
  ModifyFlowProjectResponse modifyFlowProjectWithOptions(shared_ptr<ModifyFlowProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyFlowProjectResponse modifyFlowProject(shared_ptr<ModifyFlowProjectRequest> request);
  QueryKnoxUserPasswordResponse queryKnoxUserPasswordWithOptions(shared_ptr<QueryKnoxUserPasswordRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryKnoxUserPasswordResponse queryKnoxUserPassword(shared_ptr<QueryKnoxUserPasswordRequest> request);
  DescribeFlowNodeInstanceLauncherLogResponse describeFlowNodeInstanceLauncherLogWithOptions(shared_ptr<DescribeFlowNodeInstanceLauncherLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFlowNodeInstanceLauncherLogResponse describeFlowNodeInstanceLauncherLog(shared_ptr<DescribeFlowNodeInstanceLauncherLogRequest> request);
  ListFlowResponse listFlowWithOptions(shared_ptr<ListFlowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFlowResponse listFlow(shared_ptr<ListFlowRequest> request);
  UntagResourcesResponse untagResourcesWithOptions(shared_ptr<UntagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UntagResourcesResponse untagResources(shared_ptr<UntagResourcesRequest> request);
  ListFlowClusterHostResponse listFlowClusterHostWithOptions(shared_ptr<ListFlowClusterHostRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFlowClusterHostResponse listFlowClusterHost(shared_ptr<ListFlowClusterHostRequest> request);
  ListClusterOperationResponse listClusterOperationWithOptions(shared_ptr<ListClusterOperationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListClusterOperationResponse listClusterOperation(shared_ptr<ListClusterOperationRequest> request);
  ListFlowEntitySnapshotResponse listFlowEntitySnapshotWithOptions(shared_ptr<ListFlowEntitySnapshotRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFlowEntitySnapshotResponse listFlowEntitySnapshot(shared_ptr<ListFlowEntitySnapshotRequest> request);
  DeleteClusterTemplateResponse deleteClusterTemplateWithOptions(shared_ptr<DeleteClusterTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteClusterTemplateResponse deleteClusterTemplate(shared_ptr<DeleteClusterTemplateRequest> request);
  CancelOrderResponse cancelOrderWithOptions(shared_ptr<CancelOrderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelOrderResponse cancelOrder(shared_ptr<CancelOrderRequest> request);
  CloneFlowJobResponse cloneFlowJobWithOptions(shared_ptr<CloneFlowJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CloneFlowJobResponse cloneFlowJob(shared_ptr<CloneFlowJobRequest> request);
  StartFlowResponse startFlowWithOptions(shared_ptr<StartFlowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartFlowResponse startFlow(shared_ptr<StartFlowRequest> request);
  CreateFlowJobResponse createFlowJobWithOptions(shared_ptr<CreateFlowJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFlowJobResponse createFlowJob(shared_ptr<CreateFlowJobRequest> request);
  DeleteFlowCategoryResponse deleteFlowCategoryWithOptions(shared_ptr<DeleteFlowCategoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteFlowCategoryResponse deleteFlowCategory(shared_ptr<DeleteFlowCategoryRequest> request);
  DeleteFlowEditLockResponse deleteFlowEditLockWithOptions(shared_ptr<DeleteFlowEditLockRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteFlowEditLockResponse deleteFlowEditLock(shared_ptr<DeleteFlowEditLockRequest> request);
  ResizeClusterResponse resizeClusterWithOptions(shared_ptr<ResizeClusterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResizeClusterResponse resizeCluster(shared_ptr<ResizeClusterRequest> request);
  DescribeMetaTablePreviewTaskResponse describeMetaTablePreviewTaskWithOptions(shared_ptr<DescribeMetaTablePreviewTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMetaTablePreviewTaskResponse describeMetaTablePreviewTask(shared_ptr<DescribeMetaTablePreviewTaskRequest> request);
  ListClusterServiceConfigHistoryResponse listClusterServiceConfigHistoryWithOptions(shared_ptr<ListClusterServiceConfigHistoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListClusterServiceConfigHistoryResponse listClusterServiceConfigHistory(shared_ptr<ListClusterServiceConfigHistoryRequest> request);
  ModifyScalingConfigItemResponse modifyScalingConfigItemWithOptions(shared_ptr<ModifyScalingConfigItemRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyScalingConfigItemResponse modifyScalingConfigItem(shared_ptr<ModifyScalingConfigItemRequest> request);
  ListFlowClusterAllResponse listFlowClusterAllWithOptions(shared_ptr<ListFlowClusterAllRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFlowClusterAllResponse listFlowClusterAll(shared_ptr<ListFlowClusterAllRequest> request);
  DescribeScalingGroupResponse describeScalingGroupWithOptions(shared_ptr<DescribeScalingGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeScalingGroupResponse describeScalingGroup(shared_ptr<DescribeScalingGroupRequest> request);
  ListScalingGroupResponse listScalingGroupWithOptions(shared_ptr<ListScalingGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListScalingGroupResponse listScalingGroup(shared_ptr<ListScalingGroupRequest> request);
  ModifyFlowCategoryResponse modifyFlowCategoryWithOptions(shared_ptr<ModifyFlowCategoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyFlowCategoryResponse modifyFlowCategory(shared_ptr<ModifyFlowCategoryRequest> request);
  ModifyClusterServiceConfigResponse modifyClusterServiceConfigWithOptions(shared_ptr<ModifyClusterServiceConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyClusterServiceConfigResponse modifyClusterServiceConfig(shared_ptr<ModifyClusterServiceConfigRequest> request);
  CloneFlowResponse cloneFlowWithOptions(shared_ptr<CloneFlowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CloneFlowResponse cloneFlow(shared_ptr<CloneFlowRequest> request);
  CreateClusterTemplateResponse createClusterTemplateWithOptions(shared_ptr<CreateClusterTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateClusterTemplateResponse createClusterTemplate(shared_ptr<CreateClusterTemplateRequest> request);
  UpdateLibraryInstallTaskStatusResponse updateLibraryInstallTaskStatusWithOptions(shared_ptr<UpdateLibraryInstallTaskStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateLibraryInstallTaskStatusResponse updateLibraryInstallTaskStatus(shared_ptr<UpdateLibraryInstallTaskStatusRequest> request);
  ListScalingConfigItemResponse listScalingConfigItemWithOptions(shared_ptr<ListScalingConfigItemRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListScalingConfigItemResponse listScalingConfigItem(shared_ptr<ListScalingConfigItemRequest> request);
  ListFlowInstanceResponse listFlowInstanceWithOptions(shared_ptr<ListFlowInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFlowInstanceResponse listFlowInstance(shared_ptr<ListFlowInstanceRequest> request);
  DescribeScalingMetricsResponse describeScalingMetricsWithOptions(shared_ptr<DescribeScalingMetricsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeScalingMetricsResponse describeScalingMetrics(shared_ptr<DescribeScalingMetricsRequest> request);
  UntagResourcesSystemTagsResponse untagResourcesSystemTagsWithOptions(shared_ptr<UntagResourcesSystemTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UntagResourcesSystemTagsResponse untagResourcesSystemTags(shared_ptr<UntagResourcesSystemTagsRequest> request);
  DescribeFlowProjectResponse describeFlowProjectWithOptions(shared_ptr<DescribeFlowProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFlowProjectResponse describeFlowProject(shared_ptr<DescribeFlowProjectRequest> request);
  DeleteSecurityWhiteListResponse deleteSecurityWhiteListWithOptions(shared_ptr<DeleteSecurityWhiteListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSecurityWhiteListResponse deleteSecurityWhiteList(shared_ptr<DeleteSecurityWhiteListRequest> request);
  ListScalingActivityResponse listScalingActivityWithOptions(shared_ptr<ListScalingActivityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListScalingActivityResponse listScalingActivity(shared_ptr<ListScalingActivityRequest> request);
  ListTagValuesResponse listTagValuesWithOptions(shared_ptr<ListTagValuesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTagValuesResponse listTagValues(shared_ptr<ListTagValuesRequest> request);
  ListClusterInstalledServiceResponse listClusterInstalledServiceWithOptions(shared_ptr<ListClusterInstalledServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListClusterInstalledServiceResponse listClusterInstalledService(shared_ptr<ListClusterInstalledServiceRequest> request);
  RunClusterServiceActionResponse runClusterServiceActionWithOptions(shared_ptr<RunClusterServiceActionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunClusterServiceActionResponse runClusterServiceAction(shared_ptr<RunClusterServiceActionRequest> request);
  SuspendFlowResponse suspendFlowWithOptions(shared_ptr<SuspendFlowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SuspendFlowResponse suspendFlow(shared_ptr<SuspendFlowRequest> request);
  CreateFlowProjectResponse createFlowProjectWithOptions(shared_ptr<CreateFlowProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFlowProjectResponse createFlowProject(shared_ptr<CreateFlowProjectRequest> request);
  ListFlowNodeInstanceContainerStatusResponse listFlowNodeInstanceContainerStatusWithOptions(shared_ptr<ListFlowNodeInstanceContainerStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFlowNodeInstanceContainerStatusResponse listFlowNodeInstanceContainerStatus(shared_ptr<ListFlowNodeInstanceContainerStatusRequest> request);
  ModifyClusterTemplateResponse modifyClusterTemplateWithOptions(shared_ptr<ModifyClusterTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyClusterTemplateResponse modifyClusterTemplate(shared_ptr<ModifyClusterTemplateRequest> request);
  AddSecurityWhiteListResponse addSecurityWhiteListWithOptions(shared_ptr<AddSecurityWhiteListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddSecurityWhiteListResponse addSecurityWhiteList(shared_ptr<AddSecurityWhiteListRequest> request);
  ListMetaClusterResponse listMetaClusterWithOptions(shared_ptr<ListMetaClusterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMetaClusterResponse listMetaCluster(shared_ptr<ListMetaClusterRequest> request);
  ListClusterOperationHostResponse listClusterOperationHostWithOptions(shared_ptr<ListClusterOperationHostRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListClusterOperationHostResponse listClusterOperationHost(shared_ptr<ListClusterOperationHostRequest> request);
  ListClusterTemplatesResponse listClusterTemplatesWithOptions(shared_ptr<ListClusterTemplatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListClusterTemplatesResponse listClusterTemplates(shared_ptr<ListClusterTemplatesRequest> request);
  ListClustersResponse listClustersWithOptions(shared_ptr<ListClustersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListClustersResponse listClusters(shared_ptr<ListClustersRequest> request);
  TagResourcesSystemTagsResponse tagResourcesSystemTagsWithOptions(shared_ptr<TagResourcesSystemTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TagResourcesSystemTagsResponse tagResourcesSystemTags(shared_ptr<TagResourcesSystemTagsRequest> request);
  ModifyFlowJobResponse modifyFlowJobWithOptions(shared_ptr<ModifyFlowJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyFlowJobResponse modifyFlowJob(shared_ptr<ModifyFlowJobRequest> request);
  DeleteFlowResponse deleteFlowWithOptions(shared_ptr<DeleteFlowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteFlowResponse deleteFlow(shared_ptr<DeleteFlowRequest> request);
  CreateFlowEditLockResponse createFlowEditLockWithOptions(shared_ptr<CreateFlowEditLockRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFlowEditLockResponse createFlowEditLock(shared_ptr<CreateFlowEditLockRequest> request);
  DescribeFlowNodeInstanceResponse describeFlowNodeInstanceWithOptions(shared_ptr<DescribeFlowNodeInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFlowNodeInstanceResponse describeFlowNodeInstance(shared_ptr<DescribeFlowNodeInstanceRequest> request);
  DetachAndReleaseClusterEniResponse detachAndReleaseClusterEniWithOptions(shared_ptr<DetachAndReleaseClusterEniRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DetachAndReleaseClusterEniResponse detachAndReleaseClusterEni(shared_ptr<DetachAndReleaseClusterEniRequest> request);
  DescribeScalingGroupInstanceResponse describeScalingGroupInstanceWithOptions(shared_ptr<DescribeScalingGroupInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeScalingGroupInstanceResponse describeScalingGroupInstance(shared_ptr<DescribeScalingGroupInstanceRequest> request);
  CreateClusterHostGroupResponse createClusterHostGroupWithOptions(shared_ptr<CreateClusterHostGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateClusterHostGroupResponse createClusterHostGroup(shared_ptr<CreateClusterHostGroupRequest> request);
  DescribeClusterTemplateResponse describeClusterTemplateWithOptions(shared_ptr<DescribeClusterTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeClusterTemplateResponse describeClusterTemplate(shared_ptr<DescribeClusterTemplateRequest> request);
  TagResourcesResponse tagResourcesWithOptions(shared_ptr<TagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TagResourcesResponse tagResources(shared_ptr<TagResourcesRequest> request);
  CommitFlowEntitySnapshotResponse commitFlowEntitySnapshotWithOptions(shared_ptr<CommitFlowEntitySnapshotRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CommitFlowEntitySnapshotResponse commitFlowEntitySnapshot(shared_ptr<CommitFlowEntitySnapshotRequest> request);
  SubmitFlowJobResponse submitFlowJobWithOptions(shared_ptr<SubmitFlowJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitFlowJobResponse submitFlowJob(shared_ptr<SubmitFlowJobRequest> request);
  ListFlowJobHistoryResponse listFlowJobHistoryWithOptions(shared_ptr<ListFlowJobHistoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFlowJobHistoryResponse listFlowJobHistory(shared_ptr<ListFlowJobHistoryRequest> request);
  ListTagResourcesResponse listTagResourcesWithOptions(shared_ptr<ListTagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTagResourcesResponse listTagResources(shared_ptr<ListTagResourcesRequest> request);
  ListClusterHostComponentResponse listClusterHostComponentWithOptions(shared_ptr<ListClusterHostComponentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListClusterHostComponentResponse listClusterHostComponent(shared_ptr<ListClusterHostComponentRequest> request);
  ModifyScalingGroupResponse modifyScalingGroupWithOptions(shared_ptr<ModifyScalingGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyScalingGroupResponse modifyScalingGroup(shared_ptr<ModifyScalingGroupRequest> request);
  DescribeFlowProjectClusterSettingResponse describeFlowProjectClusterSettingWithOptions(shared_ptr<DescribeFlowProjectClusterSettingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFlowProjectClusterSettingResponse describeFlowProjectClusterSetting(shared_ptr<DescribeFlowProjectClusterSettingRequest> request);
  ListFlowProjectClusterSettingResponse listFlowProjectClusterSettingWithOptions(shared_ptr<ListFlowProjectClusterSettingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFlowProjectClusterSettingResponse listFlowProjectClusterSetting(shared_ptr<ListFlowProjectClusterSettingRequest> request);
  SubmitFlowResponse submitFlowWithOptions(shared_ptr<SubmitFlowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitFlowResponse submitFlow(shared_ptr<SubmitFlowRequest> request);
  DescribeScalingCommonConfigResponse describeScalingCommonConfigWithOptions(shared_ptr<DescribeScalingCommonConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeScalingCommonConfigResponse describeScalingCommonConfig(shared_ptr<DescribeScalingCommonConfigRequest> request);
  ResumeFlowResponse resumeFlowWithOptions(shared_ptr<ResumeFlowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResumeFlowResponse resumeFlow(shared_ptr<ResumeFlowRequest> request);
  RestoreFlowEntitySnapshotResponse restoreFlowEntitySnapshotWithOptions(shared_ptr<RestoreFlowEntitySnapshotRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RestoreFlowEntitySnapshotResponse restoreFlowEntitySnapshot(shared_ptr<RestoreFlowEntitySnapshotRequest> request);
  CreateLibraryResponse createLibraryWithOptions(shared_ptr<CreateLibraryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateLibraryResponse createLibrary(shared_ptr<CreateLibraryRequest> request);
  ListVswitchResponse listVswitchWithOptions(shared_ptr<ListVswitchRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListVswitchResponse listVswitch(shared_ptr<ListVswitchRequest> request);
  DeleteFlowProjectResponse deleteFlowProjectWithOptions(shared_ptr<DeleteFlowProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteFlowProjectResponse deleteFlowProject(shared_ptr<DeleteFlowProjectRequest> request);
  ReleaseClusterResponse releaseClusterWithOptions(shared_ptr<ReleaseClusterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReleaseClusterResponse releaseCluster(shared_ptr<ReleaseClusterRequest> request);
  AddScalingConfigItemResponse addScalingConfigItemWithOptions(shared_ptr<AddScalingConfigItemRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddScalingConfigItemResponse addScalingConfigItem(shared_ptr<AddScalingConfigItemRequest> request);
  ResetUserPasswordResponse resetUserPasswordWithOptions(shared_ptr<ResetUserPasswordRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResetUserPasswordResponse resetUserPassword(shared_ptr<ResetUserPasswordRequest> request);
  ListFlowClusterAllHostsResponse listFlowClusterAllHostsWithOptions(shared_ptr<ListFlowClusterAllHostsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFlowClusterAllHostsResponse listFlowClusterAllHosts(shared_ptr<ListFlowClusterAllHostsRequest> request);
  DeleteLibrariesResponse deleteLibrariesWithOptions(shared_ptr<DeleteLibrariesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLibrariesResponse deleteLibraries(shared_ptr<DeleteLibrariesRequest> request);
  DescribeFlowCategoryTreeResponse describeFlowCategoryTreeWithOptions(shared_ptr<DescribeFlowCategoryTreeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFlowCategoryTreeResponse describeFlowCategoryTree(shared_ptr<DescribeFlowCategoryTreeRequest> request);
  ListDatasourceInstancesResponse listDatasourceInstancesWithOptions(shared_ptr<ListDatasourceInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDatasourceInstancesResponse listDatasourceInstances(shared_ptr<ListDatasourceInstancesRequest> request);
  ListFlowNodeSqlResultResponse listFlowNodeSqlResultWithOptions(shared_ptr<ListFlowNodeSqlResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFlowNodeSqlResultResponse listFlowNodeSqlResult(shared_ptr<ListFlowNodeSqlResultRequest> request);
  DescribeFlowJobResponse describeFlowJobWithOptions(shared_ptr<DescribeFlowJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFlowJobResponse describeFlowJob(shared_ptr<DescribeFlowJobRequest> request);
  DescribeLibraryInstallTaskDetailResponse describeLibraryInstallTaskDetailWithOptions(shared_ptr<DescribeLibraryInstallTaskDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLibraryInstallTaskDetailResponse describeLibraryInstallTaskDetail(shared_ptr<DescribeLibraryInstallTaskDetailRequest> request);
  ModifyFlowForWebResponse modifyFlowForWebWithOptions(shared_ptr<ModifyFlowForWebRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyFlowForWebResponse modifyFlowForWeb(shared_ptr<ModifyFlowForWebRequest> request);
  RemoveScalingConfigItemResponse removeScalingConfigItemWithOptions(shared_ptr<RemoveScalingConfigItemRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveScalingConfigItemResponse removeScalingConfigItem(shared_ptr<RemoveScalingConfigItemRequest> request);
  DescribeSecurityWhiteListResponse describeSecurityWhiteListWithOptions(shared_ptr<DescribeSecurityWhiteListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSecurityWhiteListResponse describeSecurityWhiteList(shared_ptr<DescribeSecurityWhiteListRequest> request);
  DescribeFlowNodeInstanceContainerLogResponse describeFlowNodeInstanceContainerLogWithOptions(shared_ptr<DescribeFlowNodeInstanceContainerLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFlowNodeInstanceContainerLogResponse describeFlowNodeInstanceContainerLog(shared_ptr<DescribeFlowNodeInstanceContainerLogRequest> request);
  RerunFlowResponse rerunFlowWithOptions(shared_ptr<RerunFlowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RerunFlowResponse rerunFlow(shared_ptr<RerunFlowRequest> request);
  ListTagKeysResponse listTagKeysWithOptions(shared_ptr<ListTagKeysRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTagKeysResponse listTagKeys(shared_ptr<ListTagKeysRequest> request);
  DescribeClusterOperationHostTaskLogResponse describeClusterOperationHostTaskLogWithOptions(shared_ptr<DescribeClusterOperationHostTaskLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeClusterOperationHostTaskLogResponse describeClusterOperationHostTaskLog(shared_ptr<DescribeClusterOperationHostTaskLogRequest> request);
  KillFlowJobResponse killFlowJobWithOptions(shared_ptr<KillFlowJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  KillFlowJobResponse killFlowJob(shared_ptr<KillFlowJobRequest> request);
  UninstallLibrariesResponse uninstallLibrariesWithOptions(shared_ptr<UninstallLibrariesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UninstallLibrariesResponse uninstallLibraries(shared_ptr<UninstallLibrariesRequest> request);
  DescribeClusterV2Response describeClusterV2WithOptions(shared_ptr<DescribeClusterV2Request> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeClusterV2Response describeClusterV2(shared_ptr<DescribeClusterV2Request> request);
  DescribeFlowResponse describeFlowWithOptions(shared_ptr<DescribeFlowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFlowResponse describeFlow(shared_ptr<DescribeFlowRequest> request);
  ListFlowClusterResponse listFlowClusterWithOptions(shared_ptr<ListFlowClusterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFlowClusterResponse listFlowCluster(shared_ptr<ListFlowClusterRequest> request);
  ListLdapUsersResponse listLdapUsersWithOptions(shared_ptr<ListLdapUsersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLdapUsersResponse listLdapUsers(shared_ptr<ListLdapUsersRequest> request);
  DeleteUserResponse deleteUserWithOptions(shared_ptr<DeleteUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteUserResponse deleteUser(shared_ptr<DeleteUserRequest> request);
  CreateFlowProjectClusterSettingResponse createFlowProjectClusterSettingWithOptions(shared_ptr<CreateFlowProjectClusterSettingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFlowProjectClusterSettingResponse createFlowProjectClusterSetting(shared_ptr<CreateFlowProjectClusterSettingRequest> request);
  DescribeFlowInstanceResponse describeFlowInstanceWithOptions(shared_ptr<DescribeFlowInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFlowInstanceResponse describeFlowInstance(shared_ptr<DescribeFlowInstanceRequest> request);
  CreateFlowProjectUserResponse createFlowProjectUserWithOptions(shared_ptr<CreateFlowProjectUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFlowProjectUserResponse createFlowProjectUser(shared_ptr<CreateFlowProjectUserRequest> request);
  CreateFlowCategoryResponse createFlowCategoryWithOptions(shared_ptr<CreateFlowCategoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFlowCategoryResponse createFlowCategory(shared_ptr<CreateFlowCategoryRequest> request);
  DeleteFlowProjectClusterSettingResponse deleteFlowProjectClusterSettingWithOptions(shared_ptr<DeleteFlowProjectClusterSettingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteFlowProjectClusterSettingResponse deleteFlowProjectClusterSetting(shared_ptr<DeleteFlowProjectClusterSettingRequest> request);
  ListLibrariesResponse listLibrariesWithOptions(shared_ptr<ListLibrariesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLibrariesResponse listLibraries(shared_ptr<ListLibrariesRequest> request);
  RunScalingActionResponse runScalingActionWithOptions(shared_ptr<RunScalingActionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunScalingActionResponse runScalingAction(shared_ptr<RunScalingActionRequest> request);
  InstallLibrariesResponse installLibrariesWithOptions(shared_ptr<InstallLibrariesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InstallLibrariesResponse installLibraries(shared_ptr<InstallLibrariesRequest> request);
  ListFlowJobsResponse listFlowJobsWithOptions(shared_ptr<ListFlowJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFlowJobsResponse listFlowJobs(shared_ptr<ListFlowJobsRequest> request);
  ModifyFlowResponse modifyFlowWithOptions(shared_ptr<ModifyFlowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyFlowResponse modifyFlow(shared_ptr<ModifyFlowRequest> request);
  DescribeRegionsResponse describeRegionsWithOptions(shared_ptr<DescribeRegionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRegionsResponse describeRegions(shared_ptr<DescribeRegionsRequest> request);
  ListLibraryStatusResponse listLibraryStatusWithOptions(shared_ptr<ListLibraryStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLibraryStatusResponse listLibraryStatus(shared_ptr<ListLibraryStatusRequest> request);
  DescribeClusterServiceConfigResponse describeClusterServiceConfigWithOptions(shared_ptr<DescribeClusterServiceConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeClusterServiceConfigResponse describeClusterServiceConfig(shared_ptr<DescribeClusterServiceConfigRequest> request);
  ModifyFlowProjectClusterSettingResponse modifyFlowProjectClusterSettingWithOptions(shared_ptr<ModifyFlowProjectClusterSettingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyFlowProjectClusterSettingResponse modifyFlowProjectClusterSetting(shared_ptr<ModifyFlowProjectClusterSettingRequest> request);
  DeleteFlowProjectUserResponse deleteFlowProjectUserWithOptions(shared_ptr<DeleteFlowProjectUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteFlowProjectUserResponse deleteFlowProjectUser(shared_ptr<DeleteFlowProjectUserRequest> request);
  CreateClusterV2Response createClusterV2WithOptions(shared_ptr<CreateClusterV2Request> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateClusterV2Response createClusterV2(shared_ptr<CreateClusterV2Request> request);
  ModifyClusterNameResponse modifyClusterNameWithOptions(shared_ptr<ModifyClusterNameRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyClusterNameResponse modifyClusterName(shared_ptr<ModifyClusterNameRequest> request);
  ListClusterOperationHostTaskResponse listClusterOperationHostTaskWithOptions(shared_ptr<ListClusterOperationHostTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListClusterOperationHostTaskResponse listClusterOperationHostTask(shared_ptr<ListClusterOperationHostTaskRequest> request);
  DescribeScalingConfigItemResponse describeScalingConfigItemWithOptions(shared_ptr<DescribeScalingConfigItemRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeScalingConfigItemResponse describeScalingConfigItem(shared_ptr<DescribeScalingConfigItemRequest> request);
  ListClusterHostResponse listClusterHostWithOptions(shared_ptr<ListClusterHostRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListClusterHostResponse listClusterHost(shared_ptr<ListClusterHostRequest> request);
  CreateScalingGroupResponse createScalingGroupWithOptions(shared_ptr<CreateScalingGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateScalingGroupResponse createScalingGroup(shared_ptr<CreateScalingGroupRequest> request);
  DescribeClusterServiceResponse describeClusterServiceWithOptions(shared_ptr<DescribeClusterServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeClusterServiceResponse describeClusterService(shared_ptr<DescribeClusterServiceRequest> request);
  ListFlowProjectsResponse listFlowProjectsWithOptions(shared_ptr<ListFlowProjectsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFlowProjectsResponse listFlowProjects(shared_ptr<ListFlowProjectsRequest> request);
  CreateMetaTablePreviewTaskResponse createMetaTablePreviewTaskWithOptions(shared_ptr<CreateMetaTablePreviewTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMetaTablePreviewTaskResponse createMetaTablePreviewTask(shared_ptr<CreateMetaTablePreviewTaskRequest> request);
  ListFlowProjectUserResponse listFlowProjectUserWithOptions(shared_ptr<ListFlowProjectUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFlowProjectUserResponse listFlowProjectUser(shared_ptr<ListFlowProjectUserRequest> request);
  DeleteClusterHostGroupResponse deleteClusterHostGroupWithOptions(shared_ptr<DeleteClusterHostGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteClusterHostGroupResponse deleteClusterHostGroup(shared_ptr<DeleteClusterHostGroupRequest> request);
  DescribeLibraryDetailResponse describeLibraryDetailWithOptions(shared_ptr<DescribeLibraryDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLibraryDetailResponse describeLibraryDetail(shared_ptr<DescribeLibraryDetailRequest> request);
  ListFlowsResponse listFlowsWithOptions(shared_ptr<ListFlowsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFlowsResponse listFlows(shared_ptr<ListFlowsRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Ddi20200617

#endif
