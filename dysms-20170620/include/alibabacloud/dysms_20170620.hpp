// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_DYSMS20170620_H_
#define ALIBABACLOUD_DYSMS20170620_H_

#include <alibabacloud/open_api.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Dysms20170620 {
class AddDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  AddDomainRequest() {}

  explicit AddDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~AddDomainRequest() = default;
};
class AddDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  AddDomainResponseBody() {}

  explicit AddDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddDomainResponseBody() = default;
};
class AddDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddDomainResponseBody> body{};

  AddDomainResponse() {}

  explicit AddDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddDomainResponseBody>(model1);
      }
    }
  }


  virtual ~AddDomainResponse() = default;
};
class AddDomainNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  AddDomainNewRequest() {}

  explicit AddDomainNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~AddDomainNewRequest() = default;
};
class AddDomainNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  AddDomainNewResponseBody() {}

  explicit AddDomainNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~AddDomainNewResponseBody() = default;
};
class AddDomainNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddDomainNewResponseBody> body{};

  AddDomainNewResponse() {}

  explicit AddDomainNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddDomainNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddDomainNewResponseBody>(model1);
      }
    }
  }


  virtual ~AddDomainNewResponse() = default;
};
class ApplyExportSmsSendRecordNewRequest : public Darabonba::Model {
public:
  shared_ptr<long> bizType{};
  shared_ptr<string> endDate{};
  shared_ptr<string> errorCode{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> phoneNum{};
  shared_ptr<string> prodCode{};
  shared_ptr<long> realTimeDataFlag{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> sendDate{};
  shared_ptr<long> sendStatus{};
  shared_ptr<string> signName{};
  shared_ptr<string> startDate{};
  shared_ptr<string> templateCode{};

  ApplyExportSmsSendRecordNewRequest() {}

  explicit ApplyExportSmsSendRecordNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (phoneNum) {
      res["PhoneNum"] = boost::any(*phoneNum);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (realTimeDataFlag) {
      res["RealTimeDataFlag"] = boost::any(*realTimeDataFlag);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sendDate) {
      res["SendDate"] = boost::any(*sendDate);
    }
    if (sendStatus) {
      res["SendStatus"] = boost::any(*sendStatus);
    }
    if (signName) {
      res["SignName"] = boost::any(*signName);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<long>(boost::any_cast<long>(m["BizType"]));
    }
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PhoneNum") != m.end() && !m["PhoneNum"].empty()) {
      phoneNum = make_shared<string>(boost::any_cast<string>(m["PhoneNum"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("RealTimeDataFlag") != m.end() && !m["RealTimeDataFlag"].empty()) {
      realTimeDataFlag = make_shared<long>(boost::any_cast<long>(m["RealTimeDataFlag"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SendDate") != m.end() && !m["SendDate"].empty()) {
      sendDate = make_shared<string>(boost::any_cast<string>(m["SendDate"]));
    }
    if (m.find("SendStatus") != m.end() && !m["SendStatus"].empty()) {
      sendStatus = make_shared<long>(boost::any_cast<long>(m["SendStatus"]));
    }
    if (m.find("SignName") != m.end() && !m["SignName"].empty()) {
      signName = make_shared<string>(boost::any_cast<string>(m["SignName"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
  }


  virtual ~ApplyExportSmsSendRecordNewRequest() = default;
};
class ApplyExportSmsSendRecordNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  ApplyExportSmsSendRecordNewResponseBody() {}

  explicit ApplyExportSmsSendRecordNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~ApplyExportSmsSendRecordNewResponseBody() = default;
};
class ApplyExportSmsSendRecordNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ApplyExportSmsSendRecordNewResponseBody> body{};

  ApplyExportSmsSendRecordNewResponse() {}

  explicit ApplyExportSmsSendRecordNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ApplyExportSmsSendRecordNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ApplyExportSmsSendRecordNewResponseBody>(model1);
      }
    }
  }


  virtual ~ApplyExportSmsSendRecordNewResponse() = default;
};
class BatchCreateSmsSignRequestColumnIndexMappingRule : public Darabonba::Model {
public:
  shared_ptr<long> adminIdentifiedNumber{};
  shared_ptr<long> adminName{};
  shared_ptr<long> companyName{};
  shared_ptr<long> legalPersonIdentifiedNumber{};
  shared_ptr<long> legalPersonName{};
  shared_ptr<long> organizationCode{};
  shared_ptr<long> remark{};
  shared_ptr<long> sceneDescription{};
  shared_ptr<long> signatureName{};
  shared_ptr<long> signatureSource{};
  shared_ptr<long> templateContent{};

  BatchCreateSmsSignRequestColumnIndexMappingRule() {}

  explicit BatchCreateSmsSignRequestColumnIndexMappingRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adminIdentifiedNumber) {
      res["AdminIdentifiedNumber"] = boost::any(*adminIdentifiedNumber);
    }
    if (adminName) {
      res["AdminName"] = boost::any(*adminName);
    }
    if (companyName) {
      res["CompanyName"] = boost::any(*companyName);
    }
    if (legalPersonIdentifiedNumber) {
      res["LegalPersonIdentifiedNumber"] = boost::any(*legalPersonIdentifiedNumber);
    }
    if (legalPersonName) {
      res["LegalPersonName"] = boost::any(*legalPersonName);
    }
    if (organizationCode) {
      res["OrganizationCode"] = boost::any(*organizationCode);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (sceneDescription) {
      res["SceneDescription"] = boost::any(*sceneDescription);
    }
    if (signatureName) {
      res["SignatureName"] = boost::any(*signatureName);
    }
    if (signatureSource) {
      res["SignatureSource"] = boost::any(*signatureSource);
    }
    if (templateContent) {
      res["TemplateContent"] = boost::any(*templateContent);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdminIdentifiedNumber") != m.end() && !m["AdminIdentifiedNumber"].empty()) {
      adminIdentifiedNumber = make_shared<long>(boost::any_cast<long>(m["AdminIdentifiedNumber"]));
    }
    if (m.find("AdminName") != m.end() && !m["AdminName"].empty()) {
      adminName = make_shared<long>(boost::any_cast<long>(m["AdminName"]));
    }
    if (m.find("CompanyName") != m.end() && !m["CompanyName"].empty()) {
      companyName = make_shared<long>(boost::any_cast<long>(m["CompanyName"]));
    }
    if (m.find("LegalPersonIdentifiedNumber") != m.end() && !m["LegalPersonIdentifiedNumber"].empty()) {
      legalPersonIdentifiedNumber = make_shared<long>(boost::any_cast<long>(m["LegalPersonIdentifiedNumber"]));
    }
    if (m.find("LegalPersonName") != m.end() && !m["LegalPersonName"].empty()) {
      legalPersonName = make_shared<long>(boost::any_cast<long>(m["LegalPersonName"]));
    }
    if (m.find("OrganizationCode") != m.end() && !m["OrganizationCode"].empty()) {
      organizationCode = make_shared<long>(boost::any_cast<long>(m["OrganizationCode"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<long>(boost::any_cast<long>(m["Remark"]));
    }
    if (m.find("SceneDescription") != m.end() && !m["SceneDescription"].empty()) {
      sceneDescription = make_shared<long>(boost::any_cast<long>(m["SceneDescription"]));
    }
    if (m.find("SignatureName") != m.end() && !m["SignatureName"].empty()) {
      signatureName = make_shared<long>(boost::any_cast<long>(m["SignatureName"]));
    }
    if (m.find("SignatureSource") != m.end() && !m["SignatureSource"].empty()) {
      signatureSource = make_shared<long>(boost::any_cast<long>(m["SignatureSource"]));
    }
    if (m.find("TemplateContent") != m.end() && !m["TemplateContent"].empty()) {
      templateContent = make_shared<long>(boost::any_cast<long>(m["TemplateContent"]));
    }
  }


  virtual ~BatchCreateSmsSignRequestColumnIndexMappingRule() = default;
};
class BatchCreateSmsSignRequest : public Darabonba::Model {
public:
  shared_ptr<BatchCreateSmsSignRequestColumnIndexMappingRule> columnIndexMappingRule{};
  shared_ptr<string> extendMessage{};
  shared_ptr<string> fileName{};
  shared_ptr<vector<string>> moreData{};
  shared_ptr<long> operationType{};
  shared_ptr<string> ossKeys{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> remark{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> sceneType{};
  shared_ptr<long> serviceType{};
  shared_ptr<string> signOssKey{};
  shared_ptr<string> userViewFileName{};

  BatchCreateSmsSignRequest() {}

  explicit BatchCreateSmsSignRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnIndexMappingRule) {
      res["ColumnIndexMappingRule"] = columnIndexMappingRule ? boost::any(columnIndexMappingRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (extendMessage) {
      res["ExtendMessage"] = boost::any(*extendMessage);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (moreData) {
      res["MoreData"] = boost::any(*moreData);
    }
    if (operationType) {
      res["OperationType"] = boost::any(*operationType);
    }
    if (ossKeys) {
      res["OssKeys"] = boost::any(*ossKeys);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sceneType) {
      res["SceneType"] = boost::any(*sceneType);
    }
    if (serviceType) {
      res["ServiceType"] = boost::any(*serviceType);
    }
    if (signOssKey) {
      res["SignOssKey"] = boost::any(*signOssKey);
    }
    if (userViewFileName) {
      res["UserViewFileName"] = boost::any(*userViewFileName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnIndexMappingRule") != m.end() && !m["ColumnIndexMappingRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["ColumnIndexMappingRule"].type()) {
        BatchCreateSmsSignRequestColumnIndexMappingRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ColumnIndexMappingRule"]));
        columnIndexMappingRule = make_shared<BatchCreateSmsSignRequestColumnIndexMappingRule>(model1);
      }
    }
    if (m.find("ExtendMessage") != m.end() && !m["ExtendMessage"].empty()) {
      extendMessage = make_shared<string>(boost::any_cast<string>(m["ExtendMessage"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("MoreData") != m.end() && !m["MoreData"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MoreData"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MoreData"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      moreData = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OperationType") != m.end() && !m["OperationType"].empty()) {
      operationType = make_shared<long>(boost::any_cast<long>(m["OperationType"]));
    }
    if (m.find("OssKeys") != m.end() && !m["OssKeys"].empty()) {
      ossKeys = make_shared<string>(boost::any_cast<string>(m["OssKeys"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SceneType") != m.end() && !m["SceneType"].empty()) {
      sceneType = make_shared<long>(boost::any_cast<long>(m["SceneType"]));
    }
    if (m.find("ServiceType") != m.end() && !m["ServiceType"].empty()) {
      serviceType = make_shared<long>(boost::any_cast<long>(m["ServiceType"]));
    }
    if (m.find("SignOssKey") != m.end() && !m["SignOssKey"].empty()) {
      signOssKey = make_shared<string>(boost::any_cast<string>(m["SignOssKey"]));
    }
    if (m.find("UserViewFileName") != m.end() && !m["UserViewFileName"].empty()) {
      userViewFileName = make_shared<string>(boost::any_cast<string>(m["UserViewFileName"]));
    }
  }


  virtual ~BatchCreateSmsSignRequest() = default;
};
class BatchCreateSmsSignShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> columnIndexMappingRuleShrink{};
  shared_ptr<string> extendMessage{};
  shared_ptr<string> fileName{};
  shared_ptr<string> moreDataShrink{};
  shared_ptr<long> operationType{};
  shared_ptr<string> ossKeys{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> remark{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> sceneType{};
  shared_ptr<long> serviceType{};
  shared_ptr<string> signOssKey{};
  shared_ptr<string> userViewFileName{};

  BatchCreateSmsSignShrinkRequest() {}

  explicit BatchCreateSmsSignShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnIndexMappingRuleShrink) {
      res["ColumnIndexMappingRule"] = boost::any(*columnIndexMappingRuleShrink);
    }
    if (extendMessage) {
      res["ExtendMessage"] = boost::any(*extendMessage);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (moreDataShrink) {
      res["MoreData"] = boost::any(*moreDataShrink);
    }
    if (operationType) {
      res["OperationType"] = boost::any(*operationType);
    }
    if (ossKeys) {
      res["OssKeys"] = boost::any(*ossKeys);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sceneType) {
      res["SceneType"] = boost::any(*sceneType);
    }
    if (serviceType) {
      res["ServiceType"] = boost::any(*serviceType);
    }
    if (signOssKey) {
      res["SignOssKey"] = boost::any(*signOssKey);
    }
    if (userViewFileName) {
      res["UserViewFileName"] = boost::any(*userViewFileName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnIndexMappingRule") != m.end() && !m["ColumnIndexMappingRule"].empty()) {
      columnIndexMappingRuleShrink = make_shared<string>(boost::any_cast<string>(m["ColumnIndexMappingRule"]));
    }
    if (m.find("ExtendMessage") != m.end() && !m["ExtendMessage"].empty()) {
      extendMessage = make_shared<string>(boost::any_cast<string>(m["ExtendMessage"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("MoreData") != m.end() && !m["MoreData"].empty()) {
      moreDataShrink = make_shared<string>(boost::any_cast<string>(m["MoreData"]));
    }
    if (m.find("OperationType") != m.end() && !m["OperationType"].empty()) {
      operationType = make_shared<long>(boost::any_cast<long>(m["OperationType"]));
    }
    if (m.find("OssKeys") != m.end() && !m["OssKeys"].empty()) {
      ossKeys = make_shared<string>(boost::any_cast<string>(m["OssKeys"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SceneType") != m.end() && !m["SceneType"].empty()) {
      sceneType = make_shared<long>(boost::any_cast<long>(m["SceneType"]));
    }
    if (m.find("ServiceType") != m.end() && !m["ServiceType"].empty()) {
      serviceType = make_shared<long>(boost::any_cast<long>(m["ServiceType"]));
    }
    if (m.find("SignOssKey") != m.end() && !m["SignOssKey"].empty()) {
      signOssKey = make_shared<string>(boost::any_cast<string>(m["SignOssKey"]));
    }
    if (m.find("UserViewFileName") != m.end() && !m["UserViewFileName"].empty()) {
      userViewFileName = make_shared<string>(boost::any_cast<string>(m["UserViewFileName"]));
    }
  }


  virtual ~BatchCreateSmsSignShrinkRequest() = default;
};
class BatchCreateSmsSignResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> appliedNum{};
  shared_ptr<long> availableNum{};
  shared_ptr<string> batchCreateSmsSignResult{};

  BatchCreateSmsSignResponseBodyData() {}

  explicit BatchCreateSmsSignResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appliedNum) {
      res["AppliedNum"] = boost::any(*appliedNum);
    }
    if (availableNum) {
      res["AvailableNum"] = boost::any(*availableNum);
    }
    if (batchCreateSmsSignResult) {
      res["BatchCreateSmsSignResult"] = boost::any(*batchCreateSmsSignResult);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppliedNum") != m.end() && !m["AppliedNum"].empty()) {
      appliedNum = make_shared<long>(boost::any_cast<long>(m["AppliedNum"]));
    }
    if (m.find("AvailableNum") != m.end() && !m["AvailableNum"].empty()) {
      availableNum = make_shared<long>(boost::any_cast<long>(m["AvailableNum"]));
    }
    if (m.find("BatchCreateSmsSignResult") != m.end() && !m["BatchCreateSmsSignResult"].empty()) {
      batchCreateSmsSignResult = make_shared<string>(boost::any_cast<string>(m["BatchCreateSmsSignResult"]));
    }
  }


  virtual ~BatchCreateSmsSignResponseBodyData() = default;
};
class BatchCreateSmsSignResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<BatchCreateSmsSignResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  BatchCreateSmsSignResponseBody() {}

  explicit BatchCreateSmsSignResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        BatchCreateSmsSignResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<BatchCreateSmsSignResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~BatchCreateSmsSignResponseBody() = default;
};
class BatchCreateSmsSignResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchCreateSmsSignResponseBody> body{};

  BatchCreateSmsSignResponse() {}

  explicit BatchCreateSmsSignResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchCreateSmsSignResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchCreateSmsSignResponseBody>(model1);
      }
    }
  }


  virtual ~BatchCreateSmsSignResponse() = default;
};
class BatchDeleteExportSendRecordNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> ids{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  BatchDeleteExportSendRecordNewRequest() {}

  explicit BatchDeleteExportSendRecordNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      ids = make_shared<string>(boost::any_cast<string>(m["Ids"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~BatchDeleteExportSendRecordNewRequest() = default;
};
class BatchDeleteExportSendRecordNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  BatchDeleteExportSendRecordNewResponseBody() {}

  explicit BatchDeleteExportSendRecordNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~BatchDeleteExportSendRecordNewResponseBody() = default;
};
class BatchDeleteExportSendRecordNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchDeleteExportSendRecordNewResponseBody> body{};

  BatchDeleteExportSendRecordNewResponse() {}

  explicit BatchDeleteExportSendRecordNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchDeleteExportSendRecordNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchDeleteExportSendRecordNewResponseBody>(model1);
      }
    }
  }


  virtual ~BatchDeleteExportSendRecordNewResponse() = default;
};
class BatchDeleteTaskNewRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> taskIds{};

  BatchDeleteTaskNewRequest() {}

  explicit BatchDeleteTaskNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (taskIds) {
      res["TaskIds"] = boost::any(*taskIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TaskIds") != m.end() && !m["TaskIds"].empty()) {
      taskIds = make_shared<string>(boost::any_cast<string>(m["TaskIds"]));
    }
  }


  virtual ~BatchDeleteTaskNewRequest() = default;
};
class BatchDeleteTaskNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> failList{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> successList{};

  BatchDeleteTaskNewResponseBody() {}

  explicit BatchDeleteTaskNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failList) {
      res["FailList"] = boost::any(*failList);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (successList) {
      res["SuccessList"] = boost::any(*successList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailList") != m.end() && !m["FailList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FailList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FailList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      failList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SuccessList") != m.end() && !m["SuccessList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SuccessList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SuccessList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      successList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchDeleteTaskNewResponseBody() = default;
};
class BatchDeleteTaskNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchDeleteTaskNewResponseBody> body{};

  BatchDeleteTaskNewResponse() {}

  explicit BatchDeleteTaskNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchDeleteTaskNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchDeleteTaskNewResponseBody>(model1);
      }
    }
  }


  virtual ~BatchDeleteTaskNewResponse() = default;
};
class CalculateSmsLengthNewRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> smsContent{};

  CalculateSmsLengthNewRequest() {}

  explicit CalculateSmsLengthNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (smsContent) {
      res["SmsContent"] = boost::any(*smsContent);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SmsContent") != m.end() && !m["SmsContent"].empty()) {
      smsContent = make_shared<string>(boost::any_cast<string>(m["SmsContent"]));
    }
  }


  virtual ~CalculateSmsLengthNewRequest() = default;
};
class CalculateSmsLengthNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> length{};
  shared_ptr<long> number{};
  shared_ptr<string> requestId{};

  CalculateSmsLengthNewResponseBody() {}

  explicit CalculateSmsLengthNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (length) {
      res["Length"] = boost::any(*length);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Length") != m.end() && !m["Length"].empty()) {
      length = make_shared<long>(boost::any_cast<long>(m["Length"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<long>(boost::any_cast<long>(m["Number"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CalculateSmsLengthNewResponseBody() = default;
};
class CalculateSmsLengthNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CalculateSmsLengthNewResponseBody> body{};

  CalculateSmsLengthNewResponse() {}

  explicit CalculateSmsLengthNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CalculateSmsLengthNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CalculateSmsLengthNewResponseBody>(model1);
      }
    }
  }


  virtual ~CalculateSmsLengthNewResponse() = default;
};
class CancelSmsSignRequest : public Darabonba::Model {
public:
  shared_ptr<string> orderId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<long> qualificationId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> signatureCode{};
  shared_ptr<long> signatureId{};

  CancelSmsSignRequest() {}

  explicit CancelSmsSignRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (qualificationId) {
      res["QualificationId"] = boost::any(*qualificationId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (signatureCode) {
      res["SignatureCode"] = boost::any(*signatureCode);
    }
    if (signatureId) {
      res["SignatureId"] = boost::any(*signatureId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("QualificationId") != m.end() && !m["QualificationId"].empty()) {
      qualificationId = make_shared<long>(boost::any_cast<long>(m["QualificationId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SignatureCode") != m.end() && !m["SignatureCode"].empty()) {
      signatureCode = make_shared<string>(boost::any_cast<string>(m["SignatureCode"]));
    }
    if (m.find("SignatureId") != m.end() && !m["SignatureId"].empty()) {
      signatureId = make_shared<long>(boost::any_cast<long>(m["SignatureId"]));
    }
  }


  virtual ~CancelSmsSignRequest() = default;
};
class CancelSmsSignResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  CancelSmsSignResponseBody() {}

  explicit CancelSmsSignResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~CancelSmsSignResponseBody() = default;
};
class CancelSmsSignResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CancelSmsSignResponseBody> body{};

  CancelSmsSignResponse() {}

  explicit CancelSmsSignResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelSmsSignResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelSmsSignResponseBody>(model1);
      }
    }
  }


  virtual ~CancelSmsSignResponse() = default;
};
class CancelSmsTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<long> orderId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> templateCode{};

  CancelSmsTemplateRequest() {}

  explicit CancelSmsTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
  }


  virtual ~CancelSmsTemplateRequest() = default;
};
class CancelSmsTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  CancelSmsTemplateResponseBody() {}

  explicit CancelSmsTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CancelSmsTemplateResponseBody() = default;
};
class CancelSmsTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CancelSmsTemplateResponseBody> body{};

  CancelSmsTemplateResponse() {}

  explicit CancelSmsTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelSmsTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelSmsTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~CancelSmsTemplateResponse() = default;
};
class CancelSmsTemplateNewRequest : public Darabonba::Model {
public:
  shared_ptr<bool> intelligentApproval{};
  shared_ptr<long> orderId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> templateCode{};

  CancelSmsTemplateNewRequest() {}

  explicit CancelSmsTemplateNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (intelligentApproval) {
      res["IntelligentApproval"] = boost::any(*intelligentApproval);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IntelligentApproval") != m.end() && !m["IntelligentApproval"].empty()) {
      intelligentApproval = make_shared<bool>(boost::any_cast<bool>(m["IntelligentApproval"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
  }


  virtual ~CancelSmsTemplateNewRequest() = default;
};
class CancelSmsTemplateNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  CancelSmsTemplateNewResponseBody() {}

  explicit CancelSmsTemplateNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~CancelSmsTemplateNewResponseBody() = default;
};
class CancelSmsTemplateNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CancelSmsTemplateNewResponseBody> body{};

  CancelSmsTemplateNewResponse() {}

  explicit CancelSmsTemplateNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelSmsTemplateNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelSmsTemplateNewResponseBody>(model1);
      }
    }
  }


  virtual ~CancelSmsTemplateNewResponse() = default;
};
class CheckSmsSignNewRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  CheckSmsSignNewRequest() {}

  explicit CheckSmsSignNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~CheckSmsSignNewRequest() = default;
};
class CheckSmsSignNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> common{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> verification{};

  CheckSmsSignNewResponseBody() {}

  explicit CheckSmsSignNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (common) {
      res["Common"] = boost::any(*common);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (verification) {
      res["Verification"] = boost::any(*verification);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Common") != m.end() && !m["Common"].empty()) {
      common = make_shared<bool>(boost::any_cast<bool>(m["Common"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Verification") != m.end() && !m["Verification"].empty()) {
      verification = make_shared<bool>(boost::any_cast<bool>(m["Verification"]));
    }
  }


  virtual ~CheckSmsSignNewResponseBody() = default;
};
class CheckSmsSignNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CheckSmsSignNewResponseBody> body{};

  CheckSmsSignNewResponse() {}

  explicit CheckSmsSignNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CheckSmsSignNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CheckSmsSignNewResponseBody>(model1);
      }
    }
  }


  virtual ~CheckSmsSignNewResponse() = default;
};
class CreateAlicomProductRequest : public Darabonba::Model {
public:
  shared_ptr<long> busOffer{};
  shared_ptr<string> busOffers{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> prodId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  CreateAlicomProductRequest() {}

  explicit CreateAlicomProductRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (busOffer) {
      res["BusOffer"] = boost::any(*busOffer);
    }
    if (busOffers) {
      res["BusOffers"] = boost::any(*busOffers);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (prodId) {
      res["ProdId"] = boost::any(*prodId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusOffer") != m.end() && !m["BusOffer"].empty()) {
      busOffer = make_shared<long>(boost::any_cast<long>(m["BusOffer"]));
    }
    if (m.find("BusOffers") != m.end() && !m["BusOffers"].empty()) {
      busOffers = make_shared<string>(boost::any_cast<string>(m["BusOffers"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ProdId") != m.end() && !m["ProdId"].empty()) {
      prodId = make_shared<string>(boost::any_cast<string>(m["ProdId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~CreateAlicomProductRequest() = default;
};
class CreateAlicomProductResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<string> data{};

  CreateAlicomProductResponseBody() {}

  explicit CreateAlicomProductResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
  }


  virtual ~CreateAlicomProductResponseBody() = default;
};
class CreateAlicomProductResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAlicomProductResponseBody> body{};

  CreateAlicomProductResponse() {}

  explicit CreateAlicomProductResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAlicomProductResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAlicomProductResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAlicomProductResponse() = default;
};
class CreateAuthorizationRequest : public Darabonba::Model {
public:
  shared_ptr<string> authorizeCode{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  CreateAuthorizationRequest() {}

  explicit CreateAuthorizationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorizeCode) {
      res["AuthorizeCode"] = boost::any(*authorizeCode);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthorizeCode") != m.end() && !m["AuthorizeCode"].empty()) {
      authorizeCode = make_shared<string>(boost::any_cast<string>(m["AuthorizeCode"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~CreateAuthorizationRequest() = default;
};
class CreateAuthorizationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  CreateAuthorizationResponseBody() {}

  explicit CreateAuthorizationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~CreateAuthorizationResponseBody() = default;
};
class CreateAuthorizationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAuthorizationResponseBody> body{};

  CreateAuthorizationResponse() {}

  explicit CreateAuthorizationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAuthorizationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAuthorizationResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAuthorizationResponse() = default;
};
class CreateCardMessageCallbackRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizType{};
  shared_ptr<string> callbackUrl{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  CreateCardMessageCallbackRequest() {}

  explicit CreateCardMessageCallbackRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (callbackUrl) {
      res["CallbackUrl"] = boost::any(*callbackUrl);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("CallbackUrl") != m.end() && !m["CallbackUrl"].empty()) {
      callbackUrl = make_shared<string>(boost::any_cast<string>(m["CallbackUrl"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~CreateCardMessageCallbackRequest() = default;
};
class CreateCardMessageCallbackResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> testFailCode{};
  shared_ptr<string> testResponse{};
  shared_ptr<bool> testSuccess{};

  CreateCardMessageCallbackResponseBody() {}

  explicit CreateCardMessageCallbackResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (testFailCode) {
      res["TestFailCode"] = boost::any(*testFailCode);
    }
    if (testResponse) {
      res["TestResponse"] = boost::any(*testResponse);
    }
    if (testSuccess) {
      res["TestSuccess"] = boost::any(*testSuccess);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TestFailCode") != m.end() && !m["TestFailCode"].empty()) {
      testFailCode = make_shared<string>(boost::any_cast<string>(m["TestFailCode"]));
    }
    if (m.find("TestResponse") != m.end() && !m["TestResponse"].empty()) {
      testResponse = make_shared<string>(boost::any_cast<string>(m["TestResponse"]));
    }
    if (m.find("TestSuccess") != m.end() && !m["TestSuccess"].empty()) {
      testSuccess = make_shared<bool>(boost::any_cast<bool>(m["TestSuccess"]));
    }
  }


  virtual ~CreateCardMessageCallbackResponseBody() = default;
};
class CreateCardMessageCallbackResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCardMessageCallbackResponseBody> body{};

  CreateCardMessageCallbackResponse() {}

  explicit CreateCardMessageCallbackResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCardMessageCallbackResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCardMessageCallbackResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCardMessageCallbackResponse() = default;
};
class CreateCardMessageQueueRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> queueType{};
  shared_ptr<string> region{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  CreateCardMessageQueueRequest() {}

  explicit CreateCardMessageQueueRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (queueType) {
      res["QueueType"] = boost::any(*queueType);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("QueueType") != m.end() && !m["QueueType"].empty()) {
      queueType = make_shared<string>(boost::any_cast<string>(m["QueueType"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~CreateCardMessageQueueRequest() = default;
};
class CreateCardMessageQueueResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  CreateCardMessageQueueResponseBody() {}

  explicit CreateCardMessageQueueResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~CreateCardMessageQueueResponseBody() = default;
};
class CreateCardMessageQueueResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCardMessageQueueResponseBody> body{};

  CreateCardMessageQueueResponse() {}

  explicit CreateCardMessageQueueResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCardMessageQueueResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCardMessageQueueResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCardMessageQueueResponse() = default;
};
class CreateDigitalSmsTemplateNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizType{};
  shared_ptr<string> contentOssKeys{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> remark{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> templateContent{};
  shared_ptr<string> templateName{};

  CreateDigitalSmsTemplateNewRequest() {}

  explicit CreateDigitalSmsTemplateNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (contentOssKeys) {
      res["ContentOssKeys"] = boost::any(*contentOssKeys);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (templateContent) {
      res["TemplateContent"] = boost::any(*templateContent);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("ContentOssKeys") != m.end() && !m["ContentOssKeys"].empty()) {
      contentOssKeys = make_shared<string>(boost::any_cast<string>(m["ContentOssKeys"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TemplateContent") != m.end() && !m["TemplateContent"].empty()) {
      templateContent = make_shared<string>(boost::any_cast<string>(m["TemplateContent"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
  }


  virtual ~CreateDigitalSmsTemplateNewRequest() = default;
};
class CreateDigitalSmsTemplateNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  CreateDigitalSmsTemplateNewResponseBody() {}

  explicit CreateDigitalSmsTemplateNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~CreateDigitalSmsTemplateNewResponseBody() = default;
};
class CreateDigitalSmsTemplateNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDigitalSmsTemplateNewResponseBody> body{};

  CreateDigitalSmsTemplateNewResponse() {}

  explicit CreateDigitalSmsTemplateNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDigitalSmsTemplateNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDigitalSmsTemplateNewResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDigitalSmsTemplateNewResponse() = default;
};
class CreateFileByBizRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  CreateFileByBizRequest() {}

  explicit CreateFileByBizRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~CreateFileByBizRequest() = default;
};
class CreateFileByBizResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<string> data{};

  CreateFileByBizResponseBody() {}

  explicit CreateFileByBizResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
  }


  virtual ~CreateFileByBizResponseBody() = default;
};
class CreateFileByBizResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateFileByBizResponseBody> body{};

  CreateFileByBizResponse() {}

  explicit CreateFileByBizResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateFileByBizResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateFileByBizResponseBody>(model1);
      }
    }
  }


  virtual ~CreateFileByBizResponse() = default;
};
class CreateFlowLimitRequest : public Darabonba::Model {
public:
  shared_ptr<string> dailyLimit{};
  shared_ptr<string> hourLimit{};
  shared_ptr<string> minuteLimit{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  CreateFlowLimitRequest() {}

  explicit CreateFlowLimitRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dailyLimit) {
      res["DailyLimit"] = boost::any(*dailyLimit);
    }
    if (hourLimit) {
      res["HourLimit"] = boost::any(*hourLimit);
    }
    if (minuteLimit) {
      res["MinuteLimit"] = boost::any(*minuteLimit);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DailyLimit") != m.end() && !m["DailyLimit"].empty()) {
      dailyLimit = make_shared<string>(boost::any_cast<string>(m["DailyLimit"]));
    }
    if (m.find("HourLimit") != m.end() && !m["HourLimit"].empty()) {
      hourLimit = make_shared<string>(boost::any_cast<string>(m["HourLimit"]));
    }
    if (m.find("MinuteLimit") != m.end() && !m["MinuteLimit"].empty()) {
      minuteLimit = make_shared<string>(boost::any_cast<string>(m["MinuteLimit"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~CreateFlowLimitRequest() = default;
};
class CreateFlowLimitResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<string> data{};

  CreateFlowLimitResponseBody() {}

  explicit CreateFlowLimitResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
  }


  virtual ~CreateFlowLimitResponseBody() = default;
};
class CreateFlowLimitResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateFlowLimitResponseBody> body{};

  CreateFlowLimitResponse() {}

  explicit CreateFlowLimitResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateFlowLimitResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateFlowLimitResponseBody>(model1);
      }
    }
  }


  virtual ~CreateFlowLimitResponse() = default;
};
class CreateFlowLimitNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizType{};
  shared_ptr<string> dailyLimit{};
  shared_ptr<string> hourLimit{};
  shared_ptr<string> minuteLimit{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  CreateFlowLimitNewRequest() {}

  explicit CreateFlowLimitNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (dailyLimit) {
      res["DailyLimit"] = boost::any(*dailyLimit);
    }
    if (hourLimit) {
      res["HourLimit"] = boost::any(*hourLimit);
    }
    if (minuteLimit) {
      res["MinuteLimit"] = boost::any(*minuteLimit);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("DailyLimit") != m.end() && !m["DailyLimit"].empty()) {
      dailyLimit = make_shared<string>(boost::any_cast<string>(m["DailyLimit"]));
    }
    if (m.find("HourLimit") != m.end() && !m["HourLimit"].empty()) {
      hourLimit = make_shared<string>(boost::any_cast<string>(m["HourLimit"]));
    }
    if (m.find("MinuteLimit") != m.end() && !m["MinuteLimit"].empty()) {
      minuteLimit = make_shared<string>(boost::any_cast<string>(m["MinuteLimit"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~CreateFlowLimitNewRequest() = default;
};
class CreateFlowLimitNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  CreateFlowLimitNewResponseBody() {}

  explicit CreateFlowLimitNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~CreateFlowLimitNewResponseBody() = default;
};
class CreateFlowLimitNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateFlowLimitNewResponseBody> body{};

  CreateFlowLimitNewResponse() {}

  explicit CreateFlowLimitNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateFlowLimitNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateFlowLimitNewResponseBody>(model1);
      }
    }
  }


  virtual ~CreateFlowLimitNewResponse() = default;
};
class CreateMessageCallbackNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizType{};
  shared_ptr<string> callbackUrl{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  CreateMessageCallbackNewRequest() {}

  explicit CreateMessageCallbackNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (callbackUrl) {
      res["CallbackUrl"] = boost::any(*callbackUrl);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("CallbackUrl") != m.end() && !m["CallbackUrl"].empty()) {
      callbackUrl = make_shared<string>(boost::any_cast<string>(m["CallbackUrl"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~CreateMessageCallbackNewRequest() = default;
};
class CreateMessageCallbackNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> testFailCode{};
  shared_ptr<string> testResponse{};
  shared_ptr<bool> testSuccess{};

  CreateMessageCallbackNewResponseBody() {}

  explicit CreateMessageCallbackNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (testFailCode) {
      res["TestFailCode"] = boost::any(*testFailCode);
    }
    if (testResponse) {
      res["TestResponse"] = boost::any(*testResponse);
    }
    if (testSuccess) {
      res["TestSuccess"] = boost::any(*testSuccess);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TestFailCode") != m.end() && !m["TestFailCode"].empty()) {
      testFailCode = make_shared<string>(boost::any_cast<string>(m["TestFailCode"]));
    }
    if (m.find("TestResponse") != m.end() && !m["TestResponse"].empty()) {
      testResponse = make_shared<string>(boost::any_cast<string>(m["TestResponse"]));
    }
    if (m.find("TestSuccess") != m.end() && !m["TestSuccess"].empty()) {
      testSuccess = make_shared<bool>(boost::any_cast<bool>(m["TestSuccess"]));
    }
  }


  virtual ~CreateMessageCallbackNewResponseBody() = default;
};
class CreateMessageCallbackNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMessageCallbackNewResponseBody> body{};

  CreateMessageCallbackNewResponse() {}

  explicit CreateMessageCallbackNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMessageCallbackNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMessageCallbackNewResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMessageCallbackNewResponse() = default;
};
class CreateMessageCallbackTestNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizType{};
  shared_ptr<string> content{};
  shared_ptr<string> method{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> url{};

  CreateMessageCallbackTestNewRequest() {}

  explicit CreateMessageCallbackTestNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~CreateMessageCallbackTestNewRequest() = default;
};
class CreateMessageCallbackTestNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> testFailCode{};
  shared_ptr<string> testResponse{};
  shared_ptr<bool> testSuccess{};

  CreateMessageCallbackTestNewResponseBody() {}

  explicit CreateMessageCallbackTestNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (testFailCode) {
      res["TestFailCode"] = boost::any(*testFailCode);
    }
    if (testResponse) {
      res["TestResponse"] = boost::any(*testResponse);
    }
    if (testSuccess) {
      res["TestSuccess"] = boost::any(*testSuccess);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TestFailCode") != m.end() && !m["TestFailCode"].empty()) {
      testFailCode = make_shared<string>(boost::any_cast<string>(m["TestFailCode"]));
    }
    if (m.find("TestResponse") != m.end() && !m["TestResponse"].empty()) {
      testResponse = make_shared<string>(boost::any_cast<string>(m["TestResponse"]));
    }
    if (m.find("TestSuccess") != m.end() && !m["TestSuccess"].empty()) {
      testSuccess = make_shared<bool>(boost::any_cast<bool>(m["TestSuccess"]));
    }
  }


  virtual ~CreateMessageCallbackTestNewResponseBody() = default;
};
class CreateMessageCallbackTestNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMessageCallbackTestNewResponseBody> body{};

  CreateMessageCallbackTestNewResponse() {}

  explicit CreateMessageCallbackTestNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMessageCallbackTestNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMessageCallbackTestNewResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMessageCallbackTestNewResponse() = default;
};
class CreateMessageQueueNewRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> queueType{};
  shared_ptr<string> region{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  CreateMessageQueueNewRequest() {}

  explicit CreateMessageQueueNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (queueType) {
      res["QueueType"] = boost::any(*queueType);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("QueueType") != m.end() && !m["QueueType"].empty()) {
      queueType = make_shared<string>(boost::any_cast<string>(m["QueueType"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~CreateMessageQueueNewRequest() = default;
};
class CreateMessageQueueNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  CreateMessageQueueNewResponseBody() {}

  explicit CreateMessageQueueNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~CreateMessageQueueNewResponseBody() = default;
};
class CreateMessageQueueNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMessageQueueNewResponseBody> body{};

  CreateMessageQueueNewResponse() {}

  explicit CreateMessageQueueNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMessageQueueNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMessageQueueNewResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMessageQueueNewResponse() = default;
};
class CreatePhoneWhiteListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> phoneNumbers{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  CreatePhoneWhiteListRequest() {}

  explicit CreatePhoneWhiteListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (phoneNumbers) {
      res["PhoneNumbers"] = boost::any(*phoneNumbers);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PhoneNumbers") != m.end() && !m["PhoneNumbers"].empty()) {
      phoneNumbers = make_shared<string>(boost::any_cast<string>(m["PhoneNumbers"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~CreatePhoneWhiteListRequest() = default;
};
class CreatePhoneWhiteListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<string> data{};

  CreatePhoneWhiteListResponseBody() {}

  explicit CreatePhoneWhiteListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
  }


  virtual ~CreatePhoneWhiteListResponseBody() = default;
};
class CreatePhoneWhiteListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreatePhoneWhiteListResponseBody> body{};

  CreatePhoneWhiteListResponse() {}

  explicit CreatePhoneWhiteListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreatePhoneWhiteListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreatePhoneWhiteListResponseBody>(model1);
      }
    }
  }


  virtual ~CreatePhoneWhiteListResponse() = default;
};
class CreatePhoneWhiteListNewRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> phoneNumbers{};
  shared_ptr<string> prodCode{};
  shared_ptr<vector<string>> remarks{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  CreatePhoneWhiteListNewRequest() {}

  explicit CreatePhoneWhiteListNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (phoneNumbers) {
      res["PhoneNumbers"] = boost::any(*phoneNumbers);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (remarks) {
      res["Remarks"] = boost::any(*remarks);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PhoneNumbers") != m.end() && !m["PhoneNumbers"].empty()) {
      phoneNumbers = make_shared<string>(boost::any_cast<string>(m["PhoneNumbers"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("Remarks") != m.end() && !m["Remarks"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Remarks"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Remarks"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      remarks = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~CreatePhoneWhiteListNewRequest() = default;
};
class CreatePhoneWhiteListNewShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> phoneNumbers{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> remarksShrink{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  CreatePhoneWhiteListNewShrinkRequest() {}

  explicit CreatePhoneWhiteListNewShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (phoneNumbers) {
      res["PhoneNumbers"] = boost::any(*phoneNumbers);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (remarksShrink) {
      res["Remarks"] = boost::any(*remarksShrink);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PhoneNumbers") != m.end() && !m["PhoneNumbers"].empty()) {
      phoneNumbers = make_shared<string>(boost::any_cast<string>(m["PhoneNumbers"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("Remarks") != m.end() && !m["Remarks"].empty()) {
      remarksShrink = make_shared<string>(boost::any_cast<string>(m["Remarks"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~CreatePhoneWhiteListNewShrinkRequest() = default;
};
class CreatePhoneWhiteListNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  CreatePhoneWhiteListNewResponseBody() {}

  explicit CreatePhoneWhiteListNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~CreatePhoneWhiteListNewResponseBody() = default;
};
class CreatePhoneWhiteListNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreatePhoneWhiteListNewResponseBody> body{};

  CreatePhoneWhiteListNewResponse() {}

  explicit CreatePhoneWhiteListNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreatePhoneWhiteListNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreatePhoneWhiteListNewResponseBody>(model1);
      }
    }
  }


  virtual ~CreatePhoneWhiteListNewResponse() = default;
};
class CreatePkgThresholdRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> packageWarningLimit{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  CreatePkgThresholdRequest() {}

  explicit CreatePkgThresholdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (packageWarningLimit) {
      res["PackageWarningLimit"] = boost::any(*packageWarningLimit);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PackageWarningLimit") != m.end() && !m["PackageWarningLimit"].empty()) {
      packageWarningLimit = make_shared<string>(boost::any_cast<string>(m["PackageWarningLimit"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~CreatePkgThresholdRequest() = default;
};
class CreatePkgThresholdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<string> data{};

  CreatePkgThresholdResponseBody() {}

  explicit CreatePkgThresholdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
  }


  virtual ~CreatePkgThresholdResponseBody() = default;
};
class CreatePkgThresholdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreatePkgThresholdResponseBody> body{};

  CreatePkgThresholdResponse() {}

  explicit CreatePkgThresholdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreatePkgThresholdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreatePkgThresholdResponseBody>(model1);
      }
    }
  }


  virtual ~CreatePkgThresholdResponse() = default;
};
class CreatePkgThresholdNewRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> packageWarningLimit{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  CreatePkgThresholdNewRequest() {}

  explicit CreatePkgThresholdNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (packageWarningLimit) {
      res["PackageWarningLimit"] = boost::any(*packageWarningLimit);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PackageWarningLimit") != m.end() && !m["PackageWarningLimit"].empty()) {
      packageWarningLimit = make_shared<string>(boost::any_cast<string>(m["PackageWarningLimit"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~CreatePkgThresholdNewRequest() = default;
};
class CreatePkgThresholdNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  CreatePkgThresholdNewResponseBody() {}

  explicit CreatePkgThresholdNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~CreatePkgThresholdNewResponseBody() = default;
};
class CreatePkgThresholdNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreatePkgThresholdNewResponseBody> body{};

  CreatePkgThresholdNewResponse() {}

  explicit CreatePkgThresholdNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreatePkgThresholdNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreatePkgThresholdNewResponseBody>(model1);
      }
    }
  }


  virtual ~CreatePkgThresholdNewResponse() = default;
};
class CreatePrevLimitNewRequest : public Darabonba::Model {
public:
  shared_ptr<long> hourLimit{};
  shared_ptr<long> increaseRate{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> successRate{};

  CreatePrevLimitNewRequest() {}

  explicit CreatePrevLimitNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hourLimit) {
      res["HourLimit"] = boost::any(*hourLimit);
    }
    if (increaseRate) {
      res["IncreaseRate"] = boost::any(*increaseRate);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (successRate) {
      res["SuccessRate"] = boost::any(*successRate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HourLimit") != m.end() && !m["HourLimit"].empty()) {
      hourLimit = make_shared<long>(boost::any_cast<long>(m["HourLimit"]));
    }
    if (m.find("IncreaseRate") != m.end() && !m["IncreaseRate"].empty()) {
      increaseRate = make_shared<long>(boost::any_cast<long>(m["IncreaseRate"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SuccessRate") != m.end() && !m["SuccessRate"].empty()) {
      successRate = make_shared<long>(boost::any_cast<long>(m["SuccessRate"]));
    }
  }


  virtual ~CreatePrevLimitNewRequest() = default;
};
class CreatePrevLimitNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  CreatePrevLimitNewResponseBody() {}

  explicit CreatePrevLimitNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~CreatePrevLimitNewResponseBody() = default;
};
class CreatePrevLimitNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreatePrevLimitNewResponseBody> body{};

  CreatePrevLimitNewResponse() {}

  explicit CreatePrevLimitNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreatePrevLimitNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreatePrevLimitNewResponseBody>(model1);
      }
    }
  }


  virtual ~CreatePrevLimitNewResponse() = default;
};
class CreateProductRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> prodId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  CreateProductRequest() {}

  explicit CreateProductRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (prodId) {
      res["ProdId"] = boost::any(*prodId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ProdId") != m.end() && !m["ProdId"].empty()) {
      prodId = make_shared<string>(boost::any_cast<string>(m["ProdId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~CreateProductRequest() = default;
};
class CreateProductResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<bool> data{};

  CreateProductResponseBody() {}

  explicit CreateProductResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["data"]));
    }
  }


  virtual ~CreateProductResponseBody() = default;
};
class CreateProductResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateProductResponseBody> body{};

  CreateProductResponse() {}

  explicit CreateProductResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateProductResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateProductResponseBody>(model1);
      }
    }
  }


  virtual ~CreateProductResponse() = default;
};
class CreateProductNewRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> prodId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  CreateProductNewRequest() {}

  explicit CreateProductNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (prodId) {
      res["ProdId"] = boost::any(*prodId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ProdId") != m.end() && !m["ProdId"].empty()) {
      prodId = make_shared<string>(boost::any_cast<string>(m["ProdId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~CreateProductNewRequest() = default;
};
class CreateProductNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> openResult{};
  shared_ptr<string> requestId{};

  CreateProductNewResponseBody() {}

  explicit CreateProductNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (openResult) {
      res["OpenResult"] = boost::any(*openResult);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpenResult") != m.end() && !m["OpenResult"].empty()) {
      openResult = make_shared<bool>(boost::any_cast<bool>(m["OpenResult"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateProductNewResponseBody() = default;
};
class CreateProductNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateProductNewResponseBody> body{};

  CreateProductNewResponse() {}

  explicit CreateProductNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateProductNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateProductNewResponseBody>(model1);
      }
    }
  }


  virtual ~CreateProductNewResponse() = default;
};
class CreateShortUrlNewRequest : public Darabonba::Model {
public:
  shared_ptr<long> effectDay{};
  shared_ptr<string> eventName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> sourceUrl{};

  CreateShortUrlNewRequest() {}

  explicit CreateShortUrlNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (effectDay) {
      res["EffectDay"] = boost::any(*effectDay);
    }
    if (eventName) {
      res["EventName"] = boost::any(*eventName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sourceUrl) {
      res["SourceUrl"] = boost::any(*sourceUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EffectDay") != m.end() && !m["EffectDay"].empty()) {
      effectDay = make_shared<long>(boost::any_cast<long>(m["EffectDay"]));
    }
    if (m.find("EventName") != m.end() && !m["EventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["EventName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SourceUrl") != m.end() && !m["SourceUrl"].empty()) {
      sourceUrl = make_shared<string>(boost::any_cast<string>(m["SourceUrl"]));
    }
  }


  virtual ~CreateShortUrlNewRequest() = default;
};
class CreateShortUrlNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> eventName{};
  shared_ptr<string> gmtCreateTime{};
  shared_ptr<string> gmtInvalidTime{};
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};
  shared_ptr<string> shortUrl{};
  shared_ptr<string> sourceUrl{};

  CreateShortUrlNewResponseBody() {}

  explicit CreateShortUrlNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventName) {
      res["EventName"] = boost::any(*eventName);
    }
    if (gmtCreateTime) {
      res["GmtCreateTime"] = boost::any(*gmtCreateTime);
    }
    if (gmtInvalidTime) {
      res["GmtInvalidTime"] = boost::any(*gmtInvalidTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (shortUrl) {
      res["ShortUrl"] = boost::any(*shortUrl);
    }
    if (sourceUrl) {
      res["SourceUrl"] = boost::any(*sourceUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventName") != m.end() && !m["EventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["EventName"]));
    }
    if (m.find("GmtCreateTime") != m.end() && !m["GmtCreateTime"].empty()) {
      gmtCreateTime = make_shared<string>(boost::any_cast<string>(m["GmtCreateTime"]));
    }
    if (m.find("GmtInvalidTime") != m.end() && !m["GmtInvalidTime"].empty()) {
      gmtInvalidTime = make_shared<string>(boost::any_cast<string>(m["GmtInvalidTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ShortUrl") != m.end() && !m["ShortUrl"].empty()) {
      shortUrl = make_shared<string>(boost::any_cast<string>(m["ShortUrl"]));
    }
    if (m.find("SourceUrl") != m.end() && !m["SourceUrl"].empty()) {
      sourceUrl = make_shared<string>(boost::any_cast<string>(m["SourceUrl"]));
    }
  }


  virtual ~CreateShortUrlNewResponseBody() = default;
};
class CreateShortUrlNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateShortUrlNewResponseBody> body{};

  CreateShortUrlNewResponse() {}

  explicit CreateShortUrlNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateShortUrlNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateShortUrlNewResponseBody>(model1);
      }
    }
  }


  virtual ~CreateShortUrlNewResponse() = default;
};
class CreateSmsDetectTaskNewRequest : public Darabonba::Model {
public:
  shared_ptr<bool> check{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> signName{};
  shared_ptr<string> smsContent{};
  shared_ptr<string> templateCode{};
  shared_ptr<string> templateParam{};

  CreateSmsDetectTaskNewRequest() {}

  explicit CreateSmsDetectTaskNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (check) {
      res["Check"] = boost::any(*check);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (signName) {
      res["SignName"] = boost::any(*signName);
    }
    if (smsContent) {
      res["SmsContent"] = boost::any(*smsContent);
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    if (templateParam) {
      res["TemplateParam"] = boost::any(*templateParam);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Check") != m.end() && !m["Check"].empty()) {
      check = make_shared<bool>(boost::any_cast<bool>(m["Check"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SignName") != m.end() && !m["SignName"].empty()) {
      signName = make_shared<string>(boost::any_cast<string>(m["SignName"]));
    }
    if (m.find("SmsContent") != m.end() && !m["SmsContent"].empty()) {
      smsContent = make_shared<string>(boost::any_cast<string>(m["SmsContent"]));
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
    if (m.find("TemplateParam") != m.end() && !m["TemplateParam"].empty()) {
      templateParam = make_shared<string>(boost::any_cast<string>(m["TemplateParam"]));
    }
  }


  virtual ~CreateSmsDetectTaskNewRequest() = default;
};
class CreateSmsDetectTaskNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  CreateSmsDetectTaskNewResponseBody() {}

  explicit CreateSmsDetectTaskNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~CreateSmsDetectTaskNewResponseBody() = default;
};
class CreateSmsDetectTaskNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSmsDetectTaskNewResponseBody> body{};

  CreateSmsDetectTaskNewResponse() {}

  explicit CreateSmsDetectTaskNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSmsDetectTaskNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSmsDetectTaskNewResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSmsDetectTaskNewResponse() = default;
};
class CreateSmsInternalApplyRequest : public Darabonba::Model {
public:
  shared_ptr<string> appDownloadLink{};
  shared_ptr<string> country{};
  shared_ptr<string> industry{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> pageLink{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> remark{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> templateName{};

  CreateSmsInternalApplyRequest() {}

  explicit CreateSmsInternalApplyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appDownloadLink) {
      res["AppDownloadLink"] = boost::any(*appDownloadLink);
    }
    if (country) {
      res["Country"] = boost::any(*country);
    }
    if (industry) {
      res["Industry"] = boost::any(*industry);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageLink) {
      res["PageLink"] = boost::any(*pageLink);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppDownloadLink") != m.end() && !m["AppDownloadLink"].empty()) {
      appDownloadLink = make_shared<string>(boost::any_cast<string>(m["AppDownloadLink"]));
    }
    if (m.find("Country") != m.end() && !m["Country"].empty()) {
      country = make_shared<string>(boost::any_cast<string>(m["Country"]));
    }
    if (m.find("Industry") != m.end() && !m["Industry"].empty()) {
      industry = make_shared<string>(boost::any_cast<string>(m["Industry"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageLink") != m.end() && !m["PageLink"].empty()) {
      pageLink = make_shared<string>(boost::any_cast<string>(m["PageLink"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
  }


  virtual ~CreateSmsInternalApplyRequest() = default;
};
class CreateSmsInternalApplyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<string> data{};

  CreateSmsInternalApplyResponseBody() {}

  explicit CreateSmsInternalApplyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
  }


  virtual ~CreateSmsInternalApplyResponseBody() = default;
};
class CreateSmsInternalApplyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSmsInternalApplyResponseBody> body{};

  CreateSmsInternalApplyResponse() {}

  explicit CreateSmsInternalApplyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSmsInternalApplyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSmsInternalApplyResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSmsInternalApplyResponse() = default;
};
class CreateSmsProductForChannelCustRequest : public Darabonba::Model {
public:
  shared_ptr<long> channelId{};
  shared_ptr<bool> onlyCheckOpened{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  CreateSmsProductForChannelCustRequest() {}

  explicit CreateSmsProductForChannelCustRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (onlyCheckOpened) {
      res["OnlyCheckOpened"] = boost::any(*onlyCheckOpened);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<long>(boost::any_cast<long>(m["ChannelId"]));
    }
    if (m.find("OnlyCheckOpened") != m.end() && !m["OnlyCheckOpened"].empty()) {
      onlyCheckOpened = make_shared<bool>(boost::any_cast<bool>(m["OnlyCheckOpened"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~CreateSmsProductForChannelCustRequest() = default;
};
class CreateSmsProductForChannelCustResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<string> data{};

  CreateSmsProductForChannelCustResponseBody() {}

  explicit CreateSmsProductForChannelCustResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
  }


  virtual ~CreateSmsProductForChannelCustResponseBody() = default;
};
class CreateSmsProductForChannelCustResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSmsProductForChannelCustResponseBody> body{};

  CreateSmsProductForChannelCustResponse() {}

  explicit CreateSmsProductForChannelCustResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSmsProductForChannelCustResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSmsProductForChannelCustResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSmsProductForChannelCustResponse() = default;
};
class CreateSmsSaasTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizType{};
  shared_ptr<string> clientIp{};
  shared_ptr<string> dataType{};
  shared_ptr<string> orderTime{};
  shared_ptr<string> ossFileName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> phoneList{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> scheduleType{};
  shared_ptr<string> signName{};
  shared_ptr<string> smsContent{};
  shared_ptr<string> smsTemplateCode{};
  shared_ptr<string> taskName{};
  shared_ptr<string> validCount{};

  CreateSmsSaasTaskRequest() {}

  explicit CreateSmsSaasTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (clientIp) {
      res["ClientIp"] = boost::any(*clientIp);
    }
    if (dataType) {
      res["DataType"] = boost::any(*dataType);
    }
    if (orderTime) {
      res["OrderTime"] = boost::any(*orderTime);
    }
    if (ossFileName) {
      res["OssFileName"] = boost::any(*ossFileName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (phoneList) {
      res["PhoneList"] = boost::any(*phoneList);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (scheduleType) {
      res["ScheduleType"] = boost::any(*scheduleType);
    }
    if (signName) {
      res["SignName"] = boost::any(*signName);
    }
    if (smsContent) {
      res["SmsContent"] = boost::any(*smsContent);
    }
    if (smsTemplateCode) {
      res["SmsTemplateCode"] = boost::any(*smsTemplateCode);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (validCount) {
      res["ValidCount"] = boost::any(*validCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("ClientIp") != m.end() && !m["ClientIp"].empty()) {
      clientIp = make_shared<string>(boost::any_cast<string>(m["ClientIp"]));
    }
    if (m.find("DataType") != m.end() && !m["DataType"].empty()) {
      dataType = make_shared<string>(boost::any_cast<string>(m["DataType"]));
    }
    if (m.find("OrderTime") != m.end() && !m["OrderTime"].empty()) {
      orderTime = make_shared<string>(boost::any_cast<string>(m["OrderTime"]));
    }
    if (m.find("OssFileName") != m.end() && !m["OssFileName"].empty()) {
      ossFileName = make_shared<string>(boost::any_cast<string>(m["OssFileName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PhoneList") != m.end() && !m["PhoneList"].empty()) {
      phoneList = make_shared<string>(boost::any_cast<string>(m["PhoneList"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ScheduleType") != m.end() && !m["ScheduleType"].empty()) {
      scheduleType = make_shared<string>(boost::any_cast<string>(m["ScheduleType"]));
    }
    if (m.find("SignName") != m.end() && !m["SignName"].empty()) {
      signName = make_shared<string>(boost::any_cast<string>(m["SignName"]));
    }
    if (m.find("SmsContent") != m.end() && !m["SmsContent"].empty()) {
      smsContent = make_shared<string>(boost::any_cast<string>(m["SmsContent"]));
    }
    if (m.find("SmsTemplateCode") != m.end() && !m["SmsTemplateCode"].empty()) {
      smsTemplateCode = make_shared<string>(boost::any_cast<string>(m["SmsTemplateCode"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("ValidCount") != m.end() && !m["ValidCount"].empty()) {
      validCount = make_shared<string>(boost::any_cast<string>(m["ValidCount"]));
    }
  }


  virtual ~CreateSmsSaasTaskRequest() = default;
};
class CreateSmsSaasTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<string> data{};

  CreateSmsSaasTaskResponseBody() {}

  explicit CreateSmsSaasTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
  }


  virtual ~CreateSmsSaasTaskResponseBody() = default;
};
class CreateSmsSaasTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSmsSaasTaskResponseBody> body{};

  CreateSmsSaasTaskResponse() {}

  explicit CreateSmsSaasTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSmsSaasTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSmsSaasTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSmsSaasTaskResponse() = default;
};
class CreateSmsSaasTaskNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizType{};
  shared_ptr<string> dataAbilityTaskId{};
  shared_ptr<string> dataType{};
  shared_ptr<string> orderTime{};
  shared_ptr<string> ossFileName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> phoneList{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> scheduleType{};
  shared_ptr<string> signName{};
  shared_ptr<string> smsContent{};
  shared_ptr<string> smsTemplateCode{};
  shared_ptr<string> taskName{};
  shared_ptr<string> validCount{};

  CreateSmsSaasTaskNewRequest() {}

  explicit CreateSmsSaasTaskNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (dataAbilityTaskId) {
      res["DataAbilityTaskId"] = boost::any(*dataAbilityTaskId);
    }
    if (dataType) {
      res["DataType"] = boost::any(*dataType);
    }
    if (orderTime) {
      res["OrderTime"] = boost::any(*orderTime);
    }
    if (ossFileName) {
      res["OssFileName"] = boost::any(*ossFileName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (phoneList) {
      res["PhoneList"] = boost::any(*phoneList);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (scheduleType) {
      res["ScheduleType"] = boost::any(*scheduleType);
    }
    if (signName) {
      res["SignName"] = boost::any(*signName);
    }
    if (smsContent) {
      res["SmsContent"] = boost::any(*smsContent);
    }
    if (smsTemplateCode) {
      res["SmsTemplateCode"] = boost::any(*smsTemplateCode);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (validCount) {
      res["ValidCount"] = boost::any(*validCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("DataAbilityTaskId") != m.end() && !m["DataAbilityTaskId"].empty()) {
      dataAbilityTaskId = make_shared<string>(boost::any_cast<string>(m["DataAbilityTaskId"]));
    }
    if (m.find("DataType") != m.end() && !m["DataType"].empty()) {
      dataType = make_shared<string>(boost::any_cast<string>(m["DataType"]));
    }
    if (m.find("OrderTime") != m.end() && !m["OrderTime"].empty()) {
      orderTime = make_shared<string>(boost::any_cast<string>(m["OrderTime"]));
    }
    if (m.find("OssFileName") != m.end() && !m["OssFileName"].empty()) {
      ossFileName = make_shared<string>(boost::any_cast<string>(m["OssFileName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PhoneList") != m.end() && !m["PhoneList"].empty()) {
      phoneList = make_shared<string>(boost::any_cast<string>(m["PhoneList"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ScheduleType") != m.end() && !m["ScheduleType"].empty()) {
      scheduleType = make_shared<string>(boost::any_cast<string>(m["ScheduleType"]));
    }
    if (m.find("SignName") != m.end() && !m["SignName"].empty()) {
      signName = make_shared<string>(boost::any_cast<string>(m["SignName"]));
    }
    if (m.find("SmsContent") != m.end() && !m["SmsContent"].empty()) {
      smsContent = make_shared<string>(boost::any_cast<string>(m["SmsContent"]));
    }
    if (m.find("SmsTemplateCode") != m.end() && !m["SmsTemplateCode"].empty()) {
      smsTemplateCode = make_shared<string>(boost::any_cast<string>(m["SmsTemplateCode"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("ValidCount") != m.end() && !m["ValidCount"].empty()) {
      validCount = make_shared<string>(boost::any_cast<string>(m["ValidCount"]));
    }
  }


  virtual ~CreateSmsSaasTaskNewRequest() = default;
};
class CreateSmsSaasTaskNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateSmsSaasTaskNewResponseBody() {}

  explicit CreateSmsSaasTaskNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateSmsSaasTaskNewResponseBody() = default;
};
class CreateSmsSaasTaskNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSmsSaasTaskNewResponseBody> body{};

  CreateSmsSaasTaskNewResponse() {}

  explicit CreateSmsSaasTaskNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSmsSaasTaskNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSmsSaasTaskNewResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSmsSaasTaskNewResponse() = default;
};
class CreateSmsSendFailDetailsDownloadRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> prodId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> sendDate{};

  CreateSmsSendFailDetailsDownloadRequest() {}

  explicit CreateSmsSendFailDetailsDownloadRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (prodId) {
      res["ProdId"] = boost::any(*prodId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sendDate) {
      res["SendDate"] = boost::any(*sendDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ProdId") != m.end() && !m["ProdId"].empty()) {
      prodId = make_shared<string>(boost::any_cast<string>(m["ProdId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SendDate") != m.end() && !m["SendDate"].empty()) {
      sendDate = make_shared<string>(boost::any_cast<string>(m["SendDate"]));
    }
  }


  virtual ~CreateSmsSendFailDetailsDownloadRequest() = default;
};
class CreateSmsSendFailDetailsDownloadResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<string> data{};

  CreateSmsSendFailDetailsDownloadResponseBody() {}

  explicit CreateSmsSendFailDetailsDownloadResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
  }


  virtual ~CreateSmsSendFailDetailsDownloadResponseBody() = default;
};
class CreateSmsSendFailDetailsDownloadResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSmsSendFailDetailsDownloadResponseBody> body{};

  CreateSmsSendFailDetailsDownloadResponse() {}

  explicit CreateSmsSendFailDetailsDownloadResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSmsSendFailDetailsDownloadResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSmsSendFailDetailsDownloadResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSmsSendFailDetailsDownloadResponse() = default;
};
class CreateSmsSignRequest : public Darabonba::Model {
public:
  shared_ptr<string> extendMessage{};
  shared_ptr<string> fileIds{};
  shared_ptr<string> orderId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> remark{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> sceneType{};
  shared_ptr<long> serviceType{};
  shared_ptr<string> signName{};

  CreateSmsSignRequest() {}

  explicit CreateSmsSignRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extendMessage) {
      res["ExtendMessage"] = boost::any(*extendMessage);
    }
    if (fileIds) {
      res["FileIds"] = boost::any(*fileIds);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sceneType) {
      res["SceneType"] = boost::any(*sceneType);
    }
    if (serviceType) {
      res["ServiceType"] = boost::any(*serviceType);
    }
    if (signName) {
      res["SignName"] = boost::any(*signName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtendMessage") != m.end() && !m["ExtendMessage"].empty()) {
      extendMessage = make_shared<string>(boost::any_cast<string>(m["ExtendMessage"]));
    }
    if (m.find("FileIds") != m.end() && !m["FileIds"].empty()) {
      fileIds = make_shared<string>(boost::any_cast<string>(m["FileIds"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SceneType") != m.end() && !m["SceneType"].empty()) {
      sceneType = make_shared<long>(boost::any_cast<long>(m["SceneType"]));
    }
    if (m.find("ServiceType") != m.end() && !m["ServiceType"].empty()) {
      serviceType = make_shared<long>(boost::any_cast<long>(m["ServiceType"]));
    }
    if (m.find("SignName") != m.end() && !m["SignName"].empty()) {
      signName = make_shared<string>(boost::any_cast<string>(m["SignName"]));
    }
  }


  virtual ~CreateSmsSignRequest() = default;
};
class CreateSmsSignResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<string> data{};

  CreateSmsSignResponseBody() {}

  explicit CreateSmsSignResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
  }


  virtual ~CreateSmsSignResponseBody() = default;
};
class CreateSmsSignResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSmsSignResponseBody> body{};

  CreateSmsSignResponse() {}

  explicit CreateSmsSignResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSmsSignResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSmsSignResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSmsSignResponse() = default;
};
class CreateSmsSignNewRequest : public Darabonba::Model {
public:
  shared_ptr<long> applicationSceneId{};
  shared_ptr<string> applySource{};
  shared_ptr<string> authorization{};
  shared_ptr<string> authorizationEffTime{};
  shared_ptr<string> authorizationLetter{};
  shared_ptr<bool> authorizationLetterAuditPass{};
  shared_ptr<long> authorizationLetterId{};
  shared_ptr<string> authorizationLetterName{};
  shared_ptr<string> authorizationSignScope{};
  shared_ptr<bool> createSignGray{};
  shared_ptr<bool> enableAuthorizationLetter{};
  shared_ptr<string> extendMessage{};
  shared_ptr<string> fileIds{};
  shared_ptr<bool> isAuthorizationLetterOCRComplete{};
  shared_ptr<bool> isAuthorizationLetterOCRDiff{};
  shared_ptr<bool> isSignScopeOCRDiff{};
  shared_ptr<vector<string>> moreData{};
  shared_ptr<string> orderId{};
  shared_ptr<string> organizationCode{};
  shared_ptr<string> ossKeys{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> proxyAuthorization{};
  shared_ptr<long> qualificationId{};
  shared_ptr<long> qualificationType{};
  shared_ptr<long> qualificationVersion{};
  shared_ptr<string> remark{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> sceneType{};
  shared_ptr<long> serviceType{};
  shared_ptr<string> signCode{};
  shared_ptr<string> signId{};
  shared_ptr<string> signName{};
  shared_ptr<string> signScopeOCR{};
  shared_ptr<bool> signUpgrade{};
  shared_ptr<bool> thirdParty{};
  shared_ptr<string> userViewFileName{};

  CreateSmsSignNewRequest() {}

  explicit CreateSmsSignNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationSceneId) {
      res["ApplicationSceneId"] = boost::any(*applicationSceneId);
    }
    if (applySource) {
      res["ApplySource"] = boost::any(*applySource);
    }
    if (authorization) {
      res["Authorization"] = boost::any(*authorization);
    }
    if (authorizationEffTime) {
      res["AuthorizationEffTime"] = boost::any(*authorizationEffTime);
    }
    if (authorizationLetter) {
      res["AuthorizationLetter"] = boost::any(*authorizationLetter);
    }
    if (authorizationLetterAuditPass) {
      res["AuthorizationLetterAuditPass"] = boost::any(*authorizationLetterAuditPass);
    }
    if (authorizationLetterId) {
      res["AuthorizationLetterId"] = boost::any(*authorizationLetterId);
    }
    if (authorizationLetterName) {
      res["AuthorizationLetterName"] = boost::any(*authorizationLetterName);
    }
    if (authorizationSignScope) {
      res["AuthorizationSignScope"] = boost::any(*authorizationSignScope);
    }
    if (createSignGray) {
      res["CreateSignGray"] = boost::any(*createSignGray);
    }
    if (enableAuthorizationLetter) {
      res["EnableAuthorizationLetter"] = boost::any(*enableAuthorizationLetter);
    }
    if (extendMessage) {
      res["ExtendMessage"] = boost::any(*extendMessage);
    }
    if (fileIds) {
      res["FileIds"] = boost::any(*fileIds);
    }
    if (isAuthorizationLetterOCRComplete) {
      res["IsAuthorizationLetterOCRComplete"] = boost::any(*isAuthorizationLetterOCRComplete);
    }
    if (isAuthorizationLetterOCRDiff) {
      res["IsAuthorizationLetterOCRDiff"] = boost::any(*isAuthorizationLetterOCRDiff);
    }
    if (isSignScopeOCRDiff) {
      res["IsSignScopeOCRDiff"] = boost::any(*isSignScopeOCRDiff);
    }
    if (moreData) {
      res["MoreData"] = boost::any(*moreData);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (organizationCode) {
      res["OrganizationCode"] = boost::any(*organizationCode);
    }
    if (ossKeys) {
      res["OssKeys"] = boost::any(*ossKeys);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (proxyAuthorization) {
      res["ProxyAuthorization"] = boost::any(*proxyAuthorization);
    }
    if (qualificationId) {
      res["QualificationId"] = boost::any(*qualificationId);
    }
    if (qualificationType) {
      res["QualificationType"] = boost::any(*qualificationType);
    }
    if (qualificationVersion) {
      res["QualificationVersion"] = boost::any(*qualificationVersion);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sceneType) {
      res["SceneType"] = boost::any(*sceneType);
    }
    if (serviceType) {
      res["ServiceType"] = boost::any(*serviceType);
    }
    if (signCode) {
      res["SignCode"] = boost::any(*signCode);
    }
    if (signId) {
      res["SignId"] = boost::any(*signId);
    }
    if (signName) {
      res["SignName"] = boost::any(*signName);
    }
    if (signScopeOCR) {
      res["SignScopeOCR"] = boost::any(*signScopeOCR);
    }
    if (signUpgrade) {
      res["SignUpgrade"] = boost::any(*signUpgrade);
    }
    if (thirdParty) {
      res["ThirdParty"] = boost::any(*thirdParty);
    }
    if (userViewFileName) {
      res["UserViewFileName"] = boost::any(*userViewFileName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationSceneId") != m.end() && !m["ApplicationSceneId"].empty()) {
      applicationSceneId = make_shared<long>(boost::any_cast<long>(m["ApplicationSceneId"]));
    }
    if (m.find("ApplySource") != m.end() && !m["ApplySource"].empty()) {
      applySource = make_shared<string>(boost::any_cast<string>(m["ApplySource"]));
    }
    if (m.find("Authorization") != m.end() && !m["Authorization"].empty()) {
      authorization = make_shared<string>(boost::any_cast<string>(m["Authorization"]));
    }
    if (m.find("AuthorizationEffTime") != m.end() && !m["AuthorizationEffTime"].empty()) {
      authorizationEffTime = make_shared<string>(boost::any_cast<string>(m["AuthorizationEffTime"]));
    }
    if (m.find("AuthorizationLetter") != m.end() && !m["AuthorizationLetter"].empty()) {
      authorizationLetter = make_shared<string>(boost::any_cast<string>(m["AuthorizationLetter"]));
    }
    if (m.find("AuthorizationLetterAuditPass") != m.end() && !m["AuthorizationLetterAuditPass"].empty()) {
      authorizationLetterAuditPass = make_shared<bool>(boost::any_cast<bool>(m["AuthorizationLetterAuditPass"]));
    }
    if (m.find("AuthorizationLetterId") != m.end() && !m["AuthorizationLetterId"].empty()) {
      authorizationLetterId = make_shared<long>(boost::any_cast<long>(m["AuthorizationLetterId"]));
    }
    if (m.find("AuthorizationLetterName") != m.end() && !m["AuthorizationLetterName"].empty()) {
      authorizationLetterName = make_shared<string>(boost::any_cast<string>(m["AuthorizationLetterName"]));
    }
    if (m.find("AuthorizationSignScope") != m.end() && !m["AuthorizationSignScope"].empty()) {
      authorizationSignScope = make_shared<string>(boost::any_cast<string>(m["AuthorizationSignScope"]));
    }
    if (m.find("CreateSignGray") != m.end() && !m["CreateSignGray"].empty()) {
      createSignGray = make_shared<bool>(boost::any_cast<bool>(m["CreateSignGray"]));
    }
    if (m.find("EnableAuthorizationLetter") != m.end() && !m["EnableAuthorizationLetter"].empty()) {
      enableAuthorizationLetter = make_shared<bool>(boost::any_cast<bool>(m["EnableAuthorizationLetter"]));
    }
    if (m.find("ExtendMessage") != m.end() && !m["ExtendMessage"].empty()) {
      extendMessage = make_shared<string>(boost::any_cast<string>(m["ExtendMessage"]));
    }
    if (m.find("FileIds") != m.end() && !m["FileIds"].empty()) {
      fileIds = make_shared<string>(boost::any_cast<string>(m["FileIds"]));
    }
    if (m.find("IsAuthorizationLetterOCRComplete") != m.end() && !m["IsAuthorizationLetterOCRComplete"].empty()) {
      isAuthorizationLetterOCRComplete = make_shared<bool>(boost::any_cast<bool>(m["IsAuthorizationLetterOCRComplete"]));
    }
    if (m.find("IsAuthorizationLetterOCRDiff") != m.end() && !m["IsAuthorizationLetterOCRDiff"].empty()) {
      isAuthorizationLetterOCRDiff = make_shared<bool>(boost::any_cast<bool>(m["IsAuthorizationLetterOCRDiff"]));
    }
    if (m.find("IsSignScopeOCRDiff") != m.end() && !m["IsSignScopeOCRDiff"].empty()) {
      isSignScopeOCRDiff = make_shared<bool>(boost::any_cast<bool>(m["IsSignScopeOCRDiff"]));
    }
    if (m.find("MoreData") != m.end() && !m["MoreData"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MoreData"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MoreData"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      moreData = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("OrganizationCode") != m.end() && !m["OrganizationCode"].empty()) {
      organizationCode = make_shared<string>(boost::any_cast<string>(m["OrganizationCode"]));
    }
    if (m.find("OssKeys") != m.end() && !m["OssKeys"].empty()) {
      ossKeys = make_shared<string>(boost::any_cast<string>(m["OssKeys"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ProxyAuthorization") != m.end() && !m["ProxyAuthorization"].empty()) {
      proxyAuthorization = make_shared<string>(boost::any_cast<string>(m["ProxyAuthorization"]));
    }
    if (m.find("QualificationId") != m.end() && !m["QualificationId"].empty()) {
      qualificationId = make_shared<long>(boost::any_cast<long>(m["QualificationId"]));
    }
    if (m.find("QualificationType") != m.end() && !m["QualificationType"].empty()) {
      qualificationType = make_shared<long>(boost::any_cast<long>(m["QualificationType"]));
    }
    if (m.find("QualificationVersion") != m.end() && !m["QualificationVersion"].empty()) {
      qualificationVersion = make_shared<long>(boost::any_cast<long>(m["QualificationVersion"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SceneType") != m.end() && !m["SceneType"].empty()) {
      sceneType = make_shared<long>(boost::any_cast<long>(m["SceneType"]));
    }
    if (m.find("ServiceType") != m.end() && !m["ServiceType"].empty()) {
      serviceType = make_shared<long>(boost::any_cast<long>(m["ServiceType"]));
    }
    if (m.find("SignCode") != m.end() && !m["SignCode"].empty()) {
      signCode = make_shared<string>(boost::any_cast<string>(m["SignCode"]));
    }
    if (m.find("SignId") != m.end() && !m["SignId"].empty()) {
      signId = make_shared<string>(boost::any_cast<string>(m["SignId"]));
    }
    if (m.find("SignName") != m.end() && !m["SignName"].empty()) {
      signName = make_shared<string>(boost::any_cast<string>(m["SignName"]));
    }
    if (m.find("SignScopeOCR") != m.end() && !m["SignScopeOCR"].empty()) {
      signScopeOCR = make_shared<string>(boost::any_cast<string>(m["SignScopeOCR"]));
    }
    if (m.find("SignUpgrade") != m.end() && !m["SignUpgrade"].empty()) {
      signUpgrade = make_shared<bool>(boost::any_cast<bool>(m["SignUpgrade"]));
    }
    if (m.find("ThirdParty") != m.end() && !m["ThirdParty"].empty()) {
      thirdParty = make_shared<bool>(boost::any_cast<bool>(m["ThirdParty"]));
    }
    if (m.find("UserViewFileName") != m.end() && !m["UserViewFileName"].empty()) {
      userViewFileName = make_shared<string>(boost::any_cast<string>(m["UserViewFileName"]));
    }
  }


  virtual ~CreateSmsSignNewRequest() = default;
};
class CreateSmsSignNewShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> applicationSceneId{};
  shared_ptr<string> applySource{};
  shared_ptr<string> authorization{};
  shared_ptr<string> authorizationEffTime{};
  shared_ptr<string> authorizationLetter{};
  shared_ptr<bool> authorizationLetterAuditPass{};
  shared_ptr<long> authorizationLetterId{};
  shared_ptr<string> authorizationLetterName{};
  shared_ptr<string> authorizationSignScope{};
  shared_ptr<bool> createSignGray{};
  shared_ptr<bool> enableAuthorizationLetter{};
  shared_ptr<string> extendMessage{};
  shared_ptr<string> fileIds{};
  shared_ptr<bool> isAuthorizationLetterOCRComplete{};
  shared_ptr<bool> isAuthorizationLetterOCRDiff{};
  shared_ptr<bool> isSignScopeOCRDiff{};
  shared_ptr<string> moreDataShrink{};
  shared_ptr<string> orderId{};
  shared_ptr<string> organizationCode{};
  shared_ptr<string> ossKeys{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> proxyAuthorization{};
  shared_ptr<long> qualificationId{};
  shared_ptr<long> qualificationType{};
  shared_ptr<long> qualificationVersion{};
  shared_ptr<string> remark{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> sceneType{};
  shared_ptr<long> serviceType{};
  shared_ptr<string> signCode{};
  shared_ptr<string> signId{};
  shared_ptr<string> signName{};
  shared_ptr<string> signScopeOCR{};
  shared_ptr<bool> signUpgrade{};
  shared_ptr<bool> thirdParty{};
  shared_ptr<string> userViewFileName{};

  CreateSmsSignNewShrinkRequest() {}

  explicit CreateSmsSignNewShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationSceneId) {
      res["ApplicationSceneId"] = boost::any(*applicationSceneId);
    }
    if (applySource) {
      res["ApplySource"] = boost::any(*applySource);
    }
    if (authorization) {
      res["Authorization"] = boost::any(*authorization);
    }
    if (authorizationEffTime) {
      res["AuthorizationEffTime"] = boost::any(*authorizationEffTime);
    }
    if (authorizationLetter) {
      res["AuthorizationLetter"] = boost::any(*authorizationLetter);
    }
    if (authorizationLetterAuditPass) {
      res["AuthorizationLetterAuditPass"] = boost::any(*authorizationLetterAuditPass);
    }
    if (authorizationLetterId) {
      res["AuthorizationLetterId"] = boost::any(*authorizationLetterId);
    }
    if (authorizationLetterName) {
      res["AuthorizationLetterName"] = boost::any(*authorizationLetterName);
    }
    if (authorizationSignScope) {
      res["AuthorizationSignScope"] = boost::any(*authorizationSignScope);
    }
    if (createSignGray) {
      res["CreateSignGray"] = boost::any(*createSignGray);
    }
    if (enableAuthorizationLetter) {
      res["EnableAuthorizationLetter"] = boost::any(*enableAuthorizationLetter);
    }
    if (extendMessage) {
      res["ExtendMessage"] = boost::any(*extendMessage);
    }
    if (fileIds) {
      res["FileIds"] = boost::any(*fileIds);
    }
    if (isAuthorizationLetterOCRComplete) {
      res["IsAuthorizationLetterOCRComplete"] = boost::any(*isAuthorizationLetterOCRComplete);
    }
    if (isAuthorizationLetterOCRDiff) {
      res["IsAuthorizationLetterOCRDiff"] = boost::any(*isAuthorizationLetterOCRDiff);
    }
    if (isSignScopeOCRDiff) {
      res["IsSignScopeOCRDiff"] = boost::any(*isSignScopeOCRDiff);
    }
    if (moreDataShrink) {
      res["MoreData"] = boost::any(*moreDataShrink);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (organizationCode) {
      res["OrganizationCode"] = boost::any(*organizationCode);
    }
    if (ossKeys) {
      res["OssKeys"] = boost::any(*ossKeys);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (proxyAuthorization) {
      res["ProxyAuthorization"] = boost::any(*proxyAuthorization);
    }
    if (qualificationId) {
      res["QualificationId"] = boost::any(*qualificationId);
    }
    if (qualificationType) {
      res["QualificationType"] = boost::any(*qualificationType);
    }
    if (qualificationVersion) {
      res["QualificationVersion"] = boost::any(*qualificationVersion);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sceneType) {
      res["SceneType"] = boost::any(*sceneType);
    }
    if (serviceType) {
      res["ServiceType"] = boost::any(*serviceType);
    }
    if (signCode) {
      res["SignCode"] = boost::any(*signCode);
    }
    if (signId) {
      res["SignId"] = boost::any(*signId);
    }
    if (signName) {
      res["SignName"] = boost::any(*signName);
    }
    if (signScopeOCR) {
      res["SignScopeOCR"] = boost::any(*signScopeOCR);
    }
    if (signUpgrade) {
      res["SignUpgrade"] = boost::any(*signUpgrade);
    }
    if (thirdParty) {
      res["ThirdParty"] = boost::any(*thirdParty);
    }
    if (userViewFileName) {
      res["UserViewFileName"] = boost::any(*userViewFileName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationSceneId") != m.end() && !m["ApplicationSceneId"].empty()) {
      applicationSceneId = make_shared<long>(boost::any_cast<long>(m["ApplicationSceneId"]));
    }
    if (m.find("ApplySource") != m.end() && !m["ApplySource"].empty()) {
      applySource = make_shared<string>(boost::any_cast<string>(m["ApplySource"]));
    }
    if (m.find("Authorization") != m.end() && !m["Authorization"].empty()) {
      authorization = make_shared<string>(boost::any_cast<string>(m["Authorization"]));
    }
    if (m.find("AuthorizationEffTime") != m.end() && !m["AuthorizationEffTime"].empty()) {
      authorizationEffTime = make_shared<string>(boost::any_cast<string>(m["AuthorizationEffTime"]));
    }
    if (m.find("AuthorizationLetter") != m.end() && !m["AuthorizationLetter"].empty()) {
      authorizationLetter = make_shared<string>(boost::any_cast<string>(m["AuthorizationLetter"]));
    }
    if (m.find("AuthorizationLetterAuditPass") != m.end() && !m["AuthorizationLetterAuditPass"].empty()) {
      authorizationLetterAuditPass = make_shared<bool>(boost::any_cast<bool>(m["AuthorizationLetterAuditPass"]));
    }
    if (m.find("AuthorizationLetterId") != m.end() && !m["AuthorizationLetterId"].empty()) {
      authorizationLetterId = make_shared<long>(boost::any_cast<long>(m["AuthorizationLetterId"]));
    }
    if (m.find("AuthorizationLetterName") != m.end() && !m["AuthorizationLetterName"].empty()) {
      authorizationLetterName = make_shared<string>(boost::any_cast<string>(m["AuthorizationLetterName"]));
    }
    if (m.find("AuthorizationSignScope") != m.end() && !m["AuthorizationSignScope"].empty()) {
      authorizationSignScope = make_shared<string>(boost::any_cast<string>(m["AuthorizationSignScope"]));
    }
    if (m.find("CreateSignGray") != m.end() && !m["CreateSignGray"].empty()) {
      createSignGray = make_shared<bool>(boost::any_cast<bool>(m["CreateSignGray"]));
    }
    if (m.find("EnableAuthorizationLetter") != m.end() && !m["EnableAuthorizationLetter"].empty()) {
      enableAuthorizationLetter = make_shared<bool>(boost::any_cast<bool>(m["EnableAuthorizationLetter"]));
    }
    if (m.find("ExtendMessage") != m.end() && !m["ExtendMessage"].empty()) {
      extendMessage = make_shared<string>(boost::any_cast<string>(m["ExtendMessage"]));
    }
    if (m.find("FileIds") != m.end() && !m["FileIds"].empty()) {
      fileIds = make_shared<string>(boost::any_cast<string>(m["FileIds"]));
    }
    if (m.find("IsAuthorizationLetterOCRComplete") != m.end() && !m["IsAuthorizationLetterOCRComplete"].empty()) {
      isAuthorizationLetterOCRComplete = make_shared<bool>(boost::any_cast<bool>(m["IsAuthorizationLetterOCRComplete"]));
    }
    if (m.find("IsAuthorizationLetterOCRDiff") != m.end() && !m["IsAuthorizationLetterOCRDiff"].empty()) {
      isAuthorizationLetterOCRDiff = make_shared<bool>(boost::any_cast<bool>(m["IsAuthorizationLetterOCRDiff"]));
    }
    if (m.find("IsSignScopeOCRDiff") != m.end() && !m["IsSignScopeOCRDiff"].empty()) {
      isSignScopeOCRDiff = make_shared<bool>(boost::any_cast<bool>(m["IsSignScopeOCRDiff"]));
    }
    if (m.find("MoreData") != m.end() && !m["MoreData"].empty()) {
      moreDataShrink = make_shared<string>(boost::any_cast<string>(m["MoreData"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("OrganizationCode") != m.end() && !m["OrganizationCode"].empty()) {
      organizationCode = make_shared<string>(boost::any_cast<string>(m["OrganizationCode"]));
    }
    if (m.find("OssKeys") != m.end() && !m["OssKeys"].empty()) {
      ossKeys = make_shared<string>(boost::any_cast<string>(m["OssKeys"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ProxyAuthorization") != m.end() && !m["ProxyAuthorization"].empty()) {
      proxyAuthorization = make_shared<string>(boost::any_cast<string>(m["ProxyAuthorization"]));
    }
    if (m.find("QualificationId") != m.end() && !m["QualificationId"].empty()) {
      qualificationId = make_shared<long>(boost::any_cast<long>(m["QualificationId"]));
    }
    if (m.find("QualificationType") != m.end() && !m["QualificationType"].empty()) {
      qualificationType = make_shared<long>(boost::any_cast<long>(m["QualificationType"]));
    }
    if (m.find("QualificationVersion") != m.end() && !m["QualificationVersion"].empty()) {
      qualificationVersion = make_shared<long>(boost::any_cast<long>(m["QualificationVersion"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SceneType") != m.end() && !m["SceneType"].empty()) {
      sceneType = make_shared<long>(boost::any_cast<long>(m["SceneType"]));
    }
    if (m.find("ServiceType") != m.end() && !m["ServiceType"].empty()) {
      serviceType = make_shared<long>(boost::any_cast<long>(m["ServiceType"]));
    }
    if (m.find("SignCode") != m.end() && !m["SignCode"].empty()) {
      signCode = make_shared<string>(boost::any_cast<string>(m["SignCode"]));
    }
    if (m.find("SignId") != m.end() && !m["SignId"].empty()) {
      signId = make_shared<string>(boost::any_cast<string>(m["SignId"]));
    }
    if (m.find("SignName") != m.end() && !m["SignName"].empty()) {
      signName = make_shared<string>(boost::any_cast<string>(m["SignName"]));
    }
    if (m.find("SignScopeOCR") != m.end() && !m["SignScopeOCR"].empty()) {
      signScopeOCR = make_shared<string>(boost::any_cast<string>(m["SignScopeOCR"]));
    }
    if (m.find("SignUpgrade") != m.end() && !m["SignUpgrade"].empty()) {
      signUpgrade = make_shared<bool>(boost::any_cast<bool>(m["SignUpgrade"]));
    }
    if (m.find("ThirdParty") != m.end() && !m["ThirdParty"].empty()) {
      thirdParty = make_shared<bool>(boost::any_cast<bool>(m["ThirdParty"]));
    }
    if (m.find("UserViewFileName") != m.end() && !m["UserViewFileName"].empty()) {
      userViewFileName = make_shared<string>(boost::any_cast<string>(m["UserViewFileName"]));
    }
  }


  virtual ~CreateSmsSignNewShrinkRequest() = default;
};
class CreateSmsSignNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  CreateSmsSignNewResponseBody() {}

  explicit CreateSmsSignNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~CreateSmsSignNewResponseBody() = default;
};
class CreateSmsSignNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSmsSignNewResponseBody> body{};

  CreateSmsSignNewResponse() {}

  explicit CreateSmsSignNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSmsSignNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSmsSignNewResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSmsSignNewResponse() = default;
};
class CreateSmsTemplateNewRequest : public Darabonba::Model {
public:
  shared_ptr<long> aiTemplate{};
  shared_ptr<string> aiTemplateUuid{};
  shared_ptr<long> applicationSceneId{};
  shared_ptr<string> applySource{};
  shared_ptr<string> bizType{};
  shared_ptr<long> intlType{};
  shared_ptr<vector<string>> moreData{};
  shared_ptr<string> orderId{};
  shared_ptr<string> ossKeys{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> productUrl{};
  shared_ptr<string> relatedSignName{};
  shared_ptr<string> relatedSignOrderId{};
  shared_ptr<string> relatedSignUsageName{};
  shared_ptr<string> remark{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> rmdTemplateId{};
  shared_ptr<string> templateCode{};
  shared_ptr<string> templateContent{};
  shared_ptr<string> templateName{};
  shared_ptr<string> templateRule{};
  shared_ptr<string> userViewFileName{};

  CreateSmsTemplateNewRequest() {}

  explicit CreateSmsTemplateNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aiTemplate) {
      res["AiTemplate"] = boost::any(*aiTemplate);
    }
    if (aiTemplateUuid) {
      res["AiTemplateUuid"] = boost::any(*aiTemplateUuid);
    }
    if (applicationSceneId) {
      res["ApplicationSceneId"] = boost::any(*applicationSceneId);
    }
    if (applySource) {
      res["ApplySource"] = boost::any(*applySource);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (intlType) {
      res["IntlType"] = boost::any(*intlType);
    }
    if (moreData) {
      res["MoreData"] = boost::any(*moreData);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (ossKeys) {
      res["OssKeys"] = boost::any(*ossKeys);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (productUrl) {
      res["ProductUrl"] = boost::any(*productUrl);
    }
    if (relatedSignName) {
      res["RelatedSignName"] = boost::any(*relatedSignName);
    }
    if (relatedSignOrderId) {
      res["RelatedSignOrderId"] = boost::any(*relatedSignOrderId);
    }
    if (relatedSignUsageName) {
      res["RelatedSignUsageName"] = boost::any(*relatedSignUsageName);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (rmdTemplateId) {
      res["RmdTemplateId"] = boost::any(*rmdTemplateId);
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    if (templateContent) {
      res["TemplateContent"] = boost::any(*templateContent);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (templateRule) {
      res["TemplateRule"] = boost::any(*templateRule);
    }
    if (userViewFileName) {
      res["UserViewFileName"] = boost::any(*userViewFileName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AiTemplate") != m.end() && !m["AiTemplate"].empty()) {
      aiTemplate = make_shared<long>(boost::any_cast<long>(m["AiTemplate"]));
    }
    if (m.find("AiTemplateUuid") != m.end() && !m["AiTemplateUuid"].empty()) {
      aiTemplateUuid = make_shared<string>(boost::any_cast<string>(m["AiTemplateUuid"]));
    }
    if (m.find("ApplicationSceneId") != m.end() && !m["ApplicationSceneId"].empty()) {
      applicationSceneId = make_shared<long>(boost::any_cast<long>(m["ApplicationSceneId"]));
    }
    if (m.find("ApplySource") != m.end() && !m["ApplySource"].empty()) {
      applySource = make_shared<string>(boost::any_cast<string>(m["ApplySource"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("IntlType") != m.end() && !m["IntlType"].empty()) {
      intlType = make_shared<long>(boost::any_cast<long>(m["IntlType"]));
    }
    if (m.find("MoreData") != m.end() && !m["MoreData"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MoreData"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MoreData"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      moreData = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("OssKeys") != m.end() && !m["OssKeys"].empty()) {
      ossKeys = make_shared<string>(boost::any_cast<string>(m["OssKeys"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ProductUrl") != m.end() && !m["ProductUrl"].empty()) {
      productUrl = make_shared<string>(boost::any_cast<string>(m["ProductUrl"]));
    }
    if (m.find("RelatedSignName") != m.end() && !m["RelatedSignName"].empty()) {
      relatedSignName = make_shared<string>(boost::any_cast<string>(m["RelatedSignName"]));
    }
    if (m.find("RelatedSignOrderId") != m.end() && !m["RelatedSignOrderId"].empty()) {
      relatedSignOrderId = make_shared<string>(boost::any_cast<string>(m["RelatedSignOrderId"]));
    }
    if (m.find("RelatedSignUsageName") != m.end() && !m["RelatedSignUsageName"].empty()) {
      relatedSignUsageName = make_shared<string>(boost::any_cast<string>(m["RelatedSignUsageName"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RmdTemplateId") != m.end() && !m["RmdTemplateId"].empty()) {
      rmdTemplateId = make_shared<long>(boost::any_cast<long>(m["RmdTemplateId"]));
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
    if (m.find("TemplateContent") != m.end() && !m["TemplateContent"].empty()) {
      templateContent = make_shared<string>(boost::any_cast<string>(m["TemplateContent"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("TemplateRule") != m.end() && !m["TemplateRule"].empty()) {
      templateRule = make_shared<string>(boost::any_cast<string>(m["TemplateRule"]));
    }
    if (m.find("UserViewFileName") != m.end() && !m["UserViewFileName"].empty()) {
      userViewFileName = make_shared<string>(boost::any_cast<string>(m["UserViewFileName"]));
    }
  }


  virtual ~CreateSmsTemplateNewRequest() = default;
};
class CreateSmsTemplateNewShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> aiTemplate{};
  shared_ptr<string> aiTemplateUuid{};
  shared_ptr<long> applicationSceneId{};
  shared_ptr<string> applySource{};
  shared_ptr<string> bizType{};
  shared_ptr<long> intlType{};
  shared_ptr<string> moreDataShrink{};
  shared_ptr<string> orderId{};
  shared_ptr<string> ossKeys{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> productUrl{};
  shared_ptr<string> relatedSignName{};
  shared_ptr<string> relatedSignOrderId{};
  shared_ptr<string> relatedSignUsageName{};
  shared_ptr<string> remark{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> rmdTemplateId{};
  shared_ptr<string> templateCode{};
  shared_ptr<string> templateContent{};
  shared_ptr<string> templateName{};
  shared_ptr<string> templateRule{};
  shared_ptr<string> userViewFileName{};

  CreateSmsTemplateNewShrinkRequest() {}

  explicit CreateSmsTemplateNewShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aiTemplate) {
      res["AiTemplate"] = boost::any(*aiTemplate);
    }
    if (aiTemplateUuid) {
      res["AiTemplateUuid"] = boost::any(*aiTemplateUuid);
    }
    if (applicationSceneId) {
      res["ApplicationSceneId"] = boost::any(*applicationSceneId);
    }
    if (applySource) {
      res["ApplySource"] = boost::any(*applySource);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (intlType) {
      res["IntlType"] = boost::any(*intlType);
    }
    if (moreDataShrink) {
      res["MoreData"] = boost::any(*moreDataShrink);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (ossKeys) {
      res["OssKeys"] = boost::any(*ossKeys);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (productUrl) {
      res["ProductUrl"] = boost::any(*productUrl);
    }
    if (relatedSignName) {
      res["RelatedSignName"] = boost::any(*relatedSignName);
    }
    if (relatedSignOrderId) {
      res["RelatedSignOrderId"] = boost::any(*relatedSignOrderId);
    }
    if (relatedSignUsageName) {
      res["RelatedSignUsageName"] = boost::any(*relatedSignUsageName);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (rmdTemplateId) {
      res["RmdTemplateId"] = boost::any(*rmdTemplateId);
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    if (templateContent) {
      res["TemplateContent"] = boost::any(*templateContent);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (templateRule) {
      res["TemplateRule"] = boost::any(*templateRule);
    }
    if (userViewFileName) {
      res["UserViewFileName"] = boost::any(*userViewFileName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AiTemplate") != m.end() && !m["AiTemplate"].empty()) {
      aiTemplate = make_shared<long>(boost::any_cast<long>(m["AiTemplate"]));
    }
    if (m.find("AiTemplateUuid") != m.end() && !m["AiTemplateUuid"].empty()) {
      aiTemplateUuid = make_shared<string>(boost::any_cast<string>(m["AiTemplateUuid"]));
    }
    if (m.find("ApplicationSceneId") != m.end() && !m["ApplicationSceneId"].empty()) {
      applicationSceneId = make_shared<long>(boost::any_cast<long>(m["ApplicationSceneId"]));
    }
    if (m.find("ApplySource") != m.end() && !m["ApplySource"].empty()) {
      applySource = make_shared<string>(boost::any_cast<string>(m["ApplySource"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("IntlType") != m.end() && !m["IntlType"].empty()) {
      intlType = make_shared<long>(boost::any_cast<long>(m["IntlType"]));
    }
    if (m.find("MoreData") != m.end() && !m["MoreData"].empty()) {
      moreDataShrink = make_shared<string>(boost::any_cast<string>(m["MoreData"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("OssKeys") != m.end() && !m["OssKeys"].empty()) {
      ossKeys = make_shared<string>(boost::any_cast<string>(m["OssKeys"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ProductUrl") != m.end() && !m["ProductUrl"].empty()) {
      productUrl = make_shared<string>(boost::any_cast<string>(m["ProductUrl"]));
    }
    if (m.find("RelatedSignName") != m.end() && !m["RelatedSignName"].empty()) {
      relatedSignName = make_shared<string>(boost::any_cast<string>(m["RelatedSignName"]));
    }
    if (m.find("RelatedSignOrderId") != m.end() && !m["RelatedSignOrderId"].empty()) {
      relatedSignOrderId = make_shared<string>(boost::any_cast<string>(m["RelatedSignOrderId"]));
    }
    if (m.find("RelatedSignUsageName") != m.end() && !m["RelatedSignUsageName"].empty()) {
      relatedSignUsageName = make_shared<string>(boost::any_cast<string>(m["RelatedSignUsageName"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RmdTemplateId") != m.end() && !m["RmdTemplateId"].empty()) {
      rmdTemplateId = make_shared<long>(boost::any_cast<long>(m["RmdTemplateId"]));
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
    if (m.find("TemplateContent") != m.end() && !m["TemplateContent"].empty()) {
      templateContent = make_shared<string>(boost::any_cast<string>(m["TemplateContent"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("TemplateRule") != m.end() && !m["TemplateRule"].empty()) {
      templateRule = make_shared<string>(boost::any_cast<string>(m["TemplateRule"]));
    }
    if (m.find("UserViewFileName") != m.end() && !m["UserViewFileName"].empty()) {
      userViewFileName = make_shared<string>(boost::any_cast<string>(m["UserViewFileName"]));
    }
  }


  virtual ~CreateSmsTemplateNewShrinkRequest() = default;
};
class CreateSmsTemplateNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> orderId{};
  shared_ptr<string> requestId{};

  CreateSmsTemplateNewResponseBody() {}

  explicit CreateSmsTemplateNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateSmsTemplateNewResponseBody() = default;
};
class CreateSmsTemplateNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSmsTemplateNewResponseBody> body{};

  CreateSmsTemplateNewResponse() {}

  explicit CreateSmsTemplateNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSmsTemplateNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSmsTemplateNewResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSmsTemplateNewResponse() = default;
};
class CreateWarningThresholdRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizType{};
  shared_ptr<long> dailyHaltLimit{};
  shared_ptr<long> dailyWarningLimit{};
  shared_ptr<long> monthlyHaltLimit{};
  shared_ptr<long> monthlyWarningLimit{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  CreateWarningThresholdRequest() {}

  explicit CreateWarningThresholdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (dailyHaltLimit) {
      res["DailyHaltLimit"] = boost::any(*dailyHaltLimit);
    }
    if (dailyWarningLimit) {
      res["DailyWarningLimit"] = boost::any(*dailyWarningLimit);
    }
    if (monthlyHaltLimit) {
      res["MonthlyHaltLimit"] = boost::any(*monthlyHaltLimit);
    }
    if (monthlyWarningLimit) {
      res["MonthlyWarningLimit"] = boost::any(*monthlyWarningLimit);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("DailyHaltLimit") != m.end() && !m["DailyHaltLimit"].empty()) {
      dailyHaltLimit = make_shared<long>(boost::any_cast<long>(m["DailyHaltLimit"]));
    }
    if (m.find("DailyWarningLimit") != m.end() && !m["DailyWarningLimit"].empty()) {
      dailyWarningLimit = make_shared<long>(boost::any_cast<long>(m["DailyWarningLimit"]));
    }
    if (m.find("MonthlyHaltLimit") != m.end() && !m["MonthlyHaltLimit"].empty()) {
      monthlyHaltLimit = make_shared<long>(boost::any_cast<long>(m["MonthlyHaltLimit"]));
    }
    if (m.find("MonthlyWarningLimit") != m.end() && !m["MonthlyWarningLimit"].empty()) {
      monthlyWarningLimit = make_shared<long>(boost::any_cast<long>(m["MonthlyWarningLimit"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~CreateWarningThresholdRequest() = default;
};
class CreateWarningThresholdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<string> data{};

  CreateWarningThresholdResponseBody() {}

  explicit CreateWarningThresholdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
  }


  virtual ~CreateWarningThresholdResponseBody() = default;
};
class CreateWarningThresholdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateWarningThresholdResponseBody> body{};

  CreateWarningThresholdResponse() {}

  explicit CreateWarningThresholdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateWarningThresholdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateWarningThresholdResponseBody>(model1);
      }
    }
  }


  virtual ~CreateWarningThresholdResponse() = default;
};
class CreateWarningThresholdNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizType{};
  shared_ptr<long> dailyHaltLimit{};
  shared_ptr<long> dailyWarningLimit{};
  shared_ptr<long> monthlyHaltLimit{};
  shared_ptr<long> monthlyWarningLimit{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  CreateWarningThresholdNewRequest() {}

  explicit CreateWarningThresholdNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (dailyHaltLimit) {
      res["DailyHaltLimit"] = boost::any(*dailyHaltLimit);
    }
    if (dailyWarningLimit) {
      res["DailyWarningLimit"] = boost::any(*dailyWarningLimit);
    }
    if (monthlyHaltLimit) {
      res["MonthlyHaltLimit"] = boost::any(*monthlyHaltLimit);
    }
    if (monthlyWarningLimit) {
      res["MonthlyWarningLimit"] = boost::any(*monthlyWarningLimit);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("DailyHaltLimit") != m.end() && !m["DailyHaltLimit"].empty()) {
      dailyHaltLimit = make_shared<long>(boost::any_cast<long>(m["DailyHaltLimit"]));
    }
    if (m.find("DailyWarningLimit") != m.end() && !m["DailyWarningLimit"].empty()) {
      dailyWarningLimit = make_shared<long>(boost::any_cast<long>(m["DailyWarningLimit"]));
    }
    if (m.find("MonthlyHaltLimit") != m.end() && !m["MonthlyHaltLimit"].empty()) {
      monthlyHaltLimit = make_shared<long>(boost::any_cast<long>(m["MonthlyHaltLimit"]));
    }
    if (m.find("MonthlyWarningLimit") != m.end() && !m["MonthlyWarningLimit"].empty()) {
      monthlyWarningLimit = make_shared<long>(boost::any_cast<long>(m["MonthlyWarningLimit"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~CreateWarningThresholdNewRequest() = default;
};
class CreateWarningThresholdNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  CreateWarningThresholdNewResponseBody() {}

  explicit CreateWarningThresholdNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~CreateWarningThresholdNewResponseBody() = default;
};
class CreateWarningThresholdNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateWarningThresholdNewResponseBody> body{};

  CreateWarningThresholdNewResponse() {}

  explicit CreateWarningThresholdNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateWarningThresholdNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateWarningThresholdNewResponseBody>(model1);
      }
    }
  }


  virtual ~CreateWarningThresholdNewResponse() = default;
};
class DelCardSendExportInfoRequest : public Darabonba::Model {
public:
  shared_ptr<vector<long>> ids{};

  DelCardSendExportInfoRequest() {}

  explicit DelCardSendExportInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      ids = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~DelCardSendExportInfoRequest() = default;
};
class DelCardSendExportInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> model{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DelCardSendExportInfoResponseBody() {}

  explicit DelCardSendExportInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DelCardSendExportInfoResponseBody() = default;
};
class DelCardSendExportInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DelCardSendExportInfoResponseBody> body{};

  DelCardSendExportInfoResponse() {}

  explicit DelCardSendExportInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DelCardSendExportInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DelCardSendExportInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DelCardSendExportInfoResponse() = default;
};
class DeleteCardMessageCallbackRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizType{};
  shared_ptr<string> callbackUrl{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeleteCardMessageCallbackRequest() {}

  explicit DeleteCardMessageCallbackRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (callbackUrl) {
      res["CallbackUrl"] = boost::any(*callbackUrl);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("CallbackUrl") != m.end() && !m["CallbackUrl"].empty()) {
      callbackUrl = make_shared<string>(boost::any_cast<string>(m["CallbackUrl"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeleteCardMessageCallbackRequest() = default;
};
class DeleteCardMessageCallbackResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  DeleteCardMessageCallbackResponseBody() {}

  explicit DeleteCardMessageCallbackResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~DeleteCardMessageCallbackResponseBody() = default;
};
class DeleteCardMessageCallbackResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCardMessageCallbackResponseBody> body{};

  DeleteCardMessageCallbackResponse() {}

  explicit DeleteCardMessageCallbackResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCardMessageCallbackResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCardMessageCallbackResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCardMessageCallbackResponse() = default;
};
class DeleteCardMessageQueueRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> queueType{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeleteCardMessageQueueRequest() {}

  explicit DeleteCardMessageQueueRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (queueType) {
      res["QueueType"] = boost::any(*queueType);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("QueueType") != m.end() && !m["QueueType"].empty()) {
      queueType = make_shared<string>(boost::any_cast<string>(m["QueueType"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeleteCardMessageQueueRequest() = default;
};
class DeleteCardMessageQueueResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  DeleteCardMessageQueueResponseBody() {}

  explicit DeleteCardMessageQueueResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~DeleteCardMessageQueueResponseBody() = default;
};
class DeleteCardMessageQueueResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCardMessageQueueResponseBody> body{};

  DeleteCardMessageQueueResponse() {}

  explicit DeleteCardMessageQueueResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCardMessageQueueResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCardMessageQueueResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCardMessageQueueResponse() = default;
};
class DeleteContactsRequest : public Darabonba::Model {
public:
  shared_ptr<string> ids{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeleteContactsRequest() {}

  explicit DeleteContactsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      ids = make_shared<string>(boost::any_cast<string>(m["Ids"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeleteContactsRequest() = default;
};
class DeleteContactsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<string> data{};

  DeleteContactsResponseBody() {}

  explicit DeleteContactsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
  }


  virtual ~DeleteContactsResponseBody() = default;
};
class DeleteContactsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteContactsResponseBody> body{};

  DeleteContactsResponse() {}

  explicit DeleteContactsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteContactsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteContactsResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteContactsResponse() = default;
};
class DeleteContactsNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> ids{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeleteContactsNewRequest() {}

  explicit DeleteContactsNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      ids = make_shared<string>(boost::any_cast<string>(m["Ids"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeleteContactsNewRequest() = default;
};
class DeleteContactsNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  DeleteContactsNewResponseBody() {}

  explicit DeleteContactsNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~DeleteContactsNewResponseBody() = default;
};
class DeleteContactsNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteContactsNewResponseBody> body{};

  DeleteContactsNewResponse() {}

  explicit DeleteContactsNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteContactsNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteContactsNewResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteContactsNewResponse() = default;
};
class DeleteDigitalTemplateNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> auditState{};
  shared_ptr<string> bizType{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> templateCode{};
  shared_ptr<string> templateName{};

  DeleteDigitalTemplateNewRequest() {}

  explicit DeleteDigitalTemplateNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (auditState) {
      res["AuditState"] = boost::any(*auditState);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuditState") != m.end() && !m["AuditState"].empty()) {
      auditState = make_shared<string>(boost::any_cast<string>(m["AuditState"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
  }


  virtual ~DeleteDigitalTemplateNewRequest() = default;
};
class DeleteDigitalTemplateNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  DeleteDigitalTemplateNewResponseBody() {}

  explicit DeleteDigitalTemplateNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~DeleteDigitalTemplateNewResponseBody() = default;
};
class DeleteDigitalTemplateNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDigitalTemplateNewResponseBody> body{};

  DeleteDigitalTemplateNewResponse() {}

  explicit DeleteDigitalTemplateNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDigitalTemplateNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDigitalTemplateNewResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDigitalTemplateNewResponse() = default;
};
class DeleteMessageCallbackNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizType{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeleteMessageCallbackNewRequest() {}

  explicit DeleteMessageCallbackNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeleteMessageCallbackNewRequest() = default;
};
class DeleteMessageCallbackNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  DeleteMessageCallbackNewResponseBody() {}

  explicit DeleteMessageCallbackNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~DeleteMessageCallbackNewResponseBody() = default;
};
class DeleteMessageCallbackNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMessageCallbackNewResponseBody> body{};

  DeleteMessageCallbackNewResponse() {}

  explicit DeleteMessageCallbackNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMessageCallbackNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMessageCallbackNewResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMessageCallbackNewResponse() = default;
};
class DeleteMessageQueueNewRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> queueType{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeleteMessageQueueNewRequest() {}

  explicit DeleteMessageQueueNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (queueType) {
      res["QueueType"] = boost::any(*queueType);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("QueueType") != m.end() && !m["QueueType"].empty()) {
      queueType = make_shared<string>(boost::any_cast<string>(m["QueueType"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeleteMessageQueueNewRequest() = default;
};
class DeleteMessageQueueNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  DeleteMessageQueueNewResponseBody() {}

  explicit DeleteMessageQueueNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~DeleteMessageQueueNewResponseBody() = default;
};
class DeleteMessageQueueNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMessageQueueNewResponseBody> body{};

  DeleteMessageQueueNewResponse() {}

  explicit DeleteMessageQueueNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMessageQueueNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMessageQueueNewResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMessageQueueNewResponse() = default;
};
class DeleteOrCanceleTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> isDeleted{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> status{};
  shared_ptr<long> taskId{};

  DeleteOrCanceleTaskRequest() {}

  explicit DeleteOrCanceleTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isDeleted) {
      res["IsDeleted"] = boost::any(*isDeleted);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsDeleted") != m.end() && !m["IsDeleted"].empty()) {
      isDeleted = make_shared<long>(boost::any_cast<long>(m["IsDeleted"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
  }


  virtual ~DeleteOrCanceleTaskRequest() = default;
};
class DeleteOrCanceleTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<string> data{};

  DeleteOrCanceleTaskResponseBody() {}

  explicit DeleteOrCanceleTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
  }


  virtual ~DeleteOrCanceleTaskResponseBody() = default;
};
class DeleteOrCanceleTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteOrCanceleTaskResponseBody> body{};

  DeleteOrCanceleTaskResponse() {}

  explicit DeleteOrCanceleTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteOrCanceleTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteOrCanceleTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteOrCanceleTaskResponse() = default;
};
class DeleteOrCanceleTaskNewRequest : public Darabonba::Model {
public:
  shared_ptr<long> isDeleted{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> status{};
  shared_ptr<long> taskId{};

  DeleteOrCanceleTaskNewRequest() {}

  explicit DeleteOrCanceleTaskNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isDeleted) {
      res["IsDeleted"] = boost::any(*isDeleted);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsDeleted") != m.end() && !m["IsDeleted"].empty()) {
      isDeleted = make_shared<long>(boost::any_cast<long>(m["IsDeleted"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
  }


  virtual ~DeleteOrCanceleTaskNewRequest() = default;
};
class DeleteOrCanceleTaskNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> result{};

  DeleteOrCanceleTaskNewResponseBody() {}

  explicit DeleteOrCanceleTaskNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<long>(boost::any_cast<long>(m["Result"]));
    }
  }


  virtual ~DeleteOrCanceleTaskNewResponseBody() = default;
};
class DeleteOrCanceleTaskNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteOrCanceleTaskNewResponseBody> body{};

  DeleteOrCanceleTaskNewResponse() {}

  explicit DeleteOrCanceleTaskNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteOrCanceleTaskNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteOrCanceleTaskNewResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteOrCanceleTaskNewResponse() = default;
};
class DeletePhoneWhiteListRequest : public Darabonba::Model {
public:
  shared_ptr<string> ids{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeletePhoneWhiteListRequest() {}

  explicit DeletePhoneWhiteListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      ids = make_shared<string>(boost::any_cast<string>(m["Ids"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeletePhoneWhiteListRequest() = default;
};
class DeletePhoneWhiteListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<string> data{};

  DeletePhoneWhiteListResponseBody() {}

  explicit DeletePhoneWhiteListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
  }


  virtual ~DeletePhoneWhiteListResponseBody() = default;
};
class DeletePhoneWhiteListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeletePhoneWhiteListResponseBody> body{};

  DeletePhoneWhiteListResponse() {}

  explicit DeletePhoneWhiteListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeletePhoneWhiteListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeletePhoneWhiteListResponseBody>(model1);
      }
    }
  }


  virtual ~DeletePhoneWhiteListResponse() = default;
};
class DeletePhoneWhiteListNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> ids{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeletePhoneWhiteListNewRequest() {}

  explicit DeletePhoneWhiteListNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      ids = make_shared<string>(boost::any_cast<string>(m["Ids"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeletePhoneWhiteListNewRequest() = default;
};
class DeletePhoneWhiteListNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  DeletePhoneWhiteListNewResponseBody() {}

  explicit DeletePhoneWhiteListNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~DeletePhoneWhiteListNewResponseBody() = default;
};
class DeletePhoneWhiteListNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeletePhoneWhiteListNewResponseBody> body{};

  DeletePhoneWhiteListNewResponse() {}

  explicit DeletePhoneWhiteListNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeletePhoneWhiteListNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeletePhoneWhiteListNewResponseBody>(model1);
      }
    }
  }


  virtual ~DeletePhoneWhiteListNewResponse() = default;
};
class DeleteShortUrlNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> ids{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeleteShortUrlNewRequest() {}

  explicit DeleteShortUrlNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      ids = make_shared<string>(boost::any_cast<string>(m["Ids"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeleteShortUrlNewRequest() = default;
};
class DeleteShortUrlNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  DeleteShortUrlNewResponseBody() {}

  explicit DeleteShortUrlNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~DeleteShortUrlNewResponseBody() = default;
};
class DeleteShortUrlNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteShortUrlNewResponseBody> body{};

  DeleteShortUrlNewResponse() {}

  explicit DeleteShortUrlNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteShortUrlNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteShortUrlNewResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteShortUrlNewResponse() = default;
};
class DeleteSmsTemplateNewRequest : public Darabonba::Model {
public:
  shared_ptr<bool> isSmsSign{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> smsTemplateIds{};

  DeleteSmsTemplateNewRequest() {}

  explicit DeleteSmsTemplateNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isSmsSign) {
      res["IsSmsSign"] = boost::any(*isSmsSign);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (smsTemplateIds) {
      res["SmsTemplateIds"] = boost::any(*smsTemplateIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsSmsSign") != m.end() && !m["IsSmsSign"].empty()) {
      isSmsSign = make_shared<bool>(boost::any_cast<bool>(m["IsSmsSign"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SmsTemplateIds") != m.end() && !m["SmsTemplateIds"].empty()) {
      smsTemplateIds = make_shared<string>(boost::any_cast<string>(m["SmsTemplateIds"]));
    }
  }


  virtual ~DeleteSmsTemplateNewRequest() = default;
};
class DeleteSmsTemplateNewResponseBodyFailList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> fail{};

  DeleteSmsTemplateNewResponseBodyFailList() {}

  explicit DeleteSmsTemplateNewResponseBodyFailList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fail) {
      res["Fail"] = boost::any(*fail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Fail") != m.end() && !m["Fail"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Fail"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Fail"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fail = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DeleteSmsTemplateNewResponseBodyFailList() = default;
};
class DeleteSmsTemplateNewResponseBodySuccessList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> succes{};

  DeleteSmsTemplateNewResponseBodySuccessList() {}

  explicit DeleteSmsTemplateNewResponseBodySuccessList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (succes) {
      res["Succes"] = boost::any(*succes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Succes") != m.end() && !m["Succes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Succes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Succes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      succes = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DeleteSmsTemplateNewResponseBodySuccessList() = default;
};
class DeleteSmsTemplateNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<DeleteSmsTemplateNewResponseBodyFailList> failList{};
  shared_ptr<string> requestId{};
  shared_ptr<DeleteSmsTemplateNewResponseBodySuccessList> successList{};

  DeleteSmsTemplateNewResponseBody() {}

  explicit DeleteSmsTemplateNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failList) {
      res["FailList"] = failList ? boost::any(failList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (successList) {
      res["SuccessList"] = successList ? boost::any(successList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailList") != m.end() && !m["FailList"].empty()) {
      if (typeid(map<string, boost::any>) == m["FailList"].type()) {
        DeleteSmsTemplateNewResponseBodyFailList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FailList"]));
        failList = make_shared<DeleteSmsTemplateNewResponseBodyFailList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SuccessList") != m.end() && !m["SuccessList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SuccessList"].type()) {
        DeleteSmsTemplateNewResponseBodySuccessList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SuccessList"]));
        successList = make_shared<DeleteSmsTemplateNewResponseBodySuccessList>(model1);
      }
    }
  }


  virtual ~DeleteSmsTemplateNewResponseBody() = default;
};
class DeleteSmsTemplateNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSmsTemplateNewResponseBody> body{};

  DeleteSmsTemplateNewResponse() {}

  explicit DeleteSmsTemplateNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSmsTemplateNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSmsTemplateNewResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSmsTemplateNewResponse() = default;
};
class ExportCardSmsHistoryRequest : public Darabonba::Model {
public:
  shared_ptr<long> apiSend{};
  shared_ptr<string> cardTemplateType{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<long> receiveState{};
  shared_ptr<string> receiver{};
  shared_ptr<long> renderState{};
  shared_ptr<string> signName{};
  shared_ptr<string> tmpCode{};

  ExportCardSmsHistoryRequest() {}

  explicit ExportCardSmsHistoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiSend) {
      res["ApiSend"] = boost::any(*apiSend);
    }
    if (cardTemplateType) {
      res["CardTemplateType"] = boost::any(*cardTemplateType);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (receiveState) {
      res["ReceiveState"] = boost::any(*receiveState);
    }
    if (receiver) {
      res["Receiver"] = boost::any(*receiver);
    }
    if (renderState) {
      res["RenderState"] = boost::any(*renderState);
    }
    if (signName) {
      res["SignName"] = boost::any(*signName);
    }
    if (tmpCode) {
      res["TmpCode"] = boost::any(*tmpCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiSend") != m.end() && !m["ApiSend"].empty()) {
      apiSend = make_shared<long>(boost::any_cast<long>(m["ApiSend"]));
    }
    if (m.find("CardTemplateType") != m.end() && !m["CardTemplateType"].empty()) {
      cardTemplateType = make_shared<string>(boost::any_cast<string>(m["CardTemplateType"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("ReceiveState") != m.end() && !m["ReceiveState"].empty()) {
      receiveState = make_shared<long>(boost::any_cast<long>(m["ReceiveState"]));
    }
    if (m.find("Receiver") != m.end() && !m["Receiver"].empty()) {
      receiver = make_shared<string>(boost::any_cast<string>(m["Receiver"]));
    }
    if (m.find("RenderState") != m.end() && !m["RenderState"].empty()) {
      renderState = make_shared<long>(boost::any_cast<long>(m["RenderState"]));
    }
    if (m.find("SignName") != m.end() && !m["SignName"].empty()) {
      signName = make_shared<string>(boost::any_cast<string>(m["SignName"]));
    }
    if (m.find("TmpCode") != m.end() && !m["TmpCode"].empty()) {
      tmpCode = make_shared<string>(boost::any_cast<string>(m["TmpCode"]));
    }
  }


  virtual ~ExportCardSmsHistoryRequest() = default;
};
class ExportCardSmsHistoryResponseBodyModelRecords : public Darabonba::Model {
public:
  shared_ptr<long> acceptDate{};
  shared_ptr<long> apiSend{};
  shared_ptr<string> cardTemplateType{};
  shared_ptr<string> customTmpCode{};
  shared_ptr<string> description{};
  shared_ptr<string> fuuId{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<long> isSupport{};
  shared_ptr<string> outId{};
  shared_ptr<long> pid{};
  shared_ptr<long> receiveState{};
  shared_ptr<string> receiver{};
  shared_ptr<long> renderDate{};
  shared_ptr<long> renderState{};
  shared_ptr<string> shortUrl{};
  shared_ptr<string> signName{};
  shared_ptr<string> smsContent{};
  shared_ptr<string> suggestion{};
  shared_ptr<string> tmpCode{};
  shared_ptr<string> tmpId{};
  shared_ptr<long> tmpType{};
  shared_ptr<string> tmpTypeName{};

  ExportCardSmsHistoryResponseBodyModelRecords() {}

  explicit ExportCardSmsHistoryResponseBodyModelRecords(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptDate) {
      res["AcceptDate"] = boost::any(*acceptDate);
    }
    if (apiSend) {
      res["ApiSend"] = boost::any(*apiSend);
    }
    if (cardTemplateType) {
      res["CardTemplateType"] = boost::any(*cardTemplateType);
    }
    if (customTmpCode) {
      res["CustomTmpCode"] = boost::any(*customTmpCode);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (fuuId) {
      res["FuuId"] = boost::any(*fuuId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (isSupport) {
      res["IsSupport"] = boost::any(*isSupport);
    }
    if (outId) {
      res["OutId"] = boost::any(*outId);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (receiveState) {
      res["ReceiveState"] = boost::any(*receiveState);
    }
    if (receiver) {
      res["Receiver"] = boost::any(*receiver);
    }
    if (renderDate) {
      res["RenderDate"] = boost::any(*renderDate);
    }
    if (renderState) {
      res["RenderState"] = boost::any(*renderState);
    }
    if (shortUrl) {
      res["ShortUrl"] = boost::any(*shortUrl);
    }
    if (signName) {
      res["SignName"] = boost::any(*signName);
    }
    if (smsContent) {
      res["SmsContent"] = boost::any(*smsContent);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (tmpCode) {
      res["TmpCode"] = boost::any(*tmpCode);
    }
    if (tmpId) {
      res["TmpId"] = boost::any(*tmpId);
    }
    if (tmpType) {
      res["TmpType"] = boost::any(*tmpType);
    }
    if (tmpTypeName) {
      res["TmpTypeName"] = boost::any(*tmpTypeName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptDate") != m.end() && !m["AcceptDate"].empty()) {
      acceptDate = make_shared<long>(boost::any_cast<long>(m["AcceptDate"]));
    }
    if (m.find("ApiSend") != m.end() && !m["ApiSend"].empty()) {
      apiSend = make_shared<long>(boost::any_cast<long>(m["ApiSend"]));
    }
    if (m.find("CardTemplateType") != m.end() && !m["CardTemplateType"].empty()) {
      cardTemplateType = make_shared<string>(boost::any_cast<string>(m["CardTemplateType"]));
    }
    if (m.find("CustomTmpCode") != m.end() && !m["CustomTmpCode"].empty()) {
      customTmpCode = make_shared<string>(boost::any_cast<string>(m["CustomTmpCode"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("FuuId") != m.end() && !m["FuuId"].empty()) {
      fuuId = make_shared<string>(boost::any_cast<string>(m["FuuId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IsSupport") != m.end() && !m["IsSupport"].empty()) {
      isSupport = make_shared<long>(boost::any_cast<long>(m["IsSupport"]));
    }
    if (m.find("OutId") != m.end() && !m["OutId"].empty()) {
      outId = make_shared<string>(boost::any_cast<string>(m["OutId"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<long>(boost::any_cast<long>(m["Pid"]));
    }
    if (m.find("ReceiveState") != m.end() && !m["ReceiveState"].empty()) {
      receiveState = make_shared<long>(boost::any_cast<long>(m["ReceiveState"]));
    }
    if (m.find("Receiver") != m.end() && !m["Receiver"].empty()) {
      receiver = make_shared<string>(boost::any_cast<string>(m["Receiver"]));
    }
    if (m.find("RenderDate") != m.end() && !m["RenderDate"].empty()) {
      renderDate = make_shared<long>(boost::any_cast<long>(m["RenderDate"]));
    }
    if (m.find("RenderState") != m.end() && !m["RenderState"].empty()) {
      renderState = make_shared<long>(boost::any_cast<long>(m["RenderState"]));
    }
    if (m.find("ShortUrl") != m.end() && !m["ShortUrl"].empty()) {
      shortUrl = make_shared<string>(boost::any_cast<string>(m["ShortUrl"]));
    }
    if (m.find("SignName") != m.end() && !m["SignName"].empty()) {
      signName = make_shared<string>(boost::any_cast<string>(m["SignName"]));
    }
    if (m.find("SmsContent") != m.end() && !m["SmsContent"].empty()) {
      smsContent = make_shared<string>(boost::any_cast<string>(m["SmsContent"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("TmpCode") != m.end() && !m["TmpCode"].empty()) {
      tmpCode = make_shared<string>(boost::any_cast<string>(m["TmpCode"]));
    }
    if (m.find("TmpId") != m.end() && !m["TmpId"].empty()) {
      tmpId = make_shared<string>(boost::any_cast<string>(m["TmpId"]));
    }
    if (m.find("TmpType") != m.end() && !m["TmpType"].empty()) {
      tmpType = make_shared<long>(boost::any_cast<long>(m["TmpType"]));
    }
    if (m.find("TmpTypeName") != m.end() && !m["TmpTypeName"].empty()) {
      tmpTypeName = make_shared<string>(boost::any_cast<string>(m["TmpTypeName"]));
    }
  }


  virtual ~ExportCardSmsHistoryResponseBodyModelRecords() = default;
};
class ExportCardSmsHistoryResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ExportCardSmsHistoryResponseBodyModelRecords>> records{};
  shared_ptr<long> totalCount{};

  ExportCardSmsHistoryResponseBodyModel() {}

  explicit ExportCardSmsHistoryResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (records) {
      vector<boost::any> temp1;
      for(auto item1:*records){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Records"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Records") != m.end() && !m["Records"].empty()) {
      if (typeid(vector<boost::any>) == m["Records"].type()) {
        vector<ExportCardSmsHistoryResponseBodyModelRecords> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Records"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ExportCardSmsHistoryResponseBodyModelRecords model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        records = make_shared<vector<ExportCardSmsHistoryResponseBodyModelRecords>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ExportCardSmsHistoryResponseBodyModel() = default;
};
class ExportCardSmsHistoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ExportCardSmsHistoryResponseBodyModel> model{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ExportCardSmsHistoryResponseBody() {}

  explicit ExportCardSmsHistoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        ExportCardSmsHistoryResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<ExportCardSmsHistoryResponseBodyModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ExportCardSmsHistoryResponseBody() = default;
};
class ExportCardSmsHistoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExportCardSmsHistoryResponseBody> body{};

  ExportCardSmsHistoryResponse() {}

  explicit ExportCardSmsHistoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExportCardSmsHistoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExportCardSmsHistoryResponseBody>(model1);
      }
    }
  }


  virtual ~ExportCardSmsHistoryResponse() = default;
};
class ExportCardSmsStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> customTmpCode{};
  shared_ptr<string> sendDateEnd{};
  shared_ptr<string> sendDateStart{};
  shared_ptr<string> signName{};
  shared_ptr<string> tmpCode{};
  shared_ptr<string> tmpName{};

  ExportCardSmsStatisticsRequest() {}

  explicit ExportCardSmsStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customTmpCode) {
      res["CustomTmpCode"] = boost::any(*customTmpCode);
    }
    if (sendDateEnd) {
      res["SendDateEnd"] = boost::any(*sendDateEnd);
    }
    if (sendDateStart) {
      res["SendDateStart"] = boost::any(*sendDateStart);
    }
    if (signName) {
      res["SignName"] = boost::any(*signName);
    }
    if (tmpCode) {
      res["TmpCode"] = boost::any(*tmpCode);
    }
    if (tmpName) {
      res["TmpName"] = boost::any(*tmpName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomTmpCode") != m.end() && !m["CustomTmpCode"].empty()) {
      customTmpCode = make_shared<string>(boost::any_cast<string>(m["CustomTmpCode"]));
    }
    if (m.find("SendDateEnd") != m.end() && !m["SendDateEnd"].empty()) {
      sendDateEnd = make_shared<string>(boost::any_cast<string>(m["SendDateEnd"]));
    }
    if (m.find("SendDateStart") != m.end() && !m["SendDateStart"].empty()) {
      sendDateStart = make_shared<string>(boost::any_cast<string>(m["SendDateStart"]));
    }
    if (m.find("SignName") != m.end() && !m["SignName"].empty()) {
      signName = make_shared<string>(boost::any_cast<string>(m["SignName"]));
    }
    if (m.find("TmpCode") != m.end() && !m["TmpCode"].empty()) {
      tmpCode = make_shared<string>(boost::any_cast<string>(m["TmpCode"]));
    }
    if (m.find("TmpName") != m.end() && !m["TmpName"].empty()) {
      tmpName = make_shared<string>(boost::any_cast<string>(m["TmpName"]));
    }
  }


  virtual ~ExportCardSmsStatisticsRequest() = default;
};
class ExportCardSmsStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> model{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ExportCardSmsStatisticsResponseBody() {}

  explicit ExportCardSmsStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ExportCardSmsStatisticsResponseBody() = default;
};
class ExportCardSmsStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExportCardSmsStatisticsResponseBody> body{};

  ExportCardSmsStatisticsResponse() {}

  explicit ExportCardSmsStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExportCardSmsStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExportCardSmsStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~ExportCardSmsStatisticsResponse() = default;
};
class ExportCardSmsStatisticsSendRequest : public Darabonba::Model {
public:
  shared_ptr<string> customTmpCode{};
  shared_ptr<string> sendDateEnd{};
  shared_ptr<string> sendDateStart{};
  shared_ptr<string> signName{};
  shared_ptr<string> tmpCode{};

  ExportCardSmsStatisticsSendRequest() {}

  explicit ExportCardSmsStatisticsSendRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customTmpCode) {
      res["CustomTmpCode"] = boost::any(*customTmpCode);
    }
    if (sendDateEnd) {
      res["SendDateEnd"] = boost::any(*sendDateEnd);
    }
    if (sendDateStart) {
      res["SendDateStart"] = boost::any(*sendDateStart);
    }
    if (signName) {
      res["SignName"] = boost::any(*signName);
    }
    if (tmpCode) {
      res["TmpCode"] = boost::any(*tmpCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomTmpCode") != m.end() && !m["CustomTmpCode"].empty()) {
      customTmpCode = make_shared<string>(boost::any_cast<string>(m["CustomTmpCode"]));
    }
    if (m.find("SendDateEnd") != m.end() && !m["SendDateEnd"].empty()) {
      sendDateEnd = make_shared<string>(boost::any_cast<string>(m["SendDateEnd"]));
    }
    if (m.find("SendDateStart") != m.end() && !m["SendDateStart"].empty()) {
      sendDateStart = make_shared<string>(boost::any_cast<string>(m["SendDateStart"]));
    }
    if (m.find("SignName") != m.end() && !m["SignName"].empty()) {
      signName = make_shared<string>(boost::any_cast<string>(m["SignName"]));
    }
    if (m.find("TmpCode") != m.end() && !m["TmpCode"].empty()) {
      tmpCode = make_shared<string>(boost::any_cast<string>(m["TmpCode"]));
    }
  }


  virtual ~ExportCardSmsStatisticsSendRequest() = default;
};
class ExportCardSmsStatisticsSendResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> model{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ExportCardSmsStatisticsSendResponseBody() {}

  explicit ExportCardSmsStatisticsSendResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ExportCardSmsStatisticsSendResponseBody() = default;
};
class ExportCardSmsStatisticsSendResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExportCardSmsStatisticsSendResponseBody> body{};

  ExportCardSmsStatisticsSendResponse() {}

  explicit ExportCardSmsStatisticsSendResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExportCardSmsStatisticsSendResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExportCardSmsStatisticsSendResponseBody>(model1);
      }
    }
  }


  virtual ~ExportCardSmsStatisticsSendResponse() = default;
};
class ExportTmpEffectReportDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> endDate{};
  shared_ptr<string> startDate{};
  shared_ptr<string> tmpCode{};
  shared_ptr<string> tmpName{};
  shared_ptr<string> vendorCode{};
  shared_ptr<string> vendorName{};

  ExportTmpEffectReportDataRequest() {}

  explicit ExportTmpEffectReportDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    if (tmpCode) {
      res["TmpCode"] = boost::any(*tmpCode);
    }
    if (tmpName) {
      res["TmpName"] = boost::any(*tmpName);
    }
    if (vendorCode) {
      res["VendorCode"] = boost::any(*vendorCode);
    }
    if (vendorName) {
      res["VendorName"] = boost::any(*vendorName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
    if (m.find("TmpCode") != m.end() && !m["TmpCode"].empty()) {
      tmpCode = make_shared<string>(boost::any_cast<string>(m["TmpCode"]));
    }
    if (m.find("TmpName") != m.end() && !m["TmpName"].empty()) {
      tmpName = make_shared<string>(boost::any_cast<string>(m["TmpName"]));
    }
    if (m.find("VendorCode") != m.end() && !m["VendorCode"].empty()) {
      vendorCode = make_shared<string>(boost::any_cast<string>(m["VendorCode"]));
    }
    if (m.find("VendorName") != m.end() && !m["VendorName"].empty()) {
      vendorName = make_shared<string>(boost::any_cast<string>(m["VendorName"]));
    }
  }


  virtual ~ExportTmpEffectReportDataRequest() = default;
};
class ExportTmpEffectReportDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> model{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ExportTmpEffectReportDataResponseBody() {}

  explicit ExportTmpEffectReportDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ExportTmpEffectReportDataResponseBody() = default;
};
class ExportTmpEffectReportDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExportTmpEffectReportDataResponseBody> body{};

  ExportTmpEffectReportDataResponse() {}

  explicit ExportTmpEffectReportDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExportTmpEffectReportDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExportTmpEffectReportDataResponseBody>(model1);
      }
    }
  }


  virtual ~ExportTmpEffectReportDataResponse() = default;
};
class GetLetterOfAuthorizationRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> signName{};

  GetLetterOfAuthorizationRequest() {}

  explicit GetLetterOfAuthorizationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (signName) {
      res["SignName"] = boost::any(*signName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SignName") != m.end() && !m["SignName"].empty()) {
      signName = make_shared<string>(boost::any_cast<string>(m["SignName"]));
    }
  }


  virtual ~GetLetterOfAuthorizationRequest() = default;
};
class GetLetterOfAuthorizationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  GetLetterOfAuthorizationResponseBody() {}

  explicit GetLetterOfAuthorizationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~GetLetterOfAuthorizationResponseBody() = default;
};
class GetLetterOfAuthorizationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetLetterOfAuthorizationResponseBody> body{};

  GetLetterOfAuthorizationResponse() {}

  explicit GetLetterOfAuthorizationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetLetterOfAuthorizationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetLetterOfAuthorizationResponseBody>(model1);
      }
    }
  }


  virtual ~GetLetterOfAuthorizationResponse() = default;
};
class ListPushMsgRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> msgType{};
  shared_ptr<string> name{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> pushTime{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> status{};

  ListPushMsgRequest() {}

  explicit ListPushMsgRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (msgType) {
      res["MsgType"] = boost::any(*msgType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pushTime) {
      res["PushTime"] = boost::any(*pushTime);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MsgType") != m.end() && !m["MsgType"].empty()) {
      msgType = make_shared<string>(boost::any_cast<string>(m["MsgType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PushTime") != m.end() && !m["PushTime"].empty()) {
      pushTime = make_shared<string>(boost::any_cast<string>(m["PushTime"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListPushMsgRequest() = default;
};
class ListPushMsgResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<string> createdDate{};
  shared_ptr<string> createdDateStr{};
  shared_ptr<string> id{};
  shared_ptr<string> pushTime{};
  shared_ptr<string> pushTimeStr{};
  shared_ptr<string> spec{};
  shared_ptr<string> status{};
  shared_ptr<string> statusStr{};
  shared_ptr<string> title{};
  shared_ptr<long> userNum{};

  ListPushMsgResponseBodyModel() {}

  explicit ListPushMsgResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdDate) {
      res["CreatedDate"] = boost::any(*createdDate);
    }
    if (createdDateStr) {
      res["CreatedDateStr"] = boost::any(*createdDateStr);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (pushTime) {
      res["PushTime"] = boost::any(*pushTime);
    }
    if (pushTimeStr) {
      res["PushTimeStr"] = boost::any(*pushTimeStr);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (statusStr) {
      res["StatusStr"] = boost::any(*statusStr);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (userNum) {
      res["UserNum"] = boost::any(*userNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreatedDate") != m.end() && !m["CreatedDate"].empty()) {
      createdDate = make_shared<string>(boost::any_cast<string>(m["CreatedDate"]));
    }
    if (m.find("CreatedDateStr") != m.end() && !m["CreatedDateStr"].empty()) {
      createdDateStr = make_shared<string>(boost::any_cast<string>(m["CreatedDateStr"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("PushTime") != m.end() && !m["PushTime"].empty()) {
      pushTime = make_shared<string>(boost::any_cast<string>(m["PushTime"]));
    }
    if (m.find("PushTimeStr") != m.end() && !m["PushTimeStr"].empty()) {
      pushTimeStr = make_shared<string>(boost::any_cast<string>(m["PushTimeStr"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StatusStr") != m.end() && !m["StatusStr"].empty()) {
      statusStr = make_shared<string>(boost::any_cast<string>(m["StatusStr"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UserNum") != m.end() && !m["UserNum"].empty()) {
      userNum = make_shared<long>(boost::any_cast<long>(m["UserNum"]));
    }
  }


  virtual ~ListPushMsgResponseBodyModel() = default;
};
class ListPushMsgResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<ListPushMsgResponseBodyModel> model{};
  shared_ptr<string> requestId{};

  ListPushMsgResponseBody() {}

  explicit ListPushMsgResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        ListPushMsgResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<ListPushMsgResponseBodyModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListPushMsgResponseBody() = default;
};
class ListPushMsgResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPushMsgResponseBody> body{};

  ListPushMsgResponse() {}

  explicit ListPushMsgResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPushMsgResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPushMsgResponseBody>(model1);
      }
    }
  }


  virtual ~ListPushMsgResponse() = default;
};
class ListTagResourcesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListTagResourcesRequestTag() {}

  explicit ListTagResourcesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListTagResourcesRequestTag() = default;
};
class ListTagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> scope{};
  shared_ptr<vector<ListTagResourcesRequestTag>> tag{};
  shared_ptr<long> tagOwnerUid{};

  ListTagResourcesRequest() {}

  explicit ListTagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (tagOwnerUid) {
      res["TagOwnerUid"] = boost::any(*tagOwnerUid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<ListTagResourcesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagResourcesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<ListTagResourcesRequestTag>>(expect1);
      }
    }
    if (m.find("TagOwnerUid") != m.end() && !m["TagOwnerUid"].empty()) {
      tagOwnerUid = make_shared<long>(boost::any_cast<long>(m["TagOwnerUid"]));
    }
  }


  virtual ~ListTagResourcesRequest() = default;
};
class ListTagResourcesResponseBodyTagResourcesTagResource : public Darabonba::Model {
public:
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  ListTagResourcesResponseBodyTagResourcesTagResource() {}

  explicit ListTagResourcesResponseBodyTagResourcesTagResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~ListTagResourcesResponseBodyTagResourcesTagResource() = default;
};
class ListTagResourcesResponseBodyTagResources : public Darabonba::Model {
public:
  shared_ptr<vector<ListTagResourcesResponseBodyTagResourcesTagResource>> tagResource{};

  ListTagResourcesResponseBodyTagResources() {}

  explicit ListTagResourcesResponseBodyTagResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagResource) {
      vector<boost::any> temp1;
      for(auto item1:*tagResource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagResource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagResource") != m.end() && !m["TagResource"].empty()) {
      if (typeid(vector<boost::any>) == m["TagResource"].type()) {
        vector<ListTagResourcesResponseBodyTagResourcesTagResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagResource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagResourcesResponseBodyTagResourcesTagResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagResource = make_shared<vector<ListTagResourcesResponseBodyTagResourcesTagResource>>(expect1);
      }
    }
  }


  virtual ~ListTagResourcesResponseBodyTagResources() = default;
};
class ListTagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<ListTagResourcesResponseBodyTagResources> tagResources{};

  ListTagResourcesResponseBody() {}

  explicit ListTagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tagResources) {
      res["TagResources"] = tagResources ? boost::any(tagResources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TagResources") != m.end() && !m["TagResources"].empty()) {
      if (typeid(map<string, boost::any>) == m["TagResources"].type()) {
        ListTagResourcesResponseBodyTagResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TagResources"]));
        tagResources = make_shared<ListTagResourcesResponseBodyTagResources>(model1);
      }
    }
  }


  virtual ~ListTagResourcesResponseBody() = default;
};
class ListTagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTagResourcesResponseBody> body{};

  ListTagResourcesResponse() {}

  explicit ListTagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~ListTagResourcesResponse() = default;
};
class OpenShortUrlProductRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  OpenShortUrlProductRequest() {}

  explicit OpenShortUrlProductRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~OpenShortUrlProductRequest() = default;
};
class OpenShortUrlProductResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  OpenShortUrlProductResponseBody() {}

  explicit OpenShortUrlProductResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~OpenShortUrlProductResponseBody() = default;
};
class OpenShortUrlProductResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OpenShortUrlProductResponseBody> body{};

  OpenShortUrlProductResponse() {}

  explicit OpenShortUrlProductResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OpenShortUrlProductResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OpenShortUrlProductResponseBody>(model1);
      }
    }
  }


  virtual ~OpenShortUrlProductResponse() = default;
};
class OpenShortUrlProductNewRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  OpenShortUrlProductNewRequest() {}

  explicit OpenShortUrlProductNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~OpenShortUrlProductNewRequest() = default;
};
class OpenShortUrlProductNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> rusult{};

  OpenShortUrlProductNewResponseBody() {}

  explicit OpenShortUrlProductNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (rusult) {
      res["Rusult"] = boost::any(*rusult);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Rusult") != m.end() && !m["Rusult"].empty()) {
      rusult = make_shared<bool>(boost::any_cast<bool>(m["Rusult"]));
    }
  }


  virtual ~OpenShortUrlProductNewResponseBody() = default;
};
class OpenShortUrlProductNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OpenShortUrlProductNewResponseBody> body{};

  OpenShortUrlProductNewResponse() {}

  explicit OpenShortUrlProductNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OpenShortUrlProductNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OpenShortUrlProductNewResponseBody>(model1);
      }
    }
  }


  virtual ~OpenShortUrlProductNewResponse() = default;
};
class OpencPrevFlagNewRequest : public Darabonba::Model {
public:
  shared_ptr<long> isOpen{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  OpencPrevFlagNewRequest() {}

  explicit OpencPrevFlagNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isOpen) {
      res["IsOpen"] = boost::any(*isOpen);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsOpen") != m.end() && !m["IsOpen"].empty()) {
      isOpen = make_shared<long>(boost::any_cast<long>(m["IsOpen"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~OpencPrevFlagNewRequest() = default;
};
class OpencPrevFlagNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  OpencPrevFlagNewResponseBody() {}

  explicit OpencPrevFlagNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~OpencPrevFlagNewResponseBody() = default;
};
class OpencPrevFlagNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OpencPrevFlagNewResponseBody> body{};

  OpencPrevFlagNewResponse() {}

  explicit OpencPrevFlagNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OpencPrevFlagNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OpencPrevFlagNewResponseBody>(model1);
      }
    }
  }


  virtual ~OpencPrevFlagNewResponse() = default;
};
class QueryAnyParamTemplateUserRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryAnyParamTemplateUserRequest() {}

  explicit QueryAnyParamTemplateUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryAnyParamTemplateUserRequest() = default;
};
class QueryAnyParamTemplateUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<string> data{};

  QueryAnyParamTemplateUserResponseBody() {}

  explicit QueryAnyParamTemplateUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
  }


  virtual ~QueryAnyParamTemplateUserResponseBody() = default;
};
class QueryAnyParamTemplateUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryAnyParamTemplateUserResponseBody> body{};

  QueryAnyParamTemplateUserResponse() {}

  explicit QueryAnyParamTemplateUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryAnyParamTemplateUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryAnyParamTemplateUserResponseBody>(model1);
      }
    }
  }


  virtual ~QueryAnyParamTemplateUserResponse() = default;
};
class QueryAuthorizationRequest : public Darabonba::Model {
public:
  shared_ptr<string> authorizeCode{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryAuthorizationRequest() {}

  explicit QueryAuthorizationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorizeCode) {
      res["AuthorizeCode"] = boost::any(*authorizeCode);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthorizeCode") != m.end() && !m["AuthorizeCode"].empty()) {
      authorizeCode = make_shared<string>(boost::any_cast<string>(m["AuthorizeCode"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryAuthorizationRequest() = default;
};
class QueryAuthorizationResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> aliyunUid{};
  shared_ptr<string> authorizeCode{};
  shared_ptr<bool> authorizeStatus{};
  shared_ptr<string> authorizeTime{};
  shared_ptr<string> productCode{};
  shared_ptr<string> unAuthorizeTime{};

  QueryAuthorizationResponseBodyResult() {}

  explicit QueryAuthorizationResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunUid) {
      res["AliyunUid"] = boost::any(*aliyunUid);
    }
    if (authorizeCode) {
      res["AuthorizeCode"] = boost::any(*authorizeCode);
    }
    if (authorizeStatus) {
      res["AuthorizeStatus"] = boost::any(*authorizeStatus);
    }
    if (authorizeTime) {
      res["AuthorizeTime"] = boost::any(*authorizeTime);
    }
    if (productCode) {
      res["ProductCode"] = boost::any(*productCode);
    }
    if (unAuthorizeTime) {
      res["UnAuthorizeTime"] = boost::any(*unAuthorizeTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunUid") != m.end() && !m["AliyunUid"].empty()) {
      aliyunUid = make_shared<long>(boost::any_cast<long>(m["AliyunUid"]));
    }
    if (m.find("AuthorizeCode") != m.end() && !m["AuthorizeCode"].empty()) {
      authorizeCode = make_shared<string>(boost::any_cast<string>(m["AuthorizeCode"]));
    }
    if (m.find("AuthorizeStatus") != m.end() && !m["AuthorizeStatus"].empty()) {
      authorizeStatus = make_shared<bool>(boost::any_cast<bool>(m["AuthorizeStatus"]));
    }
    if (m.find("AuthorizeTime") != m.end() && !m["AuthorizeTime"].empty()) {
      authorizeTime = make_shared<string>(boost::any_cast<string>(m["AuthorizeTime"]));
    }
    if (m.find("ProductCode") != m.end() && !m["ProductCode"].empty()) {
      productCode = make_shared<string>(boost::any_cast<string>(m["ProductCode"]));
    }
    if (m.find("UnAuthorizeTime") != m.end() && !m["UnAuthorizeTime"].empty()) {
      unAuthorizeTime = make_shared<string>(boost::any_cast<string>(m["UnAuthorizeTime"]));
    }
  }


  virtual ~QueryAuthorizationResponseBodyResult() = default;
};
class QueryAuthorizationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<QueryAuthorizationResponseBodyResult>> result{};

  QueryAuthorizationResponseBody() {}

  explicit QueryAuthorizationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<QueryAuthorizationResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryAuthorizationResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<QueryAuthorizationResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~QueryAuthorizationResponseBody() = default;
};
class QueryAuthorizationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryAuthorizationResponseBody> body{};

  QueryAuthorizationResponse() {}

  explicit QueryAuthorizationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryAuthorizationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryAuthorizationResponseBody>(model1);
      }
    }
  }


  virtual ~QueryAuthorizationResponse() = default;
};
class QueryBillingStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> billCycle{};
  shared_ptr<string> itemName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryBillingStatisticsRequest() {}

  explicit QueryBillingStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billCycle) {
      res["BillCycle"] = boost::any(*billCycle);
    }
    if (itemName) {
      res["ItemName"] = boost::any(*itemName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BillCycle") != m.end() && !m["BillCycle"].empty()) {
      billCycle = make_shared<string>(boost::any_cast<string>(m["BillCycle"]));
    }
    if (m.find("ItemName") != m.end() && !m["ItemName"].empty()) {
      itemName = make_shared<string>(boost::any_cast<string>(m["ItemName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryBillingStatisticsRequest() = default;
};
class QueryBillingStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<string> data{};

  QueryBillingStatisticsResponseBody() {}

  explicit QueryBillingStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
  }


  virtual ~QueryBillingStatisticsResponseBody() = default;
};
class QueryBillingStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryBillingStatisticsResponseBody> body{};

  QueryBillingStatisticsResponse() {}

  explicit QueryBillingStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryBillingStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryBillingStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~QueryBillingStatisticsResponse() = default;
};
class QueryCardMessageQueueRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> queueTypes{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryCardMessageQueueRequest() {}

  explicit QueryCardMessageQueueRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (queueTypes) {
      res["QueueTypes"] = boost::any(*queueTypes);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("QueueTypes") != m.end() && !m["QueueTypes"].empty()) {
      queueTypes = make_shared<string>(boost::any_cast<string>(m["QueueTypes"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryCardMessageQueueRequest() = default;
};
class QueryCardMessageQueueResponseBodyList : public Darabonba::Model {
public:
  shared_ptr<bool> isCreated{};
  shared_ptr<string> queueName{};
  shared_ptr<string> queueType{};
  shared_ptr<string> region{};

  QueryCardMessageQueueResponseBodyList() {}

  explicit QueryCardMessageQueueResponseBodyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isCreated) {
      res["IsCreated"] = boost::any(*isCreated);
    }
    if (queueName) {
      res["QueueName"] = boost::any(*queueName);
    }
    if (queueType) {
      res["QueueType"] = boost::any(*queueType);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsCreated") != m.end() && !m["IsCreated"].empty()) {
      isCreated = make_shared<bool>(boost::any_cast<bool>(m["IsCreated"]));
    }
    if (m.find("QueueName") != m.end() && !m["QueueName"].empty()) {
      queueName = make_shared<string>(boost::any_cast<string>(m["QueueName"]));
    }
    if (m.find("QueueType") != m.end() && !m["QueueType"].empty()) {
      queueType = make_shared<string>(boost::any_cast<string>(m["QueueType"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
  }


  virtual ~QueryCardMessageQueueResponseBodyList() = default;
};
class QueryCardMessageQueueResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<QueryCardMessageQueueResponseBodyList>> list{};
  shared_ptr<string> requestId{};

  QueryCardMessageQueueResponseBody() {}

  explicit QueryCardMessageQueueResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<QueryCardMessageQueueResponseBodyList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryCardMessageQueueResponseBodyList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<QueryCardMessageQueueResponseBodyList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryCardMessageQueueResponseBody() = default;
};
class QueryCardMessageQueueResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryCardMessageQueueResponseBody> body{};

  QueryCardMessageQueueResponse() {}

  explicit QueryCardMessageQueueResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryCardMessageQueueResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryCardMessageQueueResponseBody>(model1);
      }
    }
  }


  virtual ~QueryCardMessageQueueResponse() = default;
};
class QueryCardSendExportInfoRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> status{};
  shared_ptr<long> type{};

  QueryCardSendExportInfoRequest() {}

  explicit QueryCardSendExportInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~QueryCardSendExportInfoRequest() = default;
};
class QueryCardSendExportInfoResponseBodyModelRecords : public Darabonba::Model {
public:
  shared_ptr<string> ext{};
  shared_ptr<string> fileName{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<string> ossUrl{};
  shared_ptr<long> pid{};
  shared_ptr<long> status{};
  shared_ptr<long> type{};
  shared_ptr<string> userId{};

  QueryCardSendExportInfoResponseBodyModelRecords() {}

  explicit QueryCardSendExportInfoResponseBodyModelRecords(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ext) {
      res["Ext"] = boost::any(*ext);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ossUrl) {
      res["OssUrl"] = boost::any(*ossUrl);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ext") != m.end() && !m["Ext"].empty()) {
      ext = make_shared<string>(boost::any_cast<string>(m["Ext"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("OssUrl") != m.end() && !m["OssUrl"].empty()) {
      ossUrl = make_shared<string>(boost::any_cast<string>(m["OssUrl"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<long>(boost::any_cast<long>(m["Pid"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~QueryCardSendExportInfoResponseBodyModelRecords() = default;
};
class QueryCardSendExportInfoResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<QueryCardSendExportInfoResponseBodyModelRecords>> records{};
  shared_ptr<long> totalCount{};

  QueryCardSendExportInfoResponseBodyModel() {}

  explicit QueryCardSendExportInfoResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (records) {
      vector<boost::any> temp1;
      for(auto item1:*records){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Records"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Records") != m.end() && !m["Records"].empty()) {
      if (typeid(vector<boost::any>) == m["Records"].type()) {
        vector<QueryCardSendExportInfoResponseBodyModelRecords> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Records"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryCardSendExportInfoResponseBodyModelRecords model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        records = make_shared<vector<QueryCardSendExportInfoResponseBodyModelRecords>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~QueryCardSendExportInfoResponseBodyModel() = default;
};
class QueryCardSendExportInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryCardSendExportInfoResponseBodyModel> model{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryCardSendExportInfoResponseBody() {}

  explicit QueryCardSendExportInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        QueryCardSendExportInfoResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<QueryCardSendExportInfoResponseBodyModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryCardSendExportInfoResponseBody() = default;
};
class QueryCardSendExportInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryCardSendExportInfoResponseBody> body{};

  QueryCardSendExportInfoResponse() {}

  explicit QueryCardSendExportInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryCardSendExportInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryCardSendExportInfoResponseBody>(model1);
      }
    }
  }


  virtual ~QueryCardSendExportInfoResponse() = default;
};
class QueryCardSmsHistoryRequest : public Darabonba::Model {
public:
  shared_ptr<long> apiSend{};
  shared_ptr<string> cardTemplateType{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<long> maxId{};
  shared_ptr<long> minId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> receiveState{};
  shared_ptr<string> receiver{};
  shared_ptr<long> renderState{};
  shared_ptr<string> signName{};
  shared_ptr<string> tmpCode{};
  shared_ptr<long> type{};

  QueryCardSmsHistoryRequest() {}

  explicit QueryCardSmsHistoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiSend) {
      res["ApiSend"] = boost::any(*apiSend);
    }
    if (cardTemplateType) {
      res["CardTemplateType"] = boost::any(*cardTemplateType);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (maxId) {
      res["MaxId"] = boost::any(*maxId);
    }
    if (minId) {
      res["MinId"] = boost::any(*minId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (receiveState) {
      res["ReceiveState"] = boost::any(*receiveState);
    }
    if (receiver) {
      res["Receiver"] = boost::any(*receiver);
    }
    if (renderState) {
      res["RenderState"] = boost::any(*renderState);
    }
    if (signName) {
      res["SignName"] = boost::any(*signName);
    }
    if (tmpCode) {
      res["TmpCode"] = boost::any(*tmpCode);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiSend") != m.end() && !m["ApiSend"].empty()) {
      apiSend = make_shared<long>(boost::any_cast<long>(m["ApiSend"]));
    }
    if (m.find("CardTemplateType") != m.end() && !m["CardTemplateType"].empty()) {
      cardTemplateType = make_shared<string>(boost::any_cast<string>(m["CardTemplateType"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("MaxId") != m.end() && !m["MaxId"].empty()) {
      maxId = make_shared<long>(boost::any_cast<long>(m["MaxId"]));
    }
    if (m.find("MinId") != m.end() && !m["MinId"].empty()) {
      minId = make_shared<long>(boost::any_cast<long>(m["MinId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ReceiveState") != m.end() && !m["ReceiveState"].empty()) {
      receiveState = make_shared<long>(boost::any_cast<long>(m["ReceiveState"]));
    }
    if (m.find("Receiver") != m.end() && !m["Receiver"].empty()) {
      receiver = make_shared<string>(boost::any_cast<string>(m["Receiver"]));
    }
    if (m.find("RenderState") != m.end() && !m["RenderState"].empty()) {
      renderState = make_shared<long>(boost::any_cast<long>(m["RenderState"]));
    }
    if (m.find("SignName") != m.end() && !m["SignName"].empty()) {
      signName = make_shared<string>(boost::any_cast<string>(m["SignName"]));
    }
    if (m.find("TmpCode") != m.end() && !m["TmpCode"].empty()) {
      tmpCode = make_shared<string>(boost::any_cast<string>(m["TmpCode"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~QueryCardSmsHistoryRequest() = default;
};
class QueryCardSmsHistoryResponseBodyModelRecords : public Darabonba::Model {
public:
  shared_ptr<long> acceptDate{};
  shared_ptr<long> apiSend{};
  shared_ptr<string> cardTemplateType{};
  shared_ptr<string> customTmpCode{};
  shared_ptr<string> description{};
  shared_ptr<string> fuuId{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<long> isSupport{};
  shared_ptr<string> outId{};
  shared_ptr<long> pid{};
  shared_ptr<long> receiveState{};
  shared_ptr<string> receiver{};
  shared_ptr<long> renderDate{};
  shared_ptr<long> renderState{};
  shared_ptr<string> shortUrl{};
  shared_ptr<string> signName{};
  shared_ptr<string> smsContent{};
  shared_ptr<string> suggestion{};
  shared_ptr<string> tmpCode{};
  shared_ptr<string> tmpId{};
  shared_ptr<long> tmpType{};
  shared_ptr<string> tmpTypeName{};

  QueryCardSmsHistoryResponseBodyModelRecords() {}

  explicit QueryCardSmsHistoryResponseBodyModelRecords(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptDate) {
      res["AcceptDate"] = boost::any(*acceptDate);
    }
    if (apiSend) {
      res["ApiSend"] = boost::any(*apiSend);
    }
    if (cardTemplateType) {
      res["CardTemplateType"] = boost::any(*cardTemplateType);
    }
    if (customTmpCode) {
      res["CustomTmpCode"] = boost::any(*customTmpCode);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (fuuId) {
      res["FuuId"] = boost::any(*fuuId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (isSupport) {
      res["IsSupport"] = boost::any(*isSupport);
    }
    if (outId) {
      res["OutId"] = boost::any(*outId);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (receiveState) {
      res["ReceiveState"] = boost::any(*receiveState);
    }
    if (receiver) {
      res["Receiver"] = boost::any(*receiver);
    }
    if (renderDate) {
      res["RenderDate"] = boost::any(*renderDate);
    }
    if (renderState) {
      res["RenderState"] = boost::any(*renderState);
    }
    if (shortUrl) {
      res["ShortUrl"] = boost::any(*shortUrl);
    }
    if (signName) {
      res["SignName"] = boost::any(*signName);
    }
    if (smsContent) {
      res["SmsContent"] = boost::any(*smsContent);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (tmpCode) {
      res["TmpCode"] = boost::any(*tmpCode);
    }
    if (tmpId) {
      res["TmpId"] = boost::any(*tmpId);
    }
    if (tmpType) {
      res["TmpType"] = boost::any(*tmpType);
    }
    if (tmpTypeName) {
      res["TmpTypeName"] = boost::any(*tmpTypeName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptDate") != m.end() && !m["AcceptDate"].empty()) {
      acceptDate = make_shared<long>(boost::any_cast<long>(m["AcceptDate"]));
    }
    if (m.find("ApiSend") != m.end() && !m["ApiSend"].empty()) {
      apiSend = make_shared<long>(boost::any_cast<long>(m["ApiSend"]));
    }
    if (m.find("CardTemplateType") != m.end() && !m["CardTemplateType"].empty()) {
      cardTemplateType = make_shared<string>(boost::any_cast<string>(m["CardTemplateType"]));
    }
    if (m.find("CustomTmpCode") != m.end() && !m["CustomTmpCode"].empty()) {
      customTmpCode = make_shared<string>(boost::any_cast<string>(m["CustomTmpCode"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("FuuId") != m.end() && !m["FuuId"].empty()) {
      fuuId = make_shared<string>(boost::any_cast<string>(m["FuuId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IsSupport") != m.end() && !m["IsSupport"].empty()) {
      isSupport = make_shared<long>(boost::any_cast<long>(m["IsSupport"]));
    }
    if (m.find("OutId") != m.end() && !m["OutId"].empty()) {
      outId = make_shared<string>(boost::any_cast<string>(m["OutId"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<long>(boost::any_cast<long>(m["Pid"]));
    }
    if (m.find("ReceiveState") != m.end() && !m["ReceiveState"].empty()) {
      receiveState = make_shared<long>(boost::any_cast<long>(m["ReceiveState"]));
    }
    if (m.find("Receiver") != m.end() && !m["Receiver"].empty()) {
      receiver = make_shared<string>(boost::any_cast<string>(m["Receiver"]));
    }
    if (m.find("RenderDate") != m.end() && !m["RenderDate"].empty()) {
      renderDate = make_shared<long>(boost::any_cast<long>(m["RenderDate"]));
    }
    if (m.find("RenderState") != m.end() && !m["RenderState"].empty()) {
      renderState = make_shared<long>(boost::any_cast<long>(m["RenderState"]));
    }
    if (m.find("ShortUrl") != m.end() && !m["ShortUrl"].empty()) {
      shortUrl = make_shared<string>(boost::any_cast<string>(m["ShortUrl"]));
    }
    if (m.find("SignName") != m.end() && !m["SignName"].empty()) {
      signName = make_shared<string>(boost::any_cast<string>(m["SignName"]));
    }
    if (m.find("SmsContent") != m.end() && !m["SmsContent"].empty()) {
      smsContent = make_shared<string>(boost::any_cast<string>(m["SmsContent"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("TmpCode") != m.end() && !m["TmpCode"].empty()) {
      tmpCode = make_shared<string>(boost::any_cast<string>(m["TmpCode"]));
    }
    if (m.find("TmpId") != m.end() && !m["TmpId"].empty()) {
      tmpId = make_shared<string>(boost::any_cast<string>(m["TmpId"]));
    }
    if (m.find("TmpType") != m.end() && !m["TmpType"].empty()) {
      tmpType = make_shared<long>(boost::any_cast<long>(m["TmpType"]));
    }
    if (m.find("TmpTypeName") != m.end() && !m["TmpTypeName"].empty()) {
      tmpTypeName = make_shared<string>(boost::any_cast<string>(m["TmpTypeName"]));
    }
  }


  virtual ~QueryCardSmsHistoryResponseBodyModelRecords() = default;
};
class QueryCardSmsHistoryResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<QueryCardSmsHistoryResponseBodyModelRecords>> records{};
  shared_ptr<long> totalCount{};

  QueryCardSmsHistoryResponseBodyModel() {}

  explicit QueryCardSmsHistoryResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (records) {
      vector<boost::any> temp1;
      for(auto item1:*records){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Records"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Records") != m.end() && !m["Records"].empty()) {
      if (typeid(vector<boost::any>) == m["Records"].type()) {
        vector<QueryCardSmsHistoryResponseBodyModelRecords> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Records"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryCardSmsHistoryResponseBodyModelRecords model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        records = make_shared<vector<QueryCardSmsHistoryResponseBodyModelRecords>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~QueryCardSmsHistoryResponseBodyModel() = default;
};
class QueryCardSmsHistoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryCardSmsHistoryResponseBodyModel> model{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryCardSmsHistoryResponseBody() {}

  explicit QueryCardSmsHistoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        QueryCardSmsHistoryResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<QueryCardSmsHistoryResponseBodyModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryCardSmsHistoryResponseBody() = default;
};
class QueryCardSmsHistoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryCardSmsHistoryResponseBody> body{};

  QueryCardSmsHistoryResponse() {}

  explicit QueryCardSmsHistoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryCardSmsHistoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryCardSmsHistoryResponseBody>(model1);
      }
    }
  }


  virtual ~QueryCardSmsHistoryResponse() = default;
};
class QueryCardSmsHistoryDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> id{};

  QueryCardSmsHistoryDetailRequest() {}

  explicit QueryCardSmsHistoryDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~QueryCardSmsHistoryDetailRequest() = default;
};
class QueryCardSmsHistoryDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> model{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryCardSmsHistoryDetailResponseBody() {}

  explicit QueryCardSmsHistoryDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryCardSmsHistoryDetailResponseBody() = default;
};
class QueryCardSmsHistoryDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryCardSmsHistoryDetailResponseBody> body{};

  QueryCardSmsHistoryDetailResponse() {}

  explicit QueryCardSmsHistoryDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryCardSmsHistoryDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryCardSmsHistoryDetailResponseBody>(model1);
      }
    }
  }


  virtual ~QueryCardSmsHistoryDetailResponse() = default;
};
class QueryCardSmsStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> customTmpCode{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sendDateEnd{};
  shared_ptr<string> sendDateStart{};
  shared_ptr<string> signName{};
  shared_ptr<string> tmpCode{};
  shared_ptr<string> tmpName{};

  QueryCardSmsStatisticsRequest() {}

  explicit QueryCardSmsStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customTmpCode) {
      res["CustomTmpCode"] = boost::any(*customTmpCode);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sendDateEnd) {
      res["SendDateEnd"] = boost::any(*sendDateEnd);
    }
    if (sendDateStart) {
      res["SendDateStart"] = boost::any(*sendDateStart);
    }
    if (signName) {
      res["SignName"] = boost::any(*signName);
    }
    if (tmpCode) {
      res["TmpCode"] = boost::any(*tmpCode);
    }
    if (tmpName) {
      res["TmpName"] = boost::any(*tmpName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomTmpCode") != m.end() && !m["CustomTmpCode"].empty()) {
      customTmpCode = make_shared<string>(boost::any_cast<string>(m["CustomTmpCode"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SendDateEnd") != m.end() && !m["SendDateEnd"].empty()) {
      sendDateEnd = make_shared<string>(boost::any_cast<string>(m["SendDateEnd"]));
    }
    if (m.find("SendDateStart") != m.end() && !m["SendDateStart"].empty()) {
      sendDateStart = make_shared<string>(boost::any_cast<string>(m["SendDateStart"]));
    }
    if (m.find("SignName") != m.end() && !m["SignName"].empty()) {
      signName = make_shared<string>(boost::any_cast<string>(m["SignName"]));
    }
    if (m.find("TmpCode") != m.end() && !m["TmpCode"].empty()) {
      tmpCode = make_shared<string>(boost::any_cast<string>(m["TmpCode"]));
    }
    if (m.find("TmpName") != m.end() && !m["TmpName"].empty()) {
      tmpName = make_shared<string>(boost::any_cast<string>(m["TmpName"]));
    }
  }


  virtual ~QueryCardSmsStatisticsRequest() = default;
};
class QueryCardSmsStatisticsResponseBodyModelRecords : public Darabonba::Model {
public:
  shared_ptr<long> renderSuccessTotal{};
  shared_ptr<string> sendDate{};
  shared_ptr<string> signName{};
  shared_ptr<string> tmpCode{};
  shared_ptr<string> tmpName{};
  shared_ptr<long> urlGenerateTotal{};

  QueryCardSmsStatisticsResponseBodyModelRecords() {}

  explicit QueryCardSmsStatisticsResponseBodyModelRecords(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (renderSuccessTotal) {
      res["RenderSuccessTotal"] = boost::any(*renderSuccessTotal);
    }
    if (sendDate) {
      res["SendDate"] = boost::any(*sendDate);
    }
    if (signName) {
      res["SignName"] = boost::any(*signName);
    }
    if (tmpCode) {
      res["TmpCode"] = boost::any(*tmpCode);
    }
    if (tmpName) {
      res["TmpName"] = boost::any(*tmpName);
    }
    if (urlGenerateTotal) {
      res["UrlGenerateTotal"] = boost::any(*urlGenerateTotal);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RenderSuccessTotal") != m.end() && !m["RenderSuccessTotal"].empty()) {
      renderSuccessTotal = make_shared<long>(boost::any_cast<long>(m["RenderSuccessTotal"]));
    }
    if (m.find("SendDate") != m.end() && !m["SendDate"].empty()) {
      sendDate = make_shared<string>(boost::any_cast<string>(m["SendDate"]));
    }
    if (m.find("SignName") != m.end() && !m["SignName"].empty()) {
      signName = make_shared<string>(boost::any_cast<string>(m["SignName"]));
    }
    if (m.find("TmpCode") != m.end() && !m["TmpCode"].empty()) {
      tmpCode = make_shared<string>(boost::any_cast<string>(m["TmpCode"]));
    }
    if (m.find("TmpName") != m.end() && !m["TmpName"].empty()) {
      tmpName = make_shared<string>(boost::any_cast<string>(m["TmpName"]));
    }
    if (m.find("UrlGenerateTotal") != m.end() && !m["UrlGenerateTotal"].empty()) {
      urlGenerateTotal = make_shared<long>(boost::any_cast<long>(m["UrlGenerateTotal"]));
    }
  }


  virtual ~QueryCardSmsStatisticsResponseBodyModelRecords() = default;
};
class QueryCardSmsStatisticsResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<QueryCardSmsStatisticsResponseBodyModelRecords>> records{};
  shared_ptr<long> totalCount{};

  QueryCardSmsStatisticsResponseBodyModel() {}

  explicit QueryCardSmsStatisticsResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (records) {
      vector<boost::any> temp1;
      for(auto item1:*records){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Records"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Records") != m.end() && !m["Records"].empty()) {
      if (typeid(vector<boost::any>) == m["Records"].type()) {
        vector<QueryCardSmsStatisticsResponseBodyModelRecords> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Records"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryCardSmsStatisticsResponseBodyModelRecords model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        records = make_shared<vector<QueryCardSmsStatisticsResponseBodyModelRecords>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~QueryCardSmsStatisticsResponseBodyModel() = default;
};
class QueryCardSmsStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryCardSmsStatisticsResponseBodyModel> model{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryCardSmsStatisticsResponseBody() {}

  explicit QueryCardSmsStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        QueryCardSmsStatisticsResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<QueryCardSmsStatisticsResponseBodyModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryCardSmsStatisticsResponseBody() = default;
};
class QueryCardSmsStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryCardSmsStatisticsResponseBody> body{};

  QueryCardSmsStatisticsResponse() {}

  explicit QueryCardSmsStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryCardSmsStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryCardSmsStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~QueryCardSmsStatisticsResponse() = default;
};
class QueryCardSmsStatisticsListRequest : public Darabonba::Model {
public:
  shared_ptr<string> customTmpCode{};
  shared_ptr<string> sendDateEnd{};
  shared_ptr<string> sendDateStart{};
  shared_ptr<string> signName{};
  shared_ptr<string> tmpCode{};
  shared_ptr<string> tmpName{};

  QueryCardSmsStatisticsListRequest() {}

  explicit QueryCardSmsStatisticsListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customTmpCode) {
      res["CustomTmpCode"] = boost::any(*customTmpCode);
    }
    if (sendDateEnd) {
      res["SendDateEnd"] = boost::any(*sendDateEnd);
    }
    if (sendDateStart) {
      res["SendDateStart"] = boost::any(*sendDateStart);
    }
    if (signName) {
      res["SignName"] = boost::any(*signName);
    }
    if (tmpCode) {
      res["TmpCode"] = boost::any(*tmpCode);
    }
    if (tmpName) {
      res["TmpName"] = boost::any(*tmpName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomTmpCode") != m.end() && !m["CustomTmpCode"].empty()) {
      customTmpCode = make_shared<string>(boost::any_cast<string>(m["CustomTmpCode"]));
    }
    if (m.find("SendDateEnd") != m.end() && !m["SendDateEnd"].empty()) {
      sendDateEnd = make_shared<string>(boost::any_cast<string>(m["SendDateEnd"]));
    }
    if (m.find("SendDateStart") != m.end() && !m["SendDateStart"].empty()) {
      sendDateStart = make_shared<string>(boost::any_cast<string>(m["SendDateStart"]));
    }
    if (m.find("SignName") != m.end() && !m["SignName"].empty()) {
      signName = make_shared<string>(boost::any_cast<string>(m["SignName"]));
    }
    if (m.find("TmpCode") != m.end() && !m["TmpCode"].empty()) {
      tmpCode = make_shared<string>(boost::any_cast<string>(m["TmpCode"]));
    }
    if (m.find("TmpName") != m.end() && !m["TmpName"].empty()) {
      tmpName = make_shared<string>(boost::any_cast<string>(m["TmpName"]));
    }
  }


  virtual ~QueryCardSmsStatisticsListRequest() = default;
};
class QueryCardSmsStatisticsListResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<long> renderSuccessTotal{};
  shared_ptr<string> sendDate{};
  shared_ptr<long> urlGenerateTotal{};

  QueryCardSmsStatisticsListResponseBodyModel() {}

  explicit QueryCardSmsStatisticsListResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (renderSuccessTotal) {
      res["RenderSuccessTotal"] = boost::any(*renderSuccessTotal);
    }
    if (sendDate) {
      res["SendDate"] = boost::any(*sendDate);
    }
    if (urlGenerateTotal) {
      res["UrlGenerateTotal"] = boost::any(*urlGenerateTotal);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RenderSuccessTotal") != m.end() && !m["RenderSuccessTotal"].empty()) {
      renderSuccessTotal = make_shared<long>(boost::any_cast<long>(m["RenderSuccessTotal"]));
    }
    if (m.find("SendDate") != m.end() && !m["SendDate"].empty()) {
      sendDate = make_shared<string>(boost::any_cast<string>(m["SendDate"]));
    }
    if (m.find("UrlGenerateTotal") != m.end() && !m["UrlGenerateTotal"].empty()) {
      urlGenerateTotal = make_shared<long>(boost::any_cast<long>(m["UrlGenerateTotal"]));
    }
  }


  virtual ~QueryCardSmsStatisticsListResponseBodyModel() = default;
};
class QueryCardSmsStatisticsListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<QueryCardSmsStatisticsListResponseBodyModel>> model{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryCardSmsStatisticsListResponseBody() {}

  explicit QueryCardSmsStatisticsListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (model) {
      vector<boost::any> temp1;
      for(auto item1:*model){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Model"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(vector<boost::any>) == m["Model"].type()) {
        vector<QueryCardSmsStatisticsListResponseBodyModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Model"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryCardSmsStatisticsListResponseBodyModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        model = make_shared<vector<QueryCardSmsStatisticsListResponseBodyModel>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryCardSmsStatisticsListResponseBody() = default;
};
class QueryCardSmsStatisticsListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryCardSmsStatisticsListResponseBody> body{};

  QueryCardSmsStatisticsListResponse() {}

  explicit QueryCardSmsStatisticsListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryCardSmsStatisticsListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryCardSmsStatisticsListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryCardSmsStatisticsListResponse() = default;
};
class QueryCardSmsStatisticsSendRequest : public Darabonba::Model {
public:
  shared_ptr<string> customTmpCode{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sendDateEnd{};
  shared_ptr<string> sendDateStart{};
  shared_ptr<string> signName{};
  shared_ptr<string> tmpCode{};

  QueryCardSmsStatisticsSendRequest() {}

  explicit QueryCardSmsStatisticsSendRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customTmpCode) {
      res["CustomTmpCode"] = boost::any(*customTmpCode);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sendDateEnd) {
      res["SendDateEnd"] = boost::any(*sendDateEnd);
    }
    if (sendDateStart) {
      res["SendDateStart"] = boost::any(*sendDateStart);
    }
    if (signName) {
      res["SignName"] = boost::any(*signName);
    }
    if (tmpCode) {
      res["TmpCode"] = boost::any(*tmpCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomTmpCode") != m.end() && !m["CustomTmpCode"].empty()) {
      customTmpCode = make_shared<string>(boost::any_cast<string>(m["CustomTmpCode"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SendDateEnd") != m.end() && !m["SendDateEnd"].empty()) {
      sendDateEnd = make_shared<string>(boost::any_cast<string>(m["SendDateEnd"]));
    }
    if (m.find("SendDateStart") != m.end() && !m["SendDateStart"].empty()) {
      sendDateStart = make_shared<string>(boost::any_cast<string>(m["SendDateStart"]));
    }
    if (m.find("SignName") != m.end() && !m["SignName"].empty()) {
      signName = make_shared<string>(boost::any_cast<string>(m["SignName"]));
    }
    if (m.find("TmpCode") != m.end() && !m["TmpCode"].empty()) {
      tmpCode = make_shared<string>(boost::any_cast<string>(m["TmpCode"]));
    }
  }


  virtual ~QueryCardSmsStatisticsSendRequest() = default;
};
class QueryCardSmsStatisticsSendResponseBodyModelRecords : public Darabonba::Model {
public:
  shared_ptr<string> customTmpCode{};
  shared_ptr<double> renderSuccessRate{};
  shared_ptr<long> renderSuccessTotal{};
  shared_ptr<string> sendDate{};
  shared_ptr<long> sendFailTotal{};
  shared_ptr<long> sendProcessTotal{};
  shared_ptr<double> sendSuccessRate{};
  shared_ptr<long> sendSuccessTotal{};
  shared_ptr<long> sendTotal{};
  shared_ptr<string> signName{};
  shared_ptr<double> supportRate{};
  shared_ptr<long> supportTotal{};
  shared_ptr<string> tmpCode{};

  QueryCardSmsStatisticsSendResponseBodyModelRecords() {}

  explicit QueryCardSmsStatisticsSendResponseBodyModelRecords(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customTmpCode) {
      res["CustomTmpCode"] = boost::any(*customTmpCode);
    }
    if (renderSuccessRate) {
      res["RenderSuccessRate"] = boost::any(*renderSuccessRate);
    }
    if (renderSuccessTotal) {
      res["RenderSuccessTotal"] = boost::any(*renderSuccessTotal);
    }
    if (sendDate) {
      res["SendDate"] = boost::any(*sendDate);
    }
    if (sendFailTotal) {
      res["SendFailTotal"] = boost::any(*sendFailTotal);
    }
    if (sendProcessTotal) {
      res["SendProcessTotal"] = boost::any(*sendProcessTotal);
    }
    if (sendSuccessRate) {
      res["SendSuccessRate"] = boost::any(*sendSuccessRate);
    }
    if (sendSuccessTotal) {
      res["SendSuccessTotal"] = boost::any(*sendSuccessTotal);
    }
    if (sendTotal) {
      res["SendTotal"] = boost::any(*sendTotal);
    }
    if (signName) {
      res["SignName"] = boost::any(*signName);
    }
    if (supportRate) {
      res["SupportRate"] = boost::any(*supportRate);
    }
    if (supportTotal) {
      res["SupportTotal"] = boost::any(*supportTotal);
    }
    if (tmpCode) {
      res["TmpCode"] = boost::any(*tmpCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomTmpCode") != m.end() && !m["CustomTmpCode"].empty()) {
      customTmpCode = make_shared<string>(boost::any_cast<string>(m["CustomTmpCode"]));
    }
    if (m.find("RenderSuccessRate") != m.end() && !m["RenderSuccessRate"].empty()) {
      renderSuccessRate = make_shared<double>(boost::any_cast<double>(m["RenderSuccessRate"]));
    }
    if (m.find("RenderSuccessTotal") != m.end() && !m["RenderSuccessTotal"].empty()) {
      renderSuccessTotal = make_shared<long>(boost::any_cast<long>(m["RenderSuccessTotal"]));
    }
    if (m.find("SendDate") != m.end() && !m["SendDate"].empty()) {
      sendDate = make_shared<string>(boost::any_cast<string>(m["SendDate"]));
    }
    if (m.find("SendFailTotal") != m.end() && !m["SendFailTotal"].empty()) {
      sendFailTotal = make_shared<long>(boost::any_cast<long>(m["SendFailTotal"]));
    }
    if (m.find("SendProcessTotal") != m.end() && !m["SendProcessTotal"].empty()) {
      sendProcessTotal = make_shared<long>(boost::any_cast<long>(m["SendProcessTotal"]));
    }
    if (m.find("SendSuccessRate") != m.end() && !m["SendSuccessRate"].empty()) {
      sendSuccessRate = make_shared<double>(boost::any_cast<double>(m["SendSuccessRate"]));
    }
    if (m.find("SendSuccessTotal") != m.end() && !m["SendSuccessTotal"].empty()) {
      sendSuccessTotal = make_shared<long>(boost::any_cast<long>(m["SendSuccessTotal"]));
    }
    if (m.find("SendTotal") != m.end() && !m["SendTotal"].empty()) {
      sendTotal = make_shared<long>(boost::any_cast<long>(m["SendTotal"]));
    }
    if (m.find("SignName") != m.end() && !m["SignName"].empty()) {
      signName = make_shared<string>(boost::any_cast<string>(m["SignName"]));
    }
    if (m.find("SupportRate") != m.end() && !m["SupportRate"].empty()) {
      supportRate = make_shared<double>(boost::any_cast<double>(m["SupportRate"]));
    }
    if (m.find("SupportTotal") != m.end() && !m["SupportTotal"].empty()) {
      supportTotal = make_shared<long>(boost::any_cast<long>(m["SupportTotal"]));
    }
    if (m.find("TmpCode") != m.end() && !m["TmpCode"].empty()) {
      tmpCode = make_shared<string>(boost::any_cast<string>(m["TmpCode"]));
    }
  }


  virtual ~QueryCardSmsStatisticsSendResponseBodyModelRecords() = default;
};
class QueryCardSmsStatisticsSendResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<QueryCardSmsStatisticsSendResponseBodyModelRecords>> records{};
  shared_ptr<long> totalCount{};

  QueryCardSmsStatisticsSendResponseBodyModel() {}

  explicit QueryCardSmsStatisticsSendResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (records) {
      vector<boost::any> temp1;
      for(auto item1:*records){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Records"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Records") != m.end() && !m["Records"].empty()) {
      if (typeid(vector<boost::any>) == m["Records"].type()) {
        vector<QueryCardSmsStatisticsSendResponseBodyModelRecords> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Records"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryCardSmsStatisticsSendResponseBodyModelRecords model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        records = make_shared<vector<QueryCardSmsStatisticsSendResponseBodyModelRecords>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~QueryCardSmsStatisticsSendResponseBodyModel() = default;
};
class QueryCardSmsStatisticsSendResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryCardSmsStatisticsSendResponseBodyModel> model{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryCardSmsStatisticsSendResponseBody() {}

  explicit QueryCardSmsStatisticsSendResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        QueryCardSmsStatisticsSendResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<QueryCardSmsStatisticsSendResponseBodyModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryCardSmsStatisticsSendResponseBody() = default;
};
class QueryCardSmsStatisticsSendResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryCardSmsStatisticsSendResponseBody> body{};

  QueryCardSmsStatisticsSendResponse() {}

  explicit QueryCardSmsStatisticsSendResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryCardSmsStatisticsSendResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryCardSmsStatisticsSendResponseBody>(model1);
      }
    }
  }


  virtual ~QueryCardSmsStatisticsSendResponse() = default;
};
class QueryCardSmsStatisticsSendListRequest : public Darabonba::Model {
public:
  shared_ptr<string> customTmpCode{};
  shared_ptr<string> sendDateEnd{};
  shared_ptr<string> sendDateStart{};
  shared_ptr<string> signName{};
  shared_ptr<string> tmpCode{};

  QueryCardSmsStatisticsSendListRequest() {}

  explicit QueryCardSmsStatisticsSendListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customTmpCode) {
      res["CustomTmpCode"] = boost::any(*customTmpCode);
    }
    if (sendDateEnd) {
      res["SendDateEnd"] = boost::any(*sendDateEnd);
    }
    if (sendDateStart) {
      res["SendDateStart"] = boost::any(*sendDateStart);
    }
    if (signName) {
      res["SignName"] = boost::any(*signName);
    }
    if (tmpCode) {
      res["TmpCode"] = boost::any(*tmpCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomTmpCode") != m.end() && !m["CustomTmpCode"].empty()) {
      customTmpCode = make_shared<string>(boost::any_cast<string>(m["CustomTmpCode"]));
    }
    if (m.find("SendDateEnd") != m.end() && !m["SendDateEnd"].empty()) {
      sendDateEnd = make_shared<string>(boost::any_cast<string>(m["SendDateEnd"]));
    }
    if (m.find("SendDateStart") != m.end() && !m["SendDateStart"].empty()) {
      sendDateStart = make_shared<string>(boost::any_cast<string>(m["SendDateStart"]));
    }
    if (m.find("SignName") != m.end() && !m["SignName"].empty()) {
      signName = make_shared<string>(boost::any_cast<string>(m["SignName"]));
    }
    if (m.find("TmpCode") != m.end() && !m["TmpCode"].empty()) {
      tmpCode = make_shared<string>(boost::any_cast<string>(m["TmpCode"]));
    }
  }


  virtual ~QueryCardSmsStatisticsSendListRequest() = default;
};
class QueryCardSmsStatisticsSendListResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<double> renderSuccessRate{};
  shared_ptr<long> renderSuccessTotal{};
  shared_ptr<string> sendDate{};
  shared_ptr<long> sendFailTotal{};
  shared_ptr<long> sendProcessTotal{};
  shared_ptr<double> sendSuccessRate{};
  shared_ptr<long> sendSuccessTotal{};
  shared_ptr<long> sendTotal{};
  shared_ptr<double> supportRate{};
  shared_ptr<long> supportTotal{};

  QueryCardSmsStatisticsSendListResponseBodyModel() {}

  explicit QueryCardSmsStatisticsSendListResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (renderSuccessRate) {
      res["RenderSuccessRate"] = boost::any(*renderSuccessRate);
    }
    if (renderSuccessTotal) {
      res["RenderSuccessTotal"] = boost::any(*renderSuccessTotal);
    }
    if (sendDate) {
      res["SendDate"] = boost::any(*sendDate);
    }
    if (sendFailTotal) {
      res["SendFailTotal"] = boost::any(*sendFailTotal);
    }
    if (sendProcessTotal) {
      res["SendProcessTotal"] = boost::any(*sendProcessTotal);
    }
    if (sendSuccessRate) {
      res["SendSuccessRate"] = boost::any(*sendSuccessRate);
    }
    if (sendSuccessTotal) {
      res["SendSuccessTotal"] = boost::any(*sendSuccessTotal);
    }
    if (sendTotal) {
      res["SendTotal"] = boost::any(*sendTotal);
    }
    if (supportRate) {
      res["SupportRate"] = boost::any(*supportRate);
    }
    if (supportTotal) {
      res["SupportTotal"] = boost::any(*supportTotal);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RenderSuccessRate") != m.end() && !m["RenderSuccessRate"].empty()) {
      renderSuccessRate = make_shared<double>(boost::any_cast<double>(m["RenderSuccessRate"]));
    }
    if (m.find("RenderSuccessTotal") != m.end() && !m["RenderSuccessTotal"].empty()) {
      renderSuccessTotal = make_shared<long>(boost::any_cast<long>(m["RenderSuccessTotal"]));
    }
    if (m.find("SendDate") != m.end() && !m["SendDate"].empty()) {
      sendDate = make_shared<string>(boost::any_cast<string>(m["SendDate"]));
    }
    if (m.find("SendFailTotal") != m.end() && !m["SendFailTotal"].empty()) {
      sendFailTotal = make_shared<long>(boost::any_cast<long>(m["SendFailTotal"]));
    }
    if (m.find("SendProcessTotal") != m.end() && !m["SendProcessTotal"].empty()) {
      sendProcessTotal = make_shared<long>(boost::any_cast<long>(m["SendProcessTotal"]));
    }
    if (m.find("SendSuccessRate") != m.end() && !m["SendSuccessRate"].empty()) {
      sendSuccessRate = make_shared<double>(boost::any_cast<double>(m["SendSuccessRate"]));
    }
    if (m.find("SendSuccessTotal") != m.end() && !m["SendSuccessTotal"].empty()) {
      sendSuccessTotal = make_shared<long>(boost::any_cast<long>(m["SendSuccessTotal"]));
    }
    if (m.find("SendTotal") != m.end() && !m["SendTotal"].empty()) {
      sendTotal = make_shared<long>(boost::any_cast<long>(m["SendTotal"]));
    }
    if (m.find("SupportRate") != m.end() && !m["SupportRate"].empty()) {
      supportRate = make_shared<double>(boost::any_cast<double>(m["SupportRate"]));
    }
    if (m.find("SupportTotal") != m.end() && !m["SupportTotal"].empty()) {
      supportTotal = make_shared<long>(boost::any_cast<long>(m["SupportTotal"]));
    }
  }


  virtual ~QueryCardSmsStatisticsSendListResponseBodyModel() = default;
};
class QueryCardSmsStatisticsSendListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<QueryCardSmsStatisticsSendListResponseBodyModel>> model{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryCardSmsStatisticsSendListResponseBody() {}

  explicit QueryCardSmsStatisticsSendListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (model) {
      vector<boost::any> temp1;
      for(auto item1:*model){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Model"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(vector<boost::any>) == m["Model"].type()) {
        vector<QueryCardSmsStatisticsSendListResponseBodyModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Model"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryCardSmsStatisticsSendListResponseBodyModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        model = make_shared<vector<QueryCardSmsStatisticsSendListResponseBodyModel>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryCardSmsStatisticsSendListResponseBody() = default;
};
class QueryCardSmsStatisticsSendListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryCardSmsStatisticsSendListResponseBody> body{};

  QueryCardSmsStatisticsSendListResponse() {}

  explicit QueryCardSmsStatisticsSendListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryCardSmsStatisticsSendListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryCardSmsStatisticsSendListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryCardSmsStatisticsSendListResponse() = default;
};
class QueryCommonCustInfoRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryCommonCustInfoRequest() {}

  explicit QueryCommonCustInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryCommonCustInfoRequest() = default;
};
class QueryCommonCustInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<string> data{};

  QueryCommonCustInfoResponseBody() {}

  explicit QueryCommonCustInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
  }


  virtual ~QueryCommonCustInfoResponseBody() = default;
};
class QueryCommonCustInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryCommonCustInfoResponseBody> body{};

  QueryCommonCustInfoResponse() {}

  explicit QueryCommonCustInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryCommonCustInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryCommonCustInfoResponseBody>(model1);
      }
    }
  }


  virtual ~QueryCommonCustInfoResponse() = default;
};
class QueryContactsListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryContactsListRequest() {}

  explicit QueryContactsListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryContactsListRequest() = default;
};
class QueryContactsListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<string> data{};

  QueryContactsListResponseBody() {}

  explicit QueryContactsListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
  }


  virtual ~QueryContactsListResponseBody() = default;
};
class QueryContactsListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryContactsListResponseBody> body{};

  QueryContactsListResponse() {}

  explicit QueryContactsListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryContactsListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryContactsListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryContactsListResponse() = default;
};
class QueryContactsListNewRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryContactsListNewRequest() {}

  explicit QueryContactsListNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryContactsListNewRequest() = default;
};
class QueryContactsListNewResponseBodyList : public Darabonba::Model {
public:
  shared_ptr<string> email{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<long> openPkgWarning{};
  shared_ptr<long> openPreventBrushWarning{};
  shared_ptr<long> openSendWarning{};
  shared_ptr<string> phone{};
  shared_ptr<long> receiveSignTemplateAuditResult{};

  QueryContactsListNewResponseBodyList() {}

  explicit QueryContactsListNewResponseBodyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (openPkgWarning) {
      res["OpenPkgWarning"] = boost::any(*openPkgWarning);
    }
    if (openPreventBrushWarning) {
      res["OpenPreventBrushWarning"] = boost::any(*openPreventBrushWarning);
    }
    if (openSendWarning) {
      res["OpenSendWarning"] = boost::any(*openSendWarning);
    }
    if (phone) {
      res["Phone"] = boost::any(*phone);
    }
    if (receiveSignTemplateAuditResult) {
      res["ReceiveSignTemplateAuditResult"] = boost::any(*receiveSignTemplateAuditResult);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OpenPkgWarning") != m.end() && !m["OpenPkgWarning"].empty()) {
      openPkgWarning = make_shared<long>(boost::any_cast<long>(m["OpenPkgWarning"]));
    }
    if (m.find("OpenPreventBrushWarning") != m.end() && !m["OpenPreventBrushWarning"].empty()) {
      openPreventBrushWarning = make_shared<long>(boost::any_cast<long>(m["OpenPreventBrushWarning"]));
    }
    if (m.find("OpenSendWarning") != m.end() && !m["OpenSendWarning"].empty()) {
      openSendWarning = make_shared<long>(boost::any_cast<long>(m["OpenSendWarning"]));
    }
    if (m.find("Phone") != m.end() && !m["Phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["Phone"]));
    }
    if (m.find("ReceiveSignTemplateAuditResult") != m.end() && !m["ReceiveSignTemplateAuditResult"].empty()) {
      receiveSignTemplateAuditResult = make_shared<long>(boost::any_cast<long>(m["ReceiveSignTemplateAuditResult"]));
    }
  }


  virtual ~QueryContactsListNewResponseBodyList() = default;
};
class QueryContactsListNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<QueryContactsListNewResponseBodyList>> list{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  QueryContactsListNewResponseBody() {}

  explicit QueryContactsListNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<QueryContactsListNewResponseBodyList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryContactsListNewResponseBodyList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<QueryContactsListNewResponseBodyList>>(expect1);
      }
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QueryContactsListNewResponseBody() = default;
};
class QueryContactsListNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryContactsListNewResponseBody> body{};

  QueryContactsListNewResponse() {}

  explicit QueryContactsListNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryContactsListNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryContactsListNewResponseBody>(model1);
      }
    }
  }


  virtual ~QueryContactsListNewResponse() = default;
};
class QueryDailyBillInfoLeafNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> billCycle{};
  shared_ptr<string> itemId{};
  shared_ptr<string> itemName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> subjectItemId{};

  QueryDailyBillInfoLeafNewRequest() {}

  explicit QueryDailyBillInfoLeafNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billCycle) {
      res["BillCycle"] = boost::any(*billCycle);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (itemName) {
      res["ItemName"] = boost::any(*itemName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (subjectItemId) {
      res["SubjectItemId"] = boost::any(*subjectItemId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BillCycle") != m.end() && !m["BillCycle"].empty()) {
      billCycle = make_shared<string>(boost::any_cast<string>(m["BillCycle"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<string>(boost::any_cast<string>(m["ItemId"]));
    }
    if (m.find("ItemName") != m.end() && !m["ItemName"].empty()) {
      itemName = make_shared<string>(boost::any_cast<string>(m["ItemName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SubjectItemId") != m.end() && !m["SubjectItemId"].empty()) {
      subjectItemId = make_shared<string>(boost::any_cast<string>(m["SubjectItemId"]));
    }
  }


  virtual ~QueryDailyBillInfoLeafNewRequest() = default;
};
class QueryDailyBillInfoLeafNewResponseBodyListDailyBillDetailInfoDTO : public Darabonba::Model {
public:
  shared_ptr<long> addCount{};
  shared_ptr<string> addDate{};
  shared_ptr<string> addUnit{};
  shared_ptr<string> billAmount{};
  shared_ptr<string> detailItemName{};
  shared_ptr<string> singlePrice{};

  QueryDailyBillInfoLeafNewResponseBodyListDailyBillDetailInfoDTO() {}

  explicit QueryDailyBillInfoLeafNewResponseBodyListDailyBillDetailInfoDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addCount) {
      res["AddCount"] = boost::any(*addCount);
    }
    if (addDate) {
      res["AddDate"] = boost::any(*addDate);
    }
    if (addUnit) {
      res["AddUnit"] = boost::any(*addUnit);
    }
    if (billAmount) {
      res["BillAmount"] = boost::any(*billAmount);
    }
    if (detailItemName) {
      res["DetailItemName"] = boost::any(*detailItemName);
    }
    if (singlePrice) {
      res["SinglePrice"] = boost::any(*singlePrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddCount") != m.end() && !m["AddCount"].empty()) {
      addCount = make_shared<long>(boost::any_cast<long>(m["AddCount"]));
    }
    if (m.find("AddDate") != m.end() && !m["AddDate"].empty()) {
      addDate = make_shared<string>(boost::any_cast<string>(m["AddDate"]));
    }
    if (m.find("AddUnit") != m.end() && !m["AddUnit"].empty()) {
      addUnit = make_shared<string>(boost::any_cast<string>(m["AddUnit"]));
    }
    if (m.find("BillAmount") != m.end() && !m["BillAmount"].empty()) {
      billAmount = make_shared<string>(boost::any_cast<string>(m["BillAmount"]));
    }
    if (m.find("DetailItemName") != m.end() && !m["DetailItemName"].empty()) {
      detailItemName = make_shared<string>(boost::any_cast<string>(m["DetailItemName"]));
    }
    if (m.find("SinglePrice") != m.end() && !m["SinglePrice"].empty()) {
      singlePrice = make_shared<string>(boost::any_cast<string>(m["SinglePrice"]));
    }
  }


  virtual ~QueryDailyBillInfoLeafNewResponseBodyListDailyBillDetailInfoDTO() = default;
};
class QueryDailyBillInfoLeafNewResponseBodyList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDailyBillInfoLeafNewResponseBodyListDailyBillDetailInfoDTO>> dailyBillDetailInfoDTO{};

  QueryDailyBillInfoLeafNewResponseBodyList() {}

  explicit QueryDailyBillInfoLeafNewResponseBodyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dailyBillDetailInfoDTO) {
      vector<boost::any> temp1;
      for(auto item1:*dailyBillDetailInfoDTO){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DailyBillDetailInfoDTO"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DailyBillDetailInfoDTO") != m.end() && !m["DailyBillDetailInfoDTO"].empty()) {
      if (typeid(vector<boost::any>) == m["DailyBillDetailInfoDTO"].type()) {
        vector<QueryDailyBillInfoLeafNewResponseBodyListDailyBillDetailInfoDTO> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DailyBillDetailInfoDTO"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDailyBillInfoLeafNewResponseBodyListDailyBillDetailInfoDTO model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dailyBillDetailInfoDTO = make_shared<vector<QueryDailyBillInfoLeafNewResponseBodyListDailyBillDetailInfoDTO>>(expect1);
      }
    }
  }


  virtual ~QueryDailyBillInfoLeafNewResponseBodyList() = default;
};
class QueryDailyBillInfoLeafNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryDailyBillInfoLeafNewResponseBodyList> list{};
  shared_ptr<string> requestId{};

  QueryDailyBillInfoLeafNewResponseBody() {}

  explicit QueryDailyBillInfoLeafNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QueryDailyBillInfoLeafNewResponseBodyList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QueryDailyBillInfoLeafNewResponseBodyList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryDailyBillInfoLeafNewResponseBody() = default;
};
class QueryDailyBillInfoLeafNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryDailyBillInfoLeafNewResponseBody> body{};

  QueryDailyBillInfoLeafNewResponse() {}

  explicit QueryDailyBillInfoLeafNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDailyBillInfoLeafNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDailyBillInfoLeafNewResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDailyBillInfoLeafNewResponse() = default;
};
class QueryDigitalTemplateDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> auditState{};
  shared_ptr<string> bizType{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> templateCode{};
  shared_ptr<string> templateName{};

  QueryDigitalTemplateDetailRequest() {}

  explicit QueryDigitalTemplateDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (auditState) {
      res["AuditState"] = boost::any(*auditState);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuditState") != m.end() && !m["AuditState"].empty()) {
      auditState = make_shared<string>(boost::any_cast<string>(m["AuditState"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
  }


  virtual ~QueryDigitalTemplateDetailRequest() = default;
};
class QueryDigitalTemplateDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<string> data{};

  QueryDigitalTemplateDetailResponseBody() {}

  explicit QueryDigitalTemplateDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
  }


  virtual ~QueryDigitalTemplateDetailResponseBody() = default;
};
class QueryDigitalTemplateDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryDigitalTemplateDetailResponseBody> body{};

  QueryDigitalTemplateDetailResponse() {}

  explicit QueryDigitalTemplateDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDigitalTemplateDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDigitalTemplateDetailResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDigitalTemplateDetailResponse() = default;
};
class QueryDigitalTemplateDetailNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> auditState{};
  shared_ptr<string> bizType{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> templateCode{};
  shared_ptr<string> templateName{};

  QueryDigitalTemplateDetailNewRequest() {}

  explicit QueryDigitalTemplateDetailNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (auditState) {
      res["AuditState"] = boost::any(*auditState);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuditState") != m.end() && !m["AuditState"].empty()) {
      auditState = make_shared<string>(boost::any_cast<string>(m["AuditState"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
  }


  virtual ~QueryDigitalTemplateDetailNewRequest() = default;
};
class QueryDigitalTemplateDetailNewResponseBodyOssKeys : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ossKey{};

  QueryDigitalTemplateDetailNewResponseBodyOssKeys() {}

  explicit QueryDigitalTemplateDetailNewResponseBodyOssKeys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ossKey) {
      res["OssKey"] = boost::any(*ossKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OssKey") != m.end() && !m["OssKey"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OssKey"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OssKey"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ossKey = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryDigitalTemplateDetailNewResponseBodyOssKeys() = default;
};
class QueryDigitalTemplateDetailNewResponseBodyTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  QueryDigitalTemplateDetailNewResponseBodyTagsTag() {}

  explicit QueryDigitalTemplateDetailNewResponseBodyTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~QueryDigitalTemplateDetailNewResponseBodyTagsTag() = default;
};
class QueryDigitalTemplateDetailNewResponseBodyTags : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDigitalTemplateDetailNewResponseBodyTagsTag>> tag{};

  QueryDigitalTemplateDetailNewResponseBodyTags() {}

  explicit QueryDigitalTemplateDetailNewResponseBodyTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<QueryDigitalTemplateDetailNewResponseBodyTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDigitalTemplateDetailNewResponseBodyTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<QueryDigitalTemplateDetailNewResponseBodyTagsTag>>(expect1);
      }
    }
  }


  virtual ~QueryDigitalTemplateDetailNewResponseBodyTags() = default;
};
class QueryDigitalTemplateDetailNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> auditInfo{};
  shared_ptr<string> auditRemarkInfo{};
  shared_ptr<string> auditState{};
  shared_ptr<string> bizType{};
  shared_ptr<string> expireDateStr{};
  shared_ptr<string> gmtCreateStr{};
  shared_ptr<string> id{};
  shared_ptr<bool> isAnyParam{};
  shared_ptr<bool> isDefaultTemplate{};
  shared_ptr<bool> isRecently{};
  shared_ptr<string> orderId{};
  shared_ptr<QueryDigitalTemplateDetailNewResponseBodyOssKeys> ossKeys{};
  shared_ptr<string> passErrType{};
  shared_ptr<string> remark{};
  shared_ptr<string> requestId{};
  shared_ptr<long> signType{};
  shared_ptr<string> smsContent{};
  shared_ptr<string> supportVendor{};
  shared_ptr<QueryDigitalTemplateDetailNewResponseBodyTags> tags{};
  shared_ptr<string> templateCode{};
  shared_ptr<string> templateContent{};
  shared_ptr<string> templateName{};
  shared_ptr<string> templateRule{};

  QueryDigitalTemplateDetailNewResponseBody() {}

  explicit QueryDigitalTemplateDetailNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (auditInfo) {
      res["AuditInfo"] = boost::any(*auditInfo);
    }
    if (auditRemarkInfo) {
      res["AuditRemarkInfo"] = boost::any(*auditRemarkInfo);
    }
    if (auditState) {
      res["AuditState"] = boost::any(*auditState);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (expireDateStr) {
      res["ExpireDateStr"] = boost::any(*expireDateStr);
    }
    if (gmtCreateStr) {
      res["GmtCreateStr"] = boost::any(*gmtCreateStr);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (isAnyParam) {
      res["IsAnyParam"] = boost::any(*isAnyParam);
    }
    if (isDefaultTemplate) {
      res["IsDefaultTemplate"] = boost::any(*isDefaultTemplate);
    }
    if (isRecently) {
      res["IsRecently"] = boost::any(*isRecently);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (ossKeys) {
      res["OssKeys"] = ossKeys ? boost::any(ossKeys->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (passErrType) {
      res["PassErrType"] = boost::any(*passErrType);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (signType) {
      res["SignType"] = boost::any(*signType);
    }
    if (smsContent) {
      res["SmsContent"] = boost::any(*smsContent);
    }
    if (supportVendor) {
      res["SupportVendor"] = boost::any(*supportVendor);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    if (templateContent) {
      res["TemplateContent"] = boost::any(*templateContent);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (templateRule) {
      res["TemplateRule"] = boost::any(*templateRule);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuditInfo") != m.end() && !m["AuditInfo"].empty()) {
      auditInfo = make_shared<string>(boost::any_cast<string>(m["AuditInfo"]));
    }
    if (m.find("AuditRemarkInfo") != m.end() && !m["AuditRemarkInfo"].empty()) {
      auditRemarkInfo = make_shared<string>(boost::any_cast<string>(m["AuditRemarkInfo"]));
    }
    if (m.find("AuditState") != m.end() && !m["AuditState"].empty()) {
      auditState = make_shared<string>(boost::any_cast<string>(m["AuditState"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("ExpireDateStr") != m.end() && !m["ExpireDateStr"].empty()) {
      expireDateStr = make_shared<string>(boost::any_cast<string>(m["ExpireDateStr"]));
    }
    if (m.find("GmtCreateStr") != m.end() && !m["GmtCreateStr"].empty()) {
      gmtCreateStr = make_shared<string>(boost::any_cast<string>(m["GmtCreateStr"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("IsAnyParam") != m.end() && !m["IsAnyParam"].empty()) {
      isAnyParam = make_shared<bool>(boost::any_cast<bool>(m["IsAnyParam"]));
    }
    if (m.find("IsDefaultTemplate") != m.end() && !m["IsDefaultTemplate"].empty()) {
      isDefaultTemplate = make_shared<bool>(boost::any_cast<bool>(m["IsDefaultTemplate"]));
    }
    if (m.find("IsRecently") != m.end() && !m["IsRecently"].empty()) {
      isRecently = make_shared<bool>(boost::any_cast<bool>(m["IsRecently"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("OssKeys") != m.end() && !m["OssKeys"].empty()) {
      if (typeid(map<string, boost::any>) == m["OssKeys"].type()) {
        QueryDigitalTemplateDetailNewResponseBodyOssKeys model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OssKeys"]));
        ossKeys = make_shared<QueryDigitalTemplateDetailNewResponseBodyOssKeys>(model1);
      }
    }
    if (m.find("PassErrType") != m.end() && !m["PassErrType"].empty()) {
      passErrType = make_shared<string>(boost::any_cast<string>(m["PassErrType"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SignType") != m.end() && !m["SignType"].empty()) {
      signType = make_shared<long>(boost::any_cast<long>(m["SignType"]));
    }
    if (m.find("SmsContent") != m.end() && !m["SmsContent"].empty()) {
      smsContent = make_shared<string>(boost::any_cast<string>(m["SmsContent"]));
    }
    if (m.find("SupportVendor") != m.end() && !m["SupportVendor"].empty()) {
      supportVendor = make_shared<string>(boost::any_cast<string>(m["SupportVendor"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        QueryDigitalTemplateDetailNewResponseBodyTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<QueryDigitalTemplateDetailNewResponseBodyTags>(model1);
      }
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
    if (m.find("TemplateContent") != m.end() && !m["TemplateContent"].empty()) {
      templateContent = make_shared<string>(boost::any_cast<string>(m["TemplateContent"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("TemplateRule") != m.end() && !m["TemplateRule"].empty()) {
      templateRule = make_shared<string>(boost::any_cast<string>(m["TemplateRule"]));
    }
  }


  virtual ~QueryDigitalTemplateDetailNewResponseBody() = default;
};
class QueryDigitalTemplateDetailNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryDigitalTemplateDetailNewResponseBody> body{};

  QueryDigitalTemplateDetailNewResponse() {}

  explicit QueryDigitalTemplateDetailNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDigitalTemplateDetailNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDigitalTemplateDetailNewResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDigitalTemplateDetailNewResponse() = default;
};
class QueryDigitalTemplateLastRangeRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizType{};
  shared_ptr<long> limit{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> templateName{};

  QueryDigitalTemplateLastRangeRequest() {}

  explicit QueryDigitalTemplateLastRangeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (limit) {
      res["Limit"] = boost::any(*limit);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("Limit") != m.end() && !m["Limit"].empty()) {
      limit = make_shared<long>(boost::any_cast<long>(m["Limit"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
  }


  virtual ~QueryDigitalTemplateLastRangeRequest() = default;
};
class QueryDigitalTemplateLastRangeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<string> data{};

  QueryDigitalTemplateLastRangeResponseBody() {}

  explicit QueryDigitalTemplateLastRangeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
  }


  virtual ~QueryDigitalTemplateLastRangeResponseBody() = default;
};
class QueryDigitalTemplateLastRangeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryDigitalTemplateLastRangeResponseBody> body{};

  QueryDigitalTemplateLastRangeResponse() {}

  explicit QueryDigitalTemplateLastRangeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDigitalTemplateLastRangeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDigitalTemplateLastRangeResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDigitalTemplateLastRangeResponse() = default;
};
class QueryDigitalTemplateLastRangeNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> auditState{};
  shared_ptr<string> bizType{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> prodType{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> templateName{};

  QueryDigitalTemplateLastRangeNewRequest() {}

  explicit QueryDigitalTemplateLastRangeNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (auditState) {
      res["AuditState"] = boost::any(*auditState);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (prodType) {
      res["ProdType"] = boost::any(*prodType);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuditState") != m.end() && !m["AuditState"].empty()) {
      auditState = make_shared<string>(boost::any_cast<string>(m["AuditState"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ProdType") != m.end() && !m["ProdType"].empty()) {
      prodType = make_shared<string>(boost::any_cast<string>(m["ProdType"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
  }


  virtual ~QueryDigitalTemplateLastRangeNewRequest() = default;
};
class QueryDigitalTemplateLastRangeNewResponseBodyListSmsTemplate : public Darabonba::Model {
public:
  shared_ptr<string> auditInfo{};
  shared_ptr<string> auditRemarkInfo{};
  shared_ptr<string> auditState{};
  shared_ptr<string> bizType{};
  shared_ptr<string> expireDateStr{};
  shared_ptr<string> gmtCreateStr{};
  shared_ptr<string> id{};
  shared_ptr<bool> isAnyParam{};
  shared_ptr<bool> isDefaultTemplate{};
  shared_ptr<bool> isRecently{};
  shared_ptr<string> orderId{};
  shared_ptr<string> passErrType{};
  shared_ptr<string> remark{};
  shared_ptr<long> signType{};
  shared_ptr<string> smsContent{};
  shared_ptr<string> supportVendor{};
  shared_ptr<string> templateCode{};
  shared_ptr<string> templateContent{};
  shared_ptr<string> templateName{};
  shared_ptr<string> templateRule{};

  QueryDigitalTemplateLastRangeNewResponseBodyListSmsTemplate() {}

  explicit QueryDigitalTemplateLastRangeNewResponseBodyListSmsTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (auditInfo) {
      res["AuditInfo"] = boost::any(*auditInfo);
    }
    if (auditRemarkInfo) {
      res["AuditRemarkInfo"] = boost::any(*auditRemarkInfo);
    }
    if (auditState) {
      res["AuditState"] = boost::any(*auditState);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (expireDateStr) {
      res["ExpireDateStr"] = boost::any(*expireDateStr);
    }
    if (gmtCreateStr) {
      res["GmtCreateStr"] = boost::any(*gmtCreateStr);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (isAnyParam) {
      res["IsAnyParam"] = boost::any(*isAnyParam);
    }
    if (isDefaultTemplate) {
      res["IsDefaultTemplate"] = boost::any(*isDefaultTemplate);
    }
    if (isRecently) {
      res["IsRecently"] = boost::any(*isRecently);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (passErrType) {
      res["PassErrType"] = boost::any(*passErrType);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (signType) {
      res["SignType"] = boost::any(*signType);
    }
    if (smsContent) {
      res["SmsContent"] = boost::any(*smsContent);
    }
    if (supportVendor) {
      res["SupportVendor"] = boost::any(*supportVendor);
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    if (templateContent) {
      res["TemplateContent"] = boost::any(*templateContent);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (templateRule) {
      res["TemplateRule"] = boost::any(*templateRule);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuditInfo") != m.end() && !m["AuditInfo"].empty()) {
      auditInfo = make_shared<string>(boost::any_cast<string>(m["AuditInfo"]));
    }
    if (m.find("AuditRemarkInfo") != m.end() && !m["AuditRemarkInfo"].empty()) {
      auditRemarkInfo = make_shared<string>(boost::any_cast<string>(m["AuditRemarkInfo"]));
    }
    if (m.find("AuditState") != m.end() && !m["AuditState"].empty()) {
      auditState = make_shared<string>(boost::any_cast<string>(m["AuditState"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("ExpireDateStr") != m.end() && !m["ExpireDateStr"].empty()) {
      expireDateStr = make_shared<string>(boost::any_cast<string>(m["ExpireDateStr"]));
    }
    if (m.find("GmtCreateStr") != m.end() && !m["GmtCreateStr"].empty()) {
      gmtCreateStr = make_shared<string>(boost::any_cast<string>(m["GmtCreateStr"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("IsAnyParam") != m.end() && !m["IsAnyParam"].empty()) {
      isAnyParam = make_shared<bool>(boost::any_cast<bool>(m["IsAnyParam"]));
    }
    if (m.find("IsDefaultTemplate") != m.end() && !m["IsDefaultTemplate"].empty()) {
      isDefaultTemplate = make_shared<bool>(boost::any_cast<bool>(m["IsDefaultTemplate"]));
    }
    if (m.find("IsRecently") != m.end() && !m["IsRecently"].empty()) {
      isRecently = make_shared<bool>(boost::any_cast<bool>(m["IsRecently"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("PassErrType") != m.end() && !m["PassErrType"].empty()) {
      passErrType = make_shared<string>(boost::any_cast<string>(m["PassErrType"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("SignType") != m.end() && !m["SignType"].empty()) {
      signType = make_shared<long>(boost::any_cast<long>(m["SignType"]));
    }
    if (m.find("SmsContent") != m.end() && !m["SmsContent"].empty()) {
      smsContent = make_shared<string>(boost::any_cast<string>(m["SmsContent"]));
    }
    if (m.find("SupportVendor") != m.end() && !m["SupportVendor"].empty()) {
      supportVendor = make_shared<string>(boost::any_cast<string>(m["SupportVendor"]));
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
    if (m.find("TemplateContent") != m.end() && !m["TemplateContent"].empty()) {
      templateContent = make_shared<string>(boost::any_cast<string>(m["TemplateContent"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("TemplateRule") != m.end() && !m["TemplateRule"].empty()) {
      templateRule = make_shared<string>(boost::any_cast<string>(m["TemplateRule"]));
    }
  }


  virtual ~QueryDigitalTemplateLastRangeNewResponseBodyListSmsTemplate() = default;
};
class QueryDigitalTemplateLastRangeNewResponseBodyList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDigitalTemplateLastRangeNewResponseBodyListSmsTemplate>> smsTemplate{};

  QueryDigitalTemplateLastRangeNewResponseBodyList() {}

  explicit QueryDigitalTemplateLastRangeNewResponseBodyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (smsTemplate) {
      vector<boost::any> temp1;
      for(auto item1:*smsTemplate){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SmsTemplate"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SmsTemplate") != m.end() && !m["SmsTemplate"].empty()) {
      if (typeid(vector<boost::any>) == m["SmsTemplate"].type()) {
        vector<QueryDigitalTemplateLastRangeNewResponseBodyListSmsTemplate> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SmsTemplate"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDigitalTemplateLastRangeNewResponseBodyListSmsTemplate model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        smsTemplate = make_shared<vector<QueryDigitalTemplateLastRangeNewResponseBodyListSmsTemplate>>(expect1);
      }
    }
  }


  virtual ~QueryDigitalTemplateLastRangeNewResponseBodyList() = default;
};
class QueryDigitalTemplateLastRangeNewResponseBodyTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  QueryDigitalTemplateLastRangeNewResponseBodyTagsTag() {}

  explicit QueryDigitalTemplateLastRangeNewResponseBodyTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~QueryDigitalTemplateLastRangeNewResponseBodyTagsTag() = default;
};
class QueryDigitalTemplateLastRangeNewResponseBodyTags : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDigitalTemplateLastRangeNewResponseBodyTagsTag>> tag{};

  QueryDigitalTemplateLastRangeNewResponseBodyTags() {}

  explicit QueryDigitalTemplateLastRangeNewResponseBodyTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<QueryDigitalTemplateLastRangeNewResponseBodyTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDigitalTemplateLastRangeNewResponseBodyTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<QueryDigitalTemplateLastRangeNewResponseBodyTagsTag>>(expect1);
      }
    }
  }


  virtual ~QueryDigitalTemplateLastRangeNewResponseBodyTags() = default;
};
class QueryDigitalTemplateLastRangeNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryDigitalTemplateLastRangeNewResponseBodyList> list{};
  shared_ptr<string> requestId{};
  shared_ptr<QueryDigitalTemplateLastRangeNewResponseBodyTags> tags{};

  QueryDigitalTemplateLastRangeNewResponseBody() {}

  explicit QueryDigitalTemplateLastRangeNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QueryDigitalTemplateLastRangeNewResponseBodyList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QueryDigitalTemplateLastRangeNewResponseBodyList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        QueryDigitalTemplateLastRangeNewResponseBodyTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<QueryDigitalTemplateLastRangeNewResponseBodyTags>(model1);
      }
    }
  }


  virtual ~QueryDigitalTemplateLastRangeNewResponseBody() = default;
};
class QueryDigitalTemplateLastRangeNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryDigitalTemplateLastRangeNewResponseBody> body{};

  QueryDigitalTemplateLastRangeNewResponse() {}

  explicit QueryDigitalTemplateLastRangeNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDigitalTemplateLastRangeNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDigitalTemplateLastRangeNewResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDigitalTemplateLastRangeNewResponse() = default;
};
class QueryDigitalTemplatePageListRequest : public Darabonba::Model {
public:
  shared_ptr<string> auditState{};
  shared_ptr<string> bizType{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> templateCode{};
  shared_ptr<string> templateName{};

  QueryDigitalTemplatePageListRequest() {}

  explicit QueryDigitalTemplatePageListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (auditState) {
      res["AuditState"] = boost::any(*auditState);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuditState") != m.end() && !m["AuditState"].empty()) {
      auditState = make_shared<string>(boost::any_cast<string>(m["AuditState"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
  }


  virtual ~QueryDigitalTemplatePageListRequest() = default;
};
class QueryDigitalTemplatePageListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<string> data{};

  QueryDigitalTemplatePageListResponseBody() {}

  explicit QueryDigitalTemplatePageListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
  }


  virtual ~QueryDigitalTemplatePageListResponseBody() = default;
};
class QueryDigitalTemplatePageListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryDigitalTemplatePageListResponseBody> body{};

  QueryDigitalTemplatePageListResponse() {}

  explicit QueryDigitalTemplatePageListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDigitalTemplatePageListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDigitalTemplatePageListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDigitalTemplatePageListResponse() = default;
};
class QueryDigitalTemplatePageListNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> auditState{};
  shared_ptr<string> bizType{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> templateCode{};
  shared_ptr<string> templateName{};

  QueryDigitalTemplatePageListNewRequest() {}

  explicit QueryDigitalTemplatePageListNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (auditState) {
      res["AuditState"] = boost::any(*auditState);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuditState") != m.end() && !m["AuditState"].empty()) {
      auditState = make_shared<string>(boost::any_cast<string>(m["AuditState"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
  }


  virtual ~QueryDigitalTemplatePageListNewRequest() = default;
};
class QueryDigitalTemplatePageListNewResponseBodyListSmsTemplateTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  QueryDigitalTemplatePageListNewResponseBodyListSmsTemplateTagsTag() {}

  explicit QueryDigitalTemplatePageListNewResponseBodyListSmsTemplateTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~QueryDigitalTemplatePageListNewResponseBodyListSmsTemplateTagsTag() = default;
};
class QueryDigitalTemplatePageListNewResponseBodyListSmsTemplateTags : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDigitalTemplatePageListNewResponseBodyListSmsTemplateTagsTag>> tag{};

  QueryDigitalTemplatePageListNewResponseBodyListSmsTemplateTags() {}

  explicit QueryDigitalTemplatePageListNewResponseBodyListSmsTemplateTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<QueryDigitalTemplatePageListNewResponseBodyListSmsTemplateTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDigitalTemplatePageListNewResponseBodyListSmsTemplateTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<QueryDigitalTemplatePageListNewResponseBodyListSmsTemplateTagsTag>>(expect1);
      }
    }
  }


  virtual ~QueryDigitalTemplatePageListNewResponseBodyListSmsTemplateTags() = default;
};
class QueryDigitalTemplatePageListNewResponseBodyListSmsTemplate : public Darabonba::Model {
public:
  shared_ptr<string> auditInfo{};
  shared_ptr<string> auditRemarkInfo{};
  shared_ptr<string> auditState{};
  shared_ptr<string> bizType{};
  shared_ptr<string> expireDateStr{};
  shared_ptr<string> gmtCreateStr{};
  shared_ptr<string> id{};
  shared_ptr<bool> isAnyParam{};
  shared_ptr<bool> isDefaultTemplate{};
  shared_ptr<bool> isRecently{};
  shared_ptr<string> orderId{};
  shared_ptr<string> passErrType{};
  shared_ptr<string> remark{};
  shared_ptr<long> signType{};
  shared_ptr<string> smsContent{};
  shared_ptr<string> supportVendor{};
  shared_ptr<QueryDigitalTemplatePageListNewResponseBodyListSmsTemplateTags> tags{};
  shared_ptr<string> templateCode{};
  shared_ptr<string> templateContent{};
  shared_ptr<string> templateName{};
  shared_ptr<string> templateRule{};

  QueryDigitalTemplatePageListNewResponseBodyListSmsTemplate() {}

  explicit QueryDigitalTemplatePageListNewResponseBodyListSmsTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (auditInfo) {
      res["AuditInfo"] = boost::any(*auditInfo);
    }
    if (auditRemarkInfo) {
      res["AuditRemarkInfo"] = boost::any(*auditRemarkInfo);
    }
    if (auditState) {
      res["AuditState"] = boost::any(*auditState);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (expireDateStr) {
      res["ExpireDateStr"] = boost::any(*expireDateStr);
    }
    if (gmtCreateStr) {
      res["GmtCreateStr"] = boost::any(*gmtCreateStr);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (isAnyParam) {
      res["IsAnyParam"] = boost::any(*isAnyParam);
    }
    if (isDefaultTemplate) {
      res["IsDefaultTemplate"] = boost::any(*isDefaultTemplate);
    }
    if (isRecently) {
      res["IsRecently"] = boost::any(*isRecently);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (passErrType) {
      res["PassErrType"] = boost::any(*passErrType);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (signType) {
      res["SignType"] = boost::any(*signType);
    }
    if (smsContent) {
      res["SmsContent"] = boost::any(*smsContent);
    }
    if (supportVendor) {
      res["SupportVendor"] = boost::any(*supportVendor);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    if (templateContent) {
      res["TemplateContent"] = boost::any(*templateContent);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (templateRule) {
      res["TemplateRule"] = boost::any(*templateRule);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuditInfo") != m.end() && !m["AuditInfo"].empty()) {
      auditInfo = make_shared<string>(boost::any_cast<string>(m["AuditInfo"]));
    }
    if (m.find("AuditRemarkInfo") != m.end() && !m["AuditRemarkInfo"].empty()) {
      auditRemarkInfo = make_shared<string>(boost::any_cast<string>(m["AuditRemarkInfo"]));
    }
    if (m.find("AuditState") != m.end() && !m["AuditState"].empty()) {
      auditState = make_shared<string>(boost::any_cast<string>(m["AuditState"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("ExpireDateStr") != m.end() && !m["ExpireDateStr"].empty()) {
      expireDateStr = make_shared<string>(boost::any_cast<string>(m["ExpireDateStr"]));
    }
    if (m.find("GmtCreateStr") != m.end() && !m["GmtCreateStr"].empty()) {
      gmtCreateStr = make_shared<string>(boost::any_cast<string>(m["GmtCreateStr"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("IsAnyParam") != m.end() && !m["IsAnyParam"].empty()) {
      isAnyParam = make_shared<bool>(boost::any_cast<bool>(m["IsAnyParam"]));
    }
    if (m.find("IsDefaultTemplate") != m.end() && !m["IsDefaultTemplate"].empty()) {
      isDefaultTemplate = make_shared<bool>(boost::any_cast<bool>(m["IsDefaultTemplate"]));
    }
    if (m.find("IsRecently") != m.end() && !m["IsRecently"].empty()) {
      isRecently = make_shared<bool>(boost::any_cast<bool>(m["IsRecently"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("PassErrType") != m.end() && !m["PassErrType"].empty()) {
      passErrType = make_shared<string>(boost::any_cast<string>(m["PassErrType"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("SignType") != m.end() && !m["SignType"].empty()) {
      signType = make_shared<long>(boost::any_cast<long>(m["SignType"]));
    }
    if (m.find("SmsContent") != m.end() && !m["SmsContent"].empty()) {
      smsContent = make_shared<string>(boost::any_cast<string>(m["SmsContent"]));
    }
    if (m.find("SupportVendor") != m.end() && !m["SupportVendor"].empty()) {
      supportVendor = make_shared<string>(boost::any_cast<string>(m["SupportVendor"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        QueryDigitalTemplatePageListNewResponseBodyListSmsTemplateTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<QueryDigitalTemplatePageListNewResponseBodyListSmsTemplateTags>(model1);
      }
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
    if (m.find("TemplateContent") != m.end() && !m["TemplateContent"].empty()) {
      templateContent = make_shared<string>(boost::any_cast<string>(m["TemplateContent"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("TemplateRule") != m.end() && !m["TemplateRule"].empty()) {
      templateRule = make_shared<string>(boost::any_cast<string>(m["TemplateRule"]));
    }
  }


  virtual ~QueryDigitalTemplatePageListNewResponseBodyListSmsTemplate() = default;
};
class QueryDigitalTemplatePageListNewResponseBodyList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDigitalTemplatePageListNewResponseBodyListSmsTemplate>> smsTemplate{};

  QueryDigitalTemplatePageListNewResponseBodyList() {}

  explicit QueryDigitalTemplatePageListNewResponseBodyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (smsTemplate) {
      vector<boost::any> temp1;
      for(auto item1:*smsTemplate){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SmsTemplate"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SmsTemplate") != m.end() && !m["SmsTemplate"].empty()) {
      if (typeid(vector<boost::any>) == m["SmsTemplate"].type()) {
        vector<QueryDigitalTemplatePageListNewResponseBodyListSmsTemplate> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SmsTemplate"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDigitalTemplatePageListNewResponseBodyListSmsTemplate model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        smsTemplate = make_shared<vector<QueryDigitalTemplatePageListNewResponseBodyListSmsTemplate>>(expect1);
      }
    }
  }


  virtual ~QueryDigitalTemplatePageListNewResponseBodyList() = default;
};
class QueryDigitalTemplatePageListNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryDigitalTemplatePageListNewResponseBodyList> list{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  QueryDigitalTemplatePageListNewResponseBody() {}

  explicit QueryDigitalTemplatePageListNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QueryDigitalTemplatePageListNewResponseBodyList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QueryDigitalTemplatePageListNewResponseBodyList>(model1);
      }
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QueryDigitalTemplatePageListNewResponseBody() = default;
};
class QueryDigitalTemplatePageListNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryDigitalTemplatePageListNewResponseBody> body{};

  QueryDigitalTemplatePageListNewResponse() {}

  explicit QueryDigitalTemplatePageListNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDigitalTemplatePageListNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDigitalTemplatePageListNewResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDigitalTemplatePageListNewResponse() = default;
};
class QueryDomainListRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNo{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryDomainListRequest() {}

  explicit QueryDomainListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryDomainListRequest() = default;
};
class QueryDomainListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  QueryDomainListResponseBody() {}

  explicit QueryDomainListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryDomainListResponseBody() = default;
};
class QueryDomainListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryDomainListResponseBody> body{};

  QueryDomainListResponse() {}

  explicit QueryDomainListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDomainListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDomainListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDomainListResponse() = default;
};
class QueryDomainListNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNo{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryDomainListNewRequest() {}

  explicit QueryDomainListNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryDomainListNewRequest() = default;
};
class QueryDomainListNewResponseBodyList : public Darabonba::Model {
public:
  shared_ptr<long> auditStatus{};
  shared_ptr<string> domain{};
  shared_ptr<string> gmtCreate{};

  QueryDomainListNewResponseBodyList() {}

  explicit QueryDomainListNewResponseBodyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (auditStatus) {
      res["AuditStatus"] = boost::any(*auditStatus);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuditStatus") != m.end() && !m["AuditStatus"].empty()) {
      auditStatus = make_shared<long>(boost::any_cast<long>(m["AuditStatus"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
  }


  virtual ~QueryDomainListNewResponseBodyList() = default;
};
class QueryDomainListNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDomainListNewResponseBodyList>> list{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  QueryDomainListNewResponseBody() {}

  explicit QueryDomainListNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<QueryDomainListNewResponseBodyList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDomainListNewResponseBodyList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<QueryDomainListNewResponseBodyList>>(expect1);
      }
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QueryDomainListNewResponseBody() = default;
};
class QueryDomainListNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryDomainListNewResponseBody> body{};

  QueryDomainListNewResponse() {}

  explicit QueryDomainListNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDomainListNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDomainListNewResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDomainListNewResponse() = default;
};
class QueryExportSendRecordListNewRequest : public Darabonba::Model {
public:
  shared_ptr<long> applyStatus{};
  shared_ptr<string> bizType{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryExportSendRecordListNewRequest() {}

  explicit QueryExportSendRecordListNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyStatus) {
      res["ApplyStatus"] = boost::any(*applyStatus);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplyStatus") != m.end() && !m["ApplyStatus"].empty()) {
      applyStatus = make_shared<long>(boost::any_cast<long>(m["ApplyStatus"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryExportSendRecordListNewRequest() = default;
};
class QueryExportSendRecordListNewResponseBodyListFcFileUpInsResponse : public Darabonba::Model {
public:
  shared_ptr<string> fileFeature{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> handlerStatus{};
  shared_ptr<long> id{};

  QueryExportSendRecordListNewResponseBodyListFcFileUpInsResponse() {}

  explicit QueryExportSendRecordListNewResponseBodyListFcFileUpInsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileFeature) {
      res["FileFeature"] = boost::any(*fileFeature);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (handlerStatus) {
      res["HandlerStatus"] = boost::any(*handlerStatus);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileFeature") != m.end() && !m["FileFeature"].empty()) {
      fileFeature = make_shared<string>(boost::any_cast<string>(m["FileFeature"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("HandlerStatus") != m.end() && !m["HandlerStatus"].empty()) {
      handlerStatus = make_shared<long>(boost::any_cast<long>(m["HandlerStatus"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~QueryExportSendRecordListNewResponseBodyListFcFileUpInsResponse() = default;
};
class QueryExportSendRecordListNewResponseBodyList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryExportSendRecordListNewResponseBodyListFcFileUpInsResponse>> fcFileUpInsResponse{};

  QueryExportSendRecordListNewResponseBodyList() {}

  explicit QueryExportSendRecordListNewResponseBodyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fcFileUpInsResponse) {
      vector<boost::any> temp1;
      for(auto item1:*fcFileUpInsResponse){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FcFileUpInsResponse"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FcFileUpInsResponse") != m.end() && !m["FcFileUpInsResponse"].empty()) {
      if (typeid(vector<boost::any>) == m["FcFileUpInsResponse"].type()) {
        vector<QueryExportSendRecordListNewResponseBodyListFcFileUpInsResponse> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FcFileUpInsResponse"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryExportSendRecordListNewResponseBodyListFcFileUpInsResponse model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fcFileUpInsResponse = make_shared<vector<QueryExportSendRecordListNewResponseBodyListFcFileUpInsResponse>>(expect1);
      }
    }
  }


  virtual ~QueryExportSendRecordListNewResponseBodyList() = default;
};
class QueryExportSendRecordListNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryExportSendRecordListNewResponseBodyList> list{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  QueryExportSendRecordListNewResponseBody() {}

  explicit QueryExportSendRecordListNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QueryExportSendRecordListNewResponseBodyList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QueryExportSendRecordListNewResponseBodyList>(model1);
      }
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QueryExportSendRecordListNewResponseBody() = default;
};
class QueryExportSendRecordListNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryExportSendRecordListNewResponseBody> body{};

  QueryExportSendRecordListNewResponse() {}

  explicit QueryExportSendRecordListNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryExportSendRecordListNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryExportSendRecordListNewResponseBody>(model1);
      }
    }
  }


  virtual ~QueryExportSendRecordListNewResponse() = default;
};
class QueryFailDetailDownloadRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> status{};
  shared_ptr<long> taskId{};
  shared_ptr<long> taskInstanceId{};

  QueryFailDetailDownloadRequest() {}

  explicit QueryFailDetailDownloadRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskInstanceId) {
      res["TaskInstanceId"] = boost::any(*taskInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("TaskInstanceId") != m.end() && !m["TaskInstanceId"].empty()) {
      taskInstanceId = make_shared<long>(boost::any_cast<long>(m["TaskInstanceId"]));
    }
  }


  virtual ~QueryFailDetailDownloadRequest() = default;
};
class QueryFailDetailDownloadResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<string> data{};

  QueryFailDetailDownloadResponseBody() {}

  explicit QueryFailDetailDownloadResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
  }


  virtual ~QueryFailDetailDownloadResponseBody() = default;
};
class QueryFailDetailDownloadResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryFailDetailDownloadResponseBody> body{};

  QueryFailDetailDownloadResponse() {}

  explicit QueryFailDetailDownloadResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryFailDetailDownloadResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryFailDetailDownloadResponseBody>(model1);
      }
    }
  }


  virtual ~QueryFailDetailDownloadResponse() = default;
};
class QueryFailDetailDownloadNewRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> status{};
  shared_ptr<long> taskId{};
  shared_ptr<long> taskInstanceId{};

  QueryFailDetailDownloadNewRequest() {}

  explicit QueryFailDetailDownloadNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskInstanceId) {
      res["TaskInstanceId"] = boost::any(*taskInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("TaskInstanceId") != m.end() && !m["TaskInstanceId"].empty()) {
      taskInstanceId = make_shared<long>(boost::any_cast<long>(m["TaskInstanceId"]));
    }
  }


  virtual ~QueryFailDetailDownloadNewRequest() = default;
};
class QueryFailDetailDownloadNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  QueryFailDetailDownloadNewResponseBody() {}

  explicit QueryFailDetailDownloadNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~QueryFailDetailDownloadNewResponseBody() = default;
};
class QueryFailDetailDownloadNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryFailDetailDownloadNewResponseBody> body{};

  QueryFailDetailDownloadNewResponse() {}

  explicit QueryFailDetailDownloadNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryFailDetailDownloadNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryFailDetailDownloadNewResponseBody>(model1);
      }
    }
  }


  virtual ~QueryFailDetailDownloadNewResponse() = default;
};
class QueryFlowLimitRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryFlowLimitRequest() {}

  explicit QueryFlowLimitRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryFlowLimitRequest() = default;
};
class QueryFlowLimitResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<string> data{};

  QueryFlowLimitResponseBody() {}

  explicit QueryFlowLimitResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
  }


  virtual ~QueryFlowLimitResponseBody() = default;
};
class QueryFlowLimitResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryFlowLimitResponseBody> body{};

  QueryFlowLimitResponse() {}

  explicit QueryFlowLimitResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryFlowLimitResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryFlowLimitResponseBody>(model1);
      }
    }
  }


  virtual ~QueryFlowLimitResponse() = default;
};
class QueryFlowLimitNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizType{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryFlowLimitNewRequest() {}

  explicit QueryFlowLimitNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryFlowLimitNewRequest() = default;
};
class QueryFlowLimitNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> dailyLimit{};
  shared_ptr<long> hourLimit{};
  shared_ptr<long> minuteLimit{};
  shared_ptr<string> requestId{};

  QueryFlowLimitNewResponseBody() {}

  explicit QueryFlowLimitNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dailyLimit) {
      res["DailyLimit"] = boost::any(*dailyLimit);
    }
    if (hourLimit) {
      res["HourLimit"] = boost::any(*hourLimit);
    }
    if (minuteLimit) {
      res["MinuteLimit"] = boost::any(*minuteLimit);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DailyLimit") != m.end() && !m["DailyLimit"].empty()) {
      dailyLimit = make_shared<long>(boost::any_cast<long>(m["DailyLimit"]));
    }
    if (m.find("HourLimit") != m.end() && !m["HourLimit"].empty()) {
      hourLimit = make_shared<long>(boost::any_cast<long>(m["HourLimit"]));
    }
    if (m.find("MinuteLimit") != m.end() && !m["MinuteLimit"].empty()) {
      minuteLimit = make_shared<long>(boost::any_cast<long>(m["MinuteLimit"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryFlowLimitNewResponseBody() = default;
};
class QueryFlowLimitNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryFlowLimitNewResponseBody> body{};

  QueryFlowLimitNewResponse() {}

  explicit QueryFlowLimitNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryFlowLimitNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryFlowLimitNewResponseBody>(model1);
      }
    }
  }


  virtual ~QueryFlowLimitNewResponse() = default;
};
class QueryIndexColRecordRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizType{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> status{};
  shared_ptr<long> taskId{};
  shared_ptr<long> taskInstanceId{};

  QueryIndexColRecordRequest() {}

  explicit QueryIndexColRecordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskInstanceId) {
      res["TaskInstanceId"] = boost::any(*taskInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("TaskInstanceId") != m.end() && !m["TaskInstanceId"].empty()) {
      taskInstanceId = make_shared<long>(boost::any_cast<long>(m["TaskInstanceId"]));
    }
  }


  virtual ~QueryIndexColRecordRequest() = default;
};
class QueryIndexColRecordResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<string> data{};

  QueryIndexColRecordResponseBody() {}

  explicit QueryIndexColRecordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
  }


  virtual ~QueryIndexColRecordResponseBody() = default;
};
class QueryIndexColRecordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryIndexColRecordResponseBody> body{};

  QueryIndexColRecordResponse() {}

  explicit QueryIndexColRecordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryIndexColRecordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryIndexColRecordResponseBody>(model1);
      }
    }
  }


  virtual ~QueryIndexColRecordResponse() = default;
};
class QueryLearningStatusNewRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> type{};

  QueryLearningStatusNewRequest() {}

  explicit QueryLearningStatusNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~QueryLearningStatusNewRequest() = default;
};
class QueryLearningStatusNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> learningStatus{};
  shared_ptr<string> requestId{};

  QueryLearningStatusNewResponseBody() {}

  explicit QueryLearningStatusNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (learningStatus) {
      res["LearningStatus"] = boost::any(*learningStatus);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LearningStatus") != m.end() && !m["LearningStatus"].empty()) {
      learningStatus = make_shared<string>(boost::any_cast<string>(m["LearningStatus"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryLearningStatusNewResponseBody() = default;
};
class QueryLearningStatusNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryLearningStatusNewResponseBody> body{};

  QueryLearningStatusNewResponse() {}

  explicit QueryLearningStatusNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryLearningStatusNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryLearningStatusNewResponseBody>(model1);
      }
    }
  }


  virtual ~QueryLearningStatusNewResponse() = default;
};
class QueryMarketingAssistantStatusRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryMarketingAssistantStatusRequest() {}

  explicit QueryMarketingAssistantStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryMarketingAssistantStatusRequest() = default;
};
class QueryMarketingAssistantStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  QueryMarketingAssistantStatusResponseBody() {}

  explicit QueryMarketingAssistantStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryMarketingAssistantStatusResponseBody() = default;
};
class QueryMarketingAssistantStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMarketingAssistantStatusResponseBody> body{};

  QueryMarketingAssistantStatusResponse() {}

  explicit QueryMarketingAssistantStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMarketingAssistantStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMarketingAssistantStatusResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMarketingAssistantStatusResponse() = default;
};
class QueryMessageCallbackNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizType{};
  shared_ptr<string> callbackUrl{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryMessageCallbackNewRequest() {}

  explicit QueryMessageCallbackNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (callbackUrl) {
      res["CallbackUrl"] = boost::any(*callbackUrl);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("CallbackUrl") != m.end() && !m["CallbackUrl"].empty()) {
      callbackUrl = make_shared<string>(boost::any_cast<string>(m["CallbackUrl"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryMessageCallbackNewRequest() = default;
};
class QueryMessageCallbackNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> aiccsCallMidRecordCallbackUrl{};
  shared_ptr<string> aiccsCallRecordCallbackUrl{};
  shared_ptr<string> aiccsSentRecordCallbackUrl{};
  shared_ptr<string> artcCdrReportCallBackUrl{};
  shared_ptr<string> artcTempStatusReportCallBackUrl{};
  shared_ptr<string> cardDyncResCallbackUrl{};
  shared_ptr<string> cardTemplateCallBackUrl{};
  shared_ptr<string> cardVerderCallBackUrl{};
  shared_ptr<string> dcdpCallbackUrl{};
  shared_ptr<string> digitSmsTemplateCallBackUrl{};
  shared_ptr<bool> globeSmsReportCallback{};
  shared_ptr<string> globeSmsReportCallbackUrl{};
  shared_ptr<bool> isAiccsCallMidRecord{};
  shared_ptr<bool> isAiccsCallRecord{};
  shared_ptr<bool> isAiccsSentRecord{};
  shared_ptr<bool> isArtcCdrReportCallBack{};
  shared_ptr<bool> isArtcTempStatusReportCallBack{};
  shared_ptr<bool> isDcdpCallback{};
  shared_ptr<bool> isDigitSmsTemplateCallBack{};
  shared_ptr<bool> isGlobeSmsReportCallback{};
  shared_ptr<bool> isOpened{};
  shared_ptr<bool> isSecretReportMessageCallback{};
  shared_ptr<bool> isSecretSmsMessageCallback{};
  shared_ptr<bool> isSignReportCallback{};
  shared_ptr<bool> isSmartCallAsrCallBack{};
  shared_ptr<bool> isSmsReportMessageCallback{};
  shared_ptr<bool> isSmsUpMessageCallback{};
  shared_ptr<bool> isTemplateReportCallback{};
  shared_ptr<bool> isVoiceAsrCallBack{};
  shared_ptr<bool> isVoiceCallMidStateCallBack{};
  shared_ptr<bool> isVoiceCallRecordCallBack{};
  shared_ptr<bool> isVoiceRecordingCallBack{};
  shared_ptr<string> reportCallbackUrl{};
  shared_ptr<string> requestId{};
  shared_ptr<string> secretCallbackUrl{};
  shared_ptr<string> secretSmsCallbackUrl{};
  shared_ptr<string> shortLinkCallBackUrl{};
  shared_ptr<string> signReportCallbackUrl{};
  shared_ptr<string> smartCallAsrCallBackUrl{};
  shared_ptr<string> templateReportCallbackUrl{};
  shared_ptr<string> upCallbackUrl{};
  shared_ptr<string> voiceAsrCallBackUrl{};
  shared_ptr<string> voiceCallMidStateCallBackUrl{};
  shared_ptr<string> voiceCallRecordCallBackUrl{};
  shared_ptr<string> voiceRecordingCallBackUrl{};

  QueryMessageCallbackNewResponseBody() {}

  explicit QueryMessageCallbackNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aiccsCallMidRecordCallbackUrl) {
      res["AiccsCallMidRecordCallbackUrl"] = boost::any(*aiccsCallMidRecordCallbackUrl);
    }
    if (aiccsCallRecordCallbackUrl) {
      res["AiccsCallRecordCallbackUrl"] = boost::any(*aiccsCallRecordCallbackUrl);
    }
    if (aiccsSentRecordCallbackUrl) {
      res["AiccsSentRecordCallbackUrl"] = boost::any(*aiccsSentRecordCallbackUrl);
    }
    if (artcCdrReportCallBackUrl) {
      res["ArtcCdrReportCallBackUrl"] = boost::any(*artcCdrReportCallBackUrl);
    }
    if (artcTempStatusReportCallBackUrl) {
      res["ArtcTempStatusReportCallBackUrl"] = boost::any(*artcTempStatusReportCallBackUrl);
    }
    if (cardDyncResCallbackUrl) {
      res["CardDyncResCallbackUrl"] = boost::any(*cardDyncResCallbackUrl);
    }
    if (cardTemplateCallBackUrl) {
      res["CardTemplateCallBackUrl"] = boost::any(*cardTemplateCallBackUrl);
    }
    if (cardVerderCallBackUrl) {
      res["CardVerderCallBackUrl"] = boost::any(*cardVerderCallBackUrl);
    }
    if (dcdpCallbackUrl) {
      res["DcdpCallbackUrl"] = boost::any(*dcdpCallbackUrl);
    }
    if (digitSmsTemplateCallBackUrl) {
      res["DigitSmsTemplateCallBackUrl"] = boost::any(*digitSmsTemplateCallBackUrl);
    }
    if (globeSmsReportCallback) {
      res["GlobeSmsReportCallback"] = boost::any(*globeSmsReportCallback);
    }
    if (globeSmsReportCallbackUrl) {
      res["GlobeSmsReportCallbackUrl"] = boost::any(*globeSmsReportCallbackUrl);
    }
    if (isAiccsCallMidRecord) {
      res["IsAiccsCallMidRecord"] = boost::any(*isAiccsCallMidRecord);
    }
    if (isAiccsCallRecord) {
      res["IsAiccsCallRecord"] = boost::any(*isAiccsCallRecord);
    }
    if (isAiccsSentRecord) {
      res["IsAiccsSentRecord"] = boost::any(*isAiccsSentRecord);
    }
    if (isArtcCdrReportCallBack) {
      res["IsArtcCdrReportCallBack"] = boost::any(*isArtcCdrReportCallBack);
    }
    if (isArtcTempStatusReportCallBack) {
      res["IsArtcTempStatusReportCallBack"] = boost::any(*isArtcTempStatusReportCallBack);
    }
    if (isDcdpCallback) {
      res["IsDcdpCallback"] = boost::any(*isDcdpCallback);
    }
    if (isDigitSmsTemplateCallBack) {
      res["IsDigitSmsTemplateCallBack"] = boost::any(*isDigitSmsTemplateCallBack);
    }
    if (isGlobeSmsReportCallback) {
      res["IsGlobeSmsReportCallback"] = boost::any(*isGlobeSmsReportCallback);
    }
    if (isOpened) {
      res["IsOpened"] = boost::any(*isOpened);
    }
    if (isSecretReportMessageCallback) {
      res["IsSecretReportMessageCallback"] = boost::any(*isSecretReportMessageCallback);
    }
    if (isSecretSmsMessageCallback) {
      res["IsSecretSmsMessageCallback"] = boost::any(*isSecretSmsMessageCallback);
    }
    if (isSignReportCallback) {
      res["IsSignReportCallback"] = boost::any(*isSignReportCallback);
    }
    if (isSmartCallAsrCallBack) {
      res["IsSmartCallAsrCallBack"] = boost::any(*isSmartCallAsrCallBack);
    }
    if (isSmsReportMessageCallback) {
      res["IsSmsReportMessageCallback"] = boost::any(*isSmsReportMessageCallback);
    }
    if (isSmsUpMessageCallback) {
      res["IsSmsUpMessageCallback"] = boost::any(*isSmsUpMessageCallback);
    }
    if (isTemplateReportCallback) {
      res["IsTemplateReportCallback"] = boost::any(*isTemplateReportCallback);
    }
    if (isVoiceAsrCallBack) {
      res["IsVoiceAsrCallBack"] = boost::any(*isVoiceAsrCallBack);
    }
    if (isVoiceCallMidStateCallBack) {
      res["IsVoiceCallMidStateCallBack"] = boost::any(*isVoiceCallMidStateCallBack);
    }
    if (isVoiceCallRecordCallBack) {
      res["IsVoiceCallRecordCallBack"] = boost::any(*isVoiceCallRecordCallBack);
    }
    if (isVoiceRecordingCallBack) {
      res["IsVoiceRecordingCallBack"] = boost::any(*isVoiceRecordingCallBack);
    }
    if (reportCallbackUrl) {
      res["ReportCallbackUrl"] = boost::any(*reportCallbackUrl);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (secretCallbackUrl) {
      res["SecretCallbackUrl"] = boost::any(*secretCallbackUrl);
    }
    if (secretSmsCallbackUrl) {
      res["SecretSmsCallbackUrl"] = boost::any(*secretSmsCallbackUrl);
    }
    if (shortLinkCallBackUrl) {
      res["ShortLinkCallBackUrl"] = boost::any(*shortLinkCallBackUrl);
    }
    if (signReportCallbackUrl) {
      res["SignReportCallbackUrl"] = boost::any(*signReportCallbackUrl);
    }
    if (smartCallAsrCallBackUrl) {
      res["SmartCallAsrCallBackUrl"] = boost::any(*smartCallAsrCallBackUrl);
    }
    if (templateReportCallbackUrl) {
      res["TemplateReportCallbackUrl"] = boost::any(*templateReportCallbackUrl);
    }
    if (upCallbackUrl) {
      res["UpCallbackUrl"] = boost::any(*upCallbackUrl);
    }
    if (voiceAsrCallBackUrl) {
      res["VoiceAsrCallBackUrl"] = boost::any(*voiceAsrCallBackUrl);
    }
    if (voiceCallMidStateCallBackUrl) {
      res["VoiceCallMidStateCallBackUrl"] = boost::any(*voiceCallMidStateCallBackUrl);
    }
    if (voiceCallRecordCallBackUrl) {
      res["VoiceCallRecordCallBackUrl"] = boost::any(*voiceCallRecordCallBackUrl);
    }
    if (voiceRecordingCallBackUrl) {
      res["VoiceRecordingCallBackUrl"] = boost::any(*voiceRecordingCallBackUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AiccsCallMidRecordCallbackUrl") != m.end() && !m["AiccsCallMidRecordCallbackUrl"].empty()) {
      aiccsCallMidRecordCallbackUrl = make_shared<string>(boost::any_cast<string>(m["AiccsCallMidRecordCallbackUrl"]));
    }
    if (m.find("AiccsCallRecordCallbackUrl") != m.end() && !m["AiccsCallRecordCallbackUrl"].empty()) {
      aiccsCallRecordCallbackUrl = make_shared<string>(boost::any_cast<string>(m["AiccsCallRecordCallbackUrl"]));
    }
    if (m.find("AiccsSentRecordCallbackUrl") != m.end() && !m["AiccsSentRecordCallbackUrl"].empty()) {
      aiccsSentRecordCallbackUrl = make_shared<string>(boost::any_cast<string>(m["AiccsSentRecordCallbackUrl"]));
    }
    if (m.find("ArtcCdrReportCallBackUrl") != m.end() && !m["ArtcCdrReportCallBackUrl"].empty()) {
      artcCdrReportCallBackUrl = make_shared<string>(boost::any_cast<string>(m["ArtcCdrReportCallBackUrl"]));
    }
    if (m.find("ArtcTempStatusReportCallBackUrl") != m.end() && !m["ArtcTempStatusReportCallBackUrl"].empty()) {
      artcTempStatusReportCallBackUrl = make_shared<string>(boost::any_cast<string>(m["ArtcTempStatusReportCallBackUrl"]));
    }
    if (m.find("CardDyncResCallbackUrl") != m.end() && !m["CardDyncResCallbackUrl"].empty()) {
      cardDyncResCallbackUrl = make_shared<string>(boost::any_cast<string>(m["CardDyncResCallbackUrl"]));
    }
    if (m.find("CardTemplateCallBackUrl") != m.end() && !m["CardTemplateCallBackUrl"].empty()) {
      cardTemplateCallBackUrl = make_shared<string>(boost::any_cast<string>(m["CardTemplateCallBackUrl"]));
    }
    if (m.find("CardVerderCallBackUrl") != m.end() && !m["CardVerderCallBackUrl"].empty()) {
      cardVerderCallBackUrl = make_shared<string>(boost::any_cast<string>(m["CardVerderCallBackUrl"]));
    }
    if (m.find("DcdpCallbackUrl") != m.end() && !m["DcdpCallbackUrl"].empty()) {
      dcdpCallbackUrl = make_shared<string>(boost::any_cast<string>(m["DcdpCallbackUrl"]));
    }
    if (m.find("DigitSmsTemplateCallBackUrl") != m.end() && !m["DigitSmsTemplateCallBackUrl"].empty()) {
      digitSmsTemplateCallBackUrl = make_shared<string>(boost::any_cast<string>(m["DigitSmsTemplateCallBackUrl"]));
    }
    if (m.find("GlobeSmsReportCallback") != m.end() && !m["GlobeSmsReportCallback"].empty()) {
      globeSmsReportCallback = make_shared<bool>(boost::any_cast<bool>(m["GlobeSmsReportCallback"]));
    }
    if (m.find("GlobeSmsReportCallbackUrl") != m.end() && !m["GlobeSmsReportCallbackUrl"].empty()) {
      globeSmsReportCallbackUrl = make_shared<string>(boost::any_cast<string>(m["GlobeSmsReportCallbackUrl"]));
    }
    if (m.find("IsAiccsCallMidRecord") != m.end() && !m["IsAiccsCallMidRecord"].empty()) {
      isAiccsCallMidRecord = make_shared<bool>(boost::any_cast<bool>(m["IsAiccsCallMidRecord"]));
    }
    if (m.find("IsAiccsCallRecord") != m.end() && !m["IsAiccsCallRecord"].empty()) {
      isAiccsCallRecord = make_shared<bool>(boost::any_cast<bool>(m["IsAiccsCallRecord"]));
    }
    if (m.find("IsAiccsSentRecord") != m.end() && !m["IsAiccsSentRecord"].empty()) {
      isAiccsSentRecord = make_shared<bool>(boost::any_cast<bool>(m["IsAiccsSentRecord"]));
    }
    if (m.find("IsArtcCdrReportCallBack") != m.end() && !m["IsArtcCdrReportCallBack"].empty()) {
      isArtcCdrReportCallBack = make_shared<bool>(boost::any_cast<bool>(m["IsArtcCdrReportCallBack"]));
    }
    if (m.find("IsArtcTempStatusReportCallBack") != m.end() && !m["IsArtcTempStatusReportCallBack"].empty()) {
      isArtcTempStatusReportCallBack = make_shared<bool>(boost::any_cast<bool>(m["IsArtcTempStatusReportCallBack"]));
    }
    if (m.find("IsDcdpCallback") != m.end() && !m["IsDcdpCallback"].empty()) {
      isDcdpCallback = make_shared<bool>(boost::any_cast<bool>(m["IsDcdpCallback"]));
    }
    if (m.find("IsDigitSmsTemplateCallBack") != m.end() && !m["IsDigitSmsTemplateCallBack"].empty()) {
      isDigitSmsTemplateCallBack = make_shared<bool>(boost::any_cast<bool>(m["IsDigitSmsTemplateCallBack"]));
    }
    if (m.find("IsGlobeSmsReportCallback") != m.end() && !m["IsGlobeSmsReportCallback"].empty()) {
      isGlobeSmsReportCallback = make_shared<bool>(boost::any_cast<bool>(m["IsGlobeSmsReportCallback"]));
    }
    if (m.find("IsOpened") != m.end() && !m["IsOpened"].empty()) {
      isOpened = make_shared<bool>(boost::any_cast<bool>(m["IsOpened"]));
    }
    if (m.find("IsSecretReportMessageCallback") != m.end() && !m["IsSecretReportMessageCallback"].empty()) {
      isSecretReportMessageCallback = make_shared<bool>(boost::any_cast<bool>(m["IsSecretReportMessageCallback"]));
    }
    if (m.find("IsSecretSmsMessageCallback") != m.end() && !m["IsSecretSmsMessageCallback"].empty()) {
      isSecretSmsMessageCallback = make_shared<bool>(boost::any_cast<bool>(m["IsSecretSmsMessageCallback"]));
    }
    if (m.find("IsSignReportCallback") != m.end() && !m["IsSignReportCallback"].empty()) {
      isSignReportCallback = make_shared<bool>(boost::any_cast<bool>(m["IsSignReportCallback"]));
    }
    if (m.find("IsSmartCallAsrCallBack") != m.end() && !m["IsSmartCallAsrCallBack"].empty()) {
      isSmartCallAsrCallBack = make_shared<bool>(boost::any_cast<bool>(m["IsSmartCallAsrCallBack"]));
    }
    if (m.find("IsSmsReportMessageCallback") != m.end() && !m["IsSmsReportMessageCallback"].empty()) {
      isSmsReportMessageCallback = make_shared<bool>(boost::any_cast<bool>(m["IsSmsReportMessageCallback"]));
    }
    if (m.find("IsSmsUpMessageCallback") != m.end() && !m["IsSmsUpMessageCallback"].empty()) {
      isSmsUpMessageCallback = make_shared<bool>(boost::any_cast<bool>(m["IsSmsUpMessageCallback"]));
    }
    if (m.find("IsTemplateReportCallback") != m.end() && !m["IsTemplateReportCallback"].empty()) {
      isTemplateReportCallback = make_shared<bool>(boost::any_cast<bool>(m["IsTemplateReportCallback"]));
    }
    if (m.find("IsVoiceAsrCallBack") != m.end() && !m["IsVoiceAsrCallBack"].empty()) {
      isVoiceAsrCallBack = make_shared<bool>(boost::any_cast<bool>(m["IsVoiceAsrCallBack"]));
    }
    if (m.find("IsVoiceCallMidStateCallBack") != m.end() && !m["IsVoiceCallMidStateCallBack"].empty()) {
      isVoiceCallMidStateCallBack = make_shared<bool>(boost::any_cast<bool>(m["IsVoiceCallMidStateCallBack"]));
    }
    if (m.find("IsVoiceCallRecordCallBack") != m.end() && !m["IsVoiceCallRecordCallBack"].empty()) {
      isVoiceCallRecordCallBack = make_shared<bool>(boost::any_cast<bool>(m["IsVoiceCallRecordCallBack"]));
    }
    if (m.find("IsVoiceRecordingCallBack") != m.end() && !m["IsVoiceRecordingCallBack"].empty()) {
      isVoiceRecordingCallBack = make_shared<bool>(boost::any_cast<bool>(m["IsVoiceRecordingCallBack"]));
    }
    if (m.find("ReportCallbackUrl") != m.end() && !m["ReportCallbackUrl"].empty()) {
      reportCallbackUrl = make_shared<string>(boost::any_cast<string>(m["ReportCallbackUrl"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SecretCallbackUrl") != m.end() && !m["SecretCallbackUrl"].empty()) {
      secretCallbackUrl = make_shared<string>(boost::any_cast<string>(m["SecretCallbackUrl"]));
    }
    if (m.find("SecretSmsCallbackUrl") != m.end() && !m["SecretSmsCallbackUrl"].empty()) {
      secretSmsCallbackUrl = make_shared<string>(boost::any_cast<string>(m["SecretSmsCallbackUrl"]));
    }
    if (m.find("ShortLinkCallBackUrl") != m.end() && !m["ShortLinkCallBackUrl"].empty()) {
      shortLinkCallBackUrl = make_shared<string>(boost::any_cast<string>(m["ShortLinkCallBackUrl"]));
    }
    if (m.find("SignReportCallbackUrl") != m.end() && !m["SignReportCallbackUrl"].empty()) {
      signReportCallbackUrl = make_shared<string>(boost::any_cast<string>(m["SignReportCallbackUrl"]));
    }
    if (m.find("SmartCallAsrCallBackUrl") != m.end() && !m["SmartCallAsrCallBackUrl"].empty()) {
      smartCallAsrCallBackUrl = make_shared<string>(boost::any_cast<string>(m["SmartCallAsrCallBackUrl"]));
    }
    if (m.find("TemplateReportCallbackUrl") != m.end() && !m["TemplateReportCallbackUrl"].empty()) {
      templateReportCallbackUrl = make_shared<string>(boost::any_cast<string>(m["TemplateReportCallbackUrl"]));
    }
    if (m.find("UpCallbackUrl") != m.end() && !m["UpCallbackUrl"].empty()) {
      upCallbackUrl = make_shared<string>(boost::any_cast<string>(m["UpCallbackUrl"]));
    }
    if (m.find("VoiceAsrCallBackUrl") != m.end() && !m["VoiceAsrCallBackUrl"].empty()) {
      voiceAsrCallBackUrl = make_shared<string>(boost::any_cast<string>(m["VoiceAsrCallBackUrl"]));
    }
    if (m.find("VoiceCallMidStateCallBackUrl") != m.end() && !m["VoiceCallMidStateCallBackUrl"].empty()) {
      voiceCallMidStateCallBackUrl = make_shared<string>(boost::any_cast<string>(m["VoiceCallMidStateCallBackUrl"]));
    }
    if (m.find("VoiceCallRecordCallBackUrl") != m.end() && !m["VoiceCallRecordCallBackUrl"].empty()) {
      voiceCallRecordCallBackUrl = make_shared<string>(boost::any_cast<string>(m["VoiceCallRecordCallBackUrl"]));
    }
    if (m.find("VoiceRecordingCallBackUrl") != m.end() && !m["VoiceRecordingCallBackUrl"].empty()) {
      voiceRecordingCallBackUrl = make_shared<string>(boost::any_cast<string>(m["VoiceRecordingCallBackUrl"]));
    }
  }


  virtual ~QueryMessageCallbackNewResponseBody() = default;
};
class QueryMessageCallbackNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMessageCallbackNewResponseBody> body{};

  QueryMessageCallbackNewResponse() {}

  explicit QueryMessageCallbackNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMessageCallbackNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMessageCallbackNewResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMessageCallbackNewResponse() = default;
};
class QueryMessageQueueNewRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> queueTypes{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryMessageQueueNewRequest() {}

  explicit QueryMessageQueueNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (queueTypes) {
      res["QueueTypes"] = boost::any(*queueTypes);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("QueueTypes") != m.end() && !m["QueueTypes"].empty()) {
      queueTypes = make_shared<string>(boost::any_cast<string>(m["QueueTypes"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryMessageQueueNewRequest() = default;
};
class QueryMessageQueueNewResponseBodyList : public Darabonba::Model {
public:
  shared_ptr<bool> isCreated{};
  shared_ptr<string> queueName{};
  shared_ptr<string> queueType{};
  shared_ptr<string> region{};

  QueryMessageQueueNewResponseBodyList() {}

  explicit QueryMessageQueueNewResponseBodyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isCreated) {
      res["IsCreated"] = boost::any(*isCreated);
    }
    if (queueName) {
      res["QueueName"] = boost::any(*queueName);
    }
    if (queueType) {
      res["QueueType"] = boost::any(*queueType);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsCreated") != m.end() && !m["IsCreated"].empty()) {
      isCreated = make_shared<bool>(boost::any_cast<bool>(m["IsCreated"]));
    }
    if (m.find("QueueName") != m.end() && !m["QueueName"].empty()) {
      queueName = make_shared<string>(boost::any_cast<string>(m["QueueName"]));
    }
    if (m.find("QueueType") != m.end() && !m["QueueType"].empty()) {
      queueType = make_shared<string>(boost::any_cast<string>(m["QueueType"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
  }


  virtual ~QueryMessageQueueNewResponseBodyList() = default;
};
class QueryMessageQueueNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMessageQueueNewResponseBodyList>> list{};
  shared_ptr<string> requestId{};

  QueryMessageQueueNewResponseBody() {}

  explicit QueryMessageQueueNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<QueryMessageQueueNewResponseBodyList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMessageQueueNewResponseBodyList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<QueryMessageQueueNewResponseBodyList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryMessageQueueNewResponseBody() = default;
};
class QueryMessageQueueNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMessageQueueNewResponseBody> body{};

  QueryMessageQueueNewResponse() {}

  explicit QueryMessageQueueNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMessageQueueNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMessageQueueNewResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMessageQueueNewResponse() = default;
};
class QueryMonthlyBillInfoLeafNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> billCycle{};
  shared_ptr<string> itemId{};
  shared_ptr<string> itemName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> subjectItemId{};

  QueryMonthlyBillInfoLeafNewRequest() {}

  explicit QueryMonthlyBillInfoLeafNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billCycle) {
      res["BillCycle"] = boost::any(*billCycle);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (itemName) {
      res["ItemName"] = boost::any(*itemName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (subjectItemId) {
      res["SubjectItemId"] = boost::any(*subjectItemId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BillCycle") != m.end() && !m["BillCycle"].empty()) {
      billCycle = make_shared<string>(boost::any_cast<string>(m["BillCycle"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<string>(boost::any_cast<string>(m["ItemId"]));
    }
    if (m.find("ItemName") != m.end() && !m["ItemName"].empty()) {
      itemName = make_shared<string>(boost::any_cast<string>(m["ItemName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SubjectItemId") != m.end() && !m["SubjectItemId"].empty()) {
      subjectItemId = make_shared<string>(boost::any_cast<string>(m["SubjectItemId"]));
    }
  }


  virtual ~QueryMonthlyBillInfoLeafNewRequest() = default;
};
class QueryMonthlyBillInfoLeafNewResponseBodyLayeredBillDOListSubjectDetailList : public Darabonba::Model {
public:
  shared_ptr<long> addCount{};
  shared_ptr<string> addUnit{};
  shared_ptr<string> billAmount{};
  shared_ptr<string> itemId{};
  shared_ptr<string> itemName{};
  shared_ptr<string> operator_{};
  shared_ptr<string> packageBill{};
  shared_ptr<string> singlePrice{};
  shared_ptr<string> subjectItemId{};
  shared_ptr<string> subjectName{};

  QueryMonthlyBillInfoLeafNewResponseBodyLayeredBillDOListSubjectDetailList() {}

  explicit QueryMonthlyBillInfoLeafNewResponseBodyLayeredBillDOListSubjectDetailList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addCount) {
      res["AddCount"] = boost::any(*addCount);
    }
    if (addUnit) {
      res["AddUnit"] = boost::any(*addUnit);
    }
    if (billAmount) {
      res["BillAmount"] = boost::any(*billAmount);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (itemName) {
      res["ItemName"] = boost::any(*itemName);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (packageBill) {
      res["PackageBill"] = boost::any(*packageBill);
    }
    if (singlePrice) {
      res["SinglePrice"] = boost::any(*singlePrice);
    }
    if (subjectItemId) {
      res["SubjectItemId"] = boost::any(*subjectItemId);
    }
    if (subjectName) {
      res["SubjectName"] = boost::any(*subjectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddCount") != m.end() && !m["AddCount"].empty()) {
      addCount = make_shared<long>(boost::any_cast<long>(m["AddCount"]));
    }
    if (m.find("AddUnit") != m.end() && !m["AddUnit"].empty()) {
      addUnit = make_shared<string>(boost::any_cast<string>(m["AddUnit"]));
    }
    if (m.find("BillAmount") != m.end() && !m["BillAmount"].empty()) {
      billAmount = make_shared<string>(boost::any_cast<string>(m["BillAmount"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<string>(boost::any_cast<string>(m["ItemId"]));
    }
    if (m.find("ItemName") != m.end() && !m["ItemName"].empty()) {
      itemName = make_shared<string>(boost::any_cast<string>(m["ItemName"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("PackageBill") != m.end() && !m["PackageBill"].empty()) {
      packageBill = make_shared<string>(boost::any_cast<string>(m["PackageBill"]));
    }
    if (m.find("SinglePrice") != m.end() && !m["SinglePrice"].empty()) {
      singlePrice = make_shared<string>(boost::any_cast<string>(m["SinglePrice"]));
    }
    if (m.find("SubjectItemId") != m.end() && !m["SubjectItemId"].empty()) {
      subjectItemId = make_shared<string>(boost::any_cast<string>(m["SubjectItemId"]));
    }
    if (m.find("SubjectName") != m.end() && !m["SubjectName"].empty()) {
      subjectName = make_shared<string>(boost::any_cast<string>(m["SubjectName"]));
    }
  }


  virtual ~QueryMonthlyBillInfoLeafNewResponseBodyLayeredBillDOListSubjectDetailList() = default;
};
class QueryMonthlyBillInfoLeafNewResponseBodyLayeredBillDOList : public Darabonba::Model {
public:
  shared_ptr<long> addCount{};
  shared_ptr<string> addUnit{};
  shared_ptr<string> billAmount{};
  shared_ptr<string> itemId{};
  shared_ptr<string> itemName{};
  shared_ptr<string> operator_{};
  shared_ptr<string> packageBill{};
  shared_ptr<string> singlePrice{};
  shared_ptr<vector<QueryMonthlyBillInfoLeafNewResponseBodyLayeredBillDOListSubjectDetailList>> subjectDetailList{};
  shared_ptr<string> subjectItemId{};
  shared_ptr<string> subjectName{};

  QueryMonthlyBillInfoLeafNewResponseBodyLayeredBillDOList() {}

  explicit QueryMonthlyBillInfoLeafNewResponseBodyLayeredBillDOList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addCount) {
      res["AddCount"] = boost::any(*addCount);
    }
    if (addUnit) {
      res["AddUnit"] = boost::any(*addUnit);
    }
    if (billAmount) {
      res["BillAmount"] = boost::any(*billAmount);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (itemName) {
      res["ItemName"] = boost::any(*itemName);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (packageBill) {
      res["PackageBill"] = boost::any(*packageBill);
    }
    if (singlePrice) {
      res["SinglePrice"] = boost::any(*singlePrice);
    }
    if (subjectDetailList) {
      vector<boost::any> temp1;
      for(auto item1:*subjectDetailList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubjectDetailList"] = boost::any(temp1);
    }
    if (subjectItemId) {
      res["SubjectItemId"] = boost::any(*subjectItemId);
    }
    if (subjectName) {
      res["SubjectName"] = boost::any(*subjectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddCount") != m.end() && !m["AddCount"].empty()) {
      addCount = make_shared<long>(boost::any_cast<long>(m["AddCount"]));
    }
    if (m.find("AddUnit") != m.end() && !m["AddUnit"].empty()) {
      addUnit = make_shared<string>(boost::any_cast<string>(m["AddUnit"]));
    }
    if (m.find("BillAmount") != m.end() && !m["BillAmount"].empty()) {
      billAmount = make_shared<string>(boost::any_cast<string>(m["BillAmount"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<string>(boost::any_cast<string>(m["ItemId"]));
    }
    if (m.find("ItemName") != m.end() && !m["ItemName"].empty()) {
      itemName = make_shared<string>(boost::any_cast<string>(m["ItemName"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("PackageBill") != m.end() && !m["PackageBill"].empty()) {
      packageBill = make_shared<string>(boost::any_cast<string>(m["PackageBill"]));
    }
    if (m.find("SinglePrice") != m.end() && !m["SinglePrice"].empty()) {
      singlePrice = make_shared<string>(boost::any_cast<string>(m["SinglePrice"]));
    }
    if (m.find("SubjectDetailList") != m.end() && !m["SubjectDetailList"].empty()) {
      if (typeid(vector<boost::any>) == m["SubjectDetailList"].type()) {
        vector<QueryMonthlyBillInfoLeafNewResponseBodyLayeredBillDOListSubjectDetailList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubjectDetailList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMonthlyBillInfoLeafNewResponseBodyLayeredBillDOListSubjectDetailList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subjectDetailList = make_shared<vector<QueryMonthlyBillInfoLeafNewResponseBodyLayeredBillDOListSubjectDetailList>>(expect1);
      }
    }
    if (m.find("SubjectItemId") != m.end() && !m["SubjectItemId"].empty()) {
      subjectItemId = make_shared<string>(boost::any_cast<string>(m["SubjectItemId"]));
    }
    if (m.find("SubjectName") != m.end() && !m["SubjectName"].empty()) {
      subjectName = make_shared<string>(boost::any_cast<string>(m["SubjectName"]));
    }
  }


  virtual ~QueryMonthlyBillInfoLeafNewResponseBodyLayeredBillDOList() = default;
};
class QueryMonthlyBillInfoLeafNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> couponPayment{};
  shared_ptr<bool> isSeparatedPrice{};
  shared_ptr<vector<QueryMonthlyBillInfoLeafNewResponseBodyLayeredBillDOList>> layeredBillDOList{};
  shared_ptr<string> packageAmount{};
  shared_ptr<string> realPayment{};
  shared_ptr<string> requestId{};
  shared_ptr<string> totalPayment{};

  QueryMonthlyBillInfoLeafNewResponseBody() {}

  explicit QueryMonthlyBillInfoLeafNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (couponPayment) {
      res["CouponPayment"] = boost::any(*couponPayment);
    }
    if (isSeparatedPrice) {
      res["IsSeparatedPrice"] = boost::any(*isSeparatedPrice);
    }
    if (layeredBillDOList) {
      vector<boost::any> temp1;
      for(auto item1:*layeredBillDOList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LayeredBillDOList"] = boost::any(temp1);
    }
    if (packageAmount) {
      res["PackageAmount"] = boost::any(*packageAmount);
    }
    if (realPayment) {
      res["RealPayment"] = boost::any(*realPayment);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalPayment) {
      res["TotalPayment"] = boost::any(*totalPayment);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CouponPayment") != m.end() && !m["CouponPayment"].empty()) {
      couponPayment = make_shared<string>(boost::any_cast<string>(m["CouponPayment"]));
    }
    if (m.find("IsSeparatedPrice") != m.end() && !m["IsSeparatedPrice"].empty()) {
      isSeparatedPrice = make_shared<bool>(boost::any_cast<bool>(m["IsSeparatedPrice"]));
    }
    if (m.find("LayeredBillDOList") != m.end() && !m["LayeredBillDOList"].empty()) {
      if (typeid(vector<boost::any>) == m["LayeredBillDOList"].type()) {
        vector<QueryMonthlyBillInfoLeafNewResponseBodyLayeredBillDOList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LayeredBillDOList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMonthlyBillInfoLeafNewResponseBodyLayeredBillDOList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        layeredBillDOList = make_shared<vector<QueryMonthlyBillInfoLeafNewResponseBodyLayeredBillDOList>>(expect1);
      }
    }
    if (m.find("PackageAmount") != m.end() && !m["PackageAmount"].empty()) {
      packageAmount = make_shared<string>(boost::any_cast<string>(m["PackageAmount"]));
    }
    if (m.find("RealPayment") != m.end() && !m["RealPayment"].empty()) {
      realPayment = make_shared<string>(boost::any_cast<string>(m["RealPayment"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalPayment") != m.end() && !m["TotalPayment"].empty()) {
      totalPayment = make_shared<string>(boost::any_cast<string>(m["TotalPayment"]));
    }
  }


  virtual ~QueryMonthlyBillInfoLeafNewResponseBody() = default;
};
class QueryMonthlyBillInfoLeafNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMonthlyBillInfoLeafNewResponseBody> body{};

  QueryMonthlyBillInfoLeafNewResponse() {}

  explicit QueryMonthlyBillInfoLeafNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMonthlyBillInfoLeafNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMonthlyBillInfoLeafNewResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMonthlyBillInfoLeafNewResponse() = default;
};
class QueryMonthlyBillRentalRequest : public Darabonba::Model {
public:
  shared_ptr<string> billCycle{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryMonthlyBillRentalRequest() {}

  explicit QueryMonthlyBillRentalRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billCycle) {
      res["BillCycle"] = boost::any(*billCycle);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BillCycle") != m.end() && !m["BillCycle"].empty()) {
      billCycle = make_shared<string>(boost::any_cast<string>(m["BillCycle"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryMonthlyBillRentalRequest() = default;
};
class QueryMonthlyBillRentalResponseBodyDataRecords : public Darabonba::Model {
public:
  shared_ptr<long> billTime{};
  shared_ptr<string> itemId{};
  shared_ptr<string> itemName{};
  shared_ptr<long> offerTime{};
  shared_ptr<string> rental{};
  shared_ptr<string> subItemId{};
  shared_ptr<string> subItemName{};

  QueryMonthlyBillRentalResponseBodyDataRecords() {}

  explicit QueryMonthlyBillRentalResponseBodyDataRecords(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billTime) {
      res["billTime"] = boost::any(*billTime);
    }
    if (itemId) {
      res["itemId"] = boost::any(*itemId);
    }
    if (itemName) {
      res["itemName"] = boost::any(*itemName);
    }
    if (offerTime) {
      res["offerTime"] = boost::any(*offerTime);
    }
    if (rental) {
      res["rental"] = boost::any(*rental);
    }
    if (subItemId) {
      res["subItemId"] = boost::any(*subItemId);
    }
    if (subItemName) {
      res["subItemName"] = boost::any(*subItemName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("billTime") != m.end() && !m["billTime"].empty()) {
      billTime = make_shared<long>(boost::any_cast<long>(m["billTime"]));
    }
    if (m.find("itemId") != m.end() && !m["itemId"].empty()) {
      itemId = make_shared<string>(boost::any_cast<string>(m["itemId"]));
    }
    if (m.find("itemName") != m.end() && !m["itemName"].empty()) {
      itemName = make_shared<string>(boost::any_cast<string>(m["itemName"]));
    }
    if (m.find("offerTime") != m.end() && !m["offerTime"].empty()) {
      offerTime = make_shared<long>(boost::any_cast<long>(m["offerTime"]));
    }
    if (m.find("rental") != m.end() && !m["rental"].empty()) {
      rental = make_shared<string>(boost::any_cast<string>(m["rental"]));
    }
    if (m.find("subItemId") != m.end() && !m["subItemId"].empty()) {
      subItemId = make_shared<string>(boost::any_cast<string>(m["subItemId"]));
    }
    if (m.find("subItemName") != m.end() && !m["subItemName"].empty()) {
      subItemName = make_shared<string>(boost::any_cast<string>(m["subItemName"]));
    }
  }


  virtual ~QueryMonthlyBillRentalResponseBodyDataRecords() = default;
};
class QueryMonthlyBillRentalResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<QueryMonthlyBillRentalResponseBodyDataRecords>> records{};
  shared_ptr<string> rentalSum{};
  shared_ptr<long> total{};

  QueryMonthlyBillRentalResponseBodyData() {}

  explicit QueryMonthlyBillRentalResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNo) {
      res["pageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (records) {
      vector<boost::any> temp1;
      for(auto item1:*records){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["records"] = boost::any(temp1);
    }
    if (rentalSum) {
      res["rentalSum"] = boost::any(*rentalSum);
    }
    if (total) {
      res["total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("pageNo") != m.end() && !m["pageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["pageNo"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("records") != m.end() && !m["records"].empty()) {
      if (typeid(vector<boost::any>) == m["records"].type()) {
        vector<QueryMonthlyBillRentalResponseBodyDataRecords> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["records"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMonthlyBillRentalResponseBodyDataRecords model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        records = make_shared<vector<QueryMonthlyBillRentalResponseBodyDataRecords>>(expect1);
      }
    }
    if (m.find("rentalSum") != m.end() && !m["rentalSum"].empty()) {
      rentalSum = make_shared<string>(boost::any_cast<string>(m["rentalSum"]));
    }
    if (m.find("total") != m.end() && !m["total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["total"]));
    }
  }


  virtual ~QueryMonthlyBillRentalResponseBodyData() = default;
};
class QueryMonthlyBillRentalResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryMonthlyBillRentalResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryMonthlyBillRentalResponseBody() {}

  explicit QueryMonthlyBillRentalResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryMonthlyBillRentalResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryMonthlyBillRentalResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryMonthlyBillRentalResponseBody() = default;
};
class QueryMonthlyBillRentalResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMonthlyBillRentalResponseBody> body{};

  QueryMonthlyBillRentalResponse() {}

  explicit QueryMonthlyBillRentalResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMonthlyBillRentalResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMonthlyBillRentalResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMonthlyBillRentalResponse() = default;
};
class QueryMonthlyBillRentalNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> billCycle{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryMonthlyBillRentalNewRequest() {}

  explicit QueryMonthlyBillRentalNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billCycle) {
      res["BillCycle"] = boost::any(*billCycle);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BillCycle") != m.end() && !m["BillCycle"].empty()) {
      billCycle = make_shared<string>(boost::any_cast<string>(m["BillCycle"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryMonthlyBillRentalNewRequest() = default;
};
class QueryMonthlyBillRentalNewResponseBodyRecords : public Darabonba::Model {
public:
  shared_ptr<long> billTime{};
  shared_ptr<string> itemId{};
  shared_ptr<string> itemName{};
  shared_ptr<long> offerTime{};
  shared_ptr<string> rental{};
  shared_ptr<string> subItemId{};
  shared_ptr<string> subItemName{};

  QueryMonthlyBillRentalNewResponseBodyRecords() {}

  explicit QueryMonthlyBillRentalNewResponseBodyRecords(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billTime) {
      res["BillTime"] = boost::any(*billTime);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (itemName) {
      res["ItemName"] = boost::any(*itemName);
    }
    if (offerTime) {
      res["OfferTime"] = boost::any(*offerTime);
    }
    if (rental) {
      res["Rental"] = boost::any(*rental);
    }
    if (subItemId) {
      res["SubItemId"] = boost::any(*subItemId);
    }
    if (subItemName) {
      res["SubItemName"] = boost::any(*subItemName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BillTime") != m.end() && !m["BillTime"].empty()) {
      billTime = make_shared<long>(boost::any_cast<long>(m["BillTime"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<string>(boost::any_cast<string>(m["ItemId"]));
    }
    if (m.find("ItemName") != m.end() && !m["ItemName"].empty()) {
      itemName = make_shared<string>(boost::any_cast<string>(m["ItemName"]));
    }
    if (m.find("OfferTime") != m.end() && !m["OfferTime"].empty()) {
      offerTime = make_shared<long>(boost::any_cast<long>(m["OfferTime"]));
    }
    if (m.find("Rental") != m.end() && !m["Rental"].empty()) {
      rental = make_shared<string>(boost::any_cast<string>(m["Rental"]));
    }
    if (m.find("SubItemId") != m.end() && !m["SubItemId"].empty()) {
      subItemId = make_shared<string>(boost::any_cast<string>(m["SubItemId"]));
    }
    if (m.find("SubItemName") != m.end() && !m["SubItemName"].empty()) {
      subItemName = make_shared<string>(boost::any_cast<string>(m["SubItemName"]));
    }
  }


  virtual ~QueryMonthlyBillRentalNewResponseBodyRecords() = default;
};
class QueryMonthlyBillRentalNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<QueryMonthlyBillRentalNewResponseBodyRecords>> records{};
  shared_ptr<string> rentalSum{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  QueryMonthlyBillRentalNewResponseBody() {}

  explicit QueryMonthlyBillRentalNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (records) {
      vector<boost::any> temp1;
      for(auto item1:*records){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Records"] = boost::any(temp1);
    }
    if (rentalSum) {
      res["RentalSum"] = boost::any(*rentalSum);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Records") != m.end() && !m["Records"].empty()) {
      if (typeid(vector<boost::any>) == m["Records"].type()) {
        vector<QueryMonthlyBillRentalNewResponseBodyRecords> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Records"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMonthlyBillRentalNewResponseBodyRecords model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        records = make_shared<vector<QueryMonthlyBillRentalNewResponseBodyRecords>>(expect1);
      }
    }
    if (m.find("RentalSum") != m.end() && !m["RentalSum"].empty()) {
      rentalSum = make_shared<string>(boost::any_cast<string>(m["RentalSum"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QueryMonthlyBillRentalNewResponseBody() = default;
};
class QueryMonthlyBillRentalNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMonthlyBillRentalNewResponseBody> body{};

  QueryMonthlyBillRentalNewResponse() {}

  explicit QueryMonthlyBillRentalNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMonthlyBillRentalNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMonthlyBillRentalNewResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMonthlyBillRentalNewResponse() = default;
};
class QueryMsgCountRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryMsgCountRequest() {}

  explicit QueryMsgCountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryMsgCountRequest() = default;
};
class QueryMsgCountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<string> data{};

  QueryMsgCountResponseBody() {}

  explicit QueryMsgCountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
  }


  virtual ~QueryMsgCountResponseBody() = default;
};
class QueryMsgCountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMsgCountResponseBody> body{};

  QueryMsgCountResponse() {}

  explicit QueryMsgCountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMsgCountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMsgCountResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMsgCountResponse() = default;
};
class QueryOpenStatusRequest : public Darabonba::Model {
public:
  shared_ptr<long> busOffer{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> prodId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryOpenStatusRequest() {}

  explicit QueryOpenStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (busOffer) {
      res["BusOffer"] = boost::any(*busOffer);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (prodId) {
      res["ProdId"] = boost::any(*prodId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusOffer") != m.end() && !m["BusOffer"].empty()) {
      busOffer = make_shared<long>(boost::any_cast<long>(m["BusOffer"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ProdId") != m.end() && !m["ProdId"].empty()) {
      prodId = make_shared<string>(boost::any_cast<string>(m["ProdId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryOpenStatusRequest() = default;
};
class QueryOpenStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<bool> data{};

  QueryOpenStatusResponseBody() {}

  explicit QueryOpenStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["data"]));
    }
  }


  virtual ~QueryOpenStatusResponseBody() = default;
};
class QueryOpenStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryOpenStatusResponseBody> body{};

  QueryOpenStatusResponse() {}

  explicit QueryOpenStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryOpenStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryOpenStatusResponseBody>(model1);
      }
    }
  }


  virtual ~QueryOpenStatusResponse() = default;
};
class QueryOpencFlagNewRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryOpencFlagNewRequest() {}

  explicit QueryOpencFlagNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryOpencFlagNewRequest() = default;
};
class QueryOpencFlagNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> isOpen{};
  shared_ptr<string> requestId{};

  QueryOpencFlagNewResponseBody() {}

  explicit QueryOpencFlagNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isOpen) {
      res["IsOpen"] = boost::any(*isOpen);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsOpen") != m.end() && !m["IsOpen"].empty()) {
      isOpen = make_shared<long>(boost::any_cast<long>(m["IsOpen"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryOpencFlagNewResponseBody() = default;
};
class QueryOpencFlagNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryOpencFlagNewResponseBody> body{};

  QueryOpencFlagNewResponse() {}

  explicit QueryOpencFlagNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryOpencFlagNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryOpencFlagNewResponseBody>(model1);
      }
    }
  }


  virtual ~QueryOpencFlagNewResponse() = default;
};
class QueryPhoneWhiteListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> phoneNumber{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryPhoneWhiteListRequest() {}

  explicit QueryPhoneWhiteListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryPhoneWhiteListRequest() = default;
};
class QueryPhoneWhiteListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<string> data{};

  QueryPhoneWhiteListResponseBody() {}

  explicit QueryPhoneWhiteListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
  }


  virtual ~QueryPhoneWhiteListResponseBody() = default;
};
class QueryPhoneWhiteListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryPhoneWhiteListResponseBody> body{};

  QueryPhoneWhiteListResponse() {}

  explicit QueryPhoneWhiteListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryPhoneWhiteListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryPhoneWhiteListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryPhoneWhiteListResponse() = default;
};
class QueryPhoneWhiteListNewRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> phoneNumber{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryPhoneWhiteListNewRequest() {}

  explicit QueryPhoneWhiteListNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryPhoneWhiteListNewRequest() = default;
};
class QueryPhoneWhiteListNewResponseBodyList : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> phoneNumber{};
  shared_ptr<string> remark{};

  QueryPhoneWhiteListNewResponseBodyList() {}

  explicit QueryPhoneWhiteListNewResponseBodyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
  }


  virtual ~QueryPhoneWhiteListNewResponseBodyList() = default;
};
class QueryPhoneWhiteListNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<QueryPhoneWhiteListNewResponseBodyList>> list{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};
  shared_ptr<long> totalWithoutFilter{};

  QueryPhoneWhiteListNewResponseBody() {}

  explicit QueryPhoneWhiteListNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (totalWithoutFilter) {
      res["TotalWithoutFilter"] = boost::any(*totalWithoutFilter);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<QueryPhoneWhiteListNewResponseBodyList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryPhoneWhiteListNewResponseBodyList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<QueryPhoneWhiteListNewResponseBodyList>>(expect1);
      }
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("TotalWithoutFilter") != m.end() && !m["TotalWithoutFilter"].empty()) {
      totalWithoutFilter = make_shared<long>(boost::any_cast<long>(m["TotalWithoutFilter"]));
    }
  }


  virtual ~QueryPhoneWhiteListNewResponseBody() = default;
};
class QueryPhoneWhiteListNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryPhoneWhiteListNewResponseBody> body{};

  QueryPhoneWhiteListNewResponse() {}

  explicit QueryPhoneWhiteListNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryPhoneWhiteListNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryPhoneWhiteListNewResponseBody>(model1);
      }
    }
  }


  virtual ~QueryPhoneWhiteListNewResponse() = default;
};
class QueryPkgThresholdRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryPkgThresholdRequest() {}

  explicit QueryPkgThresholdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryPkgThresholdRequest() = default;
};
class QueryPkgThresholdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<string> data{};

  QueryPkgThresholdResponseBody() {}

  explicit QueryPkgThresholdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
  }


  virtual ~QueryPkgThresholdResponseBody() = default;
};
class QueryPkgThresholdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryPkgThresholdResponseBody> body{};

  QueryPkgThresholdResponse() {}

  explicit QueryPkgThresholdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryPkgThresholdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryPkgThresholdResponseBody>(model1);
      }
    }
  }


  virtual ~QueryPkgThresholdResponse() = default;
};
class QueryPkgThresholdNewRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryPkgThresholdNewRequest() {}

  explicit QueryPkgThresholdNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryPkgThresholdNewRequest() = default;
};
class QueryPkgThresholdNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> packageWarningLimit{};
  shared_ptr<string> requestId{};

  QueryPkgThresholdNewResponseBody() {}

  explicit QueryPkgThresholdNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (packageWarningLimit) {
      res["PackageWarningLimit"] = boost::any(*packageWarningLimit);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PackageWarningLimit") != m.end() && !m["PackageWarningLimit"].empty()) {
      packageWarningLimit = make_shared<long>(boost::any_cast<long>(m["PackageWarningLimit"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryPkgThresholdNewResponseBody() = default;
};
class QueryPkgThresholdNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryPkgThresholdNewResponseBody> body{};

  QueryPkgThresholdNewResponse() {}

  explicit QueryPkgThresholdNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryPkgThresholdNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryPkgThresholdNewResponseBody>(model1);
      }
    }
  }


  virtual ~QueryPkgThresholdNewResponse() = default;
};
class QueryPrevLimitNewRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryPrevLimitNewRequest() {}

  explicit QueryPrevLimitNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryPrevLimitNewRequest() = default;
};
class QueryPrevLimitNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> hourLimit{};
  shared_ptr<long> increaseRate{};
  shared_ptr<string> requestId{};
  shared_ptr<long> successRate{};

  QueryPrevLimitNewResponseBody() {}

  explicit QueryPrevLimitNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hourLimit) {
      res["HourLimit"] = boost::any(*hourLimit);
    }
    if (increaseRate) {
      res["IncreaseRate"] = boost::any(*increaseRate);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (successRate) {
      res["SuccessRate"] = boost::any(*successRate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HourLimit") != m.end() && !m["HourLimit"].empty()) {
      hourLimit = make_shared<long>(boost::any_cast<long>(m["HourLimit"]));
    }
    if (m.find("IncreaseRate") != m.end() && !m["IncreaseRate"].empty()) {
      increaseRate = make_shared<long>(boost::any_cast<long>(m["IncreaseRate"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SuccessRate") != m.end() && !m["SuccessRate"].empty()) {
      successRate = make_shared<long>(boost::any_cast<long>(m["SuccessRate"]));
    }
  }


  virtual ~QueryPrevLimitNewResponseBody() = default;
};
class QueryPrevLimitNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryPrevLimitNewResponseBody> body{};

  QueryPrevLimitNewResponse() {}

  explicit QueryPrevLimitNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryPrevLimitNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryPrevLimitNewResponseBody>(model1);
      }
    }
  }


  virtual ~QueryPrevLimitNewResponse() = default;
};
class QuerySaasRecordRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizType{};
  shared_ptr<string> indexCol{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> result{};
  shared_ptr<long> taskId{};
  shared_ptr<long> taskInstanceId{};

  QuerySaasRecordRequest() {}

  explicit QuerySaasRecordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (indexCol) {
      res["IndexCol"] = boost::any(*indexCol);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskInstanceId) {
      res["TaskInstanceId"] = boost::any(*taskInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("IndexCol") != m.end() && !m["IndexCol"].empty()) {
      indexCol = make_shared<string>(boost::any_cast<string>(m["IndexCol"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<long>(boost::any_cast<long>(m["Result"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("TaskInstanceId") != m.end() && !m["TaskInstanceId"].empty()) {
      taskInstanceId = make_shared<long>(boost::any_cast<long>(m["TaskInstanceId"]));
    }
  }


  virtual ~QuerySaasRecordRequest() = default;
};
class QuerySaasRecordResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<string> data{};

  QuerySaasRecordResponseBody() {}

  explicit QuerySaasRecordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
  }


  virtual ~QuerySaasRecordResponseBody() = default;
};
class QuerySaasRecordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySaasRecordResponseBody> body{};

  QuerySaasRecordResponse() {}

  explicit QuerySaasRecordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySaasRecordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySaasRecordResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySaasRecordResponse() = default;
};
class QuerySaasRecordNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizType{};
  shared_ptr<string> indexCol{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> result{};
  shared_ptr<long> taskId{};
  shared_ptr<long> taskInstanceId{};

  QuerySaasRecordNewRequest() {}

  explicit QuerySaasRecordNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (indexCol) {
      res["IndexCol"] = boost::any(*indexCol);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskInstanceId) {
      res["TaskInstanceId"] = boost::any(*taskInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("IndexCol") != m.end() && !m["IndexCol"].empty()) {
      indexCol = make_shared<string>(boost::any_cast<string>(m["IndexCol"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<long>(boost::any_cast<long>(m["Result"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("TaskInstanceId") != m.end() && !m["TaskInstanceId"].empty()) {
      taskInstanceId = make_shared<long>(boost::any_cast<long>(m["TaskInstanceId"]));
    }
  }


  virtual ~QuerySaasRecordNewRequest() = default;
};
class QuerySaasRecordNewResponseBodyListSaasRecord : public Darabonba::Model {
public:
  shared_ptr<string> bizType{};
  shared_ptr<long> detailPkId{};
  shared_ptr<string> indexCol{};
  shared_ptr<string> lastDealDate{};
  shared_ptr<string> recordBizExpireDate{};
  shared_ptr<string> result{};
  shared_ptr<string> resultDesc{};
  shared_ptr<string> saasContent{};
  shared_ptr<string> suggestion{};

  QuerySaasRecordNewResponseBodyListSaasRecord() {}

  explicit QuerySaasRecordNewResponseBodyListSaasRecord(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (detailPkId) {
      res["DetailPkId"] = boost::any(*detailPkId);
    }
    if (indexCol) {
      res["IndexCol"] = boost::any(*indexCol);
    }
    if (lastDealDate) {
      res["LastDealDate"] = boost::any(*lastDealDate);
    }
    if (recordBizExpireDate) {
      res["RecordBizExpireDate"] = boost::any(*recordBizExpireDate);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (resultDesc) {
      res["ResultDesc"] = boost::any(*resultDesc);
    }
    if (saasContent) {
      res["SaasContent"] = boost::any(*saasContent);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("DetailPkId") != m.end() && !m["DetailPkId"].empty()) {
      detailPkId = make_shared<long>(boost::any_cast<long>(m["DetailPkId"]));
    }
    if (m.find("IndexCol") != m.end() && !m["IndexCol"].empty()) {
      indexCol = make_shared<string>(boost::any_cast<string>(m["IndexCol"]));
    }
    if (m.find("LastDealDate") != m.end() && !m["LastDealDate"].empty()) {
      lastDealDate = make_shared<string>(boost::any_cast<string>(m["LastDealDate"]));
    }
    if (m.find("RecordBizExpireDate") != m.end() && !m["RecordBizExpireDate"].empty()) {
      recordBizExpireDate = make_shared<string>(boost::any_cast<string>(m["RecordBizExpireDate"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("ResultDesc") != m.end() && !m["ResultDesc"].empty()) {
      resultDesc = make_shared<string>(boost::any_cast<string>(m["ResultDesc"]));
    }
    if (m.find("SaasContent") != m.end() && !m["SaasContent"].empty()) {
      saasContent = make_shared<string>(boost::any_cast<string>(m["SaasContent"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
  }


  virtual ~QuerySaasRecordNewResponseBodyListSaasRecord() = default;
};
class QuerySaasRecordNewResponseBodyList : public Darabonba::Model {
public:
  shared_ptr<vector<QuerySaasRecordNewResponseBodyListSaasRecord>> saasRecord{};

  QuerySaasRecordNewResponseBodyList() {}

  explicit QuerySaasRecordNewResponseBodyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (saasRecord) {
      vector<boost::any> temp1;
      for(auto item1:*saasRecord){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SaasRecord"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SaasRecord") != m.end() && !m["SaasRecord"].empty()) {
      if (typeid(vector<boost::any>) == m["SaasRecord"].type()) {
        vector<QuerySaasRecordNewResponseBodyListSaasRecord> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SaasRecord"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySaasRecordNewResponseBodyListSaasRecord model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        saasRecord = make_shared<vector<QuerySaasRecordNewResponseBodyListSaasRecord>>(expect1);
      }
    }
  }


  virtual ~QuerySaasRecordNewResponseBodyList() = default;
};
class QuerySaasRecordNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<QuerySaasRecordNewResponseBodyList> list{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  QuerySaasRecordNewResponseBody() {}

  explicit QuerySaasRecordNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QuerySaasRecordNewResponseBodyList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QuerySaasRecordNewResponseBodyList>(model1);
      }
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QuerySaasRecordNewResponseBody() = default;
};
class QuerySaasRecordNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySaasRecordNewResponseBody> body{};

  QuerySaasRecordNewResponse() {}

  explicit QuerySaasRecordNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySaasRecordNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySaasRecordNewResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySaasRecordNewResponse() = default;
};
class QuerySendDetailsByPhoneNumRequest : public Darabonba::Model {
public:
  shared_ptr<long> bizType{};
  shared_ptr<string> errorCode{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> phoneNum{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> sendDate{};
  shared_ptr<long> sendStatus{};
  shared_ptr<string> signName{};
  shared_ptr<string> templateCode{};

  QuerySendDetailsByPhoneNumRequest() {}

  explicit QuerySendDetailsByPhoneNumRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (phoneNum) {
      res["PhoneNum"] = boost::any(*phoneNum);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sendDate) {
      res["SendDate"] = boost::any(*sendDate);
    }
    if (sendStatus) {
      res["SendStatus"] = boost::any(*sendStatus);
    }
    if (signName) {
      res["SignName"] = boost::any(*signName);
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<long>(boost::any_cast<long>(m["BizType"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PhoneNum") != m.end() && !m["PhoneNum"].empty()) {
      phoneNum = make_shared<string>(boost::any_cast<string>(m["PhoneNum"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SendDate") != m.end() && !m["SendDate"].empty()) {
      sendDate = make_shared<string>(boost::any_cast<string>(m["SendDate"]));
    }
    if (m.find("SendStatus") != m.end() && !m["SendStatus"].empty()) {
      sendStatus = make_shared<long>(boost::any_cast<long>(m["SendStatus"]));
    }
    if (m.find("SignName") != m.end() && !m["SignName"].empty()) {
      signName = make_shared<string>(boost::any_cast<string>(m["SignName"]));
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
  }


  virtual ~QuerySendDetailsByPhoneNumRequest() = default;
};
class QuerySendDetailsByPhoneNumResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<string> data{};

  QuerySendDetailsByPhoneNumResponseBody() {}

  explicit QuerySendDetailsByPhoneNumResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
  }


  virtual ~QuerySendDetailsByPhoneNumResponseBody() = default;
};
class QuerySendDetailsByPhoneNumResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySendDetailsByPhoneNumResponseBody> body{};

  QuerySendDetailsByPhoneNumResponse() {}

  explicit QuerySendDetailsByPhoneNumResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySendDetailsByPhoneNumResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySendDetailsByPhoneNumResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySendDetailsByPhoneNumResponse() = default;
};
class QuerySendDetailsByPhoneNumNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<long> bizType{};
  shared_ptr<string> errorCode{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> phoneNum{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> sendDate{};
  shared_ptr<long> sendStatus{};
  shared_ptr<string> signName{};
  shared_ptr<long> statisticsStatus{};
  shared_ptr<string> templateCode{};

  QuerySendDetailsByPhoneNumNewRequest() {}

  explicit QuerySendDetailsByPhoneNumNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (phoneNum) {
      res["PhoneNum"] = boost::any(*phoneNum);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sendDate) {
      res["SendDate"] = boost::any(*sendDate);
    }
    if (sendStatus) {
      res["SendStatus"] = boost::any(*sendStatus);
    }
    if (signName) {
      res["SignName"] = boost::any(*signName);
    }
    if (statisticsStatus) {
      res["StatisticsStatus"] = boost::any(*statisticsStatus);
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<long>(boost::any_cast<long>(m["BizType"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PhoneNum") != m.end() && !m["PhoneNum"].empty()) {
      phoneNum = make_shared<string>(boost::any_cast<string>(m["PhoneNum"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SendDate") != m.end() && !m["SendDate"].empty()) {
      sendDate = make_shared<string>(boost::any_cast<string>(m["SendDate"]));
    }
    if (m.find("SendStatus") != m.end() && !m["SendStatus"].empty()) {
      sendStatus = make_shared<long>(boost::any_cast<long>(m["SendStatus"]));
    }
    if (m.find("SignName") != m.end() && !m["SignName"].empty()) {
      signName = make_shared<string>(boost::any_cast<string>(m["SignName"]));
    }
    if (m.find("StatisticsStatus") != m.end() && !m["StatisticsStatus"].empty()) {
      statisticsStatus = make_shared<long>(boost::any_cast<long>(m["StatisticsStatus"]));
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
  }


  virtual ~QuerySendDetailsByPhoneNumNewRequest() = default;
};
class QuerySendDetailsByPhoneNumNewResponseBodyListSmsSendDetailResponse : public Darabonba::Model {
public:
  shared_ptr<string> applyDateStr{};
  shared_ptr<long> billCount{};
  shared_ptr<string> bizId{};
  shared_ptr<long> bizType{};
  shared_ptr<long> blackListStatus{};
  shared_ptr<string> content{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errCodeDesc{};
  shared_ptr<string> innerErrCode{};
  shared_ptr<string> outId{};
  shared_ptr<string> phoneNum{};
  shared_ptr<string> receiveDateStr{};
  shared_ptr<string> sendDateStr{};
  shared_ptr<long> sendStatus{};
  shared_ptr<long> smsLength{};
  shared_ptr<long> statisticsStatus{};
  shared_ptr<string> suggestion{};
  shared_ptr<string> templateCode{};

  QuerySendDetailsByPhoneNumNewResponseBodyListSmsSendDetailResponse() {}

  explicit QuerySendDetailsByPhoneNumNewResponseBodyListSmsSendDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyDateStr) {
      res["ApplyDateStr"] = boost::any(*applyDateStr);
    }
    if (billCount) {
      res["BillCount"] = boost::any(*billCount);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (blackListStatus) {
      res["BlackListStatus"] = boost::any(*blackListStatus);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errCodeDesc) {
      res["ErrCodeDesc"] = boost::any(*errCodeDesc);
    }
    if (innerErrCode) {
      res["InnerErrCode"] = boost::any(*innerErrCode);
    }
    if (outId) {
      res["OutId"] = boost::any(*outId);
    }
    if (phoneNum) {
      res["PhoneNum"] = boost::any(*phoneNum);
    }
    if (receiveDateStr) {
      res["ReceiveDateStr"] = boost::any(*receiveDateStr);
    }
    if (sendDateStr) {
      res["SendDateStr"] = boost::any(*sendDateStr);
    }
    if (sendStatus) {
      res["SendStatus"] = boost::any(*sendStatus);
    }
    if (smsLength) {
      res["SmsLength"] = boost::any(*smsLength);
    }
    if (statisticsStatus) {
      res["StatisticsStatus"] = boost::any(*statisticsStatus);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplyDateStr") != m.end() && !m["ApplyDateStr"].empty()) {
      applyDateStr = make_shared<string>(boost::any_cast<string>(m["ApplyDateStr"]));
    }
    if (m.find("BillCount") != m.end() && !m["BillCount"].empty()) {
      billCount = make_shared<long>(boost::any_cast<long>(m["BillCount"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<long>(boost::any_cast<long>(m["BizType"]));
    }
    if (m.find("BlackListStatus") != m.end() && !m["BlackListStatus"].empty()) {
      blackListStatus = make_shared<long>(boost::any_cast<long>(m["BlackListStatus"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrCodeDesc") != m.end() && !m["ErrCodeDesc"].empty()) {
      errCodeDesc = make_shared<string>(boost::any_cast<string>(m["ErrCodeDesc"]));
    }
    if (m.find("InnerErrCode") != m.end() && !m["InnerErrCode"].empty()) {
      innerErrCode = make_shared<string>(boost::any_cast<string>(m["InnerErrCode"]));
    }
    if (m.find("OutId") != m.end() && !m["OutId"].empty()) {
      outId = make_shared<string>(boost::any_cast<string>(m["OutId"]));
    }
    if (m.find("PhoneNum") != m.end() && !m["PhoneNum"].empty()) {
      phoneNum = make_shared<string>(boost::any_cast<string>(m["PhoneNum"]));
    }
    if (m.find("ReceiveDateStr") != m.end() && !m["ReceiveDateStr"].empty()) {
      receiveDateStr = make_shared<string>(boost::any_cast<string>(m["ReceiveDateStr"]));
    }
    if (m.find("SendDateStr") != m.end() && !m["SendDateStr"].empty()) {
      sendDateStr = make_shared<string>(boost::any_cast<string>(m["SendDateStr"]));
    }
    if (m.find("SendStatus") != m.end() && !m["SendStatus"].empty()) {
      sendStatus = make_shared<long>(boost::any_cast<long>(m["SendStatus"]));
    }
    if (m.find("SmsLength") != m.end() && !m["SmsLength"].empty()) {
      smsLength = make_shared<long>(boost::any_cast<long>(m["SmsLength"]));
    }
    if (m.find("StatisticsStatus") != m.end() && !m["StatisticsStatus"].empty()) {
      statisticsStatus = make_shared<long>(boost::any_cast<long>(m["StatisticsStatus"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
  }


  virtual ~QuerySendDetailsByPhoneNumNewResponseBodyListSmsSendDetailResponse() = default;
};
class QuerySendDetailsByPhoneNumNewResponseBodyList : public Darabonba::Model {
public:
  shared_ptr<vector<QuerySendDetailsByPhoneNumNewResponseBodyListSmsSendDetailResponse>> smsSendDetailResponse{};

  QuerySendDetailsByPhoneNumNewResponseBodyList() {}

  explicit QuerySendDetailsByPhoneNumNewResponseBodyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (smsSendDetailResponse) {
      vector<boost::any> temp1;
      for(auto item1:*smsSendDetailResponse){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SmsSendDetailResponse"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SmsSendDetailResponse") != m.end() && !m["SmsSendDetailResponse"].empty()) {
      if (typeid(vector<boost::any>) == m["SmsSendDetailResponse"].type()) {
        vector<QuerySendDetailsByPhoneNumNewResponseBodyListSmsSendDetailResponse> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SmsSendDetailResponse"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySendDetailsByPhoneNumNewResponseBodyListSmsSendDetailResponse model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        smsSendDetailResponse = make_shared<vector<QuerySendDetailsByPhoneNumNewResponseBodyListSmsSendDetailResponse>>(expect1);
      }
    }
  }


  virtual ~QuerySendDetailsByPhoneNumNewResponseBodyList() = default;
};
class QuerySendDetailsByPhoneNumNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<QuerySendDetailsByPhoneNumNewResponseBodyList> list{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  QuerySendDetailsByPhoneNumNewResponseBody() {}

  explicit QuerySendDetailsByPhoneNumNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QuerySendDetailsByPhoneNumNewResponseBodyList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QuerySendDetailsByPhoneNumNewResponseBodyList>(model1);
      }
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QuerySendDetailsByPhoneNumNewResponseBody() = default;
};
class QuerySendDetailsByPhoneNumNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySendDetailsByPhoneNumNewResponseBody> body{};

  QuerySendDetailsByPhoneNumNewResponse() {}

  explicit QuerySendDetailsByPhoneNumNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySendDetailsByPhoneNumNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySendDetailsByPhoneNumNewResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySendDetailsByPhoneNumNewResponse() = default;
};
class QuerySendFailDetailsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> prodId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> sendDate{};

  QuerySendFailDetailsRequest() {}

  explicit QuerySendFailDetailsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (prodId) {
      res["ProdId"] = boost::any(*prodId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sendDate) {
      res["SendDate"] = boost::any(*sendDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ProdId") != m.end() && !m["ProdId"].empty()) {
      prodId = make_shared<string>(boost::any_cast<string>(m["ProdId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SendDate") != m.end() && !m["SendDate"].empty()) {
      sendDate = make_shared<string>(boost::any_cast<string>(m["SendDate"]));
    }
  }


  virtual ~QuerySendFailDetailsRequest() = default;
};
class QuerySendFailDetailsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<string> data{};

  QuerySendFailDetailsResponseBody() {}

  explicit QuerySendFailDetailsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
  }


  virtual ~QuerySendFailDetailsResponseBody() = default;
};
class QuerySendFailDetailsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySendFailDetailsResponseBody> body{};

  QuerySendFailDetailsResponse() {}

  explicit QuerySendFailDetailsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySendFailDetailsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySendFailDetailsResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySendFailDetailsResponse() = default;
};
class QuerySendFailDetailsNewRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> prodId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> sendDate{};

  QuerySendFailDetailsNewRequest() {}

  explicit QuerySendFailDetailsNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (prodId) {
      res["ProdId"] = boost::any(*prodId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sendDate) {
      res["SendDate"] = boost::any(*sendDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ProdId") != m.end() && !m["ProdId"].empty()) {
      prodId = make_shared<string>(boost::any_cast<string>(m["ProdId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SendDate") != m.end() && !m["SendDate"].empty()) {
      sendDate = make_shared<string>(boost::any_cast<string>(m["SendDate"]));
    }
  }


  virtual ~QuerySendFailDetailsNewRequest() = default;
};
class QuerySendFailDetailsNewResponseBodyListSmsSendDetailResponse : public Darabonba::Model {
public:
  shared_ptr<long> blackListStatus{};
  shared_ptr<string> content{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errCodeDesc{};
  shared_ptr<string> outId{};
  shared_ptr<string> phoneNum{};
  shared_ptr<string> receiveDateStr{};
  shared_ptr<string> sendDateStr{};
  shared_ptr<long> sendStatus{};
  shared_ptr<string> suggestion{};
  shared_ptr<string> templateCode{};

  QuerySendFailDetailsNewResponseBodyListSmsSendDetailResponse() {}

  explicit QuerySendFailDetailsNewResponseBodyListSmsSendDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blackListStatus) {
      res["BlackListStatus"] = boost::any(*blackListStatus);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errCodeDesc) {
      res["ErrCodeDesc"] = boost::any(*errCodeDesc);
    }
    if (outId) {
      res["OutId"] = boost::any(*outId);
    }
    if (phoneNum) {
      res["PhoneNum"] = boost::any(*phoneNum);
    }
    if (receiveDateStr) {
      res["ReceiveDateStr"] = boost::any(*receiveDateStr);
    }
    if (sendDateStr) {
      res["SendDateStr"] = boost::any(*sendDateStr);
    }
    if (sendStatus) {
      res["SendStatus"] = boost::any(*sendStatus);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlackListStatus") != m.end() && !m["BlackListStatus"].empty()) {
      blackListStatus = make_shared<long>(boost::any_cast<long>(m["BlackListStatus"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrCodeDesc") != m.end() && !m["ErrCodeDesc"].empty()) {
      errCodeDesc = make_shared<string>(boost::any_cast<string>(m["ErrCodeDesc"]));
    }
    if (m.find("OutId") != m.end() && !m["OutId"].empty()) {
      outId = make_shared<string>(boost::any_cast<string>(m["OutId"]));
    }
    if (m.find("PhoneNum") != m.end() && !m["PhoneNum"].empty()) {
      phoneNum = make_shared<string>(boost::any_cast<string>(m["PhoneNum"]));
    }
    if (m.find("ReceiveDateStr") != m.end() && !m["ReceiveDateStr"].empty()) {
      receiveDateStr = make_shared<string>(boost::any_cast<string>(m["ReceiveDateStr"]));
    }
    if (m.find("SendDateStr") != m.end() && !m["SendDateStr"].empty()) {
      sendDateStr = make_shared<string>(boost::any_cast<string>(m["SendDateStr"]));
    }
    if (m.find("SendStatus") != m.end() && !m["SendStatus"].empty()) {
      sendStatus = make_shared<long>(boost::any_cast<long>(m["SendStatus"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
  }


  virtual ~QuerySendFailDetailsNewResponseBodyListSmsSendDetailResponse() = default;
};
class QuerySendFailDetailsNewResponseBodyList : public Darabonba::Model {
public:
  shared_ptr<vector<QuerySendFailDetailsNewResponseBodyListSmsSendDetailResponse>> smsSendDetailResponse{};

  QuerySendFailDetailsNewResponseBodyList() {}

  explicit QuerySendFailDetailsNewResponseBodyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (smsSendDetailResponse) {
      vector<boost::any> temp1;
      for(auto item1:*smsSendDetailResponse){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SmsSendDetailResponse"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SmsSendDetailResponse") != m.end() && !m["SmsSendDetailResponse"].empty()) {
      if (typeid(vector<boost::any>) == m["SmsSendDetailResponse"].type()) {
        vector<QuerySendFailDetailsNewResponseBodyListSmsSendDetailResponse> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SmsSendDetailResponse"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySendFailDetailsNewResponseBodyListSmsSendDetailResponse model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        smsSendDetailResponse = make_shared<vector<QuerySendFailDetailsNewResponseBodyListSmsSendDetailResponse>>(expect1);
      }
    }
  }


  virtual ~QuerySendFailDetailsNewResponseBodyList() = default;
};
class QuerySendFailDetailsNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> applyDateStr{};
  shared_ptr<long> billCount{};
  shared_ptr<long> bizType{};
  shared_ptr<string> innerErrCode{};
  shared_ptr<QuerySendFailDetailsNewResponseBodyList> list{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> smsLength{};
  shared_ptr<long> total{};

  QuerySendFailDetailsNewResponseBody() {}

  explicit QuerySendFailDetailsNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyDateStr) {
      res["ApplyDateStr"] = boost::any(*applyDateStr);
    }
    if (billCount) {
      res["BillCount"] = boost::any(*billCount);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (innerErrCode) {
      res["InnerErrCode"] = boost::any(*innerErrCode);
    }
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (smsLength) {
      res["SmsLength"] = boost::any(*smsLength);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplyDateStr") != m.end() && !m["ApplyDateStr"].empty()) {
      applyDateStr = make_shared<string>(boost::any_cast<string>(m["ApplyDateStr"]));
    }
    if (m.find("BillCount") != m.end() && !m["BillCount"].empty()) {
      billCount = make_shared<long>(boost::any_cast<long>(m["BillCount"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<long>(boost::any_cast<long>(m["BizType"]));
    }
    if (m.find("InnerErrCode") != m.end() && !m["InnerErrCode"].empty()) {
      innerErrCode = make_shared<string>(boost::any_cast<string>(m["InnerErrCode"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QuerySendFailDetailsNewResponseBodyList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QuerySendFailDetailsNewResponseBodyList>(model1);
      }
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SmsLength") != m.end() && !m["SmsLength"].empty()) {
      smsLength = make_shared<long>(boost::any_cast<long>(m["SmsLength"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QuerySendFailDetailsNewResponseBody() = default;
};
class QuerySendFailDetailsNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySendFailDetailsNewResponseBody> body{};

  QuerySendFailDetailsNewResponse() {}

  explicit QuerySendFailDetailsNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySendFailDetailsNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySendFailDetailsNewResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySendFailDetailsNewResponse() = default;
};
class QuerySendToGlobeStatusRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QuerySendToGlobeStatusRequest() {}

  explicit QuerySendToGlobeStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QuerySendToGlobeStatusRequest() = default;
};
class QuerySendToGlobeStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  QuerySendToGlobeStatusResponseBody() {}

  explicit QuerySendToGlobeStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QuerySendToGlobeStatusResponseBody() = default;
};
class QuerySendToGlobeStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySendToGlobeStatusResponseBody> body{};

  QuerySendToGlobeStatusResponse() {}

  explicit QuerySendToGlobeStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySendToGlobeStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySendToGlobeStatusResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySendToGlobeStatusResponse() = default;
};
class QueryShortUrlDetailNewRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> shortUrlId{};

  QueryShortUrlDetailNewRequest() {}

  explicit QueryShortUrlDetailNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (shortUrlId) {
      res["ShortUrlId"] = boost::any(*shortUrlId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ShortUrlId") != m.end() && !m["ShortUrlId"].empty()) {
      shortUrlId = make_shared<string>(boost::any_cast<string>(m["ShortUrlId"]));
    }
  }


  virtual ~QueryShortUrlDetailNewRequest() = default;
};
class QueryShortUrlDetailNewResponseBodyRecord : public Darabonba::Model {
public:
  shared_ptr<string> eventName{};
  shared_ptr<string> gmtCreateTime{};
  shared_ptr<string> gmtInvalidTime{};
  shared_ptr<string> id{};
  shared_ptr<string> shortUrl{};
  shared_ptr<string> sourceUrl{};
  shared_ptr<long> status{};
  shared_ptr<string> totalPv{};
  shared_ptr<string> totalUv{};

  QueryShortUrlDetailNewResponseBodyRecord() {}

  explicit QueryShortUrlDetailNewResponseBodyRecord(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventName) {
      res["EventName"] = boost::any(*eventName);
    }
    if (gmtCreateTime) {
      res["GmtCreateTime"] = boost::any(*gmtCreateTime);
    }
    if (gmtInvalidTime) {
      res["GmtInvalidTime"] = boost::any(*gmtInvalidTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (shortUrl) {
      res["ShortUrl"] = boost::any(*shortUrl);
    }
    if (sourceUrl) {
      res["SourceUrl"] = boost::any(*sourceUrl);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (totalPv) {
      res["TotalPv"] = boost::any(*totalPv);
    }
    if (totalUv) {
      res["TotalUv"] = boost::any(*totalUv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventName") != m.end() && !m["EventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["EventName"]));
    }
    if (m.find("GmtCreateTime") != m.end() && !m["GmtCreateTime"].empty()) {
      gmtCreateTime = make_shared<string>(boost::any_cast<string>(m["GmtCreateTime"]));
    }
    if (m.find("GmtInvalidTime") != m.end() && !m["GmtInvalidTime"].empty()) {
      gmtInvalidTime = make_shared<string>(boost::any_cast<string>(m["GmtInvalidTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ShortUrl") != m.end() && !m["ShortUrl"].empty()) {
      shortUrl = make_shared<string>(boost::any_cast<string>(m["ShortUrl"]));
    }
    if (m.find("SourceUrl") != m.end() && !m["SourceUrl"].empty()) {
      sourceUrl = make_shared<string>(boost::any_cast<string>(m["SourceUrl"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("TotalPv") != m.end() && !m["TotalPv"].empty()) {
      totalPv = make_shared<string>(boost::any_cast<string>(m["TotalPv"]));
    }
    if (m.find("TotalUv") != m.end() && !m["TotalUv"].empty()) {
      totalUv = make_shared<string>(boost::any_cast<string>(m["TotalUv"]));
    }
  }


  virtual ~QueryShortUrlDetailNewResponseBodyRecord() = default;
};
class QueryShortUrlDetailNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> eventName{};
  shared_ptr<string> gmtCreateTime{};
  shared_ptr<string> gmtInvalidTime{};
  shared_ptr<string> id{};
  shared_ptr<vector<QueryShortUrlDetailNewResponseBodyRecord>> record{};
  shared_ptr<string> requestId{};
  shared_ptr<string> shortUrl{};
  shared_ptr<string> sourceUrl{};
  shared_ptr<long> status{};
  shared_ptr<string> totalPv{};
  shared_ptr<string> totalUv{};

  QueryShortUrlDetailNewResponseBody() {}

  explicit QueryShortUrlDetailNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventName) {
      res["EventName"] = boost::any(*eventName);
    }
    if (gmtCreateTime) {
      res["GmtCreateTime"] = boost::any(*gmtCreateTime);
    }
    if (gmtInvalidTime) {
      res["GmtInvalidTime"] = boost::any(*gmtInvalidTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (record) {
      vector<boost::any> temp1;
      for(auto item1:*record){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Record"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (shortUrl) {
      res["ShortUrl"] = boost::any(*shortUrl);
    }
    if (sourceUrl) {
      res["SourceUrl"] = boost::any(*sourceUrl);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (totalPv) {
      res["TotalPv"] = boost::any(*totalPv);
    }
    if (totalUv) {
      res["TotalUv"] = boost::any(*totalUv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventName") != m.end() && !m["EventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["EventName"]));
    }
    if (m.find("GmtCreateTime") != m.end() && !m["GmtCreateTime"].empty()) {
      gmtCreateTime = make_shared<string>(boost::any_cast<string>(m["GmtCreateTime"]));
    }
    if (m.find("GmtInvalidTime") != m.end() && !m["GmtInvalidTime"].empty()) {
      gmtInvalidTime = make_shared<string>(boost::any_cast<string>(m["GmtInvalidTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Record") != m.end() && !m["Record"].empty()) {
      if (typeid(vector<boost::any>) == m["Record"].type()) {
        vector<QueryShortUrlDetailNewResponseBodyRecord> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Record"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryShortUrlDetailNewResponseBodyRecord model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        record = make_shared<vector<QueryShortUrlDetailNewResponseBodyRecord>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ShortUrl") != m.end() && !m["ShortUrl"].empty()) {
      shortUrl = make_shared<string>(boost::any_cast<string>(m["ShortUrl"]));
    }
    if (m.find("SourceUrl") != m.end() && !m["SourceUrl"].empty()) {
      sourceUrl = make_shared<string>(boost::any_cast<string>(m["SourceUrl"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("TotalPv") != m.end() && !m["TotalPv"].empty()) {
      totalPv = make_shared<string>(boost::any_cast<string>(m["TotalPv"]));
    }
    if (m.find("TotalUv") != m.end() && !m["TotalUv"].empty()) {
      totalUv = make_shared<string>(boost::any_cast<string>(m["TotalUv"]));
    }
  }


  virtual ~QueryShortUrlDetailNewResponseBody() = default;
};
class QueryShortUrlDetailNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryShortUrlDetailNewResponseBody> body{};

  QueryShortUrlDetailNewResponse() {}

  explicit QueryShortUrlDetailNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryShortUrlDetailNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryShortUrlDetailNewResponseBody>(model1);
      }
    }
  }


  virtual ~QueryShortUrlDetailNewResponse() = default;
};
class QueryShortUrlListNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> eventName{};
  shared_ptr<string> keyWord{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> shortUrl{};

  QueryShortUrlListNewRequest() {}

  explicit QueryShortUrlListNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventName) {
      res["EventName"] = boost::any(*eventName);
    }
    if (keyWord) {
      res["KeyWord"] = boost::any(*keyWord);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (shortUrl) {
      res["ShortUrl"] = boost::any(*shortUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventName") != m.end() && !m["EventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["EventName"]));
    }
    if (m.find("KeyWord") != m.end() && !m["KeyWord"].empty()) {
      keyWord = make_shared<string>(boost::any_cast<string>(m["KeyWord"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ShortUrl") != m.end() && !m["ShortUrl"].empty()) {
      shortUrl = make_shared<string>(boost::any_cast<string>(m["ShortUrl"]));
    }
  }


  virtual ~QueryShortUrlListNewRequest() = default;
};
class QueryShortUrlListNewResponseBodyListRecord : public Darabonba::Model {
public:
  shared_ptr<string> eventName{};
  shared_ptr<string> gmtCreateTime{};
  shared_ptr<string> gmtInvalidTime{};
  shared_ptr<string> id{};
  shared_ptr<string> reason{};
  shared_ptr<string> shortUrl{};
  shared_ptr<string> sourceUrl{};
  shared_ptr<long> status{};
  shared_ptr<string> totalPv{};
  shared_ptr<string> totalUv{};

  QueryShortUrlListNewResponseBodyListRecord() {}

  explicit QueryShortUrlListNewResponseBodyListRecord(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventName) {
      res["EventName"] = boost::any(*eventName);
    }
    if (gmtCreateTime) {
      res["GmtCreateTime"] = boost::any(*gmtCreateTime);
    }
    if (gmtInvalidTime) {
      res["GmtInvalidTime"] = boost::any(*gmtInvalidTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (shortUrl) {
      res["ShortUrl"] = boost::any(*shortUrl);
    }
    if (sourceUrl) {
      res["SourceUrl"] = boost::any(*sourceUrl);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (totalPv) {
      res["TotalPv"] = boost::any(*totalPv);
    }
    if (totalUv) {
      res["TotalUv"] = boost::any(*totalUv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventName") != m.end() && !m["EventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["EventName"]));
    }
    if (m.find("GmtCreateTime") != m.end() && !m["GmtCreateTime"].empty()) {
      gmtCreateTime = make_shared<string>(boost::any_cast<string>(m["GmtCreateTime"]));
    }
    if (m.find("GmtInvalidTime") != m.end() && !m["GmtInvalidTime"].empty()) {
      gmtInvalidTime = make_shared<string>(boost::any_cast<string>(m["GmtInvalidTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("ShortUrl") != m.end() && !m["ShortUrl"].empty()) {
      shortUrl = make_shared<string>(boost::any_cast<string>(m["ShortUrl"]));
    }
    if (m.find("SourceUrl") != m.end() && !m["SourceUrl"].empty()) {
      sourceUrl = make_shared<string>(boost::any_cast<string>(m["SourceUrl"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("TotalPv") != m.end() && !m["TotalPv"].empty()) {
      totalPv = make_shared<string>(boost::any_cast<string>(m["TotalPv"]));
    }
    if (m.find("TotalUv") != m.end() && !m["TotalUv"].empty()) {
      totalUv = make_shared<string>(boost::any_cast<string>(m["TotalUv"]));
    }
  }


  virtual ~QueryShortUrlListNewResponseBodyListRecord() = default;
};
class QueryShortUrlListNewResponseBodyList : public Darabonba::Model {
public:
  shared_ptr<string> eventName{};
  shared_ptr<string> gmtCreateTime{};
  shared_ptr<string> gmtInvalidTime{};
  shared_ptr<string> id{};
  shared_ptr<string> reason{};
  shared_ptr<vector<QueryShortUrlListNewResponseBodyListRecord>> record{};
  shared_ptr<string> shortUrl{};
  shared_ptr<string> sourceUrl{};
  shared_ptr<long> status{};
  shared_ptr<string> totalPv{};
  shared_ptr<string> totalUv{};

  QueryShortUrlListNewResponseBodyList() {}

  explicit QueryShortUrlListNewResponseBodyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventName) {
      res["EventName"] = boost::any(*eventName);
    }
    if (gmtCreateTime) {
      res["GmtCreateTime"] = boost::any(*gmtCreateTime);
    }
    if (gmtInvalidTime) {
      res["GmtInvalidTime"] = boost::any(*gmtInvalidTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (record) {
      vector<boost::any> temp1;
      for(auto item1:*record){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Record"] = boost::any(temp1);
    }
    if (shortUrl) {
      res["ShortUrl"] = boost::any(*shortUrl);
    }
    if (sourceUrl) {
      res["SourceUrl"] = boost::any(*sourceUrl);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (totalPv) {
      res["TotalPv"] = boost::any(*totalPv);
    }
    if (totalUv) {
      res["TotalUv"] = boost::any(*totalUv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventName") != m.end() && !m["EventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["EventName"]));
    }
    if (m.find("GmtCreateTime") != m.end() && !m["GmtCreateTime"].empty()) {
      gmtCreateTime = make_shared<string>(boost::any_cast<string>(m["GmtCreateTime"]));
    }
    if (m.find("GmtInvalidTime") != m.end() && !m["GmtInvalidTime"].empty()) {
      gmtInvalidTime = make_shared<string>(boost::any_cast<string>(m["GmtInvalidTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("Record") != m.end() && !m["Record"].empty()) {
      if (typeid(vector<boost::any>) == m["Record"].type()) {
        vector<QueryShortUrlListNewResponseBodyListRecord> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Record"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryShortUrlListNewResponseBodyListRecord model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        record = make_shared<vector<QueryShortUrlListNewResponseBodyListRecord>>(expect1);
      }
    }
    if (m.find("ShortUrl") != m.end() && !m["ShortUrl"].empty()) {
      shortUrl = make_shared<string>(boost::any_cast<string>(m["ShortUrl"]));
    }
    if (m.find("SourceUrl") != m.end() && !m["SourceUrl"].empty()) {
      sourceUrl = make_shared<string>(boost::any_cast<string>(m["SourceUrl"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("TotalPv") != m.end() && !m["TotalPv"].empty()) {
      totalPv = make_shared<string>(boost::any_cast<string>(m["TotalPv"]));
    }
    if (m.find("TotalUv") != m.end() && !m["TotalUv"].empty()) {
      totalUv = make_shared<string>(boost::any_cast<string>(m["TotalUv"]));
    }
  }


  virtual ~QueryShortUrlListNewResponseBodyList() = default;
};
class QueryShortUrlListNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<QueryShortUrlListNewResponseBodyList>> list{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  QueryShortUrlListNewResponseBody() {}

  explicit QueryShortUrlListNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<QueryShortUrlListNewResponseBodyList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryShortUrlListNewResponseBodyList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<QueryShortUrlListNewResponseBodyList>>(expect1);
      }
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QueryShortUrlListNewResponseBody() = default;
};
class QueryShortUrlListNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryShortUrlListNewResponseBody> body{};

  QueryShortUrlListNewResponse() {}

  explicit QueryShortUrlListNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryShortUrlListNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryShortUrlListNewResponseBody>(model1);
      }
    }
  }


  virtual ~QueryShortUrlListNewResponse() = default;
};
class QueryShortUrlStatusRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryShortUrlStatusRequest() {}

  explicit QueryShortUrlStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryShortUrlStatusRequest() = default;
};
class QueryShortUrlStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<string> data{};

  QueryShortUrlStatusResponseBody() {}

  explicit QueryShortUrlStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
  }


  virtual ~QueryShortUrlStatusResponseBody() = default;
};
class QueryShortUrlStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryShortUrlStatusResponseBody> body{};

  QueryShortUrlStatusResponse() {}

  explicit QueryShortUrlStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryShortUrlStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryShortUrlStatusResponseBody>(model1);
      }
    }
  }


  virtual ~QueryShortUrlStatusResponse() = default;
};
class QuerySlsStatusNewRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QuerySlsStatusNewRequest() {}

  explicit QuerySlsStatusNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QuerySlsStatusNewRequest() = default;
};
class QuerySlsStatusNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> authorizeStatus{};
  shared_ptr<bool> openStatus{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> requestId{};
  shared_ptr<long> saveTime{};
  shared_ptr<string> uid{};

  QuerySlsStatusNewResponseBody() {}

  explicit QuerySlsStatusNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorizeStatus) {
      res["AuthorizeStatus"] = boost::any(*authorizeStatus);
    }
    if (openStatus) {
      res["OpenStatus"] = boost::any(*openStatus);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (saveTime) {
      res["SaveTime"] = boost::any(*saveTime);
    }
    if (uid) {
      res["Uid"] = boost::any(*uid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthorizeStatus") != m.end() && !m["AuthorizeStatus"].empty()) {
      authorizeStatus = make_shared<bool>(boost::any_cast<bool>(m["AuthorizeStatus"]));
    }
    if (m.find("OpenStatus") != m.end() && !m["OpenStatus"].empty()) {
      openStatus = make_shared<bool>(boost::any_cast<bool>(m["OpenStatus"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SaveTime") != m.end() && !m["SaveTime"].empty()) {
      saveTime = make_shared<long>(boost::any_cast<long>(m["SaveTime"]));
    }
    if (m.find("Uid") != m.end() && !m["Uid"].empty()) {
      uid = make_shared<string>(boost::any_cast<string>(m["Uid"]));
    }
  }


  virtual ~QuerySlsStatusNewResponseBody() = default;
};
class QuerySlsStatusNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySlsStatusNewResponseBody> body{};

  QuerySlsStatusNewResponse() {}

  explicit QuerySlsStatusNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySlsStatusNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySlsStatusNewResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySlsStatusNewResponse() = default;
};
class QuerySmsBaseScreenNewRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QuerySmsBaseScreenNewRequest() {}

  explicit QuerySmsBaseScreenNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QuerySmsBaseScreenNewRequest() = default;
};
class QuerySmsBaseScreenNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> accountBalance{};
  shared_ptr<string> cardAbilityMark{};
  shared_ptr<string> cardCustomerMark{};
  shared_ptr<string> certifyType{};
  shared_ptr<string> channelType{};
  shared_ptr<string> childAccountAuth{};
  shared_ptr<string> creditValue{};
  shared_ptr<string> currentLocale{};
  shared_ptr<long> custFrom{};
  shared_ptr<string> custName{};
  shared_ptr<string> dataAbilityMark{};
  shared_ptr<long> dayuMigrateStatus{};
  shared_ptr<string> invoiceBalance{};
  shared_ptr<string> ipSmsAbilityMark{};
  shared_ptr<bool> isAccountMerged{};
  shared_ptr<bool> isAliInnerUser{};
  shared_ptr<bool> isChineseUser{};
  shared_ptr<bool> isDayuCustomer{};
  shared_ptr<bool> isDayuTopCust{};
  shared_ptr<bool> isMnsForceMigratingCustomer{};
  shared_ptr<bool> isMnsMigratingCustomer{};
  shared_ptr<bool> isNeedAuth{};
  shared_ptr<bool> isOldFisCust{};
  shared_ptr<bool> isOldSms{};
  shared_ptr<bool> isOpened{};
  shared_ptr<bool> isRemainMnsPackage{};
  shared_ptr<bool> isSendSmsToGlobeUser{};
  shared_ptr<bool> isShortUrlNormalUse{};
  shared_ptr<bool> isShortUrlOpened{};
  shared_ptr<bool> isSilentCust{};
  shared_ptr<long> osStatus{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> shortUrlServeTag{};
  shared_ptr<bool> smsMarketingAssistantTag{};
  shared_ptr<string> textAbilityMark{};
  shared_ptr<long> voucherNum{};

  QuerySmsBaseScreenNewResponseBody() {}

  explicit QuerySmsBaseScreenNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountBalance) {
      res["AccountBalance"] = boost::any(*accountBalance);
    }
    if (cardAbilityMark) {
      res["CardAbilityMark"] = boost::any(*cardAbilityMark);
    }
    if (cardCustomerMark) {
      res["CardCustomerMark"] = boost::any(*cardCustomerMark);
    }
    if (certifyType) {
      res["CertifyType"] = boost::any(*certifyType);
    }
    if (channelType) {
      res["ChannelType"] = boost::any(*channelType);
    }
    if (childAccountAuth) {
      res["ChildAccountAuth"] = boost::any(*childAccountAuth);
    }
    if (creditValue) {
      res["CreditValue"] = boost::any(*creditValue);
    }
    if (currentLocale) {
      res["CurrentLocale"] = boost::any(*currentLocale);
    }
    if (custFrom) {
      res["CustFrom"] = boost::any(*custFrom);
    }
    if (custName) {
      res["CustName"] = boost::any(*custName);
    }
    if (dataAbilityMark) {
      res["DataAbilityMark"] = boost::any(*dataAbilityMark);
    }
    if (dayuMigrateStatus) {
      res["DayuMigrateStatus"] = boost::any(*dayuMigrateStatus);
    }
    if (invoiceBalance) {
      res["InvoiceBalance"] = boost::any(*invoiceBalance);
    }
    if (ipSmsAbilityMark) {
      res["IpSmsAbilityMark"] = boost::any(*ipSmsAbilityMark);
    }
    if (isAccountMerged) {
      res["IsAccountMerged"] = boost::any(*isAccountMerged);
    }
    if (isAliInnerUser) {
      res["IsAliInnerUser"] = boost::any(*isAliInnerUser);
    }
    if (isChineseUser) {
      res["IsChineseUser"] = boost::any(*isChineseUser);
    }
    if (isDayuCustomer) {
      res["IsDayuCustomer"] = boost::any(*isDayuCustomer);
    }
    if (isDayuTopCust) {
      res["IsDayuTopCust"] = boost::any(*isDayuTopCust);
    }
    if (isMnsForceMigratingCustomer) {
      res["IsMnsForceMigratingCustomer"] = boost::any(*isMnsForceMigratingCustomer);
    }
    if (isMnsMigratingCustomer) {
      res["IsMnsMigratingCustomer"] = boost::any(*isMnsMigratingCustomer);
    }
    if (isNeedAuth) {
      res["IsNeedAuth"] = boost::any(*isNeedAuth);
    }
    if (isOldFisCust) {
      res["IsOldFisCust"] = boost::any(*isOldFisCust);
    }
    if (isOldSms) {
      res["IsOldSms"] = boost::any(*isOldSms);
    }
    if (isOpened) {
      res["IsOpened"] = boost::any(*isOpened);
    }
    if (isRemainMnsPackage) {
      res["IsRemainMnsPackage"] = boost::any(*isRemainMnsPackage);
    }
    if (isSendSmsToGlobeUser) {
      res["IsSendSmsToGlobeUser"] = boost::any(*isSendSmsToGlobeUser);
    }
    if (isShortUrlNormalUse) {
      res["IsShortUrlNormalUse"] = boost::any(*isShortUrlNormalUse);
    }
    if (isShortUrlOpened) {
      res["IsShortUrlOpened"] = boost::any(*isShortUrlOpened);
    }
    if (isSilentCust) {
      res["IsSilentCust"] = boost::any(*isSilentCust);
    }
    if (osStatus) {
      res["OsStatus"] = boost::any(*osStatus);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (shortUrlServeTag) {
      res["ShortUrlServeTag"] = boost::any(*shortUrlServeTag);
    }
    if (smsMarketingAssistantTag) {
      res["SmsMarketingAssistantTag"] = boost::any(*smsMarketingAssistantTag);
    }
    if (textAbilityMark) {
      res["TextAbilityMark"] = boost::any(*textAbilityMark);
    }
    if (voucherNum) {
      res["VoucherNum"] = boost::any(*voucherNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountBalance") != m.end() && !m["AccountBalance"].empty()) {
      accountBalance = make_shared<string>(boost::any_cast<string>(m["AccountBalance"]));
    }
    if (m.find("CardAbilityMark") != m.end() && !m["CardAbilityMark"].empty()) {
      cardAbilityMark = make_shared<string>(boost::any_cast<string>(m["CardAbilityMark"]));
    }
    if (m.find("CardCustomerMark") != m.end() && !m["CardCustomerMark"].empty()) {
      cardCustomerMark = make_shared<string>(boost::any_cast<string>(m["CardCustomerMark"]));
    }
    if (m.find("CertifyType") != m.end() && !m["CertifyType"].empty()) {
      certifyType = make_shared<string>(boost::any_cast<string>(m["CertifyType"]));
    }
    if (m.find("ChannelType") != m.end() && !m["ChannelType"].empty()) {
      channelType = make_shared<string>(boost::any_cast<string>(m["ChannelType"]));
    }
    if (m.find("ChildAccountAuth") != m.end() && !m["ChildAccountAuth"].empty()) {
      childAccountAuth = make_shared<string>(boost::any_cast<string>(m["ChildAccountAuth"]));
    }
    if (m.find("CreditValue") != m.end() && !m["CreditValue"].empty()) {
      creditValue = make_shared<string>(boost::any_cast<string>(m["CreditValue"]));
    }
    if (m.find("CurrentLocale") != m.end() && !m["CurrentLocale"].empty()) {
      currentLocale = make_shared<string>(boost::any_cast<string>(m["CurrentLocale"]));
    }
    if (m.find("CustFrom") != m.end() && !m["CustFrom"].empty()) {
      custFrom = make_shared<long>(boost::any_cast<long>(m["CustFrom"]));
    }
    if (m.find("CustName") != m.end() && !m["CustName"].empty()) {
      custName = make_shared<string>(boost::any_cast<string>(m["CustName"]));
    }
    if (m.find("DataAbilityMark") != m.end() && !m["DataAbilityMark"].empty()) {
      dataAbilityMark = make_shared<string>(boost::any_cast<string>(m["DataAbilityMark"]));
    }
    if (m.find("DayuMigrateStatus") != m.end() && !m["DayuMigrateStatus"].empty()) {
      dayuMigrateStatus = make_shared<long>(boost::any_cast<long>(m["DayuMigrateStatus"]));
    }
    if (m.find("InvoiceBalance") != m.end() && !m["InvoiceBalance"].empty()) {
      invoiceBalance = make_shared<string>(boost::any_cast<string>(m["InvoiceBalance"]));
    }
    if (m.find("IpSmsAbilityMark") != m.end() && !m["IpSmsAbilityMark"].empty()) {
      ipSmsAbilityMark = make_shared<string>(boost::any_cast<string>(m["IpSmsAbilityMark"]));
    }
    if (m.find("IsAccountMerged") != m.end() && !m["IsAccountMerged"].empty()) {
      isAccountMerged = make_shared<bool>(boost::any_cast<bool>(m["IsAccountMerged"]));
    }
    if (m.find("IsAliInnerUser") != m.end() && !m["IsAliInnerUser"].empty()) {
      isAliInnerUser = make_shared<bool>(boost::any_cast<bool>(m["IsAliInnerUser"]));
    }
    if (m.find("IsChineseUser") != m.end() && !m["IsChineseUser"].empty()) {
      isChineseUser = make_shared<bool>(boost::any_cast<bool>(m["IsChineseUser"]));
    }
    if (m.find("IsDayuCustomer") != m.end() && !m["IsDayuCustomer"].empty()) {
      isDayuCustomer = make_shared<bool>(boost::any_cast<bool>(m["IsDayuCustomer"]));
    }
    if (m.find("IsDayuTopCust") != m.end() && !m["IsDayuTopCust"].empty()) {
      isDayuTopCust = make_shared<bool>(boost::any_cast<bool>(m["IsDayuTopCust"]));
    }
    if (m.find("IsMnsForceMigratingCustomer") != m.end() && !m["IsMnsForceMigratingCustomer"].empty()) {
      isMnsForceMigratingCustomer = make_shared<bool>(boost::any_cast<bool>(m["IsMnsForceMigratingCustomer"]));
    }
    if (m.find("IsMnsMigratingCustomer") != m.end() && !m["IsMnsMigratingCustomer"].empty()) {
      isMnsMigratingCustomer = make_shared<bool>(boost::any_cast<bool>(m["IsMnsMigratingCustomer"]));
    }
    if (m.find("IsNeedAuth") != m.end() && !m["IsNeedAuth"].empty()) {
      isNeedAuth = make_shared<bool>(boost::any_cast<bool>(m["IsNeedAuth"]));
    }
    if (m.find("IsOldFisCust") != m.end() && !m["IsOldFisCust"].empty()) {
      isOldFisCust = make_shared<bool>(boost::any_cast<bool>(m["IsOldFisCust"]));
    }
    if (m.find("IsOldSms") != m.end() && !m["IsOldSms"].empty()) {
      isOldSms = make_shared<bool>(boost::any_cast<bool>(m["IsOldSms"]));
    }
    if (m.find("IsOpened") != m.end() && !m["IsOpened"].empty()) {
      isOpened = make_shared<bool>(boost::any_cast<bool>(m["IsOpened"]));
    }
    if (m.find("IsRemainMnsPackage") != m.end() && !m["IsRemainMnsPackage"].empty()) {
      isRemainMnsPackage = make_shared<bool>(boost::any_cast<bool>(m["IsRemainMnsPackage"]));
    }
    if (m.find("IsSendSmsToGlobeUser") != m.end() && !m["IsSendSmsToGlobeUser"].empty()) {
      isSendSmsToGlobeUser = make_shared<bool>(boost::any_cast<bool>(m["IsSendSmsToGlobeUser"]));
    }
    if (m.find("IsShortUrlNormalUse") != m.end() && !m["IsShortUrlNormalUse"].empty()) {
      isShortUrlNormalUse = make_shared<bool>(boost::any_cast<bool>(m["IsShortUrlNormalUse"]));
    }
    if (m.find("IsShortUrlOpened") != m.end() && !m["IsShortUrlOpened"].empty()) {
      isShortUrlOpened = make_shared<bool>(boost::any_cast<bool>(m["IsShortUrlOpened"]));
    }
    if (m.find("IsSilentCust") != m.end() && !m["IsSilentCust"].empty()) {
      isSilentCust = make_shared<bool>(boost::any_cast<bool>(m["IsSilentCust"]));
    }
    if (m.find("OsStatus") != m.end() && !m["OsStatus"].empty()) {
      osStatus = make_shared<long>(boost::any_cast<long>(m["OsStatus"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ShortUrlServeTag") != m.end() && !m["ShortUrlServeTag"].empty()) {
      shortUrlServeTag = make_shared<bool>(boost::any_cast<bool>(m["ShortUrlServeTag"]));
    }
    if (m.find("SmsMarketingAssistantTag") != m.end() && !m["SmsMarketingAssistantTag"].empty()) {
      smsMarketingAssistantTag = make_shared<bool>(boost::any_cast<bool>(m["SmsMarketingAssistantTag"]));
    }
    if (m.find("TextAbilityMark") != m.end() && !m["TextAbilityMark"].empty()) {
      textAbilityMark = make_shared<string>(boost::any_cast<string>(m["TextAbilityMark"]));
    }
    if (m.find("VoucherNum") != m.end() && !m["VoucherNum"].empty()) {
      voucherNum = make_shared<long>(boost::any_cast<long>(m["VoucherNum"]));
    }
  }


  virtual ~QuerySmsBaseScreenNewResponseBody() = default;
};
class QuerySmsBaseScreenNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySmsBaseScreenNewResponseBody> body{};

  QuerySmsBaseScreenNewResponse() {}

  explicit QuerySmsBaseScreenNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySmsBaseScreenNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySmsBaseScreenNewResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySmsBaseScreenNewResponse() = default;
};
class QuerySmsDetectCountsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QuerySmsDetectCountsRequest() {}

  explicit QuerySmsDetectCountsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QuerySmsDetectCountsRequest() = default;
};
class QuerySmsDetectCountsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  QuerySmsDetectCountsResponseBody() {}

  explicit QuerySmsDetectCountsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QuerySmsDetectCountsResponseBody() = default;
};
class QuerySmsDetectCountsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySmsDetectCountsResponseBody> body{};

  QuerySmsDetectCountsResponse() {}

  explicit QuerySmsDetectCountsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySmsDetectCountsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySmsDetectCountsResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySmsDetectCountsResponse() = default;
};
class QuerySmsDetectCountsNewRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QuerySmsDetectCountsNewRequest() {}

  explicit QuerySmsDetectCountsNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QuerySmsDetectCountsNewRequest() = default;
};
class QuerySmsDetectCountsNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> detectedTimes{};
  shared_ptr<long> leftTimes{};
  shared_ptr<string> requestId{};

  QuerySmsDetectCountsNewResponseBody() {}

  explicit QuerySmsDetectCountsNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (detectedTimes) {
      res["DetectedTimes"] = boost::any(*detectedTimes);
    }
    if (leftTimes) {
      res["LeftTimes"] = boost::any(*leftTimes);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DetectedTimes") != m.end() && !m["DetectedTimes"].empty()) {
      detectedTimes = make_shared<long>(boost::any_cast<long>(m["DetectedTimes"]));
    }
    if (m.find("LeftTimes") != m.end() && !m["LeftTimes"].empty()) {
      leftTimes = make_shared<long>(boost::any_cast<long>(m["LeftTimes"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QuerySmsDetectCountsNewResponseBody() = default;
};
class QuerySmsDetectCountsNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySmsDetectCountsNewResponseBody> body{};

  QuerySmsDetectCountsNewResponse() {}

  explicit QuerySmsDetectCountsNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySmsDetectCountsNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySmsDetectCountsNewResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySmsDetectCountsNewResponse() = default;
};
class QuerySmsDetectListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QuerySmsDetectListRequest() {}

  explicit QuerySmsDetectListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QuerySmsDetectListRequest() = default;
};
class QuerySmsDetectListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  QuerySmsDetectListResponseBody() {}

  explicit QuerySmsDetectListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QuerySmsDetectListResponseBody() = default;
};
class QuerySmsDetectListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySmsDetectListResponseBody> body{};

  QuerySmsDetectListResponse() {}

  explicit QuerySmsDetectListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySmsDetectListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySmsDetectListResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySmsDetectListResponse() = default;
};
class QuerySmsDetectListNewRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QuerySmsDetectListNewRequest() {}

  explicit QuerySmsDetectListNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QuerySmsDetectListNewRequest() = default;
};
class QuerySmsDetectListNewResponseBodyList : public Darabonba::Model {
public:
  shared_ptr<string> detectContent{};
  shared_ptr<string> detectSignName{};
  shared_ptr<string> detectTime{};
  shared_ptr<long> status{};
  shared_ptr<string> successRate{};
  shared_ptr<string> templateCode{};
  shared_ptr<string> templateParam{};

  QuerySmsDetectListNewResponseBodyList() {}

  explicit QuerySmsDetectListNewResponseBodyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (detectContent) {
      res["DetectContent"] = boost::any(*detectContent);
    }
    if (detectSignName) {
      res["DetectSignName"] = boost::any(*detectSignName);
    }
    if (detectTime) {
      res["DetectTime"] = boost::any(*detectTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (successRate) {
      res["SuccessRate"] = boost::any(*successRate);
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    if (templateParam) {
      res["TemplateParam"] = boost::any(*templateParam);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DetectContent") != m.end() && !m["DetectContent"].empty()) {
      detectContent = make_shared<string>(boost::any_cast<string>(m["DetectContent"]));
    }
    if (m.find("DetectSignName") != m.end() && !m["DetectSignName"].empty()) {
      detectSignName = make_shared<string>(boost::any_cast<string>(m["DetectSignName"]));
    }
    if (m.find("DetectTime") != m.end() && !m["DetectTime"].empty()) {
      detectTime = make_shared<string>(boost::any_cast<string>(m["DetectTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("SuccessRate") != m.end() && !m["SuccessRate"].empty()) {
      successRate = make_shared<string>(boost::any_cast<string>(m["SuccessRate"]));
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
    if (m.find("TemplateParam") != m.end() && !m["TemplateParam"].empty()) {
      templateParam = make_shared<string>(boost::any_cast<string>(m["TemplateParam"]));
    }
  }


  virtual ~QuerySmsDetectListNewResponseBodyList() = default;
};
class QuerySmsDetectListNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<QuerySmsDetectListNewResponseBodyList>> list{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  QuerySmsDetectListNewResponseBody() {}

  explicit QuerySmsDetectListNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<QuerySmsDetectListNewResponseBodyList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySmsDetectListNewResponseBodyList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<QuerySmsDetectListNewResponseBodyList>>(expect1);
      }
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QuerySmsDetectListNewResponseBody() = default;
};
class QuerySmsDetectListNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySmsDetectListNewResponseBody> body{};

  QuerySmsDetectListNewResponse() {}

  explicit QuerySmsDetectListNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySmsDetectListNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySmsDetectListNewResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySmsDetectListNewResponse() = default;
};
class QuerySmsPackageDetailRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> packageType{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> status{};

  QuerySmsPackageDetailRequest() {}

  explicit QuerySmsPackageDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (packageType) {
      res["PackageType"] = boost::any(*packageType);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PackageType") != m.end() && !m["PackageType"].empty()) {
      packageType = make_shared<string>(boost::any_cast<string>(m["PackageType"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~QuerySmsPackageDetailRequest() = default;
};
class QuerySmsPackageDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<string> data{};

  QuerySmsPackageDetailResponseBody() {}

  explicit QuerySmsPackageDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
  }


  virtual ~QuerySmsPackageDetailResponseBody() = default;
};
class QuerySmsPackageDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySmsPackageDetailResponseBody> body{};

  QuerySmsPackageDetailResponse() {}

  explicit QuerySmsPackageDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySmsPackageDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySmsPackageDetailResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySmsPackageDetailResponse() = default;
};
class QuerySmsPackageDetailNewRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> packageType{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> status{};

  QuerySmsPackageDetailNewRequest() {}

  explicit QuerySmsPackageDetailNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (packageType) {
      res["PackageType"] = boost::any(*packageType);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PackageType") != m.end() && !m["PackageType"].empty()) {
      packageType = make_shared<string>(boost::any_cast<string>(m["PackageType"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~QuerySmsPackageDetailNewRequest() = default;
};
class QuerySmsPackageDetailNewResponseBodyListSmsPackageDetailDTO : public Darabonba::Model {
public:
  shared_ptr<long> invalidTime{};
  shared_ptr<long> orderTime{};
  shared_ptr<string> packageType{};
  shared_ptr<long> remainCount{};
  shared_ptr<long> status{};
  shared_ptr<long> totalCount{};

  QuerySmsPackageDetailNewResponseBodyListSmsPackageDetailDTO() {}

  explicit QuerySmsPackageDetailNewResponseBodyListSmsPackageDetailDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (invalidTime) {
      res["InvalidTime"] = boost::any(*invalidTime);
    }
    if (orderTime) {
      res["OrderTime"] = boost::any(*orderTime);
    }
    if (packageType) {
      res["PackageType"] = boost::any(*packageType);
    }
    if (remainCount) {
      res["RemainCount"] = boost::any(*remainCount);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InvalidTime") != m.end() && !m["InvalidTime"].empty()) {
      invalidTime = make_shared<long>(boost::any_cast<long>(m["InvalidTime"]));
    }
    if (m.find("OrderTime") != m.end() && !m["OrderTime"].empty()) {
      orderTime = make_shared<long>(boost::any_cast<long>(m["OrderTime"]));
    }
    if (m.find("PackageType") != m.end() && !m["PackageType"].empty()) {
      packageType = make_shared<string>(boost::any_cast<string>(m["PackageType"]));
    }
    if (m.find("RemainCount") != m.end() && !m["RemainCount"].empty()) {
      remainCount = make_shared<long>(boost::any_cast<long>(m["RemainCount"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~QuerySmsPackageDetailNewResponseBodyListSmsPackageDetailDTO() = default;
};
class QuerySmsPackageDetailNewResponseBodyList : public Darabonba::Model {
public:
  shared_ptr<vector<QuerySmsPackageDetailNewResponseBodyListSmsPackageDetailDTO>> smsPackageDetailDTO{};

  QuerySmsPackageDetailNewResponseBodyList() {}

  explicit QuerySmsPackageDetailNewResponseBodyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (smsPackageDetailDTO) {
      vector<boost::any> temp1;
      for(auto item1:*smsPackageDetailDTO){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SmsPackageDetailDTO"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SmsPackageDetailDTO") != m.end() && !m["SmsPackageDetailDTO"].empty()) {
      if (typeid(vector<boost::any>) == m["SmsPackageDetailDTO"].type()) {
        vector<QuerySmsPackageDetailNewResponseBodyListSmsPackageDetailDTO> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SmsPackageDetailDTO"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySmsPackageDetailNewResponseBodyListSmsPackageDetailDTO model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        smsPackageDetailDTO = make_shared<vector<QuerySmsPackageDetailNewResponseBodyListSmsPackageDetailDTO>>(expect1);
      }
    }
  }


  virtual ~QuerySmsPackageDetailNewResponseBodyList() = default;
};
class QuerySmsPackageDetailNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<QuerySmsPackageDetailNewResponseBodyList> list{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> remainSmsCount{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};
  shared_ptr<long> totalSmsCount{};

  QuerySmsPackageDetailNewResponseBody() {}

  explicit QuerySmsPackageDetailNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (remainSmsCount) {
      res["RemainSmsCount"] = boost::any(*remainSmsCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (totalSmsCount) {
      res["TotalSmsCount"] = boost::any(*totalSmsCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QuerySmsPackageDetailNewResponseBodyList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QuerySmsPackageDetailNewResponseBodyList>(model1);
      }
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RemainSmsCount") != m.end() && !m["RemainSmsCount"].empty()) {
      remainSmsCount = make_shared<long>(boost::any_cast<long>(m["RemainSmsCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("TotalSmsCount") != m.end() && !m["TotalSmsCount"].empty()) {
      totalSmsCount = make_shared<long>(boost::any_cast<long>(m["TotalSmsCount"]));
    }
  }


  virtual ~QuerySmsPackageDetailNewResponseBody() = default;
};
class QuerySmsPackageDetailNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySmsPackageDetailNewResponseBody> body{};

  QuerySmsPackageDetailNewResponse() {}

  explicit QuerySmsPackageDetailNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySmsPackageDetailNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySmsPackageDetailNewResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySmsPackageDetailNewResponse() = default;
};
class QuerySmsPackageNewRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> packageType{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> productName{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> state{};
  shared_ptr<string> time{};

  QuerySmsPackageNewRequest() {}

  explicit QuerySmsPackageNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (packageType) {
      res["PackageType"] = boost::any(*packageType);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PackageType") != m.end() && !m["PackageType"].empty()) {
      packageType = make_shared<string>(boost::any_cast<string>(m["PackageType"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<long>(boost::any_cast<long>(m["State"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
  }


  virtual ~QuerySmsPackageNewRequest() = default;
};
class QuerySmsPackageNewResponseBodyListSmsPackageInfo : public Darabonba::Model {
public:
  shared_ptr<string> buyTime{};
  shared_ptr<string> detailOrderId{};
  shared_ptr<string> effTime{};
  shared_ptr<string> expTime{};
  shared_ptr<string> orderId{};
  shared_ptr<string> packageName{};
  shared_ptr<string> packageType{};
  shared_ptr<double> payPrice{};
  shared_ptr<long> pkgId{};
  shared_ptr<long> refundStatus{};
  shared_ptr<long> state{};
  shared_ptr<long> total{};
  shared_ptr<long> usage{};

  QuerySmsPackageNewResponseBodyListSmsPackageInfo() {}

  explicit QuerySmsPackageNewResponseBodyListSmsPackageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (buyTime) {
      res["BuyTime"] = boost::any(*buyTime);
    }
    if (detailOrderId) {
      res["DetailOrderId"] = boost::any(*detailOrderId);
    }
    if (effTime) {
      res["EffTime"] = boost::any(*effTime);
    }
    if (expTime) {
      res["ExpTime"] = boost::any(*expTime);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (packageName) {
      res["PackageName"] = boost::any(*packageName);
    }
    if (packageType) {
      res["PackageType"] = boost::any(*packageType);
    }
    if (payPrice) {
      res["PayPrice"] = boost::any(*payPrice);
    }
    if (pkgId) {
      res["PkgId"] = boost::any(*pkgId);
    }
    if (refundStatus) {
      res["RefundStatus"] = boost::any(*refundStatus);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BuyTime") != m.end() && !m["BuyTime"].empty()) {
      buyTime = make_shared<string>(boost::any_cast<string>(m["BuyTime"]));
    }
    if (m.find("DetailOrderId") != m.end() && !m["DetailOrderId"].empty()) {
      detailOrderId = make_shared<string>(boost::any_cast<string>(m["DetailOrderId"]));
    }
    if (m.find("EffTime") != m.end() && !m["EffTime"].empty()) {
      effTime = make_shared<string>(boost::any_cast<string>(m["EffTime"]));
    }
    if (m.find("ExpTime") != m.end() && !m["ExpTime"].empty()) {
      expTime = make_shared<string>(boost::any_cast<string>(m["ExpTime"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("PackageName") != m.end() && !m["PackageName"].empty()) {
      packageName = make_shared<string>(boost::any_cast<string>(m["PackageName"]));
    }
    if (m.find("PackageType") != m.end() && !m["PackageType"].empty()) {
      packageType = make_shared<string>(boost::any_cast<string>(m["PackageType"]));
    }
    if (m.find("PayPrice") != m.end() && !m["PayPrice"].empty()) {
      payPrice = make_shared<double>(boost::any_cast<double>(m["PayPrice"]));
    }
    if (m.find("PkgId") != m.end() && !m["PkgId"].empty()) {
      pkgId = make_shared<long>(boost::any_cast<long>(m["PkgId"]));
    }
    if (m.find("RefundStatus") != m.end() && !m["RefundStatus"].empty()) {
      refundStatus = make_shared<long>(boost::any_cast<long>(m["RefundStatus"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<long>(boost::any_cast<long>(m["State"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<long>(boost::any_cast<long>(m["Usage"]));
    }
  }


  virtual ~QuerySmsPackageNewResponseBodyListSmsPackageInfo() = default;
};
class QuerySmsPackageNewResponseBodyList : public Darabonba::Model {
public:
  shared_ptr<vector<QuerySmsPackageNewResponseBodyListSmsPackageInfo>> smsPackageInfo{};

  QuerySmsPackageNewResponseBodyList() {}

  explicit QuerySmsPackageNewResponseBodyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (smsPackageInfo) {
      vector<boost::any> temp1;
      for(auto item1:*smsPackageInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SmsPackageInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SmsPackageInfo") != m.end() && !m["SmsPackageInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["SmsPackageInfo"].type()) {
        vector<QuerySmsPackageNewResponseBodyListSmsPackageInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SmsPackageInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySmsPackageNewResponseBodyListSmsPackageInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        smsPackageInfo = make_shared<vector<QuerySmsPackageNewResponseBodyListSmsPackageInfo>>(expect1);
      }
    }
  }


  virtual ~QuerySmsPackageNewResponseBodyList() = default;
};
class QuerySmsPackageNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<QuerySmsPackageNewResponseBodyList> list{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  QuerySmsPackageNewResponseBody() {}

  explicit QuerySmsPackageNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QuerySmsPackageNewResponseBodyList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QuerySmsPackageNewResponseBodyList>(model1);
      }
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QuerySmsPackageNewResponseBody() = default;
};
class QuerySmsPackageNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySmsPackageNewResponseBody> body{};

  QuerySmsPackageNewResponse() {}

  explicit QuerySmsPackageNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySmsPackageNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySmsPackageNewResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySmsPackageNewResponse() = default;
};
class QuerySmsPackageOrderListRequest : public Darabonba::Model {
public:
  shared_ptr<string> billCycle{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QuerySmsPackageOrderListRequest() {}

  explicit QuerySmsPackageOrderListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billCycle) {
      res["BillCycle"] = boost::any(*billCycle);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BillCycle") != m.end() && !m["BillCycle"].empty()) {
      billCycle = make_shared<string>(boost::any_cast<string>(m["BillCycle"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QuerySmsPackageOrderListRequest() = default;
};
class QuerySmsPackageOrderListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<string> data{};

  QuerySmsPackageOrderListResponseBody() {}

  explicit QuerySmsPackageOrderListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
  }


  virtual ~QuerySmsPackageOrderListResponseBody() = default;
};
class QuerySmsPackageOrderListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySmsPackageOrderListResponseBody> body{};

  QuerySmsPackageOrderListResponse() {}

  explicit QuerySmsPackageOrderListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySmsPackageOrderListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySmsPackageOrderListResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySmsPackageOrderListResponse() = default;
};
class QuerySmsPackageOrderListNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> billCycle{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QuerySmsPackageOrderListNewRequest() {}

  explicit QuerySmsPackageOrderListNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billCycle) {
      res["BillCycle"] = boost::any(*billCycle);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BillCycle") != m.end() && !m["BillCycle"].empty()) {
      billCycle = make_shared<string>(boost::any_cast<string>(m["BillCycle"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QuerySmsPackageOrderListNewRequest() = default;
};
class QuerySmsPackageOrderListNewResponseBodyListSmsPackageOrderResponse : public Darabonba::Model {
public:
  shared_ptr<string> effectDate{};
  shared_ptr<string> expireDate{};
  shared_ptr<string> name{};
  shared_ptr<string> payPrice{};
  shared_ptr<long> state{};

  QuerySmsPackageOrderListNewResponseBodyListSmsPackageOrderResponse() {}

  explicit QuerySmsPackageOrderListNewResponseBodyListSmsPackageOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (effectDate) {
      res["EffectDate"] = boost::any(*effectDate);
    }
    if (expireDate) {
      res["ExpireDate"] = boost::any(*expireDate);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (payPrice) {
      res["PayPrice"] = boost::any(*payPrice);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EffectDate") != m.end() && !m["EffectDate"].empty()) {
      effectDate = make_shared<string>(boost::any_cast<string>(m["EffectDate"]));
    }
    if (m.find("ExpireDate") != m.end() && !m["ExpireDate"].empty()) {
      expireDate = make_shared<string>(boost::any_cast<string>(m["ExpireDate"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PayPrice") != m.end() && !m["PayPrice"].empty()) {
      payPrice = make_shared<string>(boost::any_cast<string>(m["PayPrice"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<long>(boost::any_cast<long>(m["State"]));
    }
  }


  virtual ~QuerySmsPackageOrderListNewResponseBodyListSmsPackageOrderResponse() = default;
};
class QuerySmsPackageOrderListNewResponseBodyList : public Darabonba::Model {
public:
  shared_ptr<vector<QuerySmsPackageOrderListNewResponseBodyListSmsPackageOrderResponse>> smsPackageOrderResponse{};

  QuerySmsPackageOrderListNewResponseBodyList() {}

  explicit QuerySmsPackageOrderListNewResponseBodyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (smsPackageOrderResponse) {
      vector<boost::any> temp1;
      for(auto item1:*smsPackageOrderResponse){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SmsPackageOrderResponse"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SmsPackageOrderResponse") != m.end() && !m["SmsPackageOrderResponse"].empty()) {
      if (typeid(vector<boost::any>) == m["SmsPackageOrderResponse"].type()) {
        vector<QuerySmsPackageOrderListNewResponseBodyListSmsPackageOrderResponse> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SmsPackageOrderResponse"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySmsPackageOrderListNewResponseBodyListSmsPackageOrderResponse model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        smsPackageOrderResponse = make_shared<vector<QuerySmsPackageOrderListNewResponseBodyListSmsPackageOrderResponse>>(expect1);
      }
    }
  }


  virtual ~QuerySmsPackageOrderListNewResponseBodyList() = default;
};
class QuerySmsPackageOrderListNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<QuerySmsPackageOrderListNewResponseBodyList> list{};
  shared_ptr<string> requestId{};

  QuerySmsPackageOrderListNewResponseBody() {}

  explicit QuerySmsPackageOrderListNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QuerySmsPackageOrderListNewResponseBodyList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QuerySmsPackageOrderListNewResponseBodyList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QuerySmsPackageOrderListNewResponseBody() = default;
};
class QuerySmsPackageOrderListNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySmsPackageOrderListNewResponseBody> body{};

  QuerySmsPackageOrderListNewResponse() {}

  explicit QuerySmsPackageOrderListNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySmsPackageOrderListNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySmsPackageOrderListNewResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySmsPackageOrderListNewResponse() = default;
};
class QuerySmsPackageSummaryRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QuerySmsPackageSummaryRequest() {}

  explicit QuerySmsPackageSummaryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QuerySmsPackageSummaryRequest() = default;
};
class QuerySmsPackageSummaryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<string> data{};

  QuerySmsPackageSummaryResponseBody() {}

  explicit QuerySmsPackageSummaryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
  }


  virtual ~QuerySmsPackageSummaryResponseBody() = default;
};
class QuerySmsPackageSummaryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySmsPackageSummaryResponseBody> body{};

  QuerySmsPackageSummaryResponse() {}

  explicit QuerySmsPackageSummaryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySmsPackageSummaryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySmsPackageSummaryResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySmsPackageSummaryResponse() = default;
};
class QuerySmsPackageSummaryNewRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QuerySmsPackageSummaryNewRequest() {}

  explicit QuerySmsPackageSummaryNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QuerySmsPackageSummaryNewRequest() = default;
};
class QuerySmsPackageSummaryNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> certifyType{};
  shared_ptr<long> interPackageCount{};
  shared_ptr<long> interPackageSum{};
  shared_ptr<long> mktPackageCount{};
  shared_ptr<long> mktPackageSum{};
  shared_ptr<string> requestId{};
  shared_ptr<long> smsPackageCount{};
  shared_ptr<long> smsPackageSum{};
  shared_ptr<long> sysPackageCount{};
  shared_ptr<long> sysPackageSum{};

  QuerySmsPackageSummaryNewResponseBody() {}

  explicit QuerySmsPackageSummaryNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certifyType) {
      res["CertifyType"] = boost::any(*certifyType);
    }
    if (interPackageCount) {
      res["InterPackageCount"] = boost::any(*interPackageCount);
    }
    if (interPackageSum) {
      res["InterPackageSum"] = boost::any(*interPackageSum);
    }
    if (mktPackageCount) {
      res["MktPackageCount"] = boost::any(*mktPackageCount);
    }
    if (mktPackageSum) {
      res["MktPackageSum"] = boost::any(*mktPackageSum);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (smsPackageCount) {
      res["SmsPackageCount"] = boost::any(*smsPackageCount);
    }
    if (smsPackageSum) {
      res["SmsPackageSum"] = boost::any(*smsPackageSum);
    }
    if (sysPackageCount) {
      res["SysPackageCount"] = boost::any(*sysPackageCount);
    }
    if (sysPackageSum) {
      res["SysPackageSum"] = boost::any(*sysPackageSum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertifyType") != m.end() && !m["CertifyType"].empty()) {
      certifyType = make_shared<long>(boost::any_cast<long>(m["CertifyType"]));
    }
    if (m.find("InterPackageCount") != m.end() && !m["InterPackageCount"].empty()) {
      interPackageCount = make_shared<long>(boost::any_cast<long>(m["InterPackageCount"]));
    }
    if (m.find("InterPackageSum") != m.end() && !m["InterPackageSum"].empty()) {
      interPackageSum = make_shared<long>(boost::any_cast<long>(m["InterPackageSum"]));
    }
    if (m.find("MktPackageCount") != m.end() && !m["MktPackageCount"].empty()) {
      mktPackageCount = make_shared<long>(boost::any_cast<long>(m["MktPackageCount"]));
    }
    if (m.find("MktPackageSum") != m.end() && !m["MktPackageSum"].empty()) {
      mktPackageSum = make_shared<long>(boost::any_cast<long>(m["MktPackageSum"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SmsPackageCount") != m.end() && !m["SmsPackageCount"].empty()) {
      smsPackageCount = make_shared<long>(boost::any_cast<long>(m["SmsPackageCount"]));
    }
    if (m.find("SmsPackageSum") != m.end() && !m["SmsPackageSum"].empty()) {
      smsPackageSum = make_shared<long>(boost::any_cast<long>(m["SmsPackageSum"]));
    }
    if (m.find("SysPackageCount") != m.end() && !m["SysPackageCount"].empty()) {
      sysPackageCount = make_shared<long>(boost::any_cast<long>(m["SysPackageCount"]));
    }
    if (m.find("SysPackageSum") != m.end() && !m["SysPackageSum"].empty()) {
      sysPackageSum = make_shared<long>(boost::any_cast<long>(m["SysPackageSum"]));
    }
  }


  virtual ~QuerySmsPackageSummaryNewResponseBody() = default;
};
class QuerySmsPackageSummaryNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySmsPackageSummaryNewResponseBody> body{};

  QuerySmsPackageSummaryNewResponse() {}

  explicit QuerySmsPackageSummaryNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySmsPackageSummaryNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySmsPackageSummaryNewResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySmsPackageSummaryNewResponse() = default;
};
class QuerySmsSaasTaskDetailRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> taskId{};
  shared_ptr<long> taskInstanceId{};

  QuerySmsSaasTaskDetailRequest() {}

  explicit QuerySmsSaasTaskDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskInstanceId) {
      res["TaskInstanceId"] = boost::any(*taskInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("TaskInstanceId") != m.end() && !m["TaskInstanceId"].empty()) {
      taskInstanceId = make_shared<long>(boost::any_cast<long>(m["TaskInstanceId"]));
    }
  }


  virtual ~QuerySmsSaasTaskDetailRequest() = default;
};
class QuerySmsSaasTaskDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<string> data{};

  QuerySmsSaasTaskDetailResponseBody() {}

  explicit QuerySmsSaasTaskDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
  }


  virtual ~QuerySmsSaasTaskDetailResponseBody() = default;
};
class QuerySmsSaasTaskDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySmsSaasTaskDetailResponseBody> body{};

  QuerySmsSaasTaskDetailResponse() {}

  explicit QuerySmsSaasTaskDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySmsSaasTaskDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySmsSaasTaskDetailResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySmsSaasTaskDetailResponse() = default;
};
class QuerySmsSaasTaskDetailNewRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> taskId{};

  QuerySmsSaasTaskDetailNewRequest() {}

  explicit QuerySmsSaasTaskDetailNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
  }


  virtual ~QuerySmsSaasTaskDetailNewRequest() = default;
};
class QuerySmsSaasTaskDetailNewResponseBodyPhoneList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> phoneNum{};

  QuerySmsSaasTaskDetailNewResponseBodyPhoneList() {}

  explicit QuerySmsSaasTaskDetailNewResponseBodyPhoneList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (phoneNum) {
      res["phoneNum"] = boost::any(*phoneNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("phoneNum") != m.end() && !m["phoneNum"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["phoneNum"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["phoneNum"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      phoneNum = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QuerySmsSaasTaskDetailNewResponseBodyPhoneList() = default;
};
class QuerySmsSaasTaskDetailNewResponseBodySaasBaseCommParamParamList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> param{};

  QuerySmsSaasTaskDetailNewResponseBodySaasBaseCommParamParamList() {}

  explicit QuerySmsSaasTaskDetailNewResponseBodySaasBaseCommParamParamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (param) {
      res["Param"] = boost::any(*param);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Param") != m.end() && !m["Param"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Param"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Param"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      param = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QuerySmsSaasTaskDetailNewResponseBodySaasBaseCommParamParamList() = default;
};
class QuerySmsSaasTaskDetailNewResponseBodySaasBaseCommParam : public Darabonba::Model {
public:
  shared_ptr<long> aliyunUid{};
  shared_ptr<long> billCount{};
  shared_ptr<long> byteCount{};
  shared_ptr<string> clientIp{};
  shared_ptr<long> custId{};
  shared_ptr<long> cycleNum{};
  shared_ptr<QuerySmsSaasTaskDetailNewResponseBodySaasBaseCommParamParamList> paramList{};
  shared_ptr<long> partnerId{};
  shared_ptr<string> signature{};
  shared_ptr<string> smsContent{};
  shared_ptr<string> smsTemplateCode{};
  shared_ptr<string> taskErrorCase{};
  shared_ptr<string> taskErrorSuggestion{};

  QuerySmsSaasTaskDetailNewResponseBodySaasBaseCommParam() {}

  explicit QuerySmsSaasTaskDetailNewResponseBodySaasBaseCommParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunUid) {
      res["AliyunUid"] = boost::any(*aliyunUid);
    }
    if (billCount) {
      res["BillCount"] = boost::any(*billCount);
    }
    if (byteCount) {
      res["ByteCount"] = boost::any(*byteCount);
    }
    if (clientIp) {
      res["ClientIp"] = boost::any(*clientIp);
    }
    if (custId) {
      res["CustId"] = boost::any(*custId);
    }
    if (cycleNum) {
      res["CycleNum"] = boost::any(*cycleNum);
    }
    if (paramList) {
      res["ParamList"] = paramList ? boost::any(paramList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (partnerId) {
      res["PartnerId"] = boost::any(*partnerId);
    }
    if (signature) {
      res["Signature"] = boost::any(*signature);
    }
    if (smsContent) {
      res["SmsContent"] = boost::any(*smsContent);
    }
    if (smsTemplateCode) {
      res["SmsTemplateCode"] = boost::any(*smsTemplateCode);
    }
    if (taskErrorCase) {
      res["TaskErrorCase"] = boost::any(*taskErrorCase);
    }
    if (taskErrorSuggestion) {
      res["TaskErrorSuggestion"] = boost::any(*taskErrorSuggestion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunUid") != m.end() && !m["AliyunUid"].empty()) {
      aliyunUid = make_shared<long>(boost::any_cast<long>(m["AliyunUid"]));
    }
    if (m.find("BillCount") != m.end() && !m["BillCount"].empty()) {
      billCount = make_shared<long>(boost::any_cast<long>(m["BillCount"]));
    }
    if (m.find("ByteCount") != m.end() && !m["ByteCount"].empty()) {
      byteCount = make_shared<long>(boost::any_cast<long>(m["ByteCount"]));
    }
    if (m.find("ClientIp") != m.end() && !m["ClientIp"].empty()) {
      clientIp = make_shared<string>(boost::any_cast<string>(m["ClientIp"]));
    }
    if (m.find("CustId") != m.end() && !m["CustId"].empty()) {
      custId = make_shared<long>(boost::any_cast<long>(m["CustId"]));
    }
    if (m.find("CycleNum") != m.end() && !m["CycleNum"].empty()) {
      cycleNum = make_shared<long>(boost::any_cast<long>(m["CycleNum"]));
    }
    if (m.find("ParamList") != m.end() && !m["ParamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ParamList"].type()) {
        QuerySmsSaasTaskDetailNewResponseBodySaasBaseCommParamParamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ParamList"]));
        paramList = make_shared<QuerySmsSaasTaskDetailNewResponseBodySaasBaseCommParamParamList>(model1);
      }
    }
    if (m.find("PartnerId") != m.end() && !m["PartnerId"].empty()) {
      partnerId = make_shared<long>(boost::any_cast<long>(m["PartnerId"]));
    }
    if (m.find("Signature") != m.end() && !m["Signature"].empty()) {
      signature = make_shared<string>(boost::any_cast<string>(m["Signature"]));
    }
    if (m.find("SmsContent") != m.end() && !m["SmsContent"].empty()) {
      smsContent = make_shared<string>(boost::any_cast<string>(m["SmsContent"]));
    }
    if (m.find("SmsTemplateCode") != m.end() && !m["SmsTemplateCode"].empty()) {
      smsTemplateCode = make_shared<string>(boost::any_cast<string>(m["SmsTemplateCode"]));
    }
    if (m.find("TaskErrorCase") != m.end() && !m["TaskErrorCase"].empty()) {
      taskErrorCase = make_shared<string>(boost::any_cast<string>(m["TaskErrorCase"]));
    }
    if (m.find("TaskErrorSuggestion") != m.end() && !m["TaskErrorSuggestion"].empty()) {
      taskErrorSuggestion = make_shared<string>(boost::any_cast<string>(m["TaskErrorSuggestion"]));
    }
  }


  virtual ~QuerySmsSaasTaskDetailNewResponseBodySaasBaseCommParam() = default;
};
class QuerySmsSaasTaskDetailNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> bizType{};
  shared_ptr<string> detailDownloadUrl{};
  shared_ptr<string> detailDownloadUrlForSuccess{};
  shared_ptr<string> extParams{};
  shared_ptr<long> failCount{};
  shared_ptr<string> fireTime{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<bool> isDeleted{};
  shared_ptr<bool> isPermitOrder{};
  shared_ptr<bool> isPermitOrderForSuccess{};
  shared_ptr<string> ossFilePath{};
  shared_ptr<QuerySmsSaasTaskDetailNewResponseBodyPhoneList> phoneList{};
  shared_ptr<string> requestId{};
  shared_ptr<QuerySmsSaasTaskDetailNewResponseBodySaasBaseCommParam> saasBaseCommParam{};
  shared_ptr<string> saasFileUrl{};
  shared_ptr<string> scheduleType{};
  shared_ptr<string> status{};
  shared_ptr<long> successCount{};
  shared_ptr<long> taskId{};
  shared_ptr<long> taskInstanceId{};
  shared_ptr<string> taskName{};
  shared_ptr<long> totalCount{};

  QuerySmsSaasTaskDetailNewResponseBody() {}

  explicit QuerySmsSaasTaskDetailNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (detailDownloadUrl) {
      res["DetailDownloadUrl"] = boost::any(*detailDownloadUrl);
    }
    if (detailDownloadUrlForSuccess) {
      res["DetailDownloadUrlForSuccess"] = boost::any(*detailDownloadUrlForSuccess);
    }
    if (extParams) {
      res["ExtParams"] = boost::any(*extParams);
    }
    if (failCount) {
      res["FailCount"] = boost::any(*failCount);
    }
    if (fireTime) {
      res["FireTime"] = boost::any(*fireTime);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (isDeleted) {
      res["IsDeleted"] = boost::any(*isDeleted);
    }
    if (isPermitOrder) {
      res["IsPermitOrder"] = boost::any(*isPermitOrder);
    }
    if (isPermitOrderForSuccess) {
      res["IsPermitOrderForSuccess"] = boost::any(*isPermitOrderForSuccess);
    }
    if (ossFilePath) {
      res["OssFilePath"] = boost::any(*ossFilePath);
    }
    if (phoneList) {
      res["PhoneList"] = phoneList ? boost::any(phoneList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (saasBaseCommParam) {
      res["SaasBaseCommParam"] = saasBaseCommParam ? boost::any(saasBaseCommParam->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (saasFileUrl) {
      res["SaasFileUrl"] = boost::any(*saasFileUrl);
    }
    if (scheduleType) {
      res["ScheduleType"] = boost::any(*scheduleType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (successCount) {
      res["SuccessCount"] = boost::any(*successCount);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskInstanceId) {
      res["TaskInstanceId"] = boost::any(*taskInstanceId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("DetailDownloadUrl") != m.end() && !m["DetailDownloadUrl"].empty()) {
      detailDownloadUrl = make_shared<string>(boost::any_cast<string>(m["DetailDownloadUrl"]));
    }
    if (m.find("DetailDownloadUrlForSuccess") != m.end() && !m["DetailDownloadUrlForSuccess"].empty()) {
      detailDownloadUrlForSuccess = make_shared<string>(boost::any_cast<string>(m["DetailDownloadUrlForSuccess"]));
    }
    if (m.find("ExtParams") != m.end() && !m["ExtParams"].empty()) {
      extParams = make_shared<string>(boost::any_cast<string>(m["ExtParams"]));
    }
    if (m.find("FailCount") != m.end() && !m["FailCount"].empty()) {
      failCount = make_shared<long>(boost::any_cast<long>(m["FailCount"]));
    }
    if (m.find("FireTime") != m.end() && !m["FireTime"].empty()) {
      fireTime = make_shared<string>(boost::any_cast<string>(m["FireTime"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("IsDeleted") != m.end() && !m["IsDeleted"].empty()) {
      isDeleted = make_shared<bool>(boost::any_cast<bool>(m["IsDeleted"]));
    }
    if (m.find("IsPermitOrder") != m.end() && !m["IsPermitOrder"].empty()) {
      isPermitOrder = make_shared<bool>(boost::any_cast<bool>(m["IsPermitOrder"]));
    }
    if (m.find("IsPermitOrderForSuccess") != m.end() && !m["IsPermitOrderForSuccess"].empty()) {
      isPermitOrderForSuccess = make_shared<bool>(boost::any_cast<bool>(m["IsPermitOrderForSuccess"]));
    }
    if (m.find("OssFilePath") != m.end() && !m["OssFilePath"].empty()) {
      ossFilePath = make_shared<string>(boost::any_cast<string>(m["OssFilePath"]));
    }
    if (m.find("PhoneList") != m.end() && !m["PhoneList"].empty()) {
      if (typeid(map<string, boost::any>) == m["PhoneList"].type()) {
        QuerySmsSaasTaskDetailNewResponseBodyPhoneList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PhoneList"]));
        phoneList = make_shared<QuerySmsSaasTaskDetailNewResponseBodyPhoneList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SaasBaseCommParam") != m.end() && !m["SaasBaseCommParam"].empty()) {
      if (typeid(map<string, boost::any>) == m["SaasBaseCommParam"].type()) {
        QuerySmsSaasTaskDetailNewResponseBodySaasBaseCommParam model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SaasBaseCommParam"]));
        saasBaseCommParam = make_shared<QuerySmsSaasTaskDetailNewResponseBodySaasBaseCommParam>(model1);
      }
    }
    if (m.find("SaasFileUrl") != m.end() && !m["SaasFileUrl"].empty()) {
      saasFileUrl = make_shared<string>(boost::any_cast<string>(m["SaasFileUrl"]));
    }
    if (m.find("ScheduleType") != m.end() && !m["ScheduleType"].empty()) {
      scheduleType = make_shared<string>(boost::any_cast<string>(m["ScheduleType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SuccessCount") != m.end() && !m["SuccessCount"].empty()) {
      successCount = make_shared<long>(boost::any_cast<long>(m["SuccessCount"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("TaskInstanceId") != m.end() && !m["TaskInstanceId"].empty()) {
      taskInstanceId = make_shared<long>(boost::any_cast<long>(m["TaskInstanceId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~QuerySmsSaasTaskDetailNewResponseBody() = default;
};
class QuerySmsSaasTaskDetailNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySmsSaasTaskDetailNewResponseBody> body{};

  QuerySmsSaasTaskDetailNewResponse() {}

  explicit QuerySmsSaasTaskDetailNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySmsSaasTaskDetailNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySmsSaasTaskDetailNewResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySmsSaasTaskDetailNewResponse() = default;
};
class QuerySmsSaasTaskListRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizType{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> serviceType{};
  shared_ptr<string> status{};
  shared_ptr<string> taskName{};

  QuerySmsSaasTaskListRequest() {}

  explicit QuerySmsSaasTaskListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (serviceType) {
      res["ServiceType"] = boost::any(*serviceType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ServiceType") != m.end() && !m["ServiceType"].empty()) {
      serviceType = make_shared<string>(boost::any_cast<string>(m["ServiceType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
  }


  virtual ~QuerySmsSaasTaskListRequest() = default;
};
class QuerySmsSaasTaskListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<string> data{};

  QuerySmsSaasTaskListResponseBody() {}

  explicit QuerySmsSaasTaskListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
  }


  virtual ~QuerySmsSaasTaskListResponseBody() = default;
};
class QuerySmsSaasTaskListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySmsSaasTaskListResponseBody> body{};

  QuerySmsSaasTaskListResponse() {}

  explicit QuerySmsSaasTaskListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySmsSaasTaskListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySmsSaasTaskListResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySmsSaasTaskListResponse() = default;
};
class QuerySmsSaasTaskListNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizType{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> status{};
  shared_ptr<string> taskName{};

  QuerySmsSaasTaskListNewRequest() {}

  explicit QuerySmsSaasTaskListNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
  }


  virtual ~QuerySmsSaasTaskListNewRequest() = default;
};
class QuerySmsSaasTaskListNewResponseBodyListFcSaasTaskDTOCommParams : public Darabonba::Model {
public:
  shared_ptr<long> aliyunUid{};
  shared_ptr<long> custId{};
  shared_ptr<long> cycleNum{};
  shared_ptr<long> partnerId{};

  QuerySmsSaasTaskListNewResponseBodyListFcSaasTaskDTOCommParams() {}

  explicit QuerySmsSaasTaskListNewResponseBodyListFcSaasTaskDTOCommParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunUid) {
      res["AliyunUid"] = boost::any(*aliyunUid);
    }
    if (custId) {
      res["CustId"] = boost::any(*custId);
    }
    if (cycleNum) {
      res["CycleNum"] = boost::any(*cycleNum);
    }
    if (partnerId) {
      res["PartnerId"] = boost::any(*partnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunUid") != m.end() && !m["AliyunUid"].empty()) {
      aliyunUid = make_shared<long>(boost::any_cast<long>(m["AliyunUid"]));
    }
    if (m.find("CustId") != m.end() && !m["CustId"].empty()) {
      custId = make_shared<long>(boost::any_cast<long>(m["CustId"]));
    }
    if (m.find("CycleNum") != m.end() && !m["CycleNum"].empty()) {
      cycleNum = make_shared<long>(boost::any_cast<long>(m["CycleNum"]));
    }
    if (m.find("PartnerId") != m.end() && !m["PartnerId"].empty()) {
      partnerId = make_shared<long>(boost::any_cast<long>(m["PartnerId"]));
    }
  }


  virtual ~QuerySmsSaasTaskListNewResponseBodyListFcSaasTaskDTOCommParams() = default;
};
class QuerySmsSaasTaskListNewResponseBodyListFcSaasTaskDTO : public Darabonba::Model {
public:
  shared_ptr<string> bizType{};
  shared_ptr<QuerySmsSaasTaskListNewResponseBodyListFcSaasTaskDTOCommParams> commParams{};
  shared_ptr<string> detailDownloadUrl{};
  shared_ptr<string> detailDownloadUrlForSuccess{};
  shared_ptr<string> extParams{};
  shared_ptr<long> failCount{};
  shared_ptr<string> fireTime{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<bool> isDeleted{};
  shared_ptr<bool> isPermitOrder{};
  shared_ptr<bool> isPermitOrderForSuccess{};
  shared_ptr<string> ossFilePath{};
  shared_ptr<string> scheduleType{};
  shared_ptr<string> status{};
  shared_ptr<long> successCount{};
  shared_ptr<long> taskId{};
  shared_ptr<long> taskInstanceId{};
  shared_ptr<string> taskName{};
  shared_ptr<long> totalCount{};

  QuerySmsSaasTaskListNewResponseBodyListFcSaasTaskDTO() {}

  explicit QuerySmsSaasTaskListNewResponseBodyListFcSaasTaskDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (commParams) {
      res["CommParams"] = commParams ? boost::any(commParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (detailDownloadUrl) {
      res["DetailDownloadUrl"] = boost::any(*detailDownloadUrl);
    }
    if (detailDownloadUrlForSuccess) {
      res["DetailDownloadUrlForSuccess"] = boost::any(*detailDownloadUrlForSuccess);
    }
    if (extParams) {
      res["ExtParams"] = boost::any(*extParams);
    }
    if (failCount) {
      res["FailCount"] = boost::any(*failCount);
    }
    if (fireTime) {
      res["FireTime"] = boost::any(*fireTime);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (isDeleted) {
      res["IsDeleted"] = boost::any(*isDeleted);
    }
    if (isPermitOrder) {
      res["IsPermitOrder"] = boost::any(*isPermitOrder);
    }
    if (isPermitOrderForSuccess) {
      res["IsPermitOrderForSuccess"] = boost::any(*isPermitOrderForSuccess);
    }
    if (ossFilePath) {
      res["OssFilePath"] = boost::any(*ossFilePath);
    }
    if (scheduleType) {
      res["ScheduleType"] = boost::any(*scheduleType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (successCount) {
      res["SuccessCount"] = boost::any(*successCount);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskInstanceId) {
      res["TaskInstanceId"] = boost::any(*taskInstanceId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("CommParams") != m.end() && !m["CommParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["CommParams"].type()) {
        QuerySmsSaasTaskListNewResponseBodyListFcSaasTaskDTOCommParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CommParams"]));
        commParams = make_shared<QuerySmsSaasTaskListNewResponseBodyListFcSaasTaskDTOCommParams>(model1);
      }
    }
    if (m.find("DetailDownloadUrl") != m.end() && !m["DetailDownloadUrl"].empty()) {
      detailDownloadUrl = make_shared<string>(boost::any_cast<string>(m["DetailDownloadUrl"]));
    }
    if (m.find("DetailDownloadUrlForSuccess") != m.end() && !m["DetailDownloadUrlForSuccess"].empty()) {
      detailDownloadUrlForSuccess = make_shared<string>(boost::any_cast<string>(m["DetailDownloadUrlForSuccess"]));
    }
    if (m.find("ExtParams") != m.end() && !m["ExtParams"].empty()) {
      extParams = make_shared<string>(boost::any_cast<string>(m["ExtParams"]));
    }
    if (m.find("FailCount") != m.end() && !m["FailCount"].empty()) {
      failCount = make_shared<long>(boost::any_cast<long>(m["FailCount"]));
    }
    if (m.find("FireTime") != m.end() && !m["FireTime"].empty()) {
      fireTime = make_shared<string>(boost::any_cast<string>(m["FireTime"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("IsDeleted") != m.end() && !m["IsDeleted"].empty()) {
      isDeleted = make_shared<bool>(boost::any_cast<bool>(m["IsDeleted"]));
    }
    if (m.find("IsPermitOrder") != m.end() && !m["IsPermitOrder"].empty()) {
      isPermitOrder = make_shared<bool>(boost::any_cast<bool>(m["IsPermitOrder"]));
    }
    if (m.find("IsPermitOrderForSuccess") != m.end() && !m["IsPermitOrderForSuccess"].empty()) {
      isPermitOrderForSuccess = make_shared<bool>(boost::any_cast<bool>(m["IsPermitOrderForSuccess"]));
    }
    if (m.find("OssFilePath") != m.end() && !m["OssFilePath"].empty()) {
      ossFilePath = make_shared<string>(boost::any_cast<string>(m["OssFilePath"]));
    }
    if (m.find("ScheduleType") != m.end() && !m["ScheduleType"].empty()) {
      scheduleType = make_shared<string>(boost::any_cast<string>(m["ScheduleType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SuccessCount") != m.end() && !m["SuccessCount"].empty()) {
      successCount = make_shared<long>(boost::any_cast<long>(m["SuccessCount"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("TaskInstanceId") != m.end() && !m["TaskInstanceId"].empty()) {
      taskInstanceId = make_shared<long>(boost::any_cast<long>(m["TaskInstanceId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~QuerySmsSaasTaskListNewResponseBodyListFcSaasTaskDTO() = default;
};
class QuerySmsSaasTaskListNewResponseBodyList : public Darabonba::Model {
public:
  shared_ptr<vector<QuerySmsSaasTaskListNewResponseBodyListFcSaasTaskDTO>> fcSaasTaskDTO{};

  QuerySmsSaasTaskListNewResponseBodyList() {}

  explicit QuerySmsSaasTaskListNewResponseBodyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fcSaasTaskDTO) {
      vector<boost::any> temp1;
      for(auto item1:*fcSaasTaskDTO){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FcSaasTaskDTO"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FcSaasTaskDTO") != m.end() && !m["FcSaasTaskDTO"].empty()) {
      if (typeid(vector<boost::any>) == m["FcSaasTaskDTO"].type()) {
        vector<QuerySmsSaasTaskListNewResponseBodyListFcSaasTaskDTO> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FcSaasTaskDTO"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySmsSaasTaskListNewResponseBodyListFcSaasTaskDTO model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fcSaasTaskDTO = make_shared<vector<QuerySmsSaasTaskListNewResponseBodyListFcSaasTaskDTO>>(expect1);
      }
    }
  }


  virtual ~QuerySmsSaasTaskListNewResponseBodyList() = default;
};
class QuerySmsSaasTaskListNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<QuerySmsSaasTaskListNewResponseBodyList> list{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  QuerySmsSaasTaskListNewResponseBody() {}

  explicit QuerySmsSaasTaskListNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QuerySmsSaasTaskListNewResponseBodyList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QuerySmsSaasTaskListNewResponseBodyList>(model1);
      }
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QuerySmsSaasTaskListNewResponseBody() = default;
};
class QuerySmsSaasTaskListNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySmsSaasTaskListNewResponseBody> body{};

  QuerySmsSaasTaskListNewResponse() {}

  explicit QuerySmsSaasTaskListNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySmsSaasTaskListNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySmsSaasTaskListNewResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySmsSaasTaskListNewResponse() = default;
};
class QuerySmsSendFailDetailsUrlRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> prodId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> sendDate{};

  QuerySmsSendFailDetailsUrlRequest() {}

  explicit QuerySmsSendFailDetailsUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (prodId) {
      res["ProdId"] = boost::any(*prodId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sendDate) {
      res["SendDate"] = boost::any(*sendDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ProdId") != m.end() && !m["ProdId"].empty()) {
      prodId = make_shared<string>(boost::any_cast<string>(m["ProdId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SendDate") != m.end() && !m["SendDate"].empty()) {
      sendDate = make_shared<string>(boost::any_cast<string>(m["SendDate"]));
    }
  }


  virtual ~QuerySmsSendFailDetailsUrlRequest() = default;
};
class QuerySmsSendFailDetailsUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<string> data{};

  QuerySmsSendFailDetailsUrlResponseBody() {}

  explicit QuerySmsSendFailDetailsUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
  }


  virtual ~QuerySmsSendFailDetailsUrlResponseBody() = default;
};
class QuerySmsSendFailDetailsUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySmsSendFailDetailsUrlResponseBody> body{};

  QuerySmsSendFailDetailsUrlResponse() {}

  explicit QuerySmsSendFailDetailsUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySmsSendFailDetailsUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySmsSendFailDetailsUrlResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySmsSendFailDetailsUrlResponse() = default;
};
class QuerySmsSendFailDetailsUrlNewRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> prodId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> sendDate{};

  QuerySmsSendFailDetailsUrlNewRequest() {}

  explicit QuerySmsSendFailDetailsUrlNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (prodId) {
      res["ProdId"] = boost::any(*prodId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sendDate) {
      res["SendDate"] = boost::any(*sendDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ProdId") != m.end() && !m["ProdId"].empty()) {
      prodId = make_shared<string>(boost::any_cast<string>(m["ProdId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SendDate") != m.end() && !m["SendDate"].empty()) {
      sendDate = make_shared<string>(boost::any_cast<string>(m["SendDate"]));
    }
  }


  virtual ~QuerySmsSendFailDetailsUrlNewRequest() = default;
};
class QuerySmsSendFailDetailsUrlNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> downloadUrl{};
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};

  QuerySmsSendFailDetailsUrlNewResponseBody() {}

  explicit QuerySmsSendFailDetailsUrlNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downloadUrl) {
      res["DownloadUrl"] = boost::any(*downloadUrl);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownloadUrl") != m.end() && !m["DownloadUrl"].empty()) {
      downloadUrl = make_shared<string>(boost::any_cast<string>(m["DownloadUrl"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~QuerySmsSendFailDetailsUrlNewResponseBody() = default;
};
class QuerySmsSendFailDetailsUrlNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySmsSendFailDetailsUrlNewResponseBody> body{};

  QuerySmsSendFailDetailsUrlNewResponse() {}

  explicit QuerySmsSendFailDetailsUrlNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySmsSendFailDetailsUrlNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySmsSendFailDetailsUrlNewResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySmsSendFailDetailsUrlNewResponse() = default;
};
class QuerySmsSignDetailBySignIdNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<bool> signGray{};

  QuerySmsSignDetailBySignIdNewRequest() {}

  explicit QuerySmsSignDetailBySignIdNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (signGray) {
      res["SignGray"] = boost::any(*signGray);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SignGray") != m.end() && !m["SignGray"].empty()) {
      signGray = make_shared<bool>(boost::any_cast<bool>(m["SignGray"]));
    }
  }


  virtual ~QuerySmsSignDetailBySignIdNewRequest() = default;
};
class QuerySmsSignDetailBySignIdNewResponseBodyApplicationScene : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};

  QuerySmsSignDetailBySignIdNewResponseBodyApplicationScene() {}

  explicit QuerySmsSignDetailBySignIdNewResponseBodyApplicationScene(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~QuerySmsSignDetailBySignIdNewResponseBodyApplicationScene() = default;
};
class QuerySmsSignDetailBySignIdNewResponseBodyList : public Darabonba::Model {
public:
  shared_ptr<string> auditState{};
  shared_ptr<long> sceneType{};

  QuerySmsSignDetailBySignIdNewResponseBodyList() {}

  explicit QuerySmsSignDetailBySignIdNewResponseBodyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (auditState) {
      res["AuditState"] = boost::any(*auditState);
    }
    if (sceneType) {
      res["SceneType"] = boost::any(*sceneType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuditState") != m.end() && !m["AuditState"].empty()) {
      auditState = make_shared<string>(boost::any_cast<string>(m["AuditState"]));
    }
    if (m.find("SceneType") != m.end() && !m["SceneType"].empty()) {
      sceneType = make_shared<long>(boost::any_cast<long>(m["SceneType"]));
    }
  }


  virtual ~QuerySmsSignDetailBySignIdNewResponseBodyList() = default;
};
class QuerySmsSignDetailBySignIdNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<QuerySmsSignDetailBySignIdNewResponseBodyApplicationScene> applicationScene{};
  shared_ptr<string> auditInfo{};
  shared_ptr<string> auditRemarkInfo{};
  shared_ptr<string> auditState{};
  shared_ptr<string> authorization{};
  shared_ptr<string> authorizationEffTime{};
  shared_ptr<string> authorizationLetter{};
  shared_ptr<bool> authorizationLetterAuditPass{};
  shared_ptr<string> authorizationLetterId{};
  shared_ptr<string> authorizationLetterName{};
  shared_ptr<string> authorizationLetterState{};
  shared_ptr<string> authorizationLetterStatus{};
  shared_ptr<string> authorizationSignScope{};
  shared_ptr<long> effectSceneType{};
  shared_ptr<bool> enableAuthorizationLetter{};
  shared_ptr<string> extendMessage{};
  shared_ptr<vector<long>> fileIds{};
  shared_ptr<vector<string>> fileUrlList{};
  shared_ptr<string> from{};
  shared_ptr<string> gmtCreateStr{};
  shared_ptr<string> id{};
  shared_ptr<bool> isAuthorizationLetterOCRComplete{};
  shared_ptr<bool> isAuthorizationLetterOCRDiff{};
  shared_ptr<bool> isSignScopeOCRDiff{};
  shared_ptr<vector<QuerySmsSignDetailBySignIdNewResponseBodyList>> list{};
  shared_ptr<bool> needAuthorized{};
  shared_ptr<bool> openTag{};
  shared_ptr<string> orderId{};
  shared_ptr<string> organizationCode{};
  shared_ptr<vector<string>> ossKeys{};
  shared_ptr<string> proxyAuthorization{};
  shared_ptr<string> remark{};
  shared_ptr<string> requestId{};
  shared_ptr<long> sceneType{};
  shared_ptr<long> serviceType{};
  shared_ptr<string> signCode{};
  shared_ptr<string> signName{};
  shared_ptr<string> signScopeOCR{};
  shared_ptr<string> signUpgrade{};

  QuerySmsSignDetailBySignIdNewResponseBody() {}

  explicit QuerySmsSignDetailBySignIdNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["AccessToken"] = boost::any(*accessToken);
    }
    if (applicationScene) {
      res["ApplicationScene"] = applicationScene ? boost::any(applicationScene->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (auditInfo) {
      res["AuditInfo"] = boost::any(*auditInfo);
    }
    if (auditRemarkInfo) {
      res["AuditRemarkInfo"] = boost::any(*auditRemarkInfo);
    }
    if (auditState) {
      res["AuditState"] = boost::any(*auditState);
    }
    if (authorization) {
      res["Authorization"] = boost::any(*authorization);
    }
    if (authorizationEffTime) {
      res["AuthorizationEffTime"] = boost::any(*authorizationEffTime);
    }
    if (authorizationLetter) {
      res["AuthorizationLetter"] = boost::any(*authorizationLetter);
    }
    if (authorizationLetterAuditPass) {
      res["AuthorizationLetterAuditPass"] = boost::any(*authorizationLetterAuditPass);
    }
    if (authorizationLetterId) {
      res["AuthorizationLetterId"] = boost::any(*authorizationLetterId);
    }
    if (authorizationLetterName) {
      res["AuthorizationLetterName"] = boost::any(*authorizationLetterName);
    }
    if (authorizationLetterState) {
      res["AuthorizationLetterState"] = boost::any(*authorizationLetterState);
    }
    if (authorizationLetterStatus) {
      res["AuthorizationLetterStatus"] = boost::any(*authorizationLetterStatus);
    }
    if (authorizationSignScope) {
      res["AuthorizationSignScope"] = boost::any(*authorizationSignScope);
    }
    if (effectSceneType) {
      res["EffectSceneType"] = boost::any(*effectSceneType);
    }
    if (enableAuthorizationLetter) {
      res["EnableAuthorizationLetter"] = boost::any(*enableAuthorizationLetter);
    }
    if (extendMessage) {
      res["ExtendMessage"] = boost::any(*extendMessage);
    }
    if (fileIds) {
      res["FileIds"] = boost::any(*fileIds);
    }
    if (fileUrlList) {
      res["FileUrlList"] = boost::any(*fileUrlList);
    }
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (gmtCreateStr) {
      res["GmtCreateStr"] = boost::any(*gmtCreateStr);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (isAuthorizationLetterOCRComplete) {
      res["IsAuthorizationLetterOCRComplete"] = boost::any(*isAuthorizationLetterOCRComplete);
    }
    if (isAuthorizationLetterOCRDiff) {
      res["IsAuthorizationLetterOCRDiff"] = boost::any(*isAuthorizationLetterOCRDiff);
    }
    if (isSignScopeOCRDiff) {
      res["IsSignScopeOCRDiff"] = boost::any(*isSignScopeOCRDiff);
    }
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (needAuthorized) {
      res["NeedAuthorized"] = boost::any(*needAuthorized);
    }
    if (openTag) {
      res["OpenTag"] = boost::any(*openTag);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (organizationCode) {
      res["OrganizationCode"] = boost::any(*organizationCode);
    }
    if (ossKeys) {
      res["OssKeys"] = boost::any(*ossKeys);
    }
    if (proxyAuthorization) {
      res["ProxyAuthorization"] = boost::any(*proxyAuthorization);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sceneType) {
      res["SceneType"] = boost::any(*sceneType);
    }
    if (serviceType) {
      res["ServiceType"] = boost::any(*serviceType);
    }
    if (signCode) {
      res["SignCode"] = boost::any(*signCode);
    }
    if (signName) {
      res["SignName"] = boost::any(*signName);
    }
    if (signScopeOCR) {
      res["SignScopeOCR"] = boost::any(*signScopeOCR);
    }
    if (signUpgrade) {
      res["SignUpgrade"] = boost::any(*signUpgrade);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessToken") != m.end() && !m["AccessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["AccessToken"]));
    }
    if (m.find("ApplicationScene") != m.end() && !m["ApplicationScene"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApplicationScene"].type()) {
        QuerySmsSignDetailBySignIdNewResponseBodyApplicationScene model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApplicationScene"]));
        applicationScene = make_shared<QuerySmsSignDetailBySignIdNewResponseBodyApplicationScene>(model1);
      }
    }
    if (m.find("AuditInfo") != m.end() && !m["AuditInfo"].empty()) {
      auditInfo = make_shared<string>(boost::any_cast<string>(m["AuditInfo"]));
    }
    if (m.find("AuditRemarkInfo") != m.end() && !m["AuditRemarkInfo"].empty()) {
      auditRemarkInfo = make_shared<string>(boost::any_cast<string>(m["AuditRemarkInfo"]));
    }
    if (m.find("AuditState") != m.end() && !m["AuditState"].empty()) {
      auditState = make_shared<string>(boost::any_cast<string>(m["AuditState"]));
    }
    if (m.find("Authorization") != m.end() && !m["Authorization"].empty()) {
      authorization = make_shared<string>(boost::any_cast<string>(m["Authorization"]));
    }
    if (m.find("AuthorizationEffTime") != m.end() && !m["AuthorizationEffTime"].empty()) {
      authorizationEffTime = make_shared<string>(boost::any_cast<string>(m["AuthorizationEffTime"]));
    }
    if (m.find("AuthorizationLetter") != m.end() && !m["AuthorizationLetter"].empty()) {
      authorizationLetter = make_shared<string>(boost::any_cast<string>(m["AuthorizationLetter"]));
    }
    if (m.find("AuthorizationLetterAuditPass") != m.end() && !m["AuthorizationLetterAuditPass"].empty()) {
      authorizationLetterAuditPass = make_shared<bool>(boost::any_cast<bool>(m["AuthorizationLetterAuditPass"]));
    }
    if (m.find("AuthorizationLetterId") != m.end() && !m["AuthorizationLetterId"].empty()) {
      authorizationLetterId = make_shared<string>(boost::any_cast<string>(m["AuthorizationLetterId"]));
    }
    if (m.find("AuthorizationLetterName") != m.end() && !m["AuthorizationLetterName"].empty()) {
      authorizationLetterName = make_shared<string>(boost::any_cast<string>(m["AuthorizationLetterName"]));
    }
    if (m.find("AuthorizationLetterState") != m.end() && !m["AuthorizationLetterState"].empty()) {
      authorizationLetterState = make_shared<string>(boost::any_cast<string>(m["AuthorizationLetterState"]));
    }
    if (m.find("AuthorizationLetterStatus") != m.end() && !m["AuthorizationLetterStatus"].empty()) {
      authorizationLetterStatus = make_shared<string>(boost::any_cast<string>(m["AuthorizationLetterStatus"]));
    }
    if (m.find("AuthorizationSignScope") != m.end() && !m["AuthorizationSignScope"].empty()) {
      authorizationSignScope = make_shared<string>(boost::any_cast<string>(m["AuthorizationSignScope"]));
    }
    if (m.find("EffectSceneType") != m.end() && !m["EffectSceneType"].empty()) {
      effectSceneType = make_shared<long>(boost::any_cast<long>(m["EffectSceneType"]));
    }
    if (m.find("EnableAuthorizationLetter") != m.end() && !m["EnableAuthorizationLetter"].empty()) {
      enableAuthorizationLetter = make_shared<bool>(boost::any_cast<bool>(m["EnableAuthorizationLetter"]));
    }
    if (m.find("ExtendMessage") != m.end() && !m["ExtendMessage"].empty()) {
      extendMessage = make_shared<string>(boost::any_cast<string>(m["ExtendMessage"]));
    }
    if (m.find("FileIds") != m.end() && !m["FileIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["FileIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FileIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      fileIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("FileUrlList") != m.end() && !m["FileUrlList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FileUrlList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FileUrlList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fileUrlList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
    if (m.find("GmtCreateStr") != m.end() && !m["GmtCreateStr"].empty()) {
      gmtCreateStr = make_shared<string>(boost::any_cast<string>(m["GmtCreateStr"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("IsAuthorizationLetterOCRComplete") != m.end() && !m["IsAuthorizationLetterOCRComplete"].empty()) {
      isAuthorizationLetterOCRComplete = make_shared<bool>(boost::any_cast<bool>(m["IsAuthorizationLetterOCRComplete"]));
    }
    if (m.find("IsAuthorizationLetterOCRDiff") != m.end() && !m["IsAuthorizationLetterOCRDiff"].empty()) {
      isAuthorizationLetterOCRDiff = make_shared<bool>(boost::any_cast<bool>(m["IsAuthorizationLetterOCRDiff"]));
    }
    if (m.find("IsSignScopeOCRDiff") != m.end() && !m["IsSignScopeOCRDiff"].empty()) {
      isSignScopeOCRDiff = make_shared<bool>(boost::any_cast<bool>(m["IsSignScopeOCRDiff"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<QuerySmsSignDetailBySignIdNewResponseBodyList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySmsSignDetailBySignIdNewResponseBodyList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<QuerySmsSignDetailBySignIdNewResponseBodyList>>(expect1);
      }
    }
    if (m.find("NeedAuthorized") != m.end() && !m["NeedAuthorized"].empty()) {
      needAuthorized = make_shared<bool>(boost::any_cast<bool>(m["NeedAuthorized"]));
    }
    if (m.find("OpenTag") != m.end() && !m["OpenTag"].empty()) {
      openTag = make_shared<bool>(boost::any_cast<bool>(m["OpenTag"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("OrganizationCode") != m.end() && !m["OrganizationCode"].empty()) {
      organizationCode = make_shared<string>(boost::any_cast<string>(m["OrganizationCode"]));
    }
    if (m.find("OssKeys") != m.end() && !m["OssKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OssKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OssKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ossKeys = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ProxyAuthorization") != m.end() && !m["ProxyAuthorization"].empty()) {
      proxyAuthorization = make_shared<string>(boost::any_cast<string>(m["ProxyAuthorization"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SceneType") != m.end() && !m["SceneType"].empty()) {
      sceneType = make_shared<long>(boost::any_cast<long>(m["SceneType"]));
    }
    if (m.find("ServiceType") != m.end() && !m["ServiceType"].empty()) {
      serviceType = make_shared<long>(boost::any_cast<long>(m["ServiceType"]));
    }
    if (m.find("SignCode") != m.end() && !m["SignCode"].empty()) {
      signCode = make_shared<string>(boost::any_cast<string>(m["SignCode"]));
    }
    if (m.find("SignName") != m.end() && !m["SignName"].empty()) {
      signName = make_shared<string>(boost::any_cast<string>(m["SignName"]));
    }
    if (m.find("SignScopeOCR") != m.end() && !m["SignScopeOCR"].empty()) {
      signScopeOCR = make_shared<string>(boost::any_cast<string>(m["SignScopeOCR"]));
    }
    if (m.find("SignUpgrade") != m.end() && !m["SignUpgrade"].empty()) {
      signUpgrade = make_shared<string>(boost::any_cast<string>(m["SignUpgrade"]));
    }
  }


  virtual ~QuerySmsSignDetailBySignIdNewResponseBody() = default;
};
class QuerySmsSignDetailBySignIdNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySmsSignDetailBySignIdNewResponseBody> body{};

  QuerySmsSignDetailBySignIdNewResponse() {}

  explicit QuerySmsSignDetailBySignIdNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySmsSignDetailBySignIdNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySmsSignDetailBySignIdNewResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySmsSignDetailBySignIdNewResponse() = default;
};
class QuerySmsSignLastRangeRequest : public Darabonba::Model {
public:
  shared_ptr<string> auditState{};
  shared_ptr<string> bizType{};
  shared_ptr<long> isGlobeSign{};
  shared_ptr<long> limit{};
  shared_ptr<bool> needDefaultSign{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> signName{};

  QuerySmsSignLastRangeRequest() {}

  explicit QuerySmsSignLastRangeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (auditState) {
      res["AuditState"] = boost::any(*auditState);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (isGlobeSign) {
      res["IsGlobeSign"] = boost::any(*isGlobeSign);
    }
    if (limit) {
      res["Limit"] = boost::any(*limit);
    }
    if (needDefaultSign) {
      res["NeedDefaultSign"] = boost::any(*needDefaultSign);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (signName) {
      res["SignName"] = boost::any(*signName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuditState") != m.end() && !m["AuditState"].empty()) {
      auditState = make_shared<string>(boost::any_cast<string>(m["AuditState"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("IsGlobeSign") != m.end() && !m["IsGlobeSign"].empty()) {
      isGlobeSign = make_shared<long>(boost::any_cast<long>(m["IsGlobeSign"]));
    }
    if (m.find("Limit") != m.end() && !m["Limit"].empty()) {
      limit = make_shared<long>(boost::any_cast<long>(m["Limit"]));
    }
    if (m.find("NeedDefaultSign") != m.end() && !m["NeedDefaultSign"].empty()) {
      needDefaultSign = make_shared<bool>(boost::any_cast<bool>(m["NeedDefaultSign"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SignName") != m.end() && !m["SignName"].empty()) {
      signName = make_shared<string>(boost::any_cast<string>(m["SignName"]));
    }
  }


  virtual ~QuerySmsSignLastRangeRequest() = default;
};
class QuerySmsSignLastRangeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<string> data{};

  QuerySmsSignLastRangeResponseBody() {}

  explicit QuerySmsSignLastRangeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
  }


  virtual ~QuerySmsSignLastRangeResponseBody() = default;
};
class QuerySmsSignLastRangeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySmsSignLastRangeResponseBody> body{};

  QuerySmsSignLastRangeResponse() {}

  explicit QuerySmsSignLastRangeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySmsSignLastRangeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySmsSignLastRangeResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySmsSignLastRangeResponse() = default;
};
class QuerySmsSignLastRangeNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> auditState{};
  shared_ptr<long> isGlobeSign{};
  shared_ptr<long> limit{};
  shared_ptr<bool> needDefaultSign{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> sceneType{};
  shared_ptr<string> signName{};

  QuerySmsSignLastRangeNewRequest() {}

  explicit QuerySmsSignLastRangeNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (auditState) {
      res["AuditState"] = boost::any(*auditState);
    }
    if (isGlobeSign) {
      res["IsGlobeSign"] = boost::any(*isGlobeSign);
    }
    if (limit) {
      res["Limit"] = boost::any(*limit);
    }
    if (needDefaultSign) {
      res["NeedDefaultSign"] = boost::any(*needDefaultSign);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sceneType) {
      res["SceneType"] = boost::any(*sceneType);
    }
    if (signName) {
      res["SignName"] = boost::any(*signName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuditState") != m.end() && !m["AuditState"].empty()) {
      auditState = make_shared<string>(boost::any_cast<string>(m["AuditState"]));
    }
    if (m.find("IsGlobeSign") != m.end() && !m["IsGlobeSign"].empty()) {
      isGlobeSign = make_shared<long>(boost::any_cast<long>(m["IsGlobeSign"]));
    }
    if (m.find("Limit") != m.end() && !m["Limit"].empty()) {
      limit = make_shared<long>(boost::any_cast<long>(m["Limit"]));
    }
    if (m.find("NeedDefaultSign") != m.end() && !m["NeedDefaultSign"].empty()) {
      needDefaultSign = make_shared<bool>(boost::any_cast<bool>(m["NeedDefaultSign"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SceneType") != m.end() && !m["SceneType"].empty()) {
      sceneType = make_shared<long>(boost::any_cast<long>(m["SceneType"]));
    }
    if (m.find("SignName") != m.end() && !m["SignName"].empty()) {
      signName = make_shared<string>(boost::any_cast<string>(m["SignName"]));
    }
  }


  virtual ~QuerySmsSignLastRangeNewRequest() = default;
};
class QuerySmsSignLastRangeNewResponseBodyListSmsSignFileIds : public Darabonba::Model {
public:
  shared_ptr<vector<long>> fileId{};

  QuerySmsSignLastRangeNewResponseBodyListSmsSignFileIds() {}

  explicit QuerySmsSignLastRangeNewResponseBodyListSmsSignFileIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["FileId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FileId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      fileId = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~QuerySmsSignLastRangeNewResponseBodyListSmsSignFileIds() = default;
};
class QuerySmsSignLastRangeNewResponseBodyListSmsSignFileUrlList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> fileUrl{};

  QuerySmsSignLastRangeNewResponseBodyListSmsSignFileUrlList() {}

  explicit QuerySmsSignLastRangeNewResponseBodyListSmsSignFileUrlList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FileUrl"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FileUrl"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fileUrl = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QuerySmsSignLastRangeNewResponseBodyListSmsSignFileUrlList() = default;
};
class QuerySmsSignLastRangeNewResponseBodyListSmsSignSignSceneDetailListSignSceneDetail : public Darabonba::Model {
public:
  shared_ptr<string> auditState{};
  shared_ptr<long> sceneType{};

  QuerySmsSignLastRangeNewResponseBodyListSmsSignSignSceneDetailListSignSceneDetail() {}

  explicit QuerySmsSignLastRangeNewResponseBodyListSmsSignSignSceneDetailListSignSceneDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (auditState) {
      res["AuditState"] = boost::any(*auditState);
    }
    if (sceneType) {
      res["SceneType"] = boost::any(*sceneType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuditState") != m.end() && !m["AuditState"].empty()) {
      auditState = make_shared<string>(boost::any_cast<string>(m["AuditState"]));
    }
    if (m.find("SceneType") != m.end() && !m["SceneType"].empty()) {
      sceneType = make_shared<long>(boost::any_cast<long>(m["SceneType"]));
    }
  }


  virtual ~QuerySmsSignLastRangeNewResponseBodyListSmsSignSignSceneDetailListSignSceneDetail() = default;
};
class QuerySmsSignLastRangeNewResponseBodyListSmsSignSignSceneDetailList : public Darabonba::Model {
public:
  shared_ptr<vector<QuerySmsSignLastRangeNewResponseBodyListSmsSignSignSceneDetailListSignSceneDetail>> signSceneDetail{};

  QuerySmsSignLastRangeNewResponseBodyListSmsSignSignSceneDetailList() {}

  explicit QuerySmsSignLastRangeNewResponseBodyListSmsSignSignSceneDetailList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (signSceneDetail) {
      vector<boost::any> temp1;
      for(auto item1:*signSceneDetail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SignSceneDetail"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SignSceneDetail") != m.end() && !m["SignSceneDetail"].empty()) {
      if (typeid(vector<boost::any>) == m["SignSceneDetail"].type()) {
        vector<QuerySmsSignLastRangeNewResponseBodyListSmsSignSignSceneDetailListSignSceneDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SignSceneDetail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySmsSignLastRangeNewResponseBodyListSmsSignSignSceneDetailListSignSceneDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        signSceneDetail = make_shared<vector<QuerySmsSignLastRangeNewResponseBodyListSmsSignSignSceneDetailListSignSceneDetail>>(expect1);
      }
    }
  }


  virtual ~QuerySmsSignLastRangeNewResponseBodyListSmsSignSignSceneDetailList() = default;
};
class QuerySmsSignLastRangeNewResponseBodyListSmsSign : public Darabonba::Model {
public:
  shared_ptr<string> auditInfo{};
  shared_ptr<string> auditRemarkInfo{};
  shared_ptr<string> auditState{};
  shared_ptr<string> extendMessage{};
  shared_ptr<QuerySmsSignLastRangeNewResponseBodyListSmsSignFileIds> fileIds{};
  shared_ptr<QuerySmsSignLastRangeNewResponseBodyListSmsSignFileUrlList> fileUrlList{};
  shared_ptr<string> gmtCreateStr{};
  shared_ptr<string> id{};
  shared_ptr<bool> isDefaultSign{};
  shared_ptr<string> operateDateStr{};
  shared_ptr<string> orderId{};
  shared_ptr<string> remark{};
  shared_ptr<long> sceneType{};
  shared_ptr<long> serviceType{};
  shared_ptr<string> signName{};
  shared_ptr<QuerySmsSignLastRangeNewResponseBodyListSmsSignSignSceneDetailList> signSceneDetailList{};
  shared_ptr<long> signType{};
  shared_ptr<string> signUsageName{};

  QuerySmsSignLastRangeNewResponseBodyListSmsSign() {}

  explicit QuerySmsSignLastRangeNewResponseBodyListSmsSign(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (auditInfo) {
      res["AuditInfo"] = boost::any(*auditInfo);
    }
    if (auditRemarkInfo) {
      res["AuditRemarkInfo"] = boost::any(*auditRemarkInfo);
    }
    if (auditState) {
      res["AuditState"] = boost::any(*auditState);
    }
    if (extendMessage) {
      res["ExtendMessage"] = boost::any(*extendMessage);
    }
    if (fileIds) {
      res["FileIds"] = fileIds ? boost::any(fileIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fileUrlList) {
      res["FileUrlList"] = fileUrlList ? boost::any(fileUrlList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (gmtCreateStr) {
      res["GmtCreateStr"] = boost::any(*gmtCreateStr);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (isDefaultSign) {
      res["IsDefaultSign"] = boost::any(*isDefaultSign);
    }
    if (operateDateStr) {
      res["OperateDateStr"] = boost::any(*operateDateStr);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (sceneType) {
      res["SceneType"] = boost::any(*sceneType);
    }
    if (serviceType) {
      res["ServiceType"] = boost::any(*serviceType);
    }
    if (signName) {
      res["SignName"] = boost::any(*signName);
    }
    if (signSceneDetailList) {
      res["SignSceneDetailList"] = signSceneDetailList ? boost::any(signSceneDetailList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (signType) {
      res["SignType"] = boost::any(*signType);
    }
    if (signUsageName) {
      res["SignUsageName"] = boost::any(*signUsageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuditInfo") != m.end() && !m["AuditInfo"].empty()) {
      auditInfo = make_shared<string>(boost::any_cast<string>(m["AuditInfo"]));
    }
    if (m.find("AuditRemarkInfo") != m.end() && !m["AuditRemarkInfo"].empty()) {
      auditRemarkInfo = make_shared<string>(boost::any_cast<string>(m["AuditRemarkInfo"]));
    }
    if (m.find("AuditState") != m.end() && !m["AuditState"].empty()) {
      auditState = make_shared<string>(boost::any_cast<string>(m["AuditState"]));
    }
    if (m.find("ExtendMessage") != m.end() && !m["ExtendMessage"].empty()) {
      extendMessage = make_shared<string>(boost::any_cast<string>(m["ExtendMessage"]));
    }
    if (m.find("FileIds") != m.end() && !m["FileIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["FileIds"].type()) {
        QuerySmsSignLastRangeNewResponseBodyListSmsSignFileIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FileIds"]));
        fileIds = make_shared<QuerySmsSignLastRangeNewResponseBodyListSmsSignFileIds>(model1);
      }
    }
    if (m.find("FileUrlList") != m.end() && !m["FileUrlList"].empty()) {
      if (typeid(map<string, boost::any>) == m["FileUrlList"].type()) {
        QuerySmsSignLastRangeNewResponseBodyListSmsSignFileUrlList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FileUrlList"]));
        fileUrlList = make_shared<QuerySmsSignLastRangeNewResponseBodyListSmsSignFileUrlList>(model1);
      }
    }
    if (m.find("GmtCreateStr") != m.end() && !m["GmtCreateStr"].empty()) {
      gmtCreateStr = make_shared<string>(boost::any_cast<string>(m["GmtCreateStr"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("IsDefaultSign") != m.end() && !m["IsDefaultSign"].empty()) {
      isDefaultSign = make_shared<bool>(boost::any_cast<bool>(m["IsDefaultSign"]));
    }
    if (m.find("OperateDateStr") != m.end() && !m["OperateDateStr"].empty()) {
      operateDateStr = make_shared<string>(boost::any_cast<string>(m["OperateDateStr"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("SceneType") != m.end() && !m["SceneType"].empty()) {
      sceneType = make_shared<long>(boost::any_cast<long>(m["SceneType"]));
    }
    if (m.find("ServiceType") != m.end() && !m["ServiceType"].empty()) {
      serviceType = make_shared<long>(boost::any_cast<long>(m["ServiceType"]));
    }
    if (m.find("SignName") != m.end() && !m["SignName"].empty()) {
      signName = make_shared<string>(boost::any_cast<string>(m["SignName"]));
    }
    if (m.find("SignSceneDetailList") != m.end() && !m["SignSceneDetailList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SignSceneDetailList"].type()) {
        QuerySmsSignLastRangeNewResponseBodyListSmsSignSignSceneDetailList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SignSceneDetailList"]));
        signSceneDetailList = make_shared<QuerySmsSignLastRangeNewResponseBodyListSmsSignSignSceneDetailList>(model1);
      }
    }
    if (m.find("SignType") != m.end() && !m["SignType"].empty()) {
      signType = make_shared<long>(boost::any_cast<long>(m["SignType"]));
    }
    if (m.find("SignUsageName") != m.end() && !m["SignUsageName"].empty()) {
      signUsageName = make_shared<string>(boost::any_cast<string>(m["SignUsageName"]));
    }
  }


  virtual ~QuerySmsSignLastRangeNewResponseBodyListSmsSign() = default;
};
class QuerySmsSignLastRangeNewResponseBodyList : public Darabonba::Model {
public:
  shared_ptr<vector<QuerySmsSignLastRangeNewResponseBodyListSmsSign>> smsSign{};

  QuerySmsSignLastRangeNewResponseBodyList() {}

  explicit QuerySmsSignLastRangeNewResponseBodyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (smsSign) {
      vector<boost::any> temp1;
      for(auto item1:*smsSign){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SmsSign"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SmsSign") != m.end() && !m["SmsSign"].empty()) {
      if (typeid(vector<boost::any>) == m["SmsSign"].type()) {
        vector<QuerySmsSignLastRangeNewResponseBodyListSmsSign> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SmsSign"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySmsSignLastRangeNewResponseBodyListSmsSign model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        smsSign = make_shared<vector<QuerySmsSignLastRangeNewResponseBodyListSmsSign>>(expect1);
      }
    }
  }


  virtual ~QuerySmsSignLastRangeNewResponseBodyList() = default;
};
class QuerySmsSignLastRangeNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<QuerySmsSignLastRangeNewResponseBodyList> list{};
  shared_ptr<string> requestId{};

  QuerySmsSignLastRangeNewResponseBody() {}

  explicit QuerySmsSignLastRangeNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QuerySmsSignLastRangeNewResponseBodyList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QuerySmsSignLastRangeNewResponseBodyList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QuerySmsSignLastRangeNewResponseBody() = default;
};
class QuerySmsSignLastRangeNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySmsSignLastRangeNewResponseBody> body{};

  QuerySmsSignLastRangeNewResponse() {}

  explicit QuerySmsSignLastRangeNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySmsSignLastRangeNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySmsSignLastRangeNewResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySmsSignLastRangeNewResponse() = default;
};
class QuerySmsSignListRequest : public Darabonba::Model {
public:
  shared_ptr<string> auditState{};
  shared_ptr<string> bizType{};
  shared_ptr<long> isGlobeSign{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> serviceType{};
  shared_ptr<string> signName{};

  QuerySmsSignListRequest() {}

  explicit QuerySmsSignListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (auditState) {
      res["AuditState"] = boost::any(*auditState);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (isGlobeSign) {
      res["IsGlobeSign"] = boost::any(*isGlobeSign);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (serviceType) {
      res["ServiceType"] = boost::any(*serviceType);
    }
    if (signName) {
      res["SignName"] = boost::any(*signName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuditState") != m.end() && !m["AuditState"].empty()) {
      auditState = make_shared<string>(boost::any_cast<string>(m["AuditState"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("IsGlobeSign") != m.end() && !m["IsGlobeSign"].empty()) {
      isGlobeSign = make_shared<long>(boost::any_cast<long>(m["IsGlobeSign"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ServiceType") != m.end() && !m["ServiceType"].empty()) {
      serviceType = make_shared<string>(boost::any_cast<string>(m["ServiceType"]));
    }
    if (m.find("SignName") != m.end() && !m["SignName"].empty()) {
      signName = make_shared<string>(boost::any_cast<string>(m["SignName"]));
    }
  }


  virtual ~QuerySmsSignListRequest() = default;
};
class QuerySmsSignListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<string> data{};

  QuerySmsSignListResponseBody() {}

  explicit QuerySmsSignListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
  }


  virtual ~QuerySmsSignListResponseBody() = default;
};
class QuerySmsSignListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySmsSignListResponseBody> body{};

  QuerySmsSignListResponse() {}

  explicit QuerySmsSignListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySmsSignListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySmsSignListResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySmsSignListResponse() = default;
};
class QuerySmsSignListNewRequest : public Darabonba::Model {
public:
  shared_ptr<long> aggregatedRegisterStatus{};
  shared_ptr<string> auditState{};
  shared_ptr<string> bizType{};
  shared_ptr<long> isGlobeSign{};
  shared_ptr<vector<string>> operatorCodes{};
  shared_ptr<long> operatorRegisterStatus{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> qualificationName{};
  shared_ptr<long> registerResult{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> serviceType{};
  shared_ptr<string> signName{};
  shared_ptr<string> signSource{};

  QuerySmsSignListNewRequest() {}

  explicit QuerySmsSignListNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatedRegisterStatus) {
      res["AggregatedRegisterStatus"] = boost::any(*aggregatedRegisterStatus);
    }
    if (auditState) {
      res["AuditState"] = boost::any(*auditState);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (isGlobeSign) {
      res["IsGlobeSign"] = boost::any(*isGlobeSign);
    }
    if (operatorCodes) {
      res["OperatorCodes"] = boost::any(*operatorCodes);
    }
    if (operatorRegisterStatus) {
      res["OperatorRegisterStatus"] = boost::any(*operatorRegisterStatus);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (qualificationName) {
      res["QualificationName"] = boost::any(*qualificationName);
    }
    if (registerResult) {
      res["RegisterResult"] = boost::any(*registerResult);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (serviceType) {
      res["ServiceType"] = boost::any(*serviceType);
    }
    if (signName) {
      res["SignName"] = boost::any(*signName);
    }
    if (signSource) {
      res["SignSource"] = boost::any(*signSource);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatedRegisterStatus") != m.end() && !m["AggregatedRegisterStatus"].empty()) {
      aggregatedRegisterStatus = make_shared<long>(boost::any_cast<long>(m["AggregatedRegisterStatus"]));
    }
    if (m.find("AuditState") != m.end() && !m["AuditState"].empty()) {
      auditState = make_shared<string>(boost::any_cast<string>(m["AuditState"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("IsGlobeSign") != m.end() && !m["IsGlobeSign"].empty()) {
      isGlobeSign = make_shared<long>(boost::any_cast<long>(m["IsGlobeSign"]));
    }
    if (m.find("OperatorCodes") != m.end() && !m["OperatorCodes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OperatorCodes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OperatorCodes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      operatorCodes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OperatorRegisterStatus") != m.end() && !m["OperatorRegisterStatus"].empty()) {
      operatorRegisterStatus = make_shared<long>(boost::any_cast<long>(m["OperatorRegisterStatus"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("QualificationName") != m.end() && !m["QualificationName"].empty()) {
      qualificationName = make_shared<string>(boost::any_cast<string>(m["QualificationName"]));
    }
    if (m.find("RegisterResult") != m.end() && !m["RegisterResult"].empty()) {
      registerResult = make_shared<long>(boost::any_cast<long>(m["RegisterResult"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ServiceType") != m.end() && !m["ServiceType"].empty()) {
      serviceType = make_shared<string>(boost::any_cast<string>(m["ServiceType"]));
    }
    if (m.find("SignName") != m.end() && !m["SignName"].empty()) {
      signName = make_shared<string>(boost::any_cast<string>(m["SignName"]));
    }
    if (m.find("SignSource") != m.end() && !m["SignSource"].empty()) {
      signSource = make_shared<string>(boost::any_cast<string>(m["SignSource"]));
    }
  }


  virtual ~QuerySmsSignListNewRequest() = default;
};
class QuerySmsSignListNewShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> aggregatedRegisterStatus{};
  shared_ptr<string> auditState{};
  shared_ptr<string> bizType{};
  shared_ptr<long> isGlobeSign{};
  shared_ptr<string> operatorCodesShrink{};
  shared_ptr<long> operatorRegisterStatus{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> qualificationName{};
  shared_ptr<long> registerResult{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> serviceType{};
  shared_ptr<string> signName{};
  shared_ptr<string> signSource{};

  QuerySmsSignListNewShrinkRequest() {}

  explicit QuerySmsSignListNewShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatedRegisterStatus) {
      res["AggregatedRegisterStatus"] = boost::any(*aggregatedRegisterStatus);
    }
    if (auditState) {
      res["AuditState"] = boost::any(*auditState);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (isGlobeSign) {
      res["IsGlobeSign"] = boost::any(*isGlobeSign);
    }
    if (operatorCodesShrink) {
      res["OperatorCodes"] = boost::any(*operatorCodesShrink);
    }
    if (operatorRegisterStatus) {
      res["OperatorRegisterStatus"] = boost::any(*operatorRegisterStatus);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (qualificationName) {
      res["QualificationName"] = boost::any(*qualificationName);
    }
    if (registerResult) {
      res["RegisterResult"] = boost::any(*registerResult);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (serviceType) {
      res["ServiceType"] = boost::any(*serviceType);
    }
    if (signName) {
      res["SignName"] = boost::any(*signName);
    }
    if (signSource) {
      res["SignSource"] = boost::any(*signSource);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatedRegisterStatus") != m.end() && !m["AggregatedRegisterStatus"].empty()) {
      aggregatedRegisterStatus = make_shared<long>(boost::any_cast<long>(m["AggregatedRegisterStatus"]));
    }
    if (m.find("AuditState") != m.end() && !m["AuditState"].empty()) {
      auditState = make_shared<string>(boost::any_cast<string>(m["AuditState"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("IsGlobeSign") != m.end() && !m["IsGlobeSign"].empty()) {
      isGlobeSign = make_shared<long>(boost::any_cast<long>(m["IsGlobeSign"]));
    }
    if (m.find("OperatorCodes") != m.end() && !m["OperatorCodes"].empty()) {
      operatorCodesShrink = make_shared<string>(boost::any_cast<string>(m["OperatorCodes"]));
    }
    if (m.find("OperatorRegisterStatus") != m.end() && !m["OperatorRegisterStatus"].empty()) {
      operatorRegisterStatus = make_shared<long>(boost::any_cast<long>(m["OperatorRegisterStatus"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("QualificationName") != m.end() && !m["QualificationName"].empty()) {
      qualificationName = make_shared<string>(boost::any_cast<string>(m["QualificationName"]));
    }
    if (m.find("RegisterResult") != m.end() && !m["RegisterResult"].empty()) {
      registerResult = make_shared<long>(boost::any_cast<long>(m["RegisterResult"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ServiceType") != m.end() && !m["ServiceType"].empty()) {
      serviceType = make_shared<string>(boost::any_cast<string>(m["ServiceType"]));
    }
    if (m.find("SignName") != m.end() && !m["SignName"].empty()) {
      signName = make_shared<string>(boost::any_cast<string>(m["SignName"]));
    }
    if (m.find("SignSource") != m.end() && !m["SignSource"].empty()) {
      signSource = make_shared<string>(boost::any_cast<string>(m["SignSource"]));
    }
  }


  virtual ~QuerySmsSignListNewShrinkRequest() = default;
};
class QuerySmsSignListNewResponseBodySmsSignSmsSignFileIds : public Darabonba::Model {
public:
  shared_ptr<vector<long>> fileId{};

  QuerySmsSignListNewResponseBodySmsSignSmsSignFileIds() {}

  explicit QuerySmsSignListNewResponseBodySmsSignSmsSignFileIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["FileId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FileId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      fileId = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~QuerySmsSignListNewResponseBodySmsSignSmsSignFileIds() = default;
};
class QuerySmsSignListNewResponseBodySmsSignSmsSignFileUrlList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> fileUrl{};

  QuerySmsSignListNewResponseBodySmsSignSmsSignFileUrlList() {}

  explicit QuerySmsSignListNewResponseBodySmsSignSmsSignFileUrlList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FileUrl"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FileUrl"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fileUrl = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QuerySmsSignListNewResponseBodySmsSignSmsSignFileUrlList() = default;
};
class QuerySmsSignListNewResponseBodySmsSignSmsSignSignSceneDetailListSignSceneDetail : public Darabonba::Model {
public:
  shared_ptr<string> auditState{};
  shared_ptr<long> sceneType{};

  QuerySmsSignListNewResponseBodySmsSignSmsSignSignSceneDetailListSignSceneDetail() {}

  explicit QuerySmsSignListNewResponseBodySmsSignSmsSignSignSceneDetailListSignSceneDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (auditState) {
      res["AuditState"] = boost::any(*auditState);
    }
    if (sceneType) {
      res["SceneType"] = boost::any(*sceneType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuditState") != m.end() && !m["AuditState"].empty()) {
      auditState = make_shared<string>(boost::any_cast<string>(m["AuditState"]));
    }
    if (m.find("SceneType") != m.end() && !m["SceneType"].empty()) {
      sceneType = make_shared<long>(boost::any_cast<long>(m["SceneType"]));
    }
  }


  virtual ~QuerySmsSignListNewResponseBodySmsSignSmsSignSignSceneDetailListSignSceneDetail() = default;
};
class QuerySmsSignListNewResponseBodySmsSignSmsSignSignSceneDetailList : public Darabonba::Model {
public:
  shared_ptr<vector<QuerySmsSignListNewResponseBodySmsSignSmsSignSignSceneDetailListSignSceneDetail>> signSceneDetail{};

  QuerySmsSignListNewResponseBodySmsSignSmsSignSignSceneDetailList() {}

  explicit QuerySmsSignListNewResponseBodySmsSignSmsSignSignSceneDetailList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (signSceneDetail) {
      vector<boost::any> temp1;
      for(auto item1:*signSceneDetail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SignSceneDetail"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SignSceneDetail") != m.end() && !m["SignSceneDetail"].empty()) {
      if (typeid(vector<boost::any>) == m["SignSceneDetail"].type()) {
        vector<QuerySmsSignListNewResponseBodySmsSignSmsSignSignSceneDetailListSignSceneDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SignSceneDetail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySmsSignListNewResponseBodySmsSignSmsSignSignSceneDetailListSignSceneDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        signSceneDetail = make_shared<vector<QuerySmsSignListNewResponseBodySmsSignSmsSignSignSceneDetailListSignSceneDetail>>(expect1);
      }
    }
  }


  virtual ~QuerySmsSignListNewResponseBodySmsSignSmsSignSignSceneDetailList() = default;
};
class QuerySmsSignListNewResponseBodySmsSignSmsSign : public Darabonba::Model {
public:
  shared_ptr<long> aggregatedRegisterStatus{};
  shared_ptr<string> applySource{};
  shared_ptr<string> auditInfo{};
  shared_ptr<string> auditRemarkInfo{};
  shared_ptr<string> auditState{};
  shared_ptr<string> authorization{};
  shared_ptr<string> authorizationEffTime{};
  shared_ptr<string> authorizationLetter{};
  shared_ptr<bool> authorizationLetterAuditPass{};
  shared_ptr<long> authorizationLetterId{};
  shared_ptr<string> authorizationLetterName{};
  shared_ptr<string> authorizationLetterStatus{};
  shared_ptr<string> authorizationSignScope{};
  shared_ptr<bool> canRegister{};
  shared_ptr<bool> enableAuthorizationLetter{};
  shared_ptr<string> extendMessage{};
  shared_ptr<QuerySmsSignListNewResponseBodySmsSignSmsSignFileIds> fileIds{};
  shared_ptr<QuerySmsSignListNewResponseBodySmsSignSmsSignFileUrlList> fileUrlList{};
  shared_ptr<string> gmtCreateStr{};
  shared_ptr<string> id{};
  shared_ptr<bool> isAuthorizationLetterOCRComplete{};
  shared_ptr<bool> isAuthorizationLetterOCRDiff{};
  shared_ptr<bool> isDefaultSign{};
  shared_ptr<bool> isSignScopeOCRDiff{};
  shared_ptr<long> mobileRegisterStatus{};
  shared_ptr<string> operateDateStr{};
  shared_ptr<long> orderCount{};
  shared_ptr<string> orderId{};
  shared_ptr<string> organizationCode{};
  shared_ptr<string> proxyAuthorization{};
  shared_ptr<long> qualificationId{};
  shared_ptr<string> qualificationName{};
  shared_ptr<string> qualificationState{};
  shared_ptr<long> qualificationVersion{};
  shared_ptr<long> qualificationWorkOrderId{};
  shared_ptr<long> registerResult{};
  shared_ptr<long> registerTime{};
  shared_ptr<string> remark{};
  shared_ptr<string> resultReason{};
  shared_ptr<long> sceneType{};
  shared_ptr<long> serviceType{};
  shared_ptr<string> signCode{};
  shared_ptr<string> signName{};
  shared_ptr<QuerySmsSignListNewResponseBodySmsSignSmsSignSignSceneDetailList> signSceneDetailList{};
  shared_ptr<string> signScopeOCR{};
  shared_ptr<string> signSource{};
  shared_ptr<long> signType{};
  shared_ptr<long> telecomRegisterStatus{};
  shared_ptr<long> unicomRegisterStatus{};

  QuerySmsSignListNewResponseBodySmsSignSmsSign() {}

  explicit QuerySmsSignListNewResponseBodySmsSignSmsSign(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatedRegisterStatus) {
      res["AggregatedRegisterStatus"] = boost::any(*aggregatedRegisterStatus);
    }
    if (applySource) {
      res["ApplySource"] = boost::any(*applySource);
    }
    if (auditInfo) {
      res["AuditInfo"] = boost::any(*auditInfo);
    }
    if (auditRemarkInfo) {
      res["AuditRemarkInfo"] = boost::any(*auditRemarkInfo);
    }
    if (auditState) {
      res["AuditState"] = boost::any(*auditState);
    }
    if (authorization) {
      res["Authorization"] = boost::any(*authorization);
    }
    if (authorizationEffTime) {
      res["AuthorizationEffTime"] = boost::any(*authorizationEffTime);
    }
    if (authorizationLetter) {
      res["AuthorizationLetter"] = boost::any(*authorizationLetter);
    }
    if (authorizationLetterAuditPass) {
      res["AuthorizationLetterAuditPass"] = boost::any(*authorizationLetterAuditPass);
    }
    if (authorizationLetterId) {
      res["AuthorizationLetterId"] = boost::any(*authorizationLetterId);
    }
    if (authorizationLetterName) {
      res["AuthorizationLetterName"] = boost::any(*authorizationLetterName);
    }
    if (authorizationLetterStatus) {
      res["AuthorizationLetterStatus"] = boost::any(*authorizationLetterStatus);
    }
    if (authorizationSignScope) {
      res["AuthorizationSignScope"] = boost::any(*authorizationSignScope);
    }
    if (canRegister) {
      res["CanRegister"] = boost::any(*canRegister);
    }
    if (enableAuthorizationLetter) {
      res["EnableAuthorizationLetter"] = boost::any(*enableAuthorizationLetter);
    }
    if (extendMessage) {
      res["ExtendMessage"] = boost::any(*extendMessage);
    }
    if (fileIds) {
      res["FileIds"] = fileIds ? boost::any(fileIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fileUrlList) {
      res["FileUrlList"] = fileUrlList ? boost::any(fileUrlList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (gmtCreateStr) {
      res["GmtCreateStr"] = boost::any(*gmtCreateStr);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (isAuthorizationLetterOCRComplete) {
      res["IsAuthorizationLetterOCRComplete"] = boost::any(*isAuthorizationLetterOCRComplete);
    }
    if (isAuthorizationLetterOCRDiff) {
      res["IsAuthorizationLetterOCRDiff"] = boost::any(*isAuthorizationLetterOCRDiff);
    }
    if (isDefaultSign) {
      res["IsDefaultSign"] = boost::any(*isDefaultSign);
    }
    if (isSignScopeOCRDiff) {
      res["IsSignScopeOCRDiff"] = boost::any(*isSignScopeOCRDiff);
    }
    if (mobileRegisterStatus) {
      res["MobileRegisterStatus"] = boost::any(*mobileRegisterStatus);
    }
    if (operateDateStr) {
      res["OperateDateStr"] = boost::any(*operateDateStr);
    }
    if (orderCount) {
      res["OrderCount"] = boost::any(*orderCount);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (organizationCode) {
      res["OrganizationCode"] = boost::any(*organizationCode);
    }
    if (proxyAuthorization) {
      res["ProxyAuthorization"] = boost::any(*proxyAuthorization);
    }
    if (qualificationId) {
      res["QualificationId"] = boost::any(*qualificationId);
    }
    if (qualificationName) {
      res["QualificationName"] = boost::any(*qualificationName);
    }
    if (qualificationState) {
      res["QualificationState"] = boost::any(*qualificationState);
    }
    if (qualificationVersion) {
      res["QualificationVersion"] = boost::any(*qualificationVersion);
    }
    if (qualificationWorkOrderId) {
      res["QualificationWorkOrderId"] = boost::any(*qualificationWorkOrderId);
    }
    if (registerResult) {
      res["RegisterResult"] = boost::any(*registerResult);
    }
    if (registerTime) {
      res["RegisterTime"] = boost::any(*registerTime);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (resultReason) {
      res["ResultReason"] = boost::any(*resultReason);
    }
    if (sceneType) {
      res["SceneType"] = boost::any(*sceneType);
    }
    if (serviceType) {
      res["ServiceType"] = boost::any(*serviceType);
    }
    if (signCode) {
      res["SignCode"] = boost::any(*signCode);
    }
    if (signName) {
      res["SignName"] = boost::any(*signName);
    }
    if (signSceneDetailList) {
      res["SignSceneDetailList"] = signSceneDetailList ? boost::any(signSceneDetailList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (signScopeOCR) {
      res["SignScopeOCR"] = boost::any(*signScopeOCR);
    }
    if (signSource) {
      res["SignSource"] = boost::any(*signSource);
    }
    if (signType) {
      res["SignType"] = boost::any(*signType);
    }
    if (telecomRegisterStatus) {
      res["TelecomRegisterStatus"] = boost::any(*telecomRegisterStatus);
    }
    if (unicomRegisterStatus) {
      res["UnicomRegisterStatus"] = boost::any(*unicomRegisterStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatedRegisterStatus") != m.end() && !m["AggregatedRegisterStatus"].empty()) {
      aggregatedRegisterStatus = make_shared<long>(boost::any_cast<long>(m["AggregatedRegisterStatus"]));
    }
    if (m.find("ApplySource") != m.end() && !m["ApplySource"].empty()) {
      applySource = make_shared<string>(boost::any_cast<string>(m["ApplySource"]));
    }
    if (m.find("AuditInfo") != m.end() && !m["AuditInfo"].empty()) {
      auditInfo = make_shared<string>(boost::any_cast<string>(m["AuditInfo"]));
    }
    if (m.find("AuditRemarkInfo") != m.end() && !m["AuditRemarkInfo"].empty()) {
      auditRemarkInfo = make_shared<string>(boost::any_cast<string>(m["AuditRemarkInfo"]));
    }
    if (m.find("AuditState") != m.end() && !m["AuditState"].empty()) {
      auditState = make_shared<string>(boost::any_cast<string>(m["AuditState"]));
    }
    if (m.find("Authorization") != m.end() && !m["Authorization"].empty()) {
      authorization = make_shared<string>(boost::any_cast<string>(m["Authorization"]));
    }
    if (m.find("AuthorizationEffTime") != m.end() && !m["AuthorizationEffTime"].empty()) {
      authorizationEffTime = make_shared<string>(boost::any_cast<string>(m["AuthorizationEffTime"]));
    }
    if (m.find("AuthorizationLetter") != m.end() && !m["AuthorizationLetter"].empty()) {
      authorizationLetter = make_shared<string>(boost::any_cast<string>(m["AuthorizationLetter"]));
    }
    if (m.find("AuthorizationLetterAuditPass") != m.end() && !m["AuthorizationLetterAuditPass"].empty()) {
      authorizationLetterAuditPass = make_shared<bool>(boost::any_cast<bool>(m["AuthorizationLetterAuditPass"]));
    }
    if (m.find("AuthorizationLetterId") != m.end() && !m["AuthorizationLetterId"].empty()) {
      authorizationLetterId = make_shared<long>(boost::any_cast<long>(m["AuthorizationLetterId"]));
    }
    if (m.find("AuthorizationLetterName") != m.end() && !m["AuthorizationLetterName"].empty()) {
      authorizationLetterName = make_shared<string>(boost::any_cast<string>(m["AuthorizationLetterName"]));
    }
    if (m.find("AuthorizationLetterStatus") != m.end() && !m["AuthorizationLetterStatus"].empty()) {
      authorizationLetterStatus = make_shared<string>(boost::any_cast<string>(m["AuthorizationLetterStatus"]));
    }
    if (m.find("AuthorizationSignScope") != m.end() && !m["AuthorizationSignScope"].empty()) {
      authorizationSignScope = make_shared<string>(boost::any_cast<string>(m["AuthorizationSignScope"]));
    }
    if (m.find("CanRegister") != m.end() && !m["CanRegister"].empty()) {
      canRegister = make_shared<bool>(boost::any_cast<bool>(m["CanRegister"]));
    }
    if (m.find("EnableAuthorizationLetter") != m.end() && !m["EnableAuthorizationLetter"].empty()) {
      enableAuthorizationLetter = make_shared<bool>(boost::any_cast<bool>(m["EnableAuthorizationLetter"]));
    }
    if (m.find("ExtendMessage") != m.end() && !m["ExtendMessage"].empty()) {
      extendMessage = make_shared<string>(boost::any_cast<string>(m["ExtendMessage"]));
    }
    if (m.find("FileIds") != m.end() && !m["FileIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["FileIds"].type()) {
        QuerySmsSignListNewResponseBodySmsSignSmsSignFileIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FileIds"]));
        fileIds = make_shared<QuerySmsSignListNewResponseBodySmsSignSmsSignFileIds>(model1);
      }
    }
    if (m.find("FileUrlList") != m.end() && !m["FileUrlList"].empty()) {
      if (typeid(map<string, boost::any>) == m["FileUrlList"].type()) {
        QuerySmsSignListNewResponseBodySmsSignSmsSignFileUrlList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FileUrlList"]));
        fileUrlList = make_shared<QuerySmsSignListNewResponseBodySmsSignSmsSignFileUrlList>(model1);
      }
    }
    if (m.find("GmtCreateStr") != m.end() && !m["GmtCreateStr"].empty()) {
      gmtCreateStr = make_shared<string>(boost::any_cast<string>(m["GmtCreateStr"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("IsAuthorizationLetterOCRComplete") != m.end() && !m["IsAuthorizationLetterOCRComplete"].empty()) {
      isAuthorizationLetterOCRComplete = make_shared<bool>(boost::any_cast<bool>(m["IsAuthorizationLetterOCRComplete"]));
    }
    if (m.find("IsAuthorizationLetterOCRDiff") != m.end() && !m["IsAuthorizationLetterOCRDiff"].empty()) {
      isAuthorizationLetterOCRDiff = make_shared<bool>(boost::any_cast<bool>(m["IsAuthorizationLetterOCRDiff"]));
    }
    if (m.find("IsDefaultSign") != m.end() && !m["IsDefaultSign"].empty()) {
      isDefaultSign = make_shared<bool>(boost::any_cast<bool>(m["IsDefaultSign"]));
    }
    if (m.find("IsSignScopeOCRDiff") != m.end() && !m["IsSignScopeOCRDiff"].empty()) {
      isSignScopeOCRDiff = make_shared<bool>(boost::any_cast<bool>(m["IsSignScopeOCRDiff"]));
    }
    if (m.find("MobileRegisterStatus") != m.end() && !m["MobileRegisterStatus"].empty()) {
      mobileRegisterStatus = make_shared<long>(boost::any_cast<long>(m["MobileRegisterStatus"]));
    }
    if (m.find("OperateDateStr") != m.end() && !m["OperateDateStr"].empty()) {
      operateDateStr = make_shared<string>(boost::any_cast<string>(m["OperateDateStr"]));
    }
    if (m.find("OrderCount") != m.end() && !m["OrderCount"].empty()) {
      orderCount = make_shared<long>(boost::any_cast<long>(m["OrderCount"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("OrganizationCode") != m.end() && !m["OrganizationCode"].empty()) {
      organizationCode = make_shared<string>(boost::any_cast<string>(m["OrganizationCode"]));
    }
    if (m.find("ProxyAuthorization") != m.end() && !m["ProxyAuthorization"].empty()) {
      proxyAuthorization = make_shared<string>(boost::any_cast<string>(m["ProxyAuthorization"]));
    }
    if (m.find("QualificationId") != m.end() && !m["QualificationId"].empty()) {
      qualificationId = make_shared<long>(boost::any_cast<long>(m["QualificationId"]));
    }
    if (m.find("QualificationName") != m.end() && !m["QualificationName"].empty()) {
      qualificationName = make_shared<string>(boost::any_cast<string>(m["QualificationName"]));
    }
    if (m.find("QualificationState") != m.end() && !m["QualificationState"].empty()) {
      qualificationState = make_shared<string>(boost::any_cast<string>(m["QualificationState"]));
    }
    if (m.find("QualificationVersion") != m.end() && !m["QualificationVersion"].empty()) {
      qualificationVersion = make_shared<long>(boost::any_cast<long>(m["QualificationVersion"]));
    }
    if (m.find("QualificationWorkOrderId") != m.end() && !m["QualificationWorkOrderId"].empty()) {
      qualificationWorkOrderId = make_shared<long>(boost::any_cast<long>(m["QualificationWorkOrderId"]));
    }
    if (m.find("RegisterResult") != m.end() && !m["RegisterResult"].empty()) {
      registerResult = make_shared<long>(boost::any_cast<long>(m["RegisterResult"]));
    }
    if (m.find("RegisterTime") != m.end() && !m["RegisterTime"].empty()) {
      registerTime = make_shared<long>(boost::any_cast<long>(m["RegisterTime"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("ResultReason") != m.end() && !m["ResultReason"].empty()) {
      resultReason = make_shared<string>(boost::any_cast<string>(m["ResultReason"]));
    }
    if (m.find("SceneType") != m.end() && !m["SceneType"].empty()) {
      sceneType = make_shared<long>(boost::any_cast<long>(m["SceneType"]));
    }
    if (m.find("ServiceType") != m.end() && !m["ServiceType"].empty()) {
      serviceType = make_shared<long>(boost::any_cast<long>(m["ServiceType"]));
    }
    if (m.find("SignCode") != m.end() && !m["SignCode"].empty()) {
      signCode = make_shared<string>(boost::any_cast<string>(m["SignCode"]));
    }
    if (m.find("SignName") != m.end() && !m["SignName"].empty()) {
      signName = make_shared<string>(boost::any_cast<string>(m["SignName"]));
    }
    if (m.find("SignSceneDetailList") != m.end() && !m["SignSceneDetailList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SignSceneDetailList"].type()) {
        QuerySmsSignListNewResponseBodySmsSignSmsSignSignSceneDetailList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SignSceneDetailList"]));
        signSceneDetailList = make_shared<QuerySmsSignListNewResponseBodySmsSignSmsSignSignSceneDetailList>(model1);
      }
    }
    if (m.find("SignScopeOCR") != m.end() && !m["SignScopeOCR"].empty()) {
      signScopeOCR = make_shared<string>(boost::any_cast<string>(m["SignScopeOCR"]));
    }
    if (m.find("SignSource") != m.end() && !m["SignSource"].empty()) {
      signSource = make_shared<string>(boost::any_cast<string>(m["SignSource"]));
    }
    if (m.find("SignType") != m.end() && !m["SignType"].empty()) {
      signType = make_shared<long>(boost::any_cast<long>(m["SignType"]));
    }
    if (m.find("TelecomRegisterStatus") != m.end() && !m["TelecomRegisterStatus"].empty()) {
      telecomRegisterStatus = make_shared<long>(boost::any_cast<long>(m["TelecomRegisterStatus"]));
    }
    if (m.find("UnicomRegisterStatus") != m.end() && !m["UnicomRegisterStatus"].empty()) {
      unicomRegisterStatus = make_shared<long>(boost::any_cast<long>(m["UnicomRegisterStatus"]));
    }
  }


  virtual ~QuerySmsSignListNewResponseBodySmsSignSmsSign() = default;
};
class QuerySmsSignListNewResponseBodySmsSign : public Darabonba::Model {
public:
  shared_ptr<vector<QuerySmsSignListNewResponseBodySmsSignSmsSign>> smsSign{};

  QuerySmsSignListNewResponseBodySmsSign() {}

  explicit QuerySmsSignListNewResponseBodySmsSign(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (smsSign) {
      vector<boost::any> temp1;
      for(auto item1:*smsSign){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SmsSign"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SmsSign") != m.end() && !m["SmsSign"].empty()) {
      if (typeid(vector<boost::any>) == m["SmsSign"].type()) {
        vector<QuerySmsSignListNewResponseBodySmsSignSmsSign> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SmsSign"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySmsSignListNewResponseBodySmsSignSmsSign model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        smsSign = make_shared<vector<QuerySmsSignListNewResponseBodySmsSignSmsSign>>(expect1);
      }
    }
  }


  virtual ~QuerySmsSignListNewResponseBodySmsSign() = default;
};
class QuerySmsSignListNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<QuerySmsSignListNewResponseBodySmsSign> smsSign{};
  shared_ptr<long> total{};

  QuerySmsSignListNewResponseBody() {}

  explicit QuerySmsSignListNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (smsSign) {
      res["SmsSign"] = smsSign ? boost::any(smsSign->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SmsSign") != m.end() && !m["SmsSign"].empty()) {
      if (typeid(map<string, boost::any>) == m["SmsSign"].type()) {
        QuerySmsSignListNewResponseBodySmsSign model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SmsSign"]));
        smsSign = make_shared<QuerySmsSignListNewResponseBodySmsSign>(model1);
      }
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QuerySmsSignListNewResponseBody() = default;
};
class QuerySmsSignListNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySmsSignListNewResponseBody> body{};

  QuerySmsSignListNewResponse() {}

  explicit QuerySmsSignListNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySmsSignListNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySmsSignListNewResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySmsSignListNewResponse() = default;
};
class QuerySmsSignValidRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> serviceType{};
  shared_ptr<string> signName{};

  QuerySmsSignValidRequest() {}

  explicit QuerySmsSignValidRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (serviceType) {
      res["ServiceType"] = boost::any(*serviceType);
    }
    if (signName) {
      res["SignName"] = boost::any(*signName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ServiceType") != m.end() && !m["ServiceType"].empty()) {
      serviceType = make_shared<long>(boost::any_cast<long>(m["ServiceType"]));
    }
    if (m.find("SignName") != m.end() && !m["SignName"].empty()) {
      signName = make_shared<string>(boost::any_cast<string>(m["SignName"]));
    }
  }


  virtual ~QuerySmsSignValidRequest() = default;
};
class QuerySmsSignValidResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<string> data{};

  QuerySmsSignValidResponseBody() {}

  explicit QuerySmsSignValidResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
  }


  virtual ~QuerySmsSignValidResponseBody() = default;
};
class QuerySmsSignValidResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySmsSignValidResponseBody> body{};

  QuerySmsSignValidResponse() {}

  explicit QuerySmsSignValidResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySmsSignValidResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySmsSignValidResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySmsSignValidResponse() = default;
};
class QuerySmsSignValidNewRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> serviceType{};
  shared_ptr<string> signName{};
  shared_ptr<bool> signUpgrade{};

  QuerySmsSignValidNewRequest() {}

  explicit QuerySmsSignValidNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (serviceType) {
      res["ServiceType"] = boost::any(*serviceType);
    }
    if (signName) {
      res["SignName"] = boost::any(*signName);
    }
    if (signUpgrade) {
      res["SignUpgrade"] = boost::any(*signUpgrade);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ServiceType") != m.end() && !m["ServiceType"].empty()) {
      serviceType = make_shared<long>(boost::any_cast<long>(m["ServiceType"]));
    }
    if (m.find("SignName") != m.end() && !m["SignName"].empty()) {
      signName = make_shared<string>(boost::any_cast<string>(m["SignName"]));
    }
    if (m.find("SignUpgrade") != m.end() && !m["SignUpgrade"].empty()) {
      signUpgrade = make_shared<bool>(boost::any_cast<bool>(m["SignUpgrade"]));
    }
  }


  virtual ~QuerySmsSignValidNewRequest() = default;
};
class QuerySmsSignValidNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> msg{};
  shared_ptr<string> requestId{};

  QuerySmsSignValidNewResponseBody() {}

  explicit QuerySmsSignValidNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (msg) {
      res["Msg"] = boost::any(*msg);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Msg") != m.end() && !m["Msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["Msg"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QuerySmsSignValidNewResponseBody() = default;
};
class QuerySmsSignValidNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySmsSignValidNewResponseBody> body{};

  QuerySmsSignValidNewResponse() {}

  explicit QuerySmsSignValidNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySmsSignValidNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySmsSignValidNewResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySmsSignValidNewResponse() = default;
};
class QuerySmsStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> endDate{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> prodId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> signName{};
  shared_ptr<string> startDate{};
  shared_ptr<string> template_{};

  QuerySmsStatisticsRequest() {}

  explicit QuerySmsStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (prodId) {
      res["ProdId"] = boost::any(*prodId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (signName) {
      res["SignName"] = boost::any(*signName);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    if (template_) {
      res["Template"] = boost::any(*template_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ProdId") != m.end() && !m["ProdId"].empty()) {
      prodId = make_shared<string>(boost::any_cast<string>(m["ProdId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SignName") != m.end() && !m["SignName"].empty()) {
      signName = make_shared<string>(boost::any_cast<string>(m["SignName"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["Template"]));
    }
  }


  virtual ~QuerySmsStatisticsRequest() = default;
};
class QuerySmsStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<string> data{};

  QuerySmsStatisticsResponseBody() {}

  explicit QuerySmsStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
  }


  virtual ~QuerySmsStatisticsResponseBody() = default;
};
class QuerySmsStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySmsStatisticsResponseBody> body{};

  QuerySmsStatisticsResponse() {}

  explicit QuerySmsStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySmsStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySmsStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySmsStatisticsResponse() = default;
};
class QuerySmsStatisticsByTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> endDate{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> prodId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> startDate{};
  shared_ptr<string> template_{};

  QuerySmsStatisticsByTemplateRequest() {}

  explicit QuerySmsStatisticsByTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (prodId) {
      res["ProdId"] = boost::any(*prodId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    if (template_) {
      res["Template"] = boost::any(*template_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ProdId") != m.end() && !m["ProdId"].empty()) {
      prodId = make_shared<string>(boost::any_cast<string>(m["ProdId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["Template"]));
    }
  }


  virtual ~QuerySmsStatisticsByTemplateRequest() = default;
};
class QuerySmsStatisticsByTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<string> data{};

  QuerySmsStatisticsByTemplateResponseBody() {}

  explicit QuerySmsStatisticsByTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
  }


  virtual ~QuerySmsStatisticsByTemplateResponseBody() = default;
};
class QuerySmsStatisticsByTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySmsStatisticsByTemplateResponseBody> body{};

  QuerySmsStatisticsByTemplateResponse() {}

  explicit QuerySmsStatisticsByTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySmsStatisticsByTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySmsStatisticsByTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySmsStatisticsByTemplateResponse() = default;
};
class QuerySmsStatisticsByTemplateNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> endDate{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> prodId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> startDate{};
  shared_ptr<string> template_{};

  QuerySmsStatisticsByTemplateNewRequest() {}

  explicit QuerySmsStatisticsByTemplateNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (prodId) {
      res["ProdId"] = boost::any(*prodId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    if (template_) {
      res["Template"] = boost::any(*template_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ProdId") != m.end() && !m["ProdId"].empty()) {
      prodId = make_shared<string>(boost::any_cast<string>(m["ProdId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["Template"]));
    }
  }


  virtual ~QuerySmsStatisticsByTemplateNewRequest() = default;
};
class QuerySmsStatisticsByTemplateNewResponseBodyListSmsStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<string> detailStsDate{};
  shared_ptr<string> downloadUrl{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<string> sendSuccessRate{};
  shared_ptr<long> sendTotal{};
  shared_ptr<long> sendTotalFail{};
  shared_ptr<long> sendTotalSuccess{};
  shared_ptr<long> sendTotalUnknown{};
  shared_ptr<string> status{};
  shared_ptr<string> templateCode{};
  shared_ptr<string> templateName{};

  QuerySmsStatisticsByTemplateNewResponseBodyListSmsStatisticsResponse() {}

  explicit QuerySmsStatisticsByTemplateNewResponseBodyListSmsStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (detailStsDate) {
      res["DetailStsDate"] = boost::any(*detailStsDate);
    }
    if (downloadUrl) {
      res["DownloadUrl"] = boost::any(*downloadUrl);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (sendSuccessRate) {
      res["SendSuccessRate"] = boost::any(*sendSuccessRate);
    }
    if (sendTotal) {
      res["SendTotal"] = boost::any(*sendTotal);
    }
    if (sendTotalFail) {
      res["SendTotalFail"] = boost::any(*sendTotalFail);
    }
    if (sendTotalSuccess) {
      res["SendTotalSuccess"] = boost::any(*sendTotalSuccess);
    }
    if (sendTotalUnknown) {
      res["SendTotalUnknown"] = boost::any(*sendTotalUnknown);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DetailStsDate") != m.end() && !m["DetailStsDate"].empty()) {
      detailStsDate = make_shared<string>(boost::any_cast<string>(m["DetailStsDate"]));
    }
    if (m.find("DownloadUrl") != m.end() && !m["DownloadUrl"].empty()) {
      downloadUrl = make_shared<string>(boost::any_cast<string>(m["DownloadUrl"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("SendSuccessRate") != m.end() && !m["SendSuccessRate"].empty()) {
      sendSuccessRate = make_shared<string>(boost::any_cast<string>(m["SendSuccessRate"]));
    }
    if (m.find("SendTotal") != m.end() && !m["SendTotal"].empty()) {
      sendTotal = make_shared<long>(boost::any_cast<long>(m["SendTotal"]));
    }
    if (m.find("SendTotalFail") != m.end() && !m["SendTotalFail"].empty()) {
      sendTotalFail = make_shared<long>(boost::any_cast<long>(m["SendTotalFail"]));
    }
    if (m.find("SendTotalSuccess") != m.end() && !m["SendTotalSuccess"].empty()) {
      sendTotalSuccess = make_shared<long>(boost::any_cast<long>(m["SendTotalSuccess"]));
    }
    if (m.find("SendTotalUnknown") != m.end() && !m["SendTotalUnknown"].empty()) {
      sendTotalUnknown = make_shared<long>(boost::any_cast<long>(m["SendTotalUnknown"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
  }


  virtual ~QuerySmsStatisticsByTemplateNewResponseBodyListSmsStatisticsResponse() = default;
};
class QuerySmsStatisticsByTemplateNewResponseBodyList : public Darabonba::Model {
public:
  shared_ptr<vector<QuerySmsStatisticsByTemplateNewResponseBodyListSmsStatisticsResponse>> smsStatisticsResponse{};

  QuerySmsStatisticsByTemplateNewResponseBodyList() {}

  explicit QuerySmsStatisticsByTemplateNewResponseBodyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (smsStatisticsResponse) {
      vector<boost::any> temp1;
      for(auto item1:*smsStatisticsResponse){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SmsStatisticsResponse"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SmsStatisticsResponse") != m.end() && !m["SmsStatisticsResponse"].empty()) {
      if (typeid(vector<boost::any>) == m["SmsStatisticsResponse"].type()) {
        vector<QuerySmsStatisticsByTemplateNewResponseBodyListSmsStatisticsResponse> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SmsStatisticsResponse"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySmsStatisticsByTemplateNewResponseBodyListSmsStatisticsResponse model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        smsStatisticsResponse = make_shared<vector<QuerySmsStatisticsByTemplateNewResponseBodyListSmsStatisticsResponse>>(expect1);
      }
    }
  }


  virtual ~QuerySmsStatisticsByTemplateNewResponseBodyList() = default;
};
class QuerySmsStatisticsByTemplateNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<QuerySmsStatisticsByTemplateNewResponseBodyList> list{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  QuerySmsStatisticsByTemplateNewResponseBody() {}

  explicit QuerySmsStatisticsByTemplateNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QuerySmsStatisticsByTemplateNewResponseBodyList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QuerySmsStatisticsByTemplateNewResponseBodyList>(model1);
      }
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QuerySmsStatisticsByTemplateNewResponseBody() = default;
};
class QuerySmsStatisticsByTemplateNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySmsStatisticsByTemplateNewResponseBody> body{};

  QuerySmsStatisticsByTemplateNewResponse() {}

  explicit QuerySmsStatisticsByTemplateNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySmsStatisticsByTemplateNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySmsStatisticsByTemplateNewResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySmsStatisticsByTemplateNewResponse() = default;
};
class QuerySmsStatisticsNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> endDate{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> prodCode{};
  shared_ptr<long> prodId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> signName{};
  shared_ptr<string> startDate{};
  shared_ptr<string> template_{};

  QuerySmsStatisticsNewRequest() {}

  explicit QuerySmsStatisticsNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (prodId) {
      res["ProdId"] = boost::any(*prodId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (signName) {
      res["SignName"] = boost::any(*signName);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    if (template_) {
      res["Template"] = boost::any(*template_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ProdId") != m.end() && !m["ProdId"].empty()) {
      prodId = make_shared<long>(boost::any_cast<long>(m["ProdId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SignName") != m.end() && !m["SignName"].empty()) {
      signName = make_shared<string>(boost::any_cast<string>(m["SignName"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["Template"]));
    }
  }


  virtual ~QuerySmsStatisticsNewRequest() = default;
};
class QuerySmsStatisticsNewResponseBodyList : public Darabonba::Model {
public:
  shared_ptr<long> bizType{};
  shared_ptr<string> detailStsDate{};
  shared_ptr<string> downloadUrl{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<string> sendSuccessRate{};
  shared_ptr<long> sendTotal{};
  shared_ptr<long> sendTotalFail{};
  shared_ptr<long> sendTotalSuccess{};
  shared_ptr<long> sendTotalUnknown{};
  shared_ptr<string> signName{};
  shared_ptr<string> status{};
  shared_ptr<string> templateCode{};
  shared_ptr<string> templateName{};

  QuerySmsStatisticsNewResponseBodyList() {}

  explicit QuerySmsStatisticsNewResponseBodyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (detailStsDate) {
      res["DetailStsDate"] = boost::any(*detailStsDate);
    }
    if (downloadUrl) {
      res["DownloadUrl"] = boost::any(*downloadUrl);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (sendSuccessRate) {
      res["SendSuccessRate"] = boost::any(*sendSuccessRate);
    }
    if (sendTotal) {
      res["SendTotal"] = boost::any(*sendTotal);
    }
    if (sendTotalFail) {
      res["SendTotalFail"] = boost::any(*sendTotalFail);
    }
    if (sendTotalSuccess) {
      res["SendTotalSuccess"] = boost::any(*sendTotalSuccess);
    }
    if (sendTotalUnknown) {
      res["SendTotalUnknown"] = boost::any(*sendTotalUnknown);
    }
    if (signName) {
      res["SignName"] = boost::any(*signName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<long>(boost::any_cast<long>(m["BizType"]));
    }
    if (m.find("DetailStsDate") != m.end() && !m["DetailStsDate"].empty()) {
      detailStsDate = make_shared<string>(boost::any_cast<string>(m["DetailStsDate"]));
    }
    if (m.find("DownloadUrl") != m.end() && !m["DownloadUrl"].empty()) {
      downloadUrl = make_shared<string>(boost::any_cast<string>(m["DownloadUrl"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("SendSuccessRate") != m.end() && !m["SendSuccessRate"].empty()) {
      sendSuccessRate = make_shared<string>(boost::any_cast<string>(m["SendSuccessRate"]));
    }
    if (m.find("SendTotal") != m.end() && !m["SendTotal"].empty()) {
      sendTotal = make_shared<long>(boost::any_cast<long>(m["SendTotal"]));
    }
    if (m.find("SendTotalFail") != m.end() && !m["SendTotalFail"].empty()) {
      sendTotalFail = make_shared<long>(boost::any_cast<long>(m["SendTotalFail"]));
    }
    if (m.find("SendTotalSuccess") != m.end() && !m["SendTotalSuccess"].empty()) {
      sendTotalSuccess = make_shared<long>(boost::any_cast<long>(m["SendTotalSuccess"]));
    }
    if (m.find("SendTotalUnknown") != m.end() && !m["SendTotalUnknown"].empty()) {
      sendTotalUnknown = make_shared<long>(boost::any_cast<long>(m["SendTotalUnknown"]));
    }
    if (m.find("SignName") != m.end() && !m["SignName"].empty()) {
      signName = make_shared<string>(boost::any_cast<string>(m["SignName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
  }


  virtual ~QuerySmsStatisticsNewResponseBodyList() = default;
};
class QuerySmsStatisticsNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<QuerySmsStatisticsNewResponseBodyList>> list{};
  shared_ptr<string> requestId{};

  QuerySmsStatisticsNewResponseBody() {}

  explicit QuerySmsStatisticsNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<QuerySmsStatisticsNewResponseBodyList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySmsStatisticsNewResponseBodyList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<QuerySmsStatisticsNewResponseBodyList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QuerySmsStatisticsNewResponseBody() = default;
};
class QuerySmsStatisticsNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySmsStatisticsNewResponseBody> body{};

  QuerySmsStatisticsNewResponse() {}

  explicit QuerySmsStatisticsNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySmsStatisticsNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySmsStatisticsNewResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySmsStatisticsNewResponse() = default;
};
class QuerySmsStatisticsUrlRequest : public Darabonba::Model {
public:
  shared_ptr<string> endDate{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> prodId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> signName{};
  shared_ptr<string> startDate{};
  shared_ptr<string> template_{};

  QuerySmsStatisticsUrlRequest() {}

  explicit QuerySmsStatisticsUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (prodId) {
      res["ProdId"] = boost::any(*prodId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (signName) {
      res["SignName"] = boost::any(*signName);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    if (template_) {
      res["Template"] = boost::any(*template_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ProdId") != m.end() && !m["ProdId"].empty()) {
      prodId = make_shared<string>(boost::any_cast<string>(m["ProdId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SignName") != m.end() && !m["SignName"].empty()) {
      signName = make_shared<string>(boost::any_cast<string>(m["SignName"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["Template"]));
    }
  }


  virtual ~QuerySmsStatisticsUrlRequest() = default;
};
class QuerySmsStatisticsUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<string> data{};

  QuerySmsStatisticsUrlResponseBody() {}

  explicit QuerySmsStatisticsUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
  }


  virtual ~QuerySmsStatisticsUrlResponseBody() = default;
};
class QuerySmsStatisticsUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySmsStatisticsUrlResponseBody> body{};

  QuerySmsStatisticsUrlResponse() {}

  explicit QuerySmsStatisticsUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySmsStatisticsUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySmsStatisticsUrlResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySmsStatisticsUrlResponse() = default;
};
class QuerySmsStatisticsUrlNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> endDate{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<long> prodId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> signName{};
  shared_ptr<string> startDate{};
  shared_ptr<string> template_{};

  QuerySmsStatisticsUrlNewRequest() {}

  explicit QuerySmsStatisticsUrlNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (prodId) {
      res["ProdId"] = boost::any(*prodId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (signName) {
      res["SignName"] = boost::any(*signName);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    if (template_) {
      res["Template"] = boost::any(*template_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ProdId") != m.end() && !m["ProdId"].empty()) {
      prodId = make_shared<long>(boost::any_cast<long>(m["ProdId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SignName") != m.end() && !m["SignName"].empty()) {
      signName = make_shared<string>(boost::any_cast<string>(m["SignName"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["Template"]));
    }
  }


  virtual ~QuerySmsStatisticsUrlNewRequest() = default;
};
class QuerySmsStatisticsUrlNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> downloadUrl{};
  shared_ptr<string> requestId{};

  QuerySmsStatisticsUrlNewResponseBody() {}

  explicit QuerySmsStatisticsUrlNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downloadUrl) {
      res["DownloadUrl"] = boost::any(*downloadUrl);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownloadUrl") != m.end() && !m["DownloadUrl"].empty()) {
      downloadUrl = make_shared<string>(boost::any_cast<string>(m["DownloadUrl"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QuerySmsStatisticsUrlNewResponseBody() = default;
};
class QuerySmsStatisticsUrlNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySmsStatisticsUrlNewResponseBody> body{};

  QuerySmsStatisticsUrlNewResponse() {}

  explicit QuerySmsStatisticsUrlNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySmsStatisticsUrlNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySmsStatisticsUrlNewResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySmsStatisticsUrlNewResponse() = default;
};
class QuerySmsStepRequest : public Darabonba::Model {
public:
  shared_ptr<string> billCycle{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QuerySmsStepRequest() {}

  explicit QuerySmsStepRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billCycle) {
      res["BillCycle"] = boost::any(*billCycle);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BillCycle") != m.end() && !m["BillCycle"].empty()) {
      billCycle = make_shared<string>(boost::any_cast<string>(m["BillCycle"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QuerySmsStepRequest() = default;
};
class QuerySmsStepResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<string> data{};

  QuerySmsStepResponseBody() {}

  explicit QuerySmsStepResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
  }


  virtual ~QuerySmsStepResponseBody() = default;
};
class QuerySmsStepResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySmsStepResponseBody> body{};

  QuerySmsStepResponse() {}

  explicit QuerySmsStepResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySmsStepResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySmsStepResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySmsStepResponse() = default;
};
class QuerySmsTemplateByCodeRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> templateCode{};

  QuerySmsTemplateByCodeRequest() {}

  explicit QuerySmsTemplateByCodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
  }


  virtual ~QuerySmsTemplateByCodeRequest() = default;
};
class QuerySmsTemplateByCodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<string> data{};

  QuerySmsTemplateByCodeResponseBody() {}

  explicit QuerySmsTemplateByCodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
  }


  virtual ~QuerySmsTemplateByCodeResponseBody() = default;
};
class QuerySmsTemplateByCodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySmsTemplateByCodeResponseBody> body{};

  QuerySmsTemplateByCodeResponse() {}

  explicit QuerySmsTemplateByCodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySmsTemplateByCodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySmsTemplateByCodeResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySmsTemplateByCodeResponse() = default;
};
class QuerySmsTemplateByCodeNewRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> templateCode{};

  QuerySmsTemplateByCodeNewRequest() {}

  explicit QuerySmsTemplateByCodeNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
  }


  virtual ~QuerySmsTemplateByCodeNewRequest() = default;
};
class QuerySmsTemplateByCodeNewResponseBodyApplicationScene : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};

  QuerySmsTemplateByCodeNewResponseBodyApplicationScene() {}

  explicit QuerySmsTemplateByCodeNewResponseBodyApplicationScene(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~QuerySmsTemplateByCodeNewResponseBodyApplicationScene() = default;
};
class QuerySmsTemplateByCodeNewResponseBodyFileIds : public Darabonba::Model {
public:
  shared_ptr<vector<long>> fileId{};

  QuerySmsTemplateByCodeNewResponseBodyFileIds() {}

  explicit QuerySmsTemplateByCodeNewResponseBodyFileIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["FileId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FileId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      fileId = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~QuerySmsTemplateByCodeNewResponseBodyFileIds() = default;
};
class QuerySmsTemplateByCodeNewResponseBodyFileUrlList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> fileUrl{};

  QuerySmsTemplateByCodeNewResponseBodyFileUrlList() {}

  explicit QuerySmsTemplateByCodeNewResponseBodyFileUrlList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FileUrl"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FileUrl"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fileUrl = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QuerySmsTemplateByCodeNewResponseBodyFileUrlList() = default;
};
class QuerySmsTemplateByCodeNewResponseBodyMoreDataFileIds : public Darabonba::Model {
public:
  shared_ptr<vector<long>> moreDataFileId{};

  QuerySmsTemplateByCodeNewResponseBodyMoreDataFileIds() {}

  explicit QuerySmsTemplateByCodeNewResponseBodyMoreDataFileIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (moreDataFileId) {
      res["MoreDataFileId"] = boost::any(*moreDataFileId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MoreDataFileId") != m.end() && !m["MoreDataFileId"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["MoreDataFileId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MoreDataFileId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      moreDataFileId = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~QuerySmsTemplateByCodeNewResponseBodyMoreDataFileIds() = default;
};
class QuerySmsTemplateByCodeNewResponseBodyMoreDataFileUrls : public Darabonba::Model {
public:
  shared_ptr<vector<string>> moreDataFileUrl{};

  QuerySmsTemplateByCodeNewResponseBodyMoreDataFileUrls() {}

  explicit QuerySmsTemplateByCodeNewResponseBodyMoreDataFileUrls(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (moreDataFileUrl) {
      res["MoreDataFileUrl"] = boost::any(*moreDataFileUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MoreDataFileUrl") != m.end() && !m["MoreDataFileUrl"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MoreDataFileUrl"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MoreDataFileUrl"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      moreDataFileUrl = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QuerySmsTemplateByCodeNewResponseBodyMoreDataFileUrls() = default;
};
class QuerySmsTemplateByCodeNewResponseBodyMoreDataOssKeys : public Darabonba::Model {
public:
  shared_ptr<vector<string>> moreDataOssKey{};

  QuerySmsTemplateByCodeNewResponseBodyMoreDataOssKeys() {}

  explicit QuerySmsTemplateByCodeNewResponseBodyMoreDataOssKeys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (moreDataOssKey) {
      res["MoreDataOssKey"] = boost::any(*moreDataOssKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MoreDataOssKey") != m.end() && !m["MoreDataOssKey"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MoreDataOssKey"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MoreDataOssKey"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      moreDataOssKey = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QuerySmsTemplateByCodeNewResponseBodyMoreDataOssKeys() = default;
};
class QuerySmsTemplateByCodeNewResponseBodyOssKeys : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ossKey{};

  QuerySmsTemplateByCodeNewResponseBodyOssKeys() {}

  explicit QuerySmsTemplateByCodeNewResponseBodyOssKeys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ossKey) {
      res["OssKey"] = boost::any(*ossKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OssKey") != m.end() && !m["OssKey"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OssKey"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OssKey"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ossKey = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QuerySmsTemplateByCodeNewResponseBodyOssKeys() = default;
};
class QuerySmsTemplateByCodeNewResponseBodyTagsTagInfo : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  QuerySmsTemplateByCodeNewResponseBodyTagsTagInfo() {}

  explicit QuerySmsTemplateByCodeNewResponseBodyTagsTagInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~QuerySmsTemplateByCodeNewResponseBodyTagsTagInfo() = default;
};
class QuerySmsTemplateByCodeNewResponseBodyTags : public Darabonba::Model {
public:
  shared_ptr<vector<QuerySmsTemplateByCodeNewResponseBodyTagsTagInfo>> tagInfo{};

  QuerySmsTemplateByCodeNewResponseBodyTags() {}

  explicit QuerySmsTemplateByCodeNewResponseBodyTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagInfo) {
      vector<boost::any> temp1;
      for(auto item1:*tagInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagInfo") != m.end() && !m["TagInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["TagInfo"].type()) {
        vector<QuerySmsTemplateByCodeNewResponseBodyTagsTagInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySmsTemplateByCodeNewResponseBodyTagsTagInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagInfo = make_shared<vector<QuerySmsTemplateByCodeNewResponseBodyTagsTagInfo>>(expect1);
      }
    }
  }


  virtual ~QuerySmsTemplateByCodeNewResponseBodyTags() = default;
};
class QuerySmsTemplateByCodeNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<QuerySmsTemplateByCodeNewResponseBodyApplicationScene> applicationScene{};
  shared_ptr<string> auditInfo{};
  shared_ptr<string> auditRemarkInfo{};
  shared_ptr<string> bizType{};
  shared_ptr<QuerySmsTemplateByCodeNewResponseBodyFileIds> fileIds{};
  shared_ptr<QuerySmsTemplateByCodeNewResponseBodyFileUrlList> fileUrlList{};
  shared_ptr<string> from{};
  shared_ptr<string> gmtCreateStr{};
  shared_ptr<long> intlType{};
  shared_ptr<QuerySmsTemplateByCodeNewResponseBodyMoreDataFileIds> moreDataFileIds{};
  shared_ptr<QuerySmsTemplateByCodeNewResponseBodyMoreDataFileUrls> moreDataFileUrls{};
  shared_ptr<QuerySmsTemplateByCodeNewResponseBodyMoreDataOssKeys> moreDataOssKeys{};
  shared_ptr<bool> needAuthorized{};
  shared_ptr<bool> openTag{};
  shared_ptr<string> orderId{};
  shared_ptr<QuerySmsTemplateByCodeNewResponseBodyOssKeys> ossKeys{};
  shared_ptr<string> productUrl{};
  shared_ptr<string> relatedSignName{};
  shared_ptr<string> remark{};
  shared_ptr<string> requestId{};
  shared_ptr<long> rmdTemplateId{};
  shared_ptr<long> rmdTemplateVariableNum{};
  shared_ptr<string> signName{};
  shared_ptr<long> signType{};
  shared_ptr<string> smsContent{};
  shared_ptr<QuerySmsTemplateByCodeNewResponseBodyTags> tags{};
  shared_ptr<string> templateCode{};
  shared_ptr<string> templateName{};
  shared_ptr<string> templateRule{};

  QuerySmsTemplateByCodeNewResponseBody() {}

  explicit QuerySmsTemplateByCodeNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["AccessToken"] = boost::any(*accessToken);
    }
    if (applicationScene) {
      res["ApplicationScene"] = applicationScene ? boost::any(applicationScene->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (auditInfo) {
      res["AuditInfo"] = boost::any(*auditInfo);
    }
    if (auditRemarkInfo) {
      res["AuditRemarkInfo"] = boost::any(*auditRemarkInfo);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (fileIds) {
      res["FileIds"] = fileIds ? boost::any(fileIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fileUrlList) {
      res["FileUrlList"] = fileUrlList ? boost::any(fileUrlList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (gmtCreateStr) {
      res["GmtCreateStr"] = boost::any(*gmtCreateStr);
    }
    if (intlType) {
      res["IntlType"] = boost::any(*intlType);
    }
    if (moreDataFileIds) {
      res["MoreDataFileIds"] = moreDataFileIds ? boost::any(moreDataFileIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (moreDataFileUrls) {
      res["MoreDataFileUrls"] = moreDataFileUrls ? boost::any(moreDataFileUrls->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (moreDataOssKeys) {
      res["MoreDataOssKeys"] = moreDataOssKeys ? boost::any(moreDataOssKeys->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (needAuthorized) {
      res["NeedAuthorized"] = boost::any(*needAuthorized);
    }
    if (openTag) {
      res["OpenTag"] = boost::any(*openTag);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (ossKeys) {
      res["OssKeys"] = ossKeys ? boost::any(ossKeys->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (productUrl) {
      res["ProductUrl"] = boost::any(*productUrl);
    }
    if (relatedSignName) {
      res["RelatedSignName"] = boost::any(*relatedSignName);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (rmdTemplateId) {
      res["RmdTemplateId"] = boost::any(*rmdTemplateId);
    }
    if (rmdTemplateVariableNum) {
      res["RmdTemplateVariableNum"] = boost::any(*rmdTemplateVariableNum);
    }
    if (signName) {
      res["SignName"] = boost::any(*signName);
    }
    if (signType) {
      res["SignType"] = boost::any(*signType);
    }
    if (smsContent) {
      res["SmsContent"] = boost::any(*smsContent);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (templateRule) {
      res["TemplateRule"] = boost::any(*templateRule);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessToken") != m.end() && !m["AccessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["AccessToken"]));
    }
    if (m.find("ApplicationScene") != m.end() && !m["ApplicationScene"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApplicationScene"].type()) {
        QuerySmsTemplateByCodeNewResponseBodyApplicationScene model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApplicationScene"]));
        applicationScene = make_shared<QuerySmsTemplateByCodeNewResponseBodyApplicationScene>(model1);
      }
    }
    if (m.find("AuditInfo") != m.end() && !m["AuditInfo"].empty()) {
      auditInfo = make_shared<string>(boost::any_cast<string>(m["AuditInfo"]));
    }
    if (m.find("AuditRemarkInfo") != m.end() && !m["AuditRemarkInfo"].empty()) {
      auditRemarkInfo = make_shared<string>(boost::any_cast<string>(m["AuditRemarkInfo"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("FileIds") != m.end() && !m["FileIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["FileIds"].type()) {
        QuerySmsTemplateByCodeNewResponseBodyFileIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FileIds"]));
        fileIds = make_shared<QuerySmsTemplateByCodeNewResponseBodyFileIds>(model1);
      }
    }
    if (m.find("FileUrlList") != m.end() && !m["FileUrlList"].empty()) {
      if (typeid(map<string, boost::any>) == m["FileUrlList"].type()) {
        QuerySmsTemplateByCodeNewResponseBodyFileUrlList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FileUrlList"]));
        fileUrlList = make_shared<QuerySmsTemplateByCodeNewResponseBodyFileUrlList>(model1);
      }
    }
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
    if (m.find("GmtCreateStr") != m.end() && !m["GmtCreateStr"].empty()) {
      gmtCreateStr = make_shared<string>(boost::any_cast<string>(m["GmtCreateStr"]));
    }
    if (m.find("IntlType") != m.end() && !m["IntlType"].empty()) {
      intlType = make_shared<long>(boost::any_cast<long>(m["IntlType"]));
    }
    if (m.find("MoreDataFileIds") != m.end() && !m["MoreDataFileIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["MoreDataFileIds"].type()) {
        QuerySmsTemplateByCodeNewResponseBodyMoreDataFileIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MoreDataFileIds"]));
        moreDataFileIds = make_shared<QuerySmsTemplateByCodeNewResponseBodyMoreDataFileIds>(model1);
      }
    }
    if (m.find("MoreDataFileUrls") != m.end() && !m["MoreDataFileUrls"].empty()) {
      if (typeid(map<string, boost::any>) == m["MoreDataFileUrls"].type()) {
        QuerySmsTemplateByCodeNewResponseBodyMoreDataFileUrls model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MoreDataFileUrls"]));
        moreDataFileUrls = make_shared<QuerySmsTemplateByCodeNewResponseBodyMoreDataFileUrls>(model1);
      }
    }
    if (m.find("MoreDataOssKeys") != m.end() && !m["MoreDataOssKeys"].empty()) {
      if (typeid(map<string, boost::any>) == m["MoreDataOssKeys"].type()) {
        QuerySmsTemplateByCodeNewResponseBodyMoreDataOssKeys model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MoreDataOssKeys"]));
        moreDataOssKeys = make_shared<QuerySmsTemplateByCodeNewResponseBodyMoreDataOssKeys>(model1);
      }
    }
    if (m.find("NeedAuthorized") != m.end() && !m["NeedAuthorized"].empty()) {
      needAuthorized = make_shared<bool>(boost::any_cast<bool>(m["NeedAuthorized"]));
    }
    if (m.find("OpenTag") != m.end() && !m["OpenTag"].empty()) {
      openTag = make_shared<bool>(boost::any_cast<bool>(m["OpenTag"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("OssKeys") != m.end() && !m["OssKeys"].empty()) {
      if (typeid(map<string, boost::any>) == m["OssKeys"].type()) {
        QuerySmsTemplateByCodeNewResponseBodyOssKeys model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OssKeys"]));
        ossKeys = make_shared<QuerySmsTemplateByCodeNewResponseBodyOssKeys>(model1);
      }
    }
    if (m.find("ProductUrl") != m.end() && !m["ProductUrl"].empty()) {
      productUrl = make_shared<string>(boost::any_cast<string>(m["ProductUrl"]));
    }
    if (m.find("RelatedSignName") != m.end() && !m["RelatedSignName"].empty()) {
      relatedSignName = make_shared<string>(boost::any_cast<string>(m["RelatedSignName"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RmdTemplateId") != m.end() && !m["RmdTemplateId"].empty()) {
      rmdTemplateId = make_shared<long>(boost::any_cast<long>(m["RmdTemplateId"]));
    }
    if (m.find("RmdTemplateVariableNum") != m.end() && !m["RmdTemplateVariableNum"].empty()) {
      rmdTemplateVariableNum = make_shared<long>(boost::any_cast<long>(m["RmdTemplateVariableNum"]));
    }
    if (m.find("SignName") != m.end() && !m["SignName"].empty()) {
      signName = make_shared<string>(boost::any_cast<string>(m["SignName"]));
    }
    if (m.find("SignType") != m.end() && !m["SignType"].empty()) {
      signType = make_shared<long>(boost::any_cast<long>(m["SignType"]));
    }
    if (m.find("SmsContent") != m.end() && !m["SmsContent"].empty()) {
      smsContent = make_shared<string>(boost::any_cast<string>(m["SmsContent"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        QuerySmsTemplateByCodeNewResponseBodyTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<QuerySmsTemplateByCodeNewResponseBodyTags>(model1);
      }
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("TemplateRule") != m.end() && !m["TemplateRule"].empty()) {
      templateRule = make_shared<string>(boost::any_cast<string>(m["TemplateRule"]));
    }
  }


  virtual ~QuerySmsTemplateByCodeNewResponseBody() = default;
};
class QuerySmsTemplateByCodeNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySmsTemplateByCodeNewResponseBody> body{};

  QuerySmsTemplateByCodeNewResponse() {}

  explicit QuerySmsTemplateByCodeNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySmsTemplateByCodeNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySmsTemplateByCodeNewResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySmsTemplateByCodeNewResponse() = default;
};
class QuerySmsTemplateLastRangeRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizType{};
  shared_ptr<long> limit{};
  shared_ptr<bool> needDefaultTemplate{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> prodId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> templateName{};

  QuerySmsTemplateLastRangeRequest() {}

  explicit QuerySmsTemplateLastRangeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (limit) {
      res["Limit"] = boost::any(*limit);
    }
    if (needDefaultTemplate) {
      res["NeedDefaultTemplate"] = boost::any(*needDefaultTemplate);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (prodId) {
      res["ProdId"] = boost::any(*prodId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("Limit") != m.end() && !m["Limit"].empty()) {
      limit = make_shared<long>(boost::any_cast<long>(m["Limit"]));
    }
    if (m.find("NeedDefaultTemplate") != m.end() && !m["NeedDefaultTemplate"].empty()) {
      needDefaultTemplate = make_shared<bool>(boost::any_cast<bool>(m["NeedDefaultTemplate"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ProdId") != m.end() && !m["ProdId"].empty()) {
      prodId = make_shared<string>(boost::any_cast<string>(m["ProdId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
  }


  virtual ~QuerySmsTemplateLastRangeRequest() = default;
};
class QuerySmsTemplateLastRangeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<string> data{};

  QuerySmsTemplateLastRangeResponseBody() {}

  explicit QuerySmsTemplateLastRangeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
  }


  virtual ~QuerySmsTemplateLastRangeResponseBody() = default;
};
class QuerySmsTemplateLastRangeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySmsTemplateLastRangeResponseBody> body{};

  QuerySmsTemplateLastRangeResponse() {}

  explicit QuerySmsTemplateLastRangeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySmsTemplateLastRangeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySmsTemplateLastRangeResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySmsTemplateLastRangeResponse() = default;
};
class QuerySmsTemplateLastRangeNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizType{};
  shared_ptr<bool> filterAnyParam{};
  shared_ptr<long> limit{};
  shared_ptr<bool> needDefaultTemplate{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> prodId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> templateName{};

  QuerySmsTemplateLastRangeNewRequest() {}

  explicit QuerySmsTemplateLastRangeNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (filterAnyParam) {
      res["FilterAnyParam"] = boost::any(*filterAnyParam);
    }
    if (limit) {
      res["Limit"] = boost::any(*limit);
    }
    if (needDefaultTemplate) {
      res["NeedDefaultTemplate"] = boost::any(*needDefaultTemplate);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (prodId) {
      res["ProdId"] = boost::any(*prodId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("FilterAnyParam") != m.end() && !m["FilterAnyParam"].empty()) {
      filterAnyParam = make_shared<bool>(boost::any_cast<bool>(m["FilterAnyParam"]));
    }
    if (m.find("Limit") != m.end() && !m["Limit"].empty()) {
      limit = make_shared<long>(boost::any_cast<long>(m["Limit"]));
    }
    if (m.find("NeedDefaultTemplate") != m.end() && !m["NeedDefaultTemplate"].empty()) {
      needDefaultTemplate = make_shared<bool>(boost::any_cast<bool>(m["NeedDefaultTemplate"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ProdId") != m.end() && !m["ProdId"].empty()) {
      prodId = make_shared<string>(boost::any_cast<string>(m["ProdId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
  }


  virtual ~QuerySmsTemplateLastRangeNewRequest() = default;
};
class QuerySmsTemplateLastRangeNewResponseBodyListSmsTemplateTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  QuerySmsTemplateLastRangeNewResponseBodyListSmsTemplateTagsTag() {}

  explicit QuerySmsTemplateLastRangeNewResponseBodyListSmsTemplateTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~QuerySmsTemplateLastRangeNewResponseBodyListSmsTemplateTagsTag() = default;
};
class QuerySmsTemplateLastRangeNewResponseBodyListSmsTemplateTags : public Darabonba::Model {
public:
  shared_ptr<vector<QuerySmsTemplateLastRangeNewResponseBodyListSmsTemplateTagsTag>> tag{};

  QuerySmsTemplateLastRangeNewResponseBodyListSmsTemplateTags() {}

  explicit QuerySmsTemplateLastRangeNewResponseBodyListSmsTemplateTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<QuerySmsTemplateLastRangeNewResponseBodyListSmsTemplateTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySmsTemplateLastRangeNewResponseBodyListSmsTemplateTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<QuerySmsTemplateLastRangeNewResponseBodyListSmsTemplateTagsTag>>(expect1);
      }
    }
  }


  virtual ~QuerySmsTemplateLastRangeNewResponseBodyListSmsTemplateTags() = default;
};
class QuerySmsTemplateLastRangeNewResponseBodyListSmsTemplate : public Darabonba::Model {
public:
  shared_ptr<string> auditInfo{};
  shared_ptr<string> auditRemarkInfo{};
  shared_ptr<string> auditState{};
  shared_ptr<string> bizType{};
  shared_ptr<string> expireDateStr{};
  shared_ptr<string> gmtCreateStr{};
  shared_ptr<string> id{};
  shared_ptr<bool> isAnyParam{};
  shared_ptr<bool> isDefaultTemplate{};
  shared_ptr<bool> isRecently{};
  shared_ptr<string> orderId{};
  shared_ptr<string> passErrType{};
  shared_ptr<string> remark{};
  shared_ptr<long> signType{};
  shared_ptr<string> smsContent{};
  shared_ptr<string> supportVendor{};
  shared_ptr<QuerySmsTemplateLastRangeNewResponseBodyListSmsTemplateTags> tags{};
  shared_ptr<string> templateCode{};
  shared_ptr<string> templateContent{};
  shared_ptr<string> templateName{};
  shared_ptr<string> templateRule{};

  QuerySmsTemplateLastRangeNewResponseBodyListSmsTemplate() {}

  explicit QuerySmsTemplateLastRangeNewResponseBodyListSmsTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (auditInfo) {
      res["AuditInfo"] = boost::any(*auditInfo);
    }
    if (auditRemarkInfo) {
      res["AuditRemarkInfo"] = boost::any(*auditRemarkInfo);
    }
    if (auditState) {
      res["AuditState"] = boost::any(*auditState);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (expireDateStr) {
      res["ExpireDateStr"] = boost::any(*expireDateStr);
    }
    if (gmtCreateStr) {
      res["GmtCreateStr"] = boost::any(*gmtCreateStr);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (isAnyParam) {
      res["IsAnyParam"] = boost::any(*isAnyParam);
    }
    if (isDefaultTemplate) {
      res["IsDefaultTemplate"] = boost::any(*isDefaultTemplate);
    }
    if (isRecently) {
      res["IsRecently"] = boost::any(*isRecently);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (passErrType) {
      res["PassErrType"] = boost::any(*passErrType);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (signType) {
      res["SignType"] = boost::any(*signType);
    }
    if (smsContent) {
      res["SmsContent"] = boost::any(*smsContent);
    }
    if (supportVendor) {
      res["SupportVendor"] = boost::any(*supportVendor);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    if (templateContent) {
      res["TemplateContent"] = boost::any(*templateContent);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (templateRule) {
      res["TemplateRule"] = boost::any(*templateRule);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuditInfo") != m.end() && !m["AuditInfo"].empty()) {
      auditInfo = make_shared<string>(boost::any_cast<string>(m["AuditInfo"]));
    }
    if (m.find("AuditRemarkInfo") != m.end() && !m["AuditRemarkInfo"].empty()) {
      auditRemarkInfo = make_shared<string>(boost::any_cast<string>(m["AuditRemarkInfo"]));
    }
    if (m.find("AuditState") != m.end() && !m["AuditState"].empty()) {
      auditState = make_shared<string>(boost::any_cast<string>(m["AuditState"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("ExpireDateStr") != m.end() && !m["ExpireDateStr"].empty()) {
      expireDateStr = make_shared<string>(boost::any_cast<string>(m["ExpireDateStr"]));
    }
    if (m.find("GmtCreateStr") != m.end() && !m["GmtCreateStr"].empty()) {
      gmtCreateStr = make_shared<string>(boost::any_cast<string>(m["GmtCreateStr"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("IsAnyParam") != m.end() && !m["IsAnyParam"].empty()) {
      isAnyParam = make_shared<bool>(boost::any_cast<bool>(m["IsAnyParam"]));
    }
    if (m.find("IsDefaultTemplate") != m.end() && !m["IsDefaultTemplate"].empty()) {
      isDefaultTemplate = make_shared<bool>(boost::any_cast<bool>(m["IsDefaultTemplate"]));
    }
    if (m.find("IsRecently") != m.end() && !m["IsRecently"].empty()) {
      isRecently = make_shared<bool>(boost::any_cast<bool>(m["IsRecently"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("PassErrType") != m.end() && !m["PassErrType"].empty()) {
      passErrType = make_shared<string>(boost::any_cast<string>(m["PassErrType"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("SignType") != m.end() && !m["SignType"].empty()) {
      signType = make_shared<long>(boost::any_cast<long>(m["SignType"]));
    }
    if (m.find("SmsContent") != m.end() && !m["SmsContent"].empty()) {
      smsContent = make_shared<string>(boost::any_cast<string>(m["SmsContent"]));
    }
    if (m.find("SupportVendor") != m.end() && !m["SupportVendor"].empty()) {
      supportVendor = make_shared<string>(boost::any_cast<string>(m["SupportVendor"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        QuerySmsTemplateLastRangeNewResponseBodyListSmsTemplateTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<QuerySmsTemplateLastRangeNewResponseBodyListSmsTemplateTags>(model1);
      }
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
    if (m.find("TemplateContent") != m.end() && !m["TemplateContent"].empty()) {
      templateContent = make_shared<string>(boost::any_cast<string>(m["TemplateContent"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("TemplateRule") != m.end() && !m["TemplateRule"].empty()) {
      templateRule = make_shared<string>(boost::any_cast<string>(m["TemplateRule"]));
    }
  }


  virtual ~QuerySmsTemplateLastRangeNewResponseBodyListSmsTemplate() = default;
};
class QuerySmsTemplateLastRangeNewResponseBodyList : public Darabonba::Model {
public:
  shared_ptr<vector<QuerySmsTemplateLastRangeNewResponseBodyListSmsTemplate>> smsTemplate{};

  QuerySmsTemplateLastRangeNewResponseBodyList() {}

  explicit QuerySmsTemplateLastRangeNewResponseBodyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (smsTemplate) {
      vector<boost::any> temp1;
      for(auto item1:*smsTemplate){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SmsTemplate"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SmsTemplate") != m.end() && !m["SmsTemplate"].empty()) {
      if (typeid(vector<boost::any>) == m["SmsTemplate"].type()) {
        vector<QuerySmsTemplateLastRangeNewResponseBodyListSmsTemplate> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SmsTemplate"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySmsTemplateLastRangeNewResponseBodyListSmsTemplate model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        smsTemplate = make_shared<vector<QuerySmsTemplateLastRangeNewResponseBodyListSmsTemplate>>(expect1);
      }
    }
  }


  virtual ~QuerySmsTemplateLastRangeNewResponseBodyList() = default;
};
class QuerySmsTemplateLastRangeNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<QuerySmsTemplateLastRangeNewResponseBodyList> list{};
  shared_ptr<string> requestId{};

  QuerySmsTemplateLastRangeNewResponseBody() {}

  explicit QuerySmsTemplateLastRangeNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QuerySmsTemplateLastRangeNewResponseBodyList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QuerySmsTemplateLastRangeNewResponseBodyList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QuerySmsTemplateLastRangeNewResponseBody() = default;
};
class QuerySmsTemplateLastRangeNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySmsTemplateLastRangeNewResponseBody> body{};

  QuerySmsTemplateLastRangeNewResponse() {}

  explicit QuerySmsTemplateLastRangeNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySmsTemplateLastRangeNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySmsTemplateLastRangeNewResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySmsTemplateLastRangeNewResponse() = default;
};
class QuerySmsTemplateListRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  QuerySmsTemplateListRequestTags() {}

  explicit QuerySmsTemplateListRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~QuerySmsTemplateListRequestTags() = default;
};
class QuerySmsTemplateListRequest : public Darabonba::Model {
public:
  shared_ptr<string> auditState{};
  shared_ptr<string> bizType{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> prodType{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<QuerySmsTemplateListRequestTags>> tags{};
  shared_ptr<string> templateName{};

  QuerySmsTemplateListRequest() {}

  explicit QuerySmsTemplateListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (auditState) {
      res["AuditState"] = boost::any(*auditState);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (prodType) {
      res["ProdType"] = boost::any(*prodType);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuditState") != m.end() && !m["AuditState"].empty()) {
      auditState = make_shared<string>(boost::any_cast<string>(m["AuditState"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ProdType") != m.end() && !m["ProdType"].empty()) {
      prodType = make_shared<string>(boost::any_cast<string>(m["ProdType"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<QuerySmsTemplateListRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySmsTemplateListRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<QuerySmsTemplateListRequestTags>>(expect1);
      }
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
  }


  virtual ~QuerySmsTemplateListRequest() = default;
};
class QuerySmsTemplateListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<string> data{};

  QuerySmsTemplateListResponseBody() {}

  explicit QuerySmsTemplateListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
  }


  virtual ~QuerySmsTemplateListResponseBody() = default;
};
class QuerySmsTemplateListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySmsTemplateListResponseBody> body{};

  QuerySmsTemplateListResponse() {}

  explicit QuerySmsTemplateListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySmsTemplateListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySmsTemplateListResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySmsTemplateListResponse() = default;
};
class QuerySmsTemplateListNewRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  QuerySmsTemplateListNewRequestTags() {}

  explicit QuerySmsTemplateListNewRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~QuerySmsTemplateListNewRequestTags() = default;
};
class QuerySmsTemplateListNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> auditState{};
  shared_ptr<string> bizType{};
  shared_ptr<long> intlType{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> prodType{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> tagListString{};
  shared_ptr<vector<QuerySmsTemplateListNewRequestTags>> tags{};
  shared_ptr<string> templateName{};

  QuerySmsTemplateListNewRequest() {}

  explicit QuerySmsTemplateListNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (auditState) {
      res["AuditState"] = boost::any(*auditState);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (intlType) {
      res["IntlType"] = boost::any(*intlType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (prodType) {
      res["ProdType"] = boost::any(*prodType);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tagListString) {
      res["TagListString"] = boost::any(*tagListString);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuditState") != m.end() && !m["AuditState"].empty()) {
      auditState = make_shared<string>(boost::any_cast<string>(m["AuditState"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("IntlType") != m.end() && !m["IntlType"].empty()) {
      intlType = make_shared<long>(boost::any_cast<long>(m["IntlType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ProdType") != m.end() && !m["ProdType"].empty()) {
      prodType = make_shared<string>(boost::any_cast<string>(m["ProdType"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TagListString") != m.end() && !m["TagListString"].empty()) {
      tagListString = make_shared<string>(boost::any_cast<string>(m["TagListString"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<QuerySmsTemplateListNewRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySmsTemplateListNewRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<QuerySmsTemplateListNewRequestTags>>(expect1);
      }
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
  }


  virtual ~QuerySmsTemplateListNewRequest() = default;
};
class QuerySmsTemplateListNewResponseBodyListSmsTemplateTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  QuerySmsTemplateListNewResponseBodyListSmsTemplateTagsTag() {}

  explicit QuerySmsTemplateListNewResponseBodyListSmsTemplateTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~QuerySmsTemplateListNewResponseBodyListSmsTemplateTagsTag() = default;
};
class QuerySmsTemplateListNewResponseBodyListSmsTemplateTags : public Darabonba::Model {
public:
  shared_ptr<vector<QuerySmsTemplateListNewResponseBodyListSmsTemplateTagsTag>> tag{};

  QuerySmsTemplateListNewResponseBodyListSmsTemplateTags() {}

  explicit QuerySmsTemplateListNewResponseBodyListSmsTemplateTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<QuerySmsTemplateListNewResponseBodyListSmsTemplateTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySmsTemplateListNewResponseBodyListSmsTemplateTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<QuerySmsTemplateListNewResponseBodyListSmsTemplateTagsTag>>(expect1);
      }
    }
  }


  virtual ~QuerySmsTemplateListNewResponseBodyListSmsTemplateTags() = default;
};
class QuerySmsTemplateListNewResponseBodyListSmsTemplate : public Darabonba::Model {
public:
  shared_ptr<string> auditInfo{};
  shared_ptr<string> auditRemarkInfo{};
  shared_ptr<string> auditState{};
  shared_ptr<string> bizType{};
  shared_ptr<string> expireDateStr{};
  shared_ptr<string> gmtCreateStr{};
  shared_ptr<string> id{};
  shared_ptr<bool> intelligentApproval{};
  shared_ptr<long> intlType{};
  shared_ptr<bool> isAnyParam{};
  shared_ptr<bool> isDefaultTemplate{};
  shared_ptr<bool> isRecently{};
  shared_ptr<long> orderCount{};
  shared_ptr<string> orderId{};
  shared_ptr<string> passErrType{};
  shared_ptr<string> productUrl{};
  shared_ptr<string> relatedSignName{};
  shared_ptr<string> remark{};
  shared_ptr<long> signType{};
  shared_ptr<string> smsContent{};
  shared_ptr<string> supportVendor{};
  shared_ptr<QuerySmsTemplateListNewResponseBodyListSmsTemplateTags> tags{};
  shared_ptr<string> templateCode{};
  shared_ptr<string> templateContent{};
  shared_ptr<string> templateName{};
  shared_ptr<string> templateRule{};

  QuerySmsTemplateListNewResponseBodyListSmsTemplate() {}

  explicit QuerySmsTemplateListNewResponseBodyListSmsTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (auditInfo) {
      res["AuditInfo"] = boost::any(*auditInfo);
    }
    if (auditRemarkInfo) {
      res["AuditRemarkInfo"] = boost::any(*auditRemarkInfo);
    }
    if (auditState) {
      res["AuditState"] = boost::any(*auditState);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (expireDateStr) {
      res["ExpireDateStr"] = boost::any(*expireDateStr);
    }
    if (gmtCreateStr) {
      res["GmtCreateStr"] = boost::any(*gmtCreateStr);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (intelligentApproval) {
      res["IntelligentApproval"] = boost::any(*intelligentApproval);
    }
    if (intlType) {
      res["IntlType"] = boost::any(*intlType);
    }
    if (isAnyParam) {
      res["IsAnyParam"] = boost::any(*isAnyParam);
    }
    if (isDefaultTemplate) {
      res["IsDefaultTemplate"] = boost::any(*isDefaultTemplate);
    }
    if (isRecently) {
      res["IsRecently"] = boost::any(*isRecently);
    }
    if (orderCount) {
      res["OrderCount"] = boost::any(*orderCount);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (passErrType) {
      res["PassErrType"] = boost::any(*passErrType);
    }
    if (productUrl) {
      res["ProductUrl"] = boost::any(*productUrl);
    }
    if (relatedSignName) {
      res["RelatedSignName"] = boost::any(*relatedSignName);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (signType) {
      res["SignType"] = boost::any(*signType);
    }
    if (smsContent) {
      res["SmsContent"] = boost::any(*smsContent);
    }
    if (supportVendor) {
      res["SupportVendor"] = boost::any(*supportVendor);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    if (templateContent) {
      res["TemplateContent"] = boost::any(*templateContent);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (templateRule) {
      res["TemplateRule"] = boost::any(*templateRule);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuditInfo") != m.end() && !m["AuditInfo"].empty()) {
      auditInfo = make_shared<string>(boost::any_cast<string>(m["AuditInfo"]));
    }
    if (m.find("AuditRemarkInfo") != m.end() && !m["AuditRemarkInfo"].empty()) {
      auditRemarkInfo = make_shared<string>(boost::any_cast<string>(m["AuditRemarkInfo"]));
    }
    if (m.find("AuditState") != m.end() && !m["AuditState"].empty()) {
      auditState = make_shared<string>(boost::any_cast<string>(m["AuditState"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("ExpireDateStr") != m.end() && !m["ExpireDateStr"].empty()) {
      expireDateStr = make_shared<string>(boost::any_cast<string>(m["ExpireDateStr"]));
    }
    if (m.find("GmtCreateStr") != m.end() && !m["GmtCreateStr"].empty()) {
      gmtCreateStr = make_shared<string>(boost::any_cast<string>(m["GmtCreateStr"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("IntelligentApproval") != m.end() && !m["IntelligentApproval"].empty()) {
      intelligentApproval = make_shared<bool>(boost::any_cast<bool>(m["IntelligentApproval"]));
    }
    if (m.find("IntlType") != m.end() && !m["IntlType"].empty()) {
      intlType = make_shared<long>(boost::any_cast<long>(m["IntlType"]));
    }
    if (m.find("IsAnyParam") != m.end() && !m["IsAnyParam"].empty()) {
      isAnyParam = make_shared<bool>(boost::any_cast<bool>(m["IsAnyParam"]));
    }
    if (m.find("IsDefaultTemplate") != m.end() && !m["IsDefaultTemplate"].empty()) {
      isDefaultTemplate = make_shared<bool>(boost::any_cast<bool>(m["IsDefaultTemplate"]));
    }
    if (m.find("IsRecently") != m.end() && !m["IsRecently"].empty()) {
      isRecently = make_shared<bool>(boost::any_cast<bool>(m["IsRecently"]));
    }
    if (m.find("OrderCount") != m.end() && !m["OrderCount"].empty()) {
      orderCount = make_shared<long>(boost::any_cast<long>(m["OrderCount"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("PassErrType") != m.end() && !m["PassErrType"].empty()) {
      passErrType = make_shared<string>(boost::any_cast<string>(m["PassErrType"]));
    }
    if (m.find("ProductUrl") != m.end() && !m["ProductUrl"].empty()) {
      productUrl = make_shared<string>(boost::any_cast<string>(m["ProductUrl"]));
    }
    if (m.find("RelatedSignName") != m.end() && !m["RelatedSignName"].empty()) {
      relatedSignName = make_shared<string>(boost::any_cast<string>(m["RelatedSignName"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("SignType") != m.end() && !m["SignType"].empty()) {
      signType = make_shared<long>(boost::any_cast<long>(m["SignType"]));
    }
    if (m.find("SmsContent") != m.end() && !m["SmsContent"].empty()) {
      smsContent = make_shared<string>(boost::any_cast<string>(m["SmsContent"]));
    }
    if (m.find("SupportVendor") != m.end() && !m["SupportVendor"].empty()) {
      supportVendor = make_shared<string>(boost::any_cast<string>(m["SupportVendor"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        QuerySmsTemplateListNewResponseBodyListSmsTemplateTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<QuerySmsTemplateListNewResponseBodyListSmsTemplateTags>(model1);
      }
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
    if (m.find("TemplateContent") != m.end() && !m["TemplateContent"].empty()) {
      templateContent = make_shared<string>(boost::any_cast<string>(m["TemplateContent"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("TemplateRule") != m.end() && !m["TemplateRule"].empty()) {
      templateRule = make_shared<string>(boost::any_cast<string>(m["TemplateRule"]));
    }
  }


  virtual ~QuerySmsTemplateListNewResponseBodyListSmsTemplate() = default;
};
class QuerySmsTemplateListNewResponseBodyList : public Darabonba::Model {
public:
  shared_ptr<vector<QuerySmsTemplateListNewResponseBodyListSmsTemplate>> smsTemplate{};

  QuerySmsTemplateListNewResponseBodyList() {}

  explicit QuerySmsTemplateListNewResponseBodyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (smsTemplate) {
      vector<boost::any> temp1;
      for(auto item1:*smsTemplate){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SmsTemplate"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SmsTemplate") != m.end() && !m["SmsTemplate"].empty()) {
      if (typeid(vector<boost::any>) == m["SmsTemplate"].type()) {
        vector<QuerySmsTemplateListNewResponseBodyListSmsTemplate> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SmsTemplate"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySmsTemplateListNewResponseBodyListSmsTemplate model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        smsTemplate = make_shared<vector<QuerySmsTemplateListNewResponseBodyListSmsTemplate>>(expect1);
      }
    }
  }


  virtual ~QuerySmsTemplateListNewResponseBodyList() = default;
};
class QuerySmsTemplateListNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<QuerySmsTemplateListNewResponseBodyList> list{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  QuerySmsTemplateListNewResponseBody() {}

  explicit QuerySmsTemplateListNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QuerySmsTemplateListNewResponseBodyList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QuerySmsTemplateListNewResponseBodyList>(model1);
      }
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QuerySmsTemplateListNewResponseBody() = default;
};
class QuerySmsTemplateListNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySmsTemplateListNewResponseBody> body{};

  QuerySmsTemplateListNewResponse() {}

  explicit QuerySmsTemplateListNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySmsTemplateListNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySmsTemplateListNewResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySmsTemplateListNewResponse() = default;
};
class QuerySmsUserTagsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QuerySmsUserTagsRequest() {}

  explicit QuerySmsUserTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QuerySmsUserTagsRequest() = default;
};
class QuerySmsUserTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<string> data{};

  QuerySmsUserTagsResponseBody() {}

  explicit QuerySmsUserTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
  }


  virtual ~QuerySmsUserTagsResponseBody() = default;
};
class QuerySmsUserTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySmsUserTagsResponseBody> body{};

  QuerySmsUserTagsResponse() {}

  explicit QuerySmsUserTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySmsUserTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySmsUserTagsResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySmsUserTagsResponse() = default;
};
class QuerySmsUserTagsNewRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QuerySmsUserTagsNewRequest() {}

  explicit QuerySmsUserTagsNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QuerySmsUserTagsNewRequest() = default;
};
class QuerySmsUserTagsNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> isAnyParamTemplateUser{};
  shared_ptr<bool> isBatchCreateSmsSign{};
  shared_ptr<bool> isInnerUser{};
  shared_ptr<bool> isNewUser{};
  shared_ptr<bool> isNoneStatusNoChargeCust{};
  shared_ptr<bool> isOpenTemplateRule{};
  shared_ptr<bool> isOpenedCard{};
  shared_ptr<bool> isOpenedDigit{};
  shared_ptr<bool> isOpenedInternationalSms{};
  shared_ptr<bool> isOpenedMarket{};
  shared_ptr<bool> isOpenedSaas{};
  shared_ptr<bool> isOpenedSmppStandardProtocol{};
  shared_ptr<bool> isOpenedStandardProtocol{};
  shared_ptr<bool> isVirtualCust{};
  shared_ptr<bool> requestId{};
  shared_ptr<bool> signCheckCommon{};
  shared_ptr<bool> signCheckVerification{};
  shared_ptr<bool> smsInformationSupervision{};

  QuerySmsUserTagsNewResponseBody() {}

  explicit QuerySmsUserTagsNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isAnyParamTemplateUser) {
      res["IsAnyParamTemplateUser"] = boost::any(*isAnyParamTemplateUser);
    }
    if (isBatchCreateSmsSign) {
      res["IsBatchCreateSmsSign"] = boost::any(*isBatchCreateSmsSign);
    }
    if (isInnerUser) {
      res["IsInnerUser"] = boost::any(*isInnerUser);
    }
    if (isNewUser) {
      res["IsNewUser"] = boost::any(*isNewUser);
    }
    if (isNoneStatusNoChargeCust) {
      res["IsNoneStatusNoChargeCust"] = boost::any(*isNoneStatusNoChargeCust);
    }
    if (isOpenTemplateRule) {
      res["IsOpenTemplateRule"] = boost::any(*isOpenTemplateRule);
    }
    if (isOpenedCard) {
      res["IsOpenedCard"] = boost::any(*isOpenedCard);
    }
    if (isOpenedDigit) {
      res["IsOpenedDigit"] = boost::any(*isOpenedDigit);
    }
    if (isOpenedInternationalSms) {
      res["IsOpenedInternationalSms"] = boost::any(*isOpenedInternationalSms);
    }
    if (isOpenedMarket) {
      res["IsOpenedMarket"] = boost::any(*isOpenedMarket);
    }
    if (isOpenedSaas) {
      res["IsOpenedSaas"] = boost::any(*isOpenedSaas);
    }
    if (isOpenedSmppStandardProtocol) {
      res["IsOpenedSmppStandardProtocol"] = boost::any(*isOpenedSmppStandardProtocol);
    }
    if (isOpenedStandardProtocol) {
      res["IsOpenedStandardProtocol"] = boost::any(*isOpenedStandardProtocol);
    }
    if (isVirtualCust) {
      res["IsVirtualCust"] = boost::any(*isVirtualCust);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (signCheckCommon) {
      res["SignCheckCommon"] = boost::any(*signCheckCommon);
    }
    if (signCheckVerification) {
      res["SignCheckVerification"] = boost::any(*signCheckVerification);
    }
    if (smsInformationSupervision) {
      res["SmsInformationSupervision"] = boost::any(*smsInformationSupervision);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsAnyParamTemplateUser") != m.end() && !m["IsAnyParamTemplateUser"].empty()) {
      isAnyParamTemplateUser = make_shared<bool>(boost::any_cast<bool>(m["IsAnyParamTemplateUser"]));
    }
    if (m.find("IsBatchCreateSmsSign") != m.end() && !m["IsBatchCreateSmsSign"].empty()) {
      isBatchCreateSmsSign = make_shared<bool>(boost::any_cast<bool>(m["IsBatchCreateSmsSign"]));
    }
    if (m.find("IsInnerUser") != m.end() && !m["IsInnerUser"].empty()) {
      isInnerUser = make_shared<bool>(boost::any_cast<bool>(m["IsInnerUser"]));
    }
    if (m.find("IsNewUser") != m.end() && !m["IsNewUser"].empty()) {
      isNewUser = make_shared<bool>(boost::any_cast<bool>(m["IsNewUser"]));
    }
    if (m.find("IsNoneStatusNoChargeCust") != m.end() && !m["IsNoneStatusNoChargeCust"].empty()) {
      isNoneStatusNoChargeCust = make_shared<bool>(boost::any_cast<bool>(m["IsNoneStatusNoChargeCust"]));
    }
    if (m.find("IsOpenTemplateRule") != m.end() && !m["IsOpenTemplateRule"].empty()) {
      isOpenTemplateRule = make_shared<bool>(boost::any_cast<bool>(m["IsOpenTemplateRule"]));
    }
    if (m.find("IsOpenedCard") != m.end() && !m["IsOpenedCard"].empty()) {
      isOpenedCard = make_shared<bool>(boost::any_cast<bool>(m["IsOpenedCard"]));
    }
    if (m.find("IsOpenedDigit") != m.end() && !m["IsOpenedDigit"].empty()) {
      isOpenedDigit = make_shared<bool>(boost::any_cast<bool>(m["IsOpenedDigit"]));
    }
    if (m.find("IsOpenedInternationalSms") != m.end() && !m["IsOpenedInternationalSms"].empty()) {
      isOpenedInternationalSms = make_shared<bool>(boost::any_cast<bool>(m["IsOpenedInternationalSms"]));
    }
    if (m.find("IsOpenedMarket") != m.end() && !m["IsOpenedMarket"].empty()) {
      isOpenedMarket = make_shared<bool>(boost::any_cast<bool>(m["IsOpenedMarket"]));
    }
    if (m.find("IsOpenedSaas") != m.end() && !m["IsOpenedSaas"].empty()) {
      isOpenedSaas = make_shared<bool>(boost::any_cast<bool>(m["IsOpenedSaas"]));
    }
    if (m.find("IsOpenedSmppStandardProtocol") != m.end() && !m["IsOpenedSmppStandardProtocol"].empty()) {
      isOpenedSmppStandardProtocol = make_shared<bool>(boost::any_cast<bool>(m["IsOpenedSmppStandardProtocol"]));
    }
    if (m.find("IsOpenedStandardProtocol") != m.end() && !m["IsOpenedStandardProtocol"].empty()) {
      isOpenedStandardProtocol = make_shared<bool>(boost::any_cast<bool>(m["IsOpenedStandardProtocol"]));
    }
    if (m.find("IsVirtualCust") != m.end() && !m["IsVirtualCust"].empty()) {
      isVirtualCust = make_shared<bool>(boost::any_cast<bool>(m["IsVirtualCust"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<bool>(boost::any_cast<bool>(m["RequestId"]));
    }
    if (m.find("SignCheckCommon") != m.end() && !m["SignCheckCommon"].empty()) {
      signCheckCommon = make_shared<bool>(boost::any_cast<bool>(m["SignCheckCommon"]));
    }
    if (m.find("SignCheckVerification") != m.end() && !m["SignCheckVerification"].empty()) {
      signCheckVerification = make_shared<bool>(boost::any_cast<bool>(m["SignCheckVerification"]));
    }
    if (m.find("SmsInformationSupervision") != m.end() && !m["SmsInformationSupervision"].empty()) {
      smsInformationSupervision = make_shared<bool>(boost::any_cast<bool>(m["SmsInformationSupervision"]));
    }
  }


  virtual ~QuerySmsUserTagsNewResponseBody() = default;
};
class QuerySmsUserTagsNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySmsUserTagsNewResponseBody> body{};

  QuerySmsUserTagsNewResponse() {}

  explicit QuerySmsUserTagsNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySmsUserTagsNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySmsUserTagsNewResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySmsUserTagsNewResponse() = default;
};
class QueryStandarTemplateCollectionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizType{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> templateContent{};

  QueryStandarTemplateCollectionsRequest() {}

  explicit QueryStandarTemplateCollectionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (templateContent) {
      res["TemplateContent"] = boost::any(*templateContent);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TemplateContent") != m.end() && !m["TemplateContent"].empty()) {
      templateContent = make_shared<string>(boost::any_cast<string>(m["TemplateContent"]));
    }
  }


  virtual ~QueryStandarTemplateCollectionsRequest() = default;
};
class QueryStandarTemplateCollectionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<string> data{};

  QueryStandarTemplateCollectionsResponseBody() {}

  explicit QueryStandarTemplateCollectionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
  }


  virtual ~QueryStandarTemplateCollectionsResponseBody() = default;
};
class QueryStandarTemplateCollectionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryStandarTemplateCollectionsResponseBody> body{};

  QueryStandarTemplateCollectionsResponse() {}

  explicit QueryStandarTemplateCollectionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryStandarTemplateCollectionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryStandarTemplateCollectionsResponseBody>(model1);
      }
    }
  }


  virtual ~QueryStandarTemplateCollectionsResponse() = default;
};
class QueryStandarTemplateCollectionsNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizType{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> templateContent{};

  QueryStandarTemplateCollectionsNewRequest() {}

  explicit QueryStandarTemplateCollectionsNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (templateContent) {
      res["TemplateContent"] = boost::any(*templateContent);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TemplateContent") != m.end() && !m["TemplateContent"].empty()) {
      templateContent = make_shared<string>(boost::any_cast<string>(m["TemplateContent"]));
    }
  }


  virtual ~QueryStandarTemplateCollectionsNewRequest() = default;
};
class QueryStandarTemplateCollectionsNewResponseBodyListFcPartnerTemplateDTO : public Darabonba::Model {
public:
  shared_ptr<long> businessType{};
  shared_ptr<long> fcTag{};
  shared_ptr<string> i18n{};
  shared_ptr<long> id{};
  shared_ptr<long> isDeleted{};
  shared_ptr<long> mcBusinessType{};
  shared_ptr<long> mcCategory{};
  shared_ptr<string> mcSignature{};
  shared_ptr<long> messageTypeId{};
  shared_ptr<string> opNick{};
  shared_ptr<long> partnerId{};
  shared_ptr<long> qualificationId{};
  shared_ptr<string> remark{};
  shared_ptr<long> signTemplateId{};
  shared_ptr<long> signType{};
  shared_ptr<string> sourceId{};
  shared_ptr<long> speedLevel{};
  shared_ptr<long> state{};
  shared_ptr<string> templateCode{};
  shared_ptr<string> templateContent{};
  shared_ptr<long> templateId{};
  shared_ptr<string> templateName{};
  shared_ptr<string> templateParamRule{};
  shared_ptr<long> templateSenderType{};
  shared_ptr<long> templateType{};
  shared_ptr<long> totalCountLimit{};
  shared_ptr<long> voiceType{};

  QueryStandarTemplateCollectionsNewResponseBodyListFcPartnerTemplateDTO() {}

  explicit QueryStandarTemplateCollectionsNewResponseBodyListFcPartnerTemplateDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (fcTag) {
      res["FcTag"] = boost::any(*fcTag);
    }
    if (i18n) {
      res["I18n"] = boost::any(*i18n);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (isDeleted) {
      res["IsDeleted"] = boost::any(*isDeleted);
    }
    if (mcBusinessType) {
      res["McBusinessType"] = boost::any(*mcBusinessType);
    }
    if (mcCategory) {
      res["McCategory"] = boost::any(*mcCategory);
    }
    if (mcSignature) {
      res["McSignature"] = boost::any(*mcSignature);
    }
    if (messageTypeId) {
      res["MessageTypeId"] = boost::any(*messageTypeId);
    }
    if (opNick) {
      res["OpNick"] = boost::any(*opNick);
    }
    if (partnerId) {
      res["PartnerId"] = boost::any(*partnerId);
    }
    if (qualificationId) {
      res["QualificationId"] = boost::any(*qualificationId);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (signTemplateId) {
      res["SignTemplateId"] = boost::any(*signTemplateId);
    }
    if (signType) {
      res["SignType"] = boost::any(*signType);
    }
    if (sourceId) {
      res["SourceId"] = boost::any(*sourceId);
    }
    if (speedLevel) {
      res["SpeedLevel"] = boost::any(*speedLevel);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    if (templateContent) {
      res["TemplateContent"] = boost::any(*templateContent);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (templateParamRule) {
      res["TemplateParamRule"] = boost::any(*templateParamRule);
    }
    if (templateSenderType) {
      res["TemplateSenderType"] = boost::any(*templateSenderType);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    if (totalCountLimit) {
      res["TotalCountLimit"] = boost::any(*totalCountLimit);
    }
    if (voiceType) {
      res["VoiceType"] = boost::any(*voiceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<long>(boost::any_cast<long>(m["BusinessType"]));
    }
    if (m.find("FcTag") != m.end() && !m["FcTag"].empty()) {
      fcTag = make_shared<long>(boost::any_cast<long>(m["FcTag"]));
    }
    if (m.find("I18n") != m.end() && !m["I18n"].empty()) {
      i18n = make_shared<string>(boost::any_cast<string>(m["I18n"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IsDeleted") != m.end() && !m["IsDeleted"].empty()) {
      isDeleted = make_shared<long>(boost::any_cast<long>(m["IsDeleted"]));
    }
    if (m.find("McBusinessType") != m.end() && !m["McBusinessType"].empty()) {
      mcBusinessType = make_shared<long>(boost::any_cast<long>(m["McBusinessType"]));
    }
    if (m.find("McCategory") != m.end() && !m["McCategory"].empty()) {
      mcCategory = make_shared<long>(boost::any_cast<long>(m["McCategory"]));
    }
    if (m.find("McSignature") != m.end() && !m["McSignature"].empty()) {
      mcSignature = make_shared<string>(boost::any_cast<string>(m["McSignature"]));
    }
    if (m.find("MessageTypeId") != m.end() && !m["MessageTypeId"].empty()) {
      messageTypeId = make_shared<long>(boost::any_cast<long>(m["MessageTypeId"]));
    }
    if (m.find("OpNick") != m.end() && !m["OpNick"].empty()) {
      opNick = make_shared<string>(boost::any_cast<string>(m["OpNick"]));
    }
    if (m.find("PartnerId") != m.end() && !m["PartnerId"].empty()) {
      partnerId = make_shared<long>(boost::any_cast<long>(m["PartnerId"]));
    }
    if (m.find("QualificationId") != m.end() && !m["QualificationId"].empty()) {
      qualificationId = make_shared<long>(boost::any_cast<long>(m["QualificationId"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("SignTemplateId") != m.end() && !m["SignTemplateId"].empty()) {
      signTemplateId = make_shared<long>(boost::any_cast<long>(m["SignTemplateId"]));
    }
    if (m.find("SignType") != m.end() && !m["SignType"].empty()) {
      signType = make_shared<long>(boost::any_cast<long>(m["SignType"]));
    }
    if (m.find("SourceId") != m.end() && !m["SourceId"].empty()) {
      sourceId = make_shared<string>(boost::any_cast<string>(m["SourceId"]));
    }
    if (m.find("SpeedLevel") != m.end() && !m["SpeedLevel"].empty()) {
      speedLevel = make_shared<long>(boost::any_cast<long>(m["SpeedLevel"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<long>(boost::any_cast<long>(m["State"]));
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
    if (m.find("TemplateContent") != m.end() && !m["TemplateContent"].empty()) {
      templateContent = make_shared<string>(boost::any_cast<string>(m["TemplateContent"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("TemplateParamRule") != m.end() && !m["TemplateParamRule"].empty()) {
      templateParamRule = make_shared<string>(boost::any_cast<string>(m["TemplateParamRule"]));
    }
    if (m.find("TemplateSenderType") != m.end() && !m["TemplateSenderType"].empty()) {
      templateSenderType = make_shared<long>(boost::any_cast<long>(m["TemplateSenderType"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<long>(boost::any_cast<long>(m["TemplateType"]));
    }
    if (m.find("TotalCountLimit") != m.end() && !m["TotalCountLimit"].empty()) {
      totalCountLimit = make_shared<long>(boost::any_cast<long>(m["TotalCountLimit"]));
    }
    if (m.find("VoiceType") != m.end() && !m["VoiceType"].empty()) {
      voiceType = make_shared<long>(boost::any_cast<long>(m["VoiceType"]));
    }
  }


  virtual ~QueryStandarTemplateCollectionsNewResponseBodyListFcPartnerTemplateDTO() = default;
};
class QueryStandarTemplateCollectionsNewResponseBodyList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryStandarTemplateCollectionsNewResponseBodyListFcPartnerTemplateDTO>> fcPartnerTemplateDTO{};

  QueryStandarTemplateCollectionsNewResponseBodyList() {}

  explicit QueryStandarTemplateCollectionsNewResponseBodyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fcPartnerTemplateDTO) {
      vector<boost::any> temp1;
      for(auto item1:*fcPartnerTemplateDTO){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FcPartnerTemplateDTO"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FcPartnerTemplateDTO") != m.end() && !m["FcPartnerTemplateDTO"].empty()) {
      if (typeid(vector<boost::any>) == m["FcPartnerTemplateDTO"].type()) {
        vector<QueryStandarTemplateCollectionsNewResponseBodyListFcPartnerTemplateDTO> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FcPartnerTemplateDTO"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryStandarTemplateCollectionsNewResponseBodyListFcPartnerTemplateDTO model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fcPartnerTemplateDTO = make_shared<vector<QueryStandarTemplateCollectionsNewResponseBodyListFcPartnerTemplateDTO>>(expect1);
      }
    }
  }


  virtual ~QueryStandarTemplateCollectionsNewResponseBodyList() = default;
};
class QueryStandarTemplateCollectionsNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryStandarTemplateCollectionsNewResponseBodyList> list{};
  shared_ptr<string> requestId{};

  QueryStandarTemplateCollectionsNewResponseBody() {}

  explicit QueryStandarTemplateCollectionsNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QueryStandarTemplateCollectionsNewResponseBodyList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QueryStandarTemplateCollectionsNewResponseBodyList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryStandarTemplateCollectionsNewResponseBody() = default;
};
class QueryStandarTemplateCollectionsNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryStandarTemplateCollectionsNewResponseBody> body{};

  QueryStandarTemplateCollectionsNewResponse() {}

  explicit QueryStandarTemplateCollectionsNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryStandarTemplateCollectionsNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryStandarTemplateCollectionsNewResponseBody>(model1);
      }
    }
  }


  virtual ~QueryStandarTemplateCollectionsNewResponse() = default;
};
class QueryStandardProtocolRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<long> protocolType{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryStandardProtocolRequest() {}

  explicit QueryStandardProtocolRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (protocolType) {
      res["ProtocolType"] = boost::any(*protocolType);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ProtocolType") != m.end() && !m["ProtocolType"].empty()) {
      protocolType = make_shared<long>(boost::any_cast<long>(m["ProtocolType"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryStandardProtocolRequest() = default;
};
class QueryStandardProtocolResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<string> data{};

  QueryStandardProtocolResponseBody() {}

  explicit QueryStandardProtocolResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
  }


  virtual ~QueryStandardProtocolResponseBody() = default;
};
class QueryStandardProtocolResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryStandardProtocolResponseBody> body{};

  QueryStandardProtocolResponse() {}

  explicit QueryStandardProtocolResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryStandardProtocolResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryStandardProtocolResponseBody>(model1);
      }
    }
  }


  virtual ~QueryStandardProtocolResponse() = default;
};
class QueryStandardProtocolListNewRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<long> protocolType{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryStandardProtocolListNewRequest() {}

  explicit QueryStandardProtocolListNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (protocolType) {
      res["ProtocolType"] = boost::any(*protocolType);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ProtocolType") != m.end() && !m["ProtocolType"].empty()) {
      protocolType = make_shared<long>(boost::any_cast<long>(m["ProtocolType"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryStandardProtocolListNewRequest() = default;
};
class QueryStandardProtocolListNewResponseBodyList : public Darabonba::Model {
public:
  shared_ptr<string> auditOrderId{};
  shared_ptr<string> corpCode{};
  shared_ptr<string> effIpWhiteList{};
  shared_ptr<long> featureCode{};
  shared_ptr<string> ip{};
  shared_ptr<long> ipAuditStatus{};
  shared_ptr<string> ipWhiteList{};
  shared_ptr<long> partnerId{};
  shared_ptr<string> port{};
  shared_ptr<long> profileId{};
  shared_ptr<long> protocolType{};
  shared_ptr<string> protocolTypeStr{};
  shared_ptr<long> realNameInsId{};
  shared_ptr<string> resCode{};
  shared_ptr<string> smsSign{};
  shared_ptr<string> smsType{};
  shared_ptr<string> spCode{};
  shared_ptr<string> status{};
  shared_ptr<string> templateCode{};
  shared_ptr<long> userLimit{};
  shared_ptr<long> userMaxChannel{};
  shared_ptr<string> userName{};
  shared_ptr<string> userPwd{};

  QueryStandardProtocolListNewResponseBodyList() {}

  explicit QueryStandardProtocolListNewResponseBodyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (auditOrderId) {
      res["AuditOrderId"] = boost::any(*auditOrderId);
    }
    if (corpCode) {
      res["CorpCode"] = boost::any(*corpCode);
    }
    if (effIpWhiteList) {
      res["EffIpWhiteList"] = boost::any(*effIpWhiteList);
    }
    if (featureCode) {
      res["FeatureCode"] = boost::any(*featureCode);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (ipAuditStatus) {
      res["IpAuditStatus"] = boost::any(*ipAuditStatus);
    }
    if (ipWhiteList) {
      res["IpWhiteList"] = boost::any(*ipWhiteList);
    }
    if (partnerId) {
      res["PartnerId"] = boost::any(*partnerId);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (profileId) {
      res["ProfileId"] = boost::any(*profileId);
    }
    if (protocolType) {
      res["ProtocolType"] = boost::any(*protocolType);
    }
    if (protocolTypeStr) {
      res["ProtocolTypeStr"] = boost::any(*protocolTypeStr);
    }
    if (realNameInsId) {
      res["RealNameInsId"] = boost::any(*realNameInsId);
    }
    if (resCode) {
      res["ResCode"] = boost::any(*resCode);
    }
    if (smsSign) {
      res["SmsSign"] = boost::any(*smsSign);
    }
    if (smsType) {
      res["SmsType"] = boost::any(*smsType);
    }
    if (spCode) {
      res["SpCode"] = boost::any(*spCode);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    if (userLimit) {
      res["UserLimit"] = boost::any(*userLimit);
    }
    if (userMaxChannel) {
      res["UserMaxChannel"] = boost::any(*userMaxChannel);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (userPwd) {
      res["UserPwd"] = boost::any(*userPwd);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuditOrderId") != m.end() && !m["AuditOrderId"].empty()) {
      auditOrderId = make_shared<string>(boost::any_cast<string>(m["AuditOrderId"]));
    }
    if (m.find("CorpCode") != m.end() && !m["CorpCode"].empty()) {
      corpCode = make_shared<string>(boost::any_cast<string>(m["CorpCode"]));
    }
    if (m.find("EffIpWhiteList") != m.end() && !m["EffIpWhiteList"].empty()) {
      effIpWhiteList = make_shared<string>(boost::any_cast<string>(m["EffIpWhiteList"]));
    }
    if (m.find("FeatureCode") != m.end() && !m["FeatureCode"].empty()) {
      featureCode = make_shared<long>(boost::any_cast<long>(m["FeatureCode"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("IpAuditStatus") != m.end() && !m["IpAuditStatus"].empty()) {
      ipAuditStatus = make_shared<long>(boost::any_cast<long>(m["IpAuditStatus"]));
    }
    if (m.find("IpWhiteList") != m.end() && !m["IpWhiteList"].empty()) {
      ipWhiteList = make_shared<string>(boost::any_cast<string>(m["IpWhiteList"]));
    }
    if (m.find("PartnerId") != m.end() && !m["PartnerId"].empty()) {
      partnerId = make_shared<long>(boost::any_cast<long>(m["PartnerId"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("ProfileId") != m.end() && !m["ProfileId"].empty()) {
      profileId = make_shared<long>(boost::any_cast<long>(m["ProfileId"]));
    }
    if (m.find("ProtocolType") != m.end() && !m["ProtocolType"].empty()) {
      protocolType = make_shared<long>(boost::any_cast<long>(m["ProtocolType"]));
    }
    if (m.find("ProtocolTypeStr") != m.end() && !m["ProtocolTypeStr"].empty()) {
      protocolTypeStr = make_shared<string>(boost::any_cast<string>(m["ProtocolTypeStr"]));
    }
    if (m.find("RealNameInsId") != m.end() && !m["RealNameInsId"].empty()) {
      realNameInsId = make_shared<long>(boost::any_cast<long>(m["RealNameInsId"]));
    }
    if (m.find("ResCode") != m.end() && !m["ResCode"].empty()) {
      resCode = make_shared<string>(boost::any_cast<string>(m["ResCode"]));
    }
    if (m.find("SmsSign") != m.end() && !m["SmsSign"].empty()) {
      smsSign = make_shared<string>(boost::any_cast<string>(m["SmsSign"]));
    }
    if (m.find("SmsType") != m.end() && !m["SmsType"].empty()) {
      smsType = make_shared<string>(boost::any_cast<string>(m["SmsType"]));
    }
    if (m.find("SpCode") != m.end() && !m["SpCode"].empty()) {
      spCode = make_shared<string>(boost::any_cast<string>(m["SpCode"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
    if (m.find("UserLimit") != m.end() && !m["UserLimit"].empty()) {
      userLimit = make_shared<long>(boost::any_cast<long>(m["UserLimit"]));
    }
    if (m.find("UserMaxChannel") != m.end() && !m["UserMaxChannel"].empty()) {
      userMaxChannel = make_shared<long>(boost::any_cast<long>(m["UserMaxChannel"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("UserPwd") != m.end() && !m["UserPwd"].empty()) {
      userPwd = make_shared<string>(boost::any_cast<string>(m["UserPwd"]));
    }
  }


  virtual ~QueryStandardProtocolListNewResponseBodyList() = default;
};
class QueryStandardProtocolListNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<QueryStandardProtocolListNewResponseBodyList>> list{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  QueryStandardProtocolListNewResponseBody() {}

  explicit QueryStandardProtocolListNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<QueryStandardProtocolListNewResponseBodyList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryStandardProtocolListNewResponseBodyList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<QueryStandardProtocolListNewResponseBodyList>>(expect1);
      }
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QueryStandardProtocolListNewResponseBody() = default;
};
class QueryStandardProtocolListNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryStandardProtocolListNewResponseBody> body{};

  QueryStandardProtocolListNewResponse() {}

  explicit QueryStandardProtocolListNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryStandardProtocolListNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryStandardProtocolListNewResponseBody>(model1);
      }
    }
  }


  virtual ~QueryStandardProtocolListNewResponse() = default;
};
class QueryTagResourcesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  QueryTagResourcesRequestTag() {}

  explicit QueryTagResourcesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~QueryTagResourcesRequestTag() = default;
};
class QueryTagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<QueryTagResourcesRequestTag>> tag{};

  QueryTagResourcesRequest() {}

  explicit QueryTagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<QueryTagResourcesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryTagResourcesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<QueryTagResourcesRequestTag>>(expect1);
      }
    }
  }


  virtual ~QueryTagResourcesRequest() = default;
};
class QueryTagResourcesResponseBodyTagResources : public Darabonba::Model {
public:
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  QueryTagResourcesResponseBodyTagResources() {}

  explicit QueryTagResourcesResponseBodyTagResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~QueryTagResourcesResponseBodyTagResources() = default;
};
class QueryTagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<QueryTagResourcesResponseBodyTagResources>> tagResources{};

  QueryTagResourcesResponseBody() {}

  explicit QueryTagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tagResources) {
      vector<boost::any> temp1;
      for(auto item1:*tagResources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagResources"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TagResources") != m.end() && !m["TagResources"].empty()) {
      if (typeid(vector<boost::any>) == m["TagResources"].type()) {
        vector<QueryTagResourcesResponseBodyTagResources> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagResources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryTagResourcesResponseBodyTagResources model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagResources = make_shared<vector<QueryTagResourcesResponseBodyTagResources>>(expect1);
      }
    }
  }


  virtual ~QueryTagResourcesResponseBody() = default;
};
class QueryTagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryTagResourcesResponseBody> body{};

  QueryTagResourcesResponse() {}

  explicit QueryTagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryTagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryTagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~QueryTagResourcesResponse() = default;
};
class QueryTagResourcesNewRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  QueryTagResourcesNewRequestTag() {}

  explicit QueryTagResourcesNewRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~QueryTagResourcesNewRequestTag() = default;
};
class QueryTagResourcesNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceIdListString{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<QueryTagResourcesNewRequestTag>> tag{};
  shared_ptr<string> tagListString{};

  QueryTagResourcesNewRequest() {}

  explicit QueryTagResourcesNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceIdListString) {
      res["ResourceIdListString"] = boost::any(*resourceIdListString);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (tagListString) {
      res["TagListString"] = boost::any(*tagListString);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceIdListString") != m.end() && !m["ResourceIdListString"].empty()) {
      resourceIdListString = make_shared<string>(boost::any_cast<string>(m["ResourceIdListString"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<QueryTagResourcesNewRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryTagResourcesNewRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<QueryTagResourcesNewRequestTag>>(expect1);
      }
    }
    if (m.find("TagListString") != m.end() && !m["TagListString"].empty()) {
      tagListString = make_shared<string>(boost::any_cast<string>(m["TagListString"]));
    }
  }


  virtual ~QueryTagResourcesNewRequest() = default;
};
class QueryTagResourcesNewResponseBodyTagResources : public Darabonba::Model {
public:
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  QueryTagResourcesNewResponseBodyTagResources() {}

  explicit QueryTagResourcesNewResponseBodyTagResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~QueryTagResourcesNewResponseBodyTagResources() = default;
};
class QueryTagResourcesNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<QueryTagResourcesNewResponseBodyTagResources>> tagResources{};

  QueryTagResourcesNewResponseBody() {}

  explicit QueryTagResourcesNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tagResources) {
      vector<boost::any> temp1;
      for(auto item1:*tagResources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagResources"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TagResources") != m.end() && !m["TagResources"].empty()) {
      if (typeid(vector<boost::any>) == m["TagResources"].type()) {
        vector<QueryTagResourcesNewResponseBodyTagResources> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagResources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryTagResourcesNewResponseBodyTagResources model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagResources = make_shared<vector<QueryTagResourcesNewResponseBodyTagResources>>(expect1);
      }
    }
  }


  virtual ~QueryTagResourcesNewResponseBody() = default;
};
class QueryTagResourcesNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryTagResourcesNewResponseBody> body{};

  QueryTagResourcesNewResponse() {}

  explicit QueryTagResourcesNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryTagResourcesNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryTagResourcesNewResponseBody>(model1);
      }
    }
  }


  virtual ~QueryTagResourcesNewResponse() = default;
};
class QueryTmpEffectReportDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> endDate{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> startDate{};
  shared_ptr<string> tmpCode{};
  shared_ptr<string> tmpName{};
  shared_ptr<string> vendorCode{};
  shared_ptr<string> vendorName{};

  QueryTmpEffectReportDataRequest() {}

  explicit QueryTmpEffectReportDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    if (tmpCode) {
      res["TmpCode"] = boost::any(*tmpCode);
    }
    if (tmpName) {
      res["TmpName"] = boost::any(*tmpName);
    }
    if (vendorCode) {
      res["VendorCode"] = boost::any(*vendorCode);
    }
    if (vendorName) {
      res["VendorName"] = boost::any(*vendorName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
    if (m.find("TmpCode") != m.end() && !m["TmpCode"].empty()) {
      tmpCode = make_shared<string>(boost::any_cast<string>(m["TmpCode"]));
    }
    if (m.find("TmpName") != m.end() && !m["TmpName"].empty()) {
      tmpName = make_shared<string>(boost::any_cast<string>(m["TmpName"]));
    }
    if (m.find("VendorCode") != m.end() && !m["VendorCode"].empty()) {
      vendorCode = make_shared<string>(boost::any_cast<string>(m["VendorCode"]));
    }
    if (m.find("VendorName") != m.end() && !m["VendorName"].empty()) {
      vendorName = make_shared<string>(boost::any_cast<string>(m["VendorName"]));
    }
  }


  virtual ~QueryTmpEffectReportDataRequest() = default;
};
class QueryTmpEffectReportDataResponseBodyModelRecords : public Darabonba::Model {
public:
  shared_ptr<string> clickPv{};
  shared_ptr<string> clickUv{};
  shared_ptr<string> date{};
  shared_ptr<string> exposePv{};
  shared_ptr<string> exposeUv{};
  shared_ptr<long> id{};
  shared_ptr<string> rptSuccessCount{};
  shared_ptr<string> tmpCode{};
  shared_ptr<string> tmpName{};
  shared_ptr<string> vendorName{};

  QueryTmpEffectReportDataResponseBodyModelRecords() {}

  explicit QueryTmpEffectReportDataResponseBodyModelRecords(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clickPv) {
      res["ClickPv"] = boost::any(*clickPv);
    }
    if (clickUv) {
      res["ClickUv"] = boost::any(*clickUv);
    }
    if (date) {
      res["Date"] = boost::any(*date);
    }
    if (exposePv) {
      res["ExposePv"] = boost::any(*exposePv);
    }
    if (exposeUv) {
      res["ExposeUv"] = boost::any(*exposeUv);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (rptSuccessCount) {
      res["RptSuccessCount"] = boost::any(*rptSuccessCount);
    }
    if (tmpCode) {
      res["TmpCode"] = boost::any(*tmpCode);
    }
    if (tmpName) {
      res["TmpName"] = boost::any(*tmpName);
    }
    if (vendorName) {
      res["VendorName"] = boost::any(*vendorName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClickPv") != m.end() && !m["ClickPv"].empty()) {
      clickPv = make_shared<string>(boost::any_cast<string>(m["ClickPv"]));
    }
    if (m.find("ClickUv") != m.end() && !m["ClickUv"].empty()) {
      clickUv = make_shared<string>(boost::any_cast<string>(m["ClickUv"]));
    }
    if (m.find("Date") != m.end() && !m["Date"].empty()) {
      date = make_shared<string>(boost::any_cast<string>(m["Date"]));
    }
    if (m.find("ExposePv") != m.end() && !m["ExposePv"].empty()) {
      exposePv = make_shared<string>(boost::any_cast<string>(m["ExposePv"]));
    }
    if (m.find("ExposeUv") != m.end() && !m["ExposeUv"].empty()) {
      exposeUv = make_shared<string>(boost::any_cast<string>(m["ExposeUv"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RptSuccessCount") != m.end() && !m["RptSuccessCount"].empty()) {
      rptSuccessCount = make_shared<string>(boost::any_cast<string>(m["RptSuccessCount"]));
    }
    if (m.find("TmpCode") != m.end() && !m["TmpCode"].empty()) {
      tmpCode = make_shared<string>(boost::any_cast<string>(m["TmpCode"]));
    }
    if (m.find("TmpName") != m.end() && !m["TmpName"].empty()) {
      tmpName = make_shared<string>(boost::any_cast<string>(m["TmpName"]));
    }
    if (m.find("VendorName") != m.end() && !m["VendorName"].empty()) {
      vendorName = make_shared<string>(boost::any_cast<string>(m["VendorName"]));
    }
  }


  virtual ~QueryTmpEffectReportDataResponseBodyModelRecords() = default;
};
class QueryTmpEffectReportDataResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<QueryTmpEffectReportDataResponseBodyModelRecords>> records{};
  shared_ptr<long> totalCount{};

  QueryTmpEffectReportDataResponseBodyModel() {}

  explicit QueryTmpEffectReportDataResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (records) {
      vector<boost::any> temp1;
      for(auto item1:*records){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Records"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Records") != m.end() && !m["Records"].empty()) {
      if (typeid(vector<boost::any>) == m["Records"].type()) {
        vector<QueryTmpEffectReportDataResponseBodyModelRecords> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Records"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryTmpEffectReportDataResponseBodyModelRecords model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        records = make_shared<vector<QueryTmpEffectReportDataResponseBodyModelRecords>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~QueryTmpEffectReportDataResponseBodyModel() = default;
};
class QueryTmpEffectReportDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryTmpEffectReportDataResponseBodyModel> model{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryTmpEffectReportDataResponseBody() {}

  explicit QueryTmpEffectReportDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        QueryTmpEffectReportDataResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<QueryTmpEffectReportDataResponseBodyModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryTmpEffectReportDataResponseBody() = default;
};
class QueryTmpEffectReportDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryTmpEffectReportDataResponseBody> body{};

  QueryTmpEffectReportDataResponse() {}

  explicit QueryTmpEffectReportDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryTmpEffectReportDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryTmpEffectReportDataResponseBody>(model1);
      }
    }
  }


  virtual ~QueryTmpEffectReportDataResponse() = default;
};
class QueryTmpEffectReportDayDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> endDate{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> startDate{};
  shared_ptr<string> tmpCode{};
  shared_ptr<string> tmpName{};
  shared_ptr<string> vendorName{};

  QueryTmpEffectReportDayDataRequest() {}

  explicit QueryTmpEffectReportDayDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    if (tmpCode) {
      res["TmpCode"] = boost::any(*tmpCode);
    }
    if (tmpName) {
      res["TmpName"] = boost::any(*tmpName);
    }
    if (vendorName) {
      res["VendorName"] = boost::any(*vendorName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
    if (m.find("TmpCode") != m.end() && !m["TmpCode"].empty()) {
      tmpCode = make_shared<string>(boost::any_cast<string>(m["TmpCode"]));
    }
    if (m.find("TmpName") != m.end() && !m["TmpName"].empty()) {
      tmpName = make_shared<string>(boost::any_cast<string>(m["TmpName"]));
    }
    if (m.find("VendorName") != m.end() && !m["VendorName"].empty()) {
      vendorName = make_shared<string>(boost::any_cast<string>(m["VendorName"]));
    }
  }


  virtual ~QueryTmpEffectReportDayDataRequest() = default;
};
class QueryTmpEffectReportDayDataResponseBodyModelRecords : public Darabonba::Model {
public:
  shared_ptr<string> clickPv{};
  shared_ptr<string> clickUv{};
  shared_ptr<string> date{};
  shared_ptr<string> exposePv{};
  shared_ptr<string> exposeUv{};
  shared_ptr<string> rptSuccessCount{};
  shared_ptr<string> tmpCode{};
  shared_ptr<string> tmpName{};
  shared_ptr<string> vendorName{};

  QueryTmpEffectReportDayDataResponseBodyModelRecords() {}

  explicit QueryTmpEffectReportDayDataResponseBodyModelRecords(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clickPv) {
      res["ClickPv"] = boost::any(*clickPv);
    }
    if (clickUv) {
      res["ClickUv"] = boost::any(*clickUv);
    }
    if (date) {
      res["Date"] = boost::any(*date);
    }
    if (exposePv) {
      res["ExposePv"] = boost::any(*exposePv);
    }
    if (exposeUv) {
      res["ExposeUv"] = boost::any(*exposeUv);
    }
    if (rptSuccessCount) {
      res["RptSuccessCount"] = boost::any(*rptSuccessCount);
    }
    if (tmpCode) {
      res["TmpCode"] = boost::any(*tmpCode);
    }
    if (tmpName) {
      res["TmpName"] = boost::any(*tmpName);
    }
    if (vendorName) {
      res["VendorName"] = boost::any(*vendorName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClickPv") != m.end() && !m["ClickPv"].empty()) {
      clickPv = make_shared<string>(boost::any_cast<string>(m["ClickPv"]));
    }
    if (m.find("ClickUv") != m.end() && !m["ClickUv"].empty()) {
      clickUv = make_shared<string>(boost::any_cast<string>(m["ClickUv"]));
    }
    if (m.find("Date") != m.end() && !m["Date"].empty()) {
      date = make_shared<string>(boost::any_cast<string>(m["Date"]));
    }
    if (m.find("ExposePv") != m.end() && !m["ExposePv"].empty()) {
      exposePv = make_shared<string>(boost::any_cast<string>(m["ExposePv"]));
    }
    if (m.find("ExposeUv") != m.end() && !m["ExposeUv"].empty()) {
      exposeUv = make_shared<string>(boost::any_cast<string>(m["ExposeUv"]));
    }
    if (m.find("RptSuccessCount") != m.end() && !m["RptSuccessCount"].empty()) {
      rptSuccessCount = make_shared<string>(boost::any_cast<string>(m["RptSuccessCount"]));
    }
    if (m.find("TmpCode") != m.end() && !m["TmpCode"].empty()) {
      tmpCode = make_shared<string>(boost::any_cast<string>(m["TmpCode"]));
    }
    if (m.find("TmpName") != m.end() && !m["TmpName"].empty()) {
      tmpName = make_shared<string>(boost::any_cast<string>(m["TmpName"]));
    }
    if (m.find("VendorName") != m.end() && !m["VendorName"].empty()) {
      vendorName = make_shared<string>(boost::any_cast<string>(m["VendorName"]));
    }
  }


  virtual ~QueryTmpEffectReportDayDataResponseBodyModelRecords() = default;
};
class QueryTmpEffectReportDayDataResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<QueryTmpEffectReportDayDataResponseBodyModelRecords>> records{};
  shared_ptr<long> totalCount{};

  QueryTmpEffectReportDayDataResponseBodyModel() {}

  explicit QueryTmpEffectReportDayDataResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (records) {
      vector<boost::any> temp1;
      for(auto item1:*records){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Records"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Records") != m.end() && !m["Records"].empty()) {
      if (typeid(vector<boost::any>) == m["Records"].type()) {
        vector<QueryTmpEffectReportDayDataResponseBodyModelRecords> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Records"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryTmpEffectReportDayDataResponseBodyModelRecords model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        records = make_shared<vector<QueryTmpEffectReportDayDataResponseBodyModelRecords>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~QueryTmpEffectReportDayDataResponseBodyModel() = default;
};
class QueryTmpEffectReportDayDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryTmpEffectReportDayDataResponseBodyModel> model{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryTmpEffectReportDayDataResponseBody() {}

  explicit QueryTmpEffectReportDayDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        QueryTmpEffectReportDayDataResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<QueryTmpEffectReportDayDataResponseBodyModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryTmpEffectReportDayDataResponseBody() = default;
};
class QueryTmpEffectReportDayDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryTmpEffectReportDayDataResponseBody> body{};

  QueryTmpEffectReportDayDataResponse() {}

  explicit QueryTmpEffectReportDayDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryTmpEffectReportDayDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryTmpEffectReportDayDataResponseBody>(model1);
      }
    }
  }


  virtual ~QueryTmpEffectReportDayDataResponse() = default;
};
class QueryUsertagExistenceRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> usertagPosition{};

  QueryUsertagExistenceRequest() {}

  explicit QueryUsertagExistenceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (usertagPosition) {
      res["UsertagPosition"] = boost::any(*usertagPosition);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("UsertagPosition") != m.end() && !m["UsertagPosition"].empty()) {
      usertagPosition = make_shared<long>(boost::any_cast<long>(m["UsertagPosition"]));
    }
  }


  virtual ~QueryUsertagExistenceRequest() = default;
};
class QueryUsertagExistenceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<bool> data{};

  QueryUsertagExistenceResponseBody() {}

  explicit QueryUsertagExistenceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["data"]));
    }
  }


  virtual ~QueryUsertagExistenceResponseBody() = default;
};
class QueryUsertagExistenceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryUsertagExistenceResponseBody> body{};

  QueryUsertagExistenceResponse() {}

  explicit QueryUsertagExistenceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryUsertagExistenceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryUsertagExistenceResponseBody>(model1);
      }
    }
  }


  virtual ~QueryUsertagExistenceResponse() = default;
};
class QueryWarningThresholdRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizType{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryWarningThresholdRequest() {}

  explicit QueryWarningThresholdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryWarningThresholdRequest() = default;
};
class QueryWarningThresholdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<string> data{};

  QueryWarningThresholdResponseBody() {}

  explicit QueryWarningThresholdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
  }


  virtual ~QueryWarningThresholdResponseBody() = default;
};
class QueryWarningThresholdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryWarningThresholdResponseBody> body{};

  QueryWarningThresholdResponse() {}

  explicit QueryWarningThresholdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryWarningThresholdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryWarningThresholdResponseBody>(model1);
      }
    }
  }


  virtual ~QueryWarningThresholdResponse() = default;
};
class QueryWarningThresholdNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizType{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryWarningThresholdNewRequest() {}

  explicit QueryWarningThresholdNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryWarningThresholdNewRequest() = default;
};
class QueryWarningThresholdNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> bizType{};
  shared_ptr<string> contactPhone{};
  shared_ptr<long> dailyHaltLimit{};
  shared_ptr<long> dailyWarningLimit{};
  shared_ptr<long> domesticDailySuccess{};
  shared_ptr<long> domesticDailyTotal{};
  shared_ptr<long> domesticMonthlySuccess{};
  shared_ptr<long> domesticMonthlyTotal{};
  shared_ptr<long> monthlyHaltLimit{};
  shared_ptr<long> monthlyWarningLimit{};
  shared_ptr<long> outDailySuccess{};
  shared_ptr<long> outDailyTotal{};
  shared_ptr<long> outMonthlySuccess{};
  shared_ptr<long> outMonthlyTotal{};
  shared_ptr<bool> prevWaringNotice{};
  shared_ptr<string> requestId{};

  QueryWarningThresholdNewResponseBody() {}

  explicit QueryWarningThresholdNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (contactPhone) {
      res["ContactPhone"] = boost::any(*contactPhone);
    }
    if (dailyHaltLimit) {
      res["DailyHaltLimit"] = boost::any(*dailyHaltLimit);
    }
    if (dailyWarningLimit) {
      res["DailyWarningLimit"] = boost::any(*dailyWarningLimit);
    }
    if (domesticDailySuccess) {
      res["DomesticDailySuccess"] = boost::any(*domesticDailySuccess);
    }
    if (domesticDailyTotal) {
      res["DomesticDailyTotal"] = boost::any(*domesticDailyTotal);
    }
    if (domesticMonthlySuccess) {
      res["DomesticMonthlySuccess"] = boost::any(*domesticMonthlySuccess);
    }
    if (domesticMonthlyTotal) {
      res["DomesticMonthlyTotal"] = boost::any(*domesticMonthlyTotal);
    }
    if (monthlyHaltLimit) {
      res["MonthlyHaltLimit"] = boost::any(*monthlyHaltLimit);
    }
    if (monthlyWarningLimit) {
      res["MonthlyWarningLimit"] = boost::any(*monthlyWarningLimit);
    }
    if (outDailySuccess) {
      res["OutDailySuccess"] = boost::any(*outDailySuccess);
    }
    if (outDailyTotal) {
      res["OutDailyTotal"] = boost::any(*outDailyTotal);
    }
    if (outMonthlySuccess) {
      res["OutMonthlySuccess"] = boost::any(*outMonthlySuccess);
    }
    if (outMonthlyTotal) {
      res["OutMonthlyTotal"] = boost::any(*outMonthlyTotal);
    }
    if (prevWaringNotice) {
      res["PrevWaringNotice"] = boost::any(*prevWaringNotice);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("ContactPhone") != m.end() && !m["ContactPhone"].empty()) {
      contactPhone = make_shared<string>(boost::any_cast<string>(m["ContactPhone"]));
    }
    if (m.find("DailyHaltLimit") != m.end() && !m["DailyHaltLimit"].empty()) {
      dailyHaltLimit = make_shared<long>(boost::any_cast<long>(m["DailyHaltLimit"]));
    }
    if (m.find("DailyWarningLimit") != m.end() && !m["DailyWarningLimit"].empty()) {
      dailyWarningLimit = make_shared<long>(boost::any_cast<long>(m["DailyWarningLimit"]));
    }
    if (m.find("DomesticDailySuccess") != m.end() && !m["DomesticDailySuccess"].empty()) {
      domesticDailySuccess = make_shared<long>(boost::any_cast<long>(m["DomesticDailySuccess"]));
    }
    if (m.find("DomesticDailyTotal") != m.end() && !m["DomesticDailyTotal"].empty()) {
      domesticDailyTotal = make_shared<long>(boost::any_cast<long>(m["DomesticDailyTotal"]));
    }
    if (m.find("DomesticMonthlySuccess") != m.end() && !m["DomesticMonthlySuccess"].empty()) {
      domesticMonthlySuccess = make_shared<long>(boost::any_cast<long>(m["DomesticMonthlySuccess"]));
    }
    if (m.find("DomesticMonthlyTotal") != m.end() && !m["DomesticMonthlyTotal"].empty()) {
      domesticMonthlyTotal = make_shared<long>(boost::any_cast<long>(m["DomesticMonthlyTotal"]));
    }
    if (m.find("MonthlyHaltLimit") != m.end() && !m["MonthlyHaltLimit"].empty()) {
      monthlyHaltLimit = make_shared<long>(boost::any_cast<long>(m["MonthlyHaltLimit"]));
    }
    if (m.find("MonthlyWarningLimit") != m.end() && !m["MonthlyWarningLimit"].empty()) {
      monthlyWarningLimit = make_shared<long>(boost::any_cast<long>(m["MonthlyWarningLimit"]));
    }
    if (m.find("OutDailySuccess") != m.end() && !m["OutDailySuccess"].empty()) {
      outDailySuccess = make_shared<long>(boost::any_cast<long>(m["OutDailySuccess"]));
    }
    if (m.find("OutDailyTotal") != m.end() && !m["OutDailyTotal"].empty()) {
      outDailyTotal = make_shared<long>(boost::any_cast<long>(m["OutDailyTotal"]));
    }
    if (m.find("OutMonthlySuccess") != m.end() && !m["OutMonthlySuccess"].empty()) {
      outMonthlySuccess = make_shared<long>(boost::any_cast<long>(m["OutMonthlySuccess"]));
    }
    if (m.find("OutMonthlyTotal") != m.end() && !m["OutMonthlyTotal"].empty()) {
      outMonthlyTotal = make_shared<long>(boost::any_cast<long>(m["OutMonthlyTotal"]));
    }
    if (m.find("PrevWaringNotice") != m.end() && !m["PrevWaringNotice"].empty()) {
      prevWaringNotice = make_shared<bool>(boost::any_cast<bool>(m["PrevWaringNotice"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryWarningThresholdNewResponseBody() = default;
};
class QueryWarningThresholdNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryWarningThresholdNewResponseBody> body{};

  QueryWarningThresholdNewResponse() {}

  explicit QueryWarningThresholdNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryWarningThresholdNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryWarningThresholdNewResponseBody>(model1);
      }
    }
  }


  virtual ~QueryWarningThresholdNewResponse() = default;
};
class QueryWorkOrdAuditListNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> orderId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryWorkOrdAuditListNewRequest() {}

  explicit QueryWorkOrdAuditListNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryWorkOrdAuditListNewRequest() = default;
};
class QueryWorkOrdAuditListNewResponseBodyListParamAuditRemarkInfo : public Darabonba::Model {
public:
  shared_ptr<string> rejectDate{};
  shared_ptr<string> rejectInfo{};
  shared_ptr<string> rejectSubInfo{};

  QueryWorkOrdAuditListNewResponseBodyListParamAuditRemarkInfo() {}

  explicit QueryWorkOrdAuditListNewResponseBodyListParamAuditRemarkInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rejectDate) {
      res["RejectDate"] = boost::any(*rejectDate);
    }
    if (rejectInfo) {
      res["RejectInfo"] = boost::any(*rejectInfo);
    }
    if (rejectSubInfo) {
      res["RejectSubInfo"] = boost::any(*rejectSubInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RejectDate") != m.end() && !m["RejectDate"].empty()) {
      rejectDate = make_shared<string>(boost::any_cast<string>(m["RejectDate"]));
    }
    if (m.find("RejectInfo") != m.end() && !m["RejectInfo"].empty()) {
      rejectInfo = make_shared<string>(boost::any_cast<string>(m["RejectInfo"]));
    }
    if (m.find("RejectSubInfo") != m.end() && !m["RejectSubInfo"].empty()) {
      rejectSubInfo = make_shared<string>(boost::any_cast<string>(m["RejectSubInfo"]));
    }
  }


  virtual ~QueryWorkOrdAuditListNewResponseBodyListParamAuditRemarkInfo() = default;
};
class QueryWorkOrdAuditListNewResponseBodyListParamAuditState : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> name{};
  shared_ptr<long> value{};

  QueryWorkOrdAuditListNewResponseBodyListParamAuditState() {}

  explicit QueryWorkOrdAuditListNewResponseBodyListParamAuditState(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~QueryWorkOrdAuditListNewResponseBodyListParamAuditState() = default;
};
class QueryWorkOrdAuditListNewResponseBodyListParam : public Darabonba::Model {
public:
  shared_ptr<string> auditInfo{};
  shared_ptr<QueryWorkOrdAuditListNewResponseBodyListParamAuditRemarkInfo> auditRemarkInfo{};
  shared_ptr<QueryWorkOrdAuditListNewResponseBodyListParamAuditState> auditState{};
  shared_ptr<long> businessType{};
  shared_ptr<string> extendMessage{};
  shared_ptr<vector<long>> fileIds{};
  shared_ptr<vector<string>> fileUrlList{};
  shared_ptr<string> gmtCreateStr{};
  shared_ptr<long> id{};
  shared_ptr<string> orderId{};
  shared_ptr<long> partnerId{};
  shared_ptr<string> remark{};
  shared_ptr<long> sceneType{};
  shared_ptr<string> signName{};
  shared_ptr<long> signType{};

  QueryWorkOrdAuditListNewResponseBodyListParam() {}

  explicit QueryWorkOrdAuditListNewResponseBodyListParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (auditInfo) {
      res["AuditInfo"] = boost::any(*auditInfo);
    }
    if (auditRemarkInfo) {
      res["AuditRemarkInfo"] = auditRemarkInfo ? boost::any(auditRemarkInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (auditState) {
      res["AuditState"] = auditState ? boost::any(auditState->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (extendMessage) {
      res["ExtendMessage"] = boost::any(*extendMessage);
    }
    if (fileIds) {
      res["FileIds"] = boost::any(*fileIds);
    }
    if (fileUrlList) {
      res["FileUrlList"] = boost::any(*fileUrlList);
    }
    if (gmtCreateStr) {
      res["GmtCreateStr"] = boost::any(*gmtCreateStr);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (partnerId) {
      res["PartnerId"] = boost::any(*partnerId);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (sceneType) {
      res["SceneType"] = boost::any(*sceneType);
    }
    if (signName) {
      res["SignName"] = boost::any(*signName);
    }
    if (signType) {
      res["SignType"] = boost::any(*signType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuditInfo") != m.end() && !m["AuditInfo"].empty()) {
      auditInfo = make_shared<string>(boost::any_cast<string>(m["AuditInfo"]));
    }
    if (m.find("AuditRemarkInfo") != m.end() && !m["AuditRemarkInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["AuditRemarkInfo"].type()) {
        QueryWorkOrdAuditListNewResponseBodyListParamAuditRemarkInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AuditRemarkInfo"]));
        auditRemarkInfo = make_shared<QueryWorkOrdAuditListNewResponseBodyListParamAuditRemarkInfo>(model1);
      }
    }
    if (m.find("AuditState") != m.end() && !m["AuditState"].empty()) {
      if (typeid(map<string, boost::any>) == m["AuditState"].type()) {
        QueryWorkOrdAuditListNewResponseBodyListParamAuditState model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AuditState"]));
        auditState = make_shared<QueryWorkOrdAuditListNewResponseBodyListParamAuditState>(model1);
      }
    }
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<long>(boost::any_cast<long>(m["BusinessType"]));
    }
    if (m.find("ExtendMessage") != m.end() && !m["ExtendMessage"].empty()) {
      extendMessage = make_shared<string>(boost::any_cast<string>(m["ExtendMessage"]));
    }
    if (m.find("FileIds") != m.end() && !m["FileIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["FileIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FileIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      fileIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("FileUrlList") != m.end() && !m["FileUrlList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FileUrlList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FileUrlList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fileUrlList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("GmtCreateStr") != m.end() && !m["GmtCreateStr"].empty()) {
      gmtCreateStr = make_shared<string>(boost::any_cast<string>(m["GmtCreateStr"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("PartnerId") != m.end() && !m["PartnerId"].empty()) {
      partnerId = make_shared<long>(boost::any_cast<long>(m["PartnerId"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("SceneType") != m.end() && !m["SceneType"].empty()) {
      sceneType = make_shared<long>(boost::any_cast<long>(m["SceneType"]));
    }
    if (m.find("SignName") != m.end() && !m["SignName"].empty()) {
      signName = make_shared<string>(boost::any_cast<string>(m["SignName"]));
    }
    if (m.find("SignType") != m.end() && !m["SignType"].empty()) {
      signType = make_shared<long>(boost::any_cast<long>(m["SignType"]));
    }
  }


  virtual ~QueryWorkOrdAuditListNewResponseBodyListParam() = default;
};
class QueryWorkOrdAuditListNewResponseBodyList : public Darabonba::Model {
public:
  shared_ptr<string> auditRemark{};
  shared_ptr<string> auditResult{};
  shared_ptr<string> bizType{};
  shared_ptr<string> createDate{};
  shared_ptr<string> ordId{};
  shared_ptr<string> ordStatus{};
  shared_ptr<QueryWorkOrdAuditListNewResponseBodyListParam> param{};

  QueryWorkOrdAuditListNewResponseBodyList() {}

  explicit QueryWorkOrdAuditListNewResponseBodyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (auditRemark) {
      res["AuditRemark"] = boost::any(*auditRemark);
    }
    if (auditResult) {
      res["AuditResult"] = boost::any(*auditResult);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (createDate) {
      res["CreateDate"] = boost::any(*createDate);
    }
    if (ordId) {
      res["OrdId"] = boost::any(*ordId);
    }
    if (ordStatus) {
      res["OrdStatus"] = boost::any(*ordStatus);
    }
    if (param) {
      res["Param"] = param ? boost::any(param->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuditRemark") != m.end() && !m["AuditRemark"].empty()) {
      auditRemark = make_shared<string>(boost::any_cast<string>(m["AuditRemark"]));
    }
    if (m.find("AuditResult") != m.end() && !m["AuditResult"].empty()) {
      auditResult = make_shared<string>(boost::any_cast<string>(m["AuditResult"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("CreateDate") != m.end() && !m["CreateDate"].empty()) {
      createDate = make_shared<string>(boost::any_cast<string>(m["CreateDate"]));
    }
    if (m.find("OrdId") != m.end() && !m["OrdId"].empty()) {
      ordId = make_shared<string>(boost::any_cast<string>(m["OrdId"]));
    }
    if (m.find("OrdStatus") != m.end() && !m["OrdStatus"].empty()) {
      ordStatus = make_shared<string>(boost::any_cast<string>(m["OrdStatus"]));
    }
    if (m.find("Param") != m.end() && !m["Param"].empty()) {
      if (typeid(map<string, boost::any>) == m["Param"].type()) {
        QueryWorkOrdAuditListNewResponseBodyListParam model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Param"]));
        param = make_shared<QueryWorkOrdAuditListNewResponseBodyListParam>(model1);
      }
    }
  }


  virtual ~QueryWorkOrdAuditListNewResponseBodyList() = default;
};
class QueryWorkOrdAuditListNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<QueryWorkOrdAuditListNewResponseBodyList>> list{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  QueryWorkOrdAuditListNewResponseBody() {}

  explicit QueryWorkOrdAuditListNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<QueryWorkOrdAuditListNewResponseBodyList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryWorkOrdAuditListNewResponseBodyList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<QueryWorkOrdAuditListNewResponseBodyList>>(expect1);
      }
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QueryWorkOrdAuditListNewResponseBody() = default;
};
class QueryWorkOrdAuditListNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryWorkOrdAuditListNewResponseBody> body{};

  QueryWorkOrdAuditListNewResponse() {}

  explicit QueryWorkOrdAuditListNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryWorkOrdAuditListNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryWorkOrdAuditListNewResponseBody>(model1);
      }
    }
  }


  virtual ~QueryWorkOrdAuditListNewResponse() = default;
};
class SaveContactsNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> email{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<long> openPkgWarning{};
  shared_ptr<long> openPreventBrushWarning{};
  shared_ptr<long> openSendWarning{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> phone{};
  shared_ptr<string> prodCode{};
  shared_ptr<long> receiveSignTemplateAuditResult{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> verificationCode{};

  SaveContactsNewRequest() {}

  explicit SaveContactsNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (openPkgWarning) {
      res["OpenPkgWarning"] = boost::any(*openPkgWarning);
    }
    if (openPreventBrushWarning) {
      res["OpenPreventBrushWarning"] = boost::any(*openPreventBrushWarning);
    }
    if (openSendWarning) {
      res["OpenSendWarning"] = boost::any(*openSendWarning);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (phone) {
      res["Phone"] = boost::any(*phone);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (receiveSignTemplateAuditResult) {
      res["ReceiveSignTemplateAuditResult"] = boost::any(*receiveSignTemplateAuditResult);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (verificationCode) {
      res["VerificationCode"] = boost::any(*verificationCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OpenPkgWarning") != m.end() && !m["OpenPkgWarning"].empty()) {
      openPkgWarning = make_shared<long>(boost::any_cast<long>(m["OpenPkgWarning"]));
    }
    if (m.find("OpenPreventBrushWarning") != m.end() && !m["OpenPreventBrushWarning"].empty()) {
      openPreventBrushWarning = make_shared<long>(boost::any_cast<long>(m["OpenPreventBrushWarning"]));
    }
    if (m.find("OpenSendWarning") != m.end() && !m["OpenSendWarning"].empty()) {
      openSendWarning = make_shared<long>(boost::any_cast<long>(m["OpenSendWarning"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Phone") != m.end() && !m["Phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["Phone"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ReceiveSignTemplateAuditResult") != m.end() && !m["ReceiveSignTemplateAuditResult"].empty()) {
      receiveSignTemplateAuditResult = make_shared<long>(boost::any_cast<long>(m["ReceiveSignTemplateAuditResult"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("VerificationCode") != m.end() && !m["VerificationCode"].empty()) {
      verificationCode = make_shared<string>(boost::any_cast<string>(m["VerificationCode"]));
    }
  }


  virtual ~SaveContactsNewRequest() = default;
};
class SaveContactsNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  SaveContactsNewResponseBody() {}

  explicit SaveContactsNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~SaveContactsNewResponseBody() = default;
};
class SaveContactsNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SaveContactsNewResponseBody> body{};

  SaveContactsNewResponse() {}

  explicit SaveContactsNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SaveContactsNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SaveContactsNewResponseBody>(model1);
      }
    }
  }


  virtual ~SaveContactsNewResponse() = default;
};
class SaveLearningStatusNewRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  SaveLearningStatusNewRequest() {}

  explicit SaveLearningStatusNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~SaveLearningStatusNewRequest() = default;
};
class SaveLearningStatusNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  SaveLearningStatusNewResponseBody() {}

  explicit SaveLearningStatusNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~SaveLearningStatusNewResponseBody() = default;
};
class SaveLearningStatusNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SaveLearningStatusNewResponseBody> body{};

  SaveLearningStatusNewResponse() {}

  explicit SaveLearningStatusNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SaveLearningStatusNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SaveLearningStatusNewResponseBody>(model1);
      }
    }
  }


  virtual ~SaveLearningStatusNewResponse() = default;
};
class SelectTagResourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};
  shared_ptr<string> type{};

  SelectTagResourceRequest() {}

  explicit SelectTagResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SelectTagResourceRequest() = default;
};
class SelectTagResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  SelectTagResourceResponseBody() {}

  explicit SelectTagResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SelectTagResourceResponseBody() = default;
};
class SelectTagResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SelectTagResourceResponseBody> body{};

  SelectTagResourceResponse() {}

  explicit SelectTagResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SelectTagResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SelectTagResourceResponseBody>(model1);
      }
    }
  }


  virtual ~SelectTagResourceResponse() = default;
};
class SelectTagResourceNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};
  shared_ptr<string> type{};

  SelectTagResourceNewRequest() {}

  explicit SelectTagResourceNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SelectTagResourceNewRequest() = default;
};
class SelectTagResourceNewResponseBodyTags : public Darabonba::Model {
public:
  shared_ptr<vector<string>> tag{};

  SelectTagResourceNewResponseBodyTags() {}

  explicit SelectTagResourceNewResponseBodyTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Tag"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tag = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~SelectTagResourceNewResponseBodyTags() = default;
};
class SelectTagResourceNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<SelectTagResourceNewResponseBodyTags> tags{};

  SelectTagResourceNewResponseBody() {}

  explicit SelectTagResourceNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        SelectTagResourceNewResponseBodyTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<SelectTagResourceNewResponseBodyTags>(model1);
      }
    }
  }


  virtual ~SelectTagResourceNewResponseBody() = default;
};
class SelectTagResourceNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SelectTagResourceNewResponseBody> body{};

  SelectTagResourceNewResponse() {}

  explicit SelectTagResourceNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SelectTagResourceNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SelectTagResourceNewResponseBody>(model1);
      }
    }
  }


  virtual ~SelectTagResourceNewResponse() = default;
};
class SendSmsTestRequest : public Darabonba::Model {
public:
  shared_ptr<string> ncToken{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> phoneNumber{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> remoteIp{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> sig{};
  shared_ptr<string> signName{};
  shared_ptr<string> templateCode{};
  shared_ptr<string> templateParam{};
  shared_ptr<string> testType{};

  SendSmsTestRequest() {}

  explicit SendSmsTestRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ncToken) {
      res["NcToken"] = boost::any(*ncToken);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (remoteIp) {
      res["RemoteIp"] = boost::any(*remoteIp);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (sig) {
      res["Sig"] = boost::any(*sig);
    }
    if (signName) {
      res["SignName"] = boost::any(*signName);
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    if (templateParam) {
      res["TemplateParam"] = boost::any(*templateParam);
    }
    if (testType) {
      res["TestType"] = boost::any(*testType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NcToken") != m.end() && !m["NcToken"].empty()) {
      ncToken = make_shared<string>(boost::any_cast<string>(m["NcToken"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("RemoteIp") != m.end() && !m["RemoteIp"].empty()) {
      remoteIp = make_shared<string>(boost::any_cast<string>(m["RemoteIp"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("Sig") != m.end() && !m["Sig"].empty()) {
      sig = make_shared<string>(boost::any_cast<string>(m["Sig"]));
    }
    if (m.find("SignName") != m.end() && !m["SignName"].empty()) {
      signName = make_shared<string>(boost::any_cast<string>(m["SignName"]));
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
    if (m.find("TemplateParam") != m.end() && !m["TemplateParam"].empty()) {
      templateParam = make_shared<string>(boost::any_cast<string>(m["TemplateParam"]));
    }
    if (m.find("TestType") != m.end() && !m["TestType"].empty()) {
      testType = make_shared<string>(boost::any_cast<string>(m["TestType"]));
    }
  }


  virtual ~SendSmsTestRequest() = default;
};
class SendSmsTestResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<string> data{};

  SendSmsTestResponseBody() {}

  explicit SendSmsTestResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
  }


  virtual ~SendSmsTestResponseBody() = default;
};
class SendSmsTestResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SendSmsTestResponseBody> body{};

  SendSmsTestResponse() {}

  explicit SendSmsTestResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SendSmsTestResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SendSmsTestResponseBody>(model1);
      }
    }
  }


  virtual ~SendSmsTestResponse() = default;
};
class SendSmsTestNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> ncToken{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> phoneNumber{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> remoteIp{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> sig{};
  shared_ptr<string> signName{};
  shared_ptr<string> templateCode{};
  shared_ptr<string> templateParam{};
  shared_ptr<string> testType{};

  SendSmsTestNewRequest() {}

  explicit SendSmsTestNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ncToken) {
      res["NcToken"] = boost::any(*ncToken);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (remoteIp) {
      res["RemoteIp"] = boost::any(*remoteIp);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (sig) {
      res["Sig"] = boost::any(*sig);
    }
    if (signName) {
      res["SignName"] = boost::any(*signName);
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    if (templateParam) {
      res["TemplateParam"] = boost::any(*templateParam);
    }
    if (testType) {
      res["TestType"] = boost::any(*testType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NcToken") != m.end() && !m["NcToken"].empty()) {
      ncToken = make_shared<string>(boost::any_cast<string>(m["NcToken"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("RemoteIp") != m.end() && !m["RemoteIp"].empty()) {
      remoteIp = make_shared<string>(boost::any_cast<string>(m["RemoteIp"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("Sig") != m.end() && !m["Sig"].empty()) {
      sig = make_shared<string>(boost::any_cast<string>(m["Sig"]));
    }
    if (m.find("SignName") != m.end() && !m["SignName"].empty()) {
      signName = make_shared<string>(boost::any_cast<string>(m["SignName"]));
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
    if (m.find("TemplateParam") != m.end() && !m["TemplateParam"].empty()) {
      templateParam = make_shared<string>(boost::any_cast<string>(m["TemplateParam"]));
    }
    if (m.find("TestType") != m.end() && !m["TestType"].empty()) {
      testType = make_shared<string>(boost::any_cast<string>(m["TestType"]));
    }
  }


  virtual ~SendSmsTestNewRequest() = default;
};
class SendSmsTestNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> msg{};
  shared_ptr<string> requestId{};

  SendSmsTestNewResponseBody() {}

  explicit SendSmsTestNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (msg) {
      res["Msg"] = boost::any(*msg);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Msg") != m.end() && !m["Msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["Msg"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SendSmsTestNewResponseBody() = default;
};
class SendSmsTestNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SendSmsTestNewResponseBody> body{};

  SendSmsTestNewResponse() {}

  explicit SendSmsTestNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SendSmsTestNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SendSmsTestNewResponseBody>(model1);
      }
    }
  }


  virtual ~SendSmsTestNewResponse() = default;
};
class SendVerificationRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizType{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> target{};
  shared_ptr<string> verifyType{};

  SendVerificationRequest() {}

  explicit SendVerificationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    if (verifyType) {
      res["VerifyType"] = boost::any(*verifyType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
    if (m.find("VerifyType") != m.end() && !m["VerifyType"].empty()) {
      verifyType = make_shared<string>(boost::any_cast<string>(m["VerifyType"]));
    }
  }


  virtual ~SendVerificationRequest() = default;
};
class SendVerificationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<string> data{};

  SendVerificationResponseBody() {}

  explicit SendVerificationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
  }


  virtual ~SendVerificationResponseBody() = default;
};
class SendVerificationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SendVerificationResponseBody> body{};

  SendVerificationResponse() {}

  explicit SendVerificationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SendVerificationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SendVerificationResponseBody>(model1);
      }
    }
  }


  virtual ~SendVerificationResponse() = default;
};
class SendVerificationNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizType{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> target{};
  shared_ptr<string> verifyType{};

  SendVerificationNewRequest() {}

  explicit SendVerificationNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    if (verifyType) {
      res["VerifyType"] = boost::any(*verifyType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
    if (m.find("VerifyType") != m.end() && !m["VerifyType"].empty()) {
      verifyType = make_shared<string>(boost::any_cast<string>(m["VerifyType"]));
    }
  }


  virtual ~SendVerificationNewRequest() = default;
};
class SendVerificationNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  SendVerificationNewResponseBody() {}

  explicit SendVerificationNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~SendVerificationNewResponseBody() = default;
};
class SendVerificationNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SendVerificationNewResponseBody> body{};

  SendVerificationNewResponse() {}

  explicit SendVerificationNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SendVerificationNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SendVerificationNewResponseBody>(model1);
      }
    }
  }


  virtual ~SendVerificationNewResponse() = default;
};
class TagResourcesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  TagResourcesRequestTag() {}

  explicit TagResourcesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~TagResourcesRequestTag() = default;
};
class TagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<TagResourcesRequestTag>> tag{};

  TagResourcesRequest() {}

  explicit TagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<TagResourcesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TagResourcesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<TagResourcesRequestTag>>(expect1);
      }
    }
  }


  virtual ~TagResourcesRequest() = default;
};
class TagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  TagResourcesResponseBody() {}

  explicit TagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~TagResourcesResponseBody() = default;
};
class TagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TagResourcesResponseBody> body{};

  TagResourcesResponse() {}

  explicit TagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~TagResourcesResponse() = default;
};
class TagResourcesNewRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  TagResourcesNewRequestTag() {}

  explicit TagResourcesNewRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~TagResourcesNewRequestTag() = default;
};
class TagResourcesNewRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceIdListString{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<TagResourcesNewRequestTag>> tag{};
  shared_ptr<string> tagListString{};

  TagResourcesNewRequest() {}

  explicit TagResourcesNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceIdListString) {
      res["ResourceIdListString"] = boost::any(*resourceIdListString);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (tagListString) {
      res["TagListString"] = boost::any(*tagListString);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceIdListString") != m.end() && !m["ResourceIdListString"].empty()) {
      resourceIdListString = make_shared<string>(boost::any_cast<string>(m["ResourceIdListString"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<TagResourcesNewRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TagResourcesNewRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<TagResourcesNewRequestTag>>(expect1);
      }
    }
    if (m.find("TagListString") != m.end() && !m["TagListString"].empty()) {
      tagListString = make_shared<string>(boost::any_cast<string>(m["TagListString"]));
    }
  }


  virtual ~TagResourcesNewRequest() = default;
};
class TagResourcesNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  TagResourcesNewResponseBody() {}

  explicit TagResourcesNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~TagResourcesNewResponseBody() = default;
};
class TagResourcesNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TagResourcesNewResponseBody> body{};

  TagResourcesNewResponse() {}

  explicit TagResourcesNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TagResourcesNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TagResourcesNewResponseBody>(model1);
      }
    }
  }


  virtual ~TagResourcesNewResponse() = default;
};
class TagResourcesSystemTagsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  TagResourcesSystemTagsRequestTag() {}

  explicit TagResourcesSystemTagsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~TagResourcesSystemTagsRequestTag() = default;
};
class TagResourcesSystemTagsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> scope{};
  shared_ptr<vector<TagResourcesSystemTagsRequestTag>> tag{};
  shared_ptr<long> tagOwnerUid{};

  TagResourcesSystemTagsRequest() {}

  explicit TagResourcesSystemTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (tagOwnerUid) {
      res["TagOwnerUid"] = boost::any(*tagOwnerUid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<TagResourcesSystemTagsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TagResourcesSystemTagsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<TagResourcesSystemTagsRequestTag>>(expect1);
      }
    }
    if (m.find("TagOwnerUid") != m.end() && !m["TagOwnerUid"].empty()) {
      tagOwnerUid = make_shared<long>(boost::any_cast<long>(m["TagOwnerUid"]));
    }
  }


  virtual ~TagResourcesSystemTagsRequest() = default;
};
class TagResourcesSystemTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  TagResourcesSystemTagsResponseBody() {}

  explicit TagResourcesSystemTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~TagResourcesSystemTagsResponseBody() = default;
};
class TagResourcesSystemTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TagResourcesSystemTagsResponseBody> body{};

  TagResourcesSystemTagsResponse() {}

  explicit TagResourcesSystemTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TagResourcesSystemTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TagResourcesSystemTagsResponseBody>(model1);
      }
    }
  }


  virtual ~TagResourcesSystemTagsResponse() = default;
};
class UntagResourcesRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  UntagResourcesRequestTags() {}

  explicit UntagResourcesRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UntagResourcesRequestTags() = default;
};
class UntagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> all{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<UntagResourcesRequestTags>> tags{};

  UntagResourcesRequest() {}

  explicit UntagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (all) {
      res["All"] = boost::any(*all);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("All") != m.end() && !m["All"].empty()) {
      all = make_shared<bool>(boost::any_cast<bool>(m["All"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<UntagResourcesRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UntagResourcesRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<UntagResourcesRequestTags>>(expect1);
      }
    }
  }


  virtual ~UntagResourcesRequest() = default;
};
class UntagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  UntagResourcesResponseBody() {}

  explicit UntagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UntagResourcesResponseBody() = default;
};
class UntagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UntagResourcesResponseBody> body{};

  UntagResourcesResponse() {}

  explicit UntagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UntagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UntagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~UntagResourcesResponse() = default;
};
class UntagResourcesNewRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  UntagResourcesNewRequestTags() {}

  explicit UntagResourcesNewRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UntagResourcesNewRequestTags() = default;
};
class UntagResourcesNewRequest : public Darabonba::Model {
public:
  shared_ptr<bool> all{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceIdListString{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tagListString{};
  shared_ptr<vector<UntagResourcesNewRequestTags>> tags{};

  UntagResourcesNewRequest() {}

  explicit UntagResourcesNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (all) {
      res["All"] = boost::any(*all);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceIdListString) {
      res["ResourceIdListString"] = boost::any(*resourceIdListString);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagListString) {
      res["TagListString"] = boost::any(*tagListString);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("All") != m.end() && !m["All"].empty()) {
      all = make_shared<bool>(boost::any_cast<bool>(m["All"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceIdListString") != m.end() && !m["ResourceIdListString"].empty()) {
      resourceIdListString = make_shared<string>(boost::any_cast<string>(m["ResourceIdListString"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagListString") != m.end() && !m["TagListString"].empty()) {
      tagListString = make_shared<string>(boost::any_cast<string>(m["TagListString"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<UntagResourcesNewRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UntagResourcesNewRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<UntagResourcesNewRequestTags>>(expect1);
      }
    }
  }


  virtual ~UntagResourcesNewRequest() = default;
};
class UntagResourcesNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  UntagResourcesNewResponseBody() {}

  explicit UntagResourcesNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~UntagResourcesNewResponseBody() = default;
};
class UntagResourcesNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UntagResourcesNewResponseBody> body{};

  UntagResourcesNewResponse() {}

  explicit UntagResourcesNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UntagResourcesNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UntagResourcesNewResponseBody>(model1);
      }
    }
  }


  virtual ~UntagResourcesNewResponse() = default;
};
class UntagResourcesSystemTagsRequest : public Darabonba::Model {
public:
  shared_ptr<bool> all{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<string>> tagKey{};
  shared_ptr<long> tagOwnerUid{};

  UntagResourcesSystemTagsRequest() {}

  explicit UntagResourcesSystemTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (all) {
      res["All"] = boost::any(*all);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagOwnerUid) {
      res["TagOwnerUid"] = boost::any(*tagOwnerUid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("All") != m.end() && !m["All"].empty()) {
      all = make_shared<bool>(boost::any_cast<bool>(m["All"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TagKey"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TagKey"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tagKey = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TagOwnerUid") != m.end() && !m["TagOwnerUid"].empty()) {
      tagOwnerUid = make_shared<long>(boost::any_cast<long>(m["TagOwnerUid"]));
    }
  }


  virtual ~UntagResourcesSystemTagsRequest() = default;
};
class UntagResourcesSystemTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  UntagResourcesSystemTagsResponseBody() {}

  explicit UntagResourcesSystemTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UntagResourcesSystemTagsResponseBody() = default;
};
class UntagResourcesSystemTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UntagResourcesSystemTagsResponseBody> body{};

  UntagResourcesSystemTagsResponse() {}

  explicit UntagResourcesSystemTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UntagResourcesSystemTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UntagResourcesSystemTagsResponseBody>(model1);
      }
    }
  }


  virtual ~UntagResourcesSystemTagsResponse() = default;
};
class UpdateIpWhiteListNewRequest : public Darabonba::Model {
public:
  shared_ptr<long> featureCode{};
  shared_ptr<string> ipWhiteList{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<long> realNameInsId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> userName{};

  UpdateIpWhiteListNewRequest() {}

  explicit UpdateIpWhiteListNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (featureCode) {
      res["FeatureCode"] = boost::any(*featureCode);
    }
    if (ipWhiteList) {
      res["IpWhiteList"] = boost::any(*ipWhiteList);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (realNameInsId) {
      res["RealNameInsId"] = boost::any(*realNameInsId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FeatureCode") != m.end() && !m["FeatureCode"].empty()) {
      featureCode = make_shared<long>(boost::any_cast<long>(m["FeatureCode"]));
    }
    if (m.find("IpWhiteList") != m.end() && !m["IpWhiteList"].empty()) {
      ipWhiteList = make_shared<string>(boost::any_cast<string>(m["IpWhiteList"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("RealNameInsId") != m.end() && !m["RealNameInsId"].empty()) {
      realNameInsId = make_shared<long>(boost::any_cast<long>(m["RealNameInsId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~UpdateIpWhiteListNewRequest() = default;
};
class UpdateIpWhiteListNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  UpdateIpWhiteListNewResponseBody() {}

  explicit UpdateIpWhiteListNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~UpdateIpWhiteListNewResponseBody() = default;
};
class UpdateIpWhiteListNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateIpWhiteListNewResponseBody> body{};

  UpdateIpWhiteListNewResponse() {}

  explicit UpdateIpWhiteListNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateIpWhiteListNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateIpWhiteListNewResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateIpWhiteListNewResponse() = default;
};
class UpdatePartnerTemplateNewRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> templateCode{};
  shared_ptr<string> templateName{};

  UpdatePartnerTemplateNewRequest() {}

  explicit UpdatePartnerTemplateNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
  }


  virtual ~UpdatePartnerTemplateNewRequest() = default;
};
class UpdatePartnerTemplateNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  UpdatePartnerTemplateNewResponseBody() {}

  explicit UpdatePartnerTemplateNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~UpdatePartnerTemplateNewResponseBody() = default;
};
class UpdatePartnerTemplateNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdatePartnerTemplateNewResponseBody> body{};

  UpdatePartnerTemplateNewResponse() {}

  explicit UpdatePartnerTemplateNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdatePartnerTemplateNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdatePartnerTemplateNewResponseBody>(model1);
      }
    }
  }


  virtual ~UpdatePartnerTemplateNewResponse() = default;
};
class UpdateSlsStatusNewRequest : public Darabonba::Model {
public:
  shared_ptr<bool> authStatus{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> saveTime{};

  UpdateSlsStatusNewRequest() {}

  explicit UpdateSlsStatusNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authStatus) {
      res["AuthStatus"] = boost::any(*authStatus);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (saveTime) {
      res["SaveTime"] = boost::any(*saveTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthStatus") != m.end() && !m["AuthStatus"].empty()) {
      authStatus = make_shared<bool>(boost::any_cast<bool>(m["AuthStatus"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SaveTime") != m.end() && !m["SaveTime"].empty()) {
      saveTime = make_shared<long>(boost::any_cast<long>(m["SaveTime"]));
    }
  }


  virtual ~UpdateSlsStatusNewRequest() = default;
};
class UpdateSlsStatusNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> authorizeStatus{};
  shared_ptr<bool> openStatus{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> requestId{};
  shared_ptr<long> saveTime{};
  shared_ptr<string> uid{};

  UpdateSlsStatusNewResponseBody() {}

  explicit UpdateSlsStatusNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorizeStatus) {
      res["AuthorizeStatus"] = boost::any(*authorizeStatus);
    }
    if (openStatus) {
      res["OpenStatus"] = boost::any(*openStatus);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (saveTime) {
      res["SaveTime"] = boost::any(*saveTime);
    }
    if (uid) {
      res["Uid"] = boost::any(*uid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthorizeStatus") != m.end() && !m["AuthorizeStatus"].empty()) {
      authorizeStatus = make_shared<bool>(boost::any_cast<bool>(m["AuthorizeStatus"]));
    }
    if (m.find("OpenStatus") != m.end() && !m["OpenStatus"].empty()) {
      openStatus = make_shared<bool>(boost::any_cast<bool>(m["OpenStatus"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SaveTime") != m.end() && !m["SaveTime"].empty()) {
      saveTime = make_shared<long>(boost::any_cast<long>(m["SaveTime"]));
    }
    if (m.find("Uid") != m.end() && !m["Uid"].empty()) {
      uid = make_shared<string>(boost::any_cast<string>(m["Uid"]));
    }
  }


  virtual ~UpdateSlsStatusNewResponseBody() = default;
};
class UpdateSlsStatusNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateSlsStatusNewResponseBody> body{};

  UpdateSlsStatusNewResponse() {}

  explicit UpdateSlsStatusNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateSlsStatusNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateSlsStatusNewResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateSlsStatusNewResponse() = default;
};
class UploadCardResRequest : public Darabonba::Model {
public:
  shared_ptr<string> callerParentId{};
  shared_ptr<string> callerType{};
  shared_ptr<string> callerUid{};
  shared_ptr<string> extendInfo{};
  shared_ptr<long> fileSize{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> memo{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceType{};

  UploadCardResRequest() {}

  explicit UploadCardResRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callerParentId) {
      res["CallerParentId"] = boost::any(*callerParentId);
    }
    if (callerType) {
      res["CallerType"] = boost::any(*callerType);
    }
    if (callerUid) {
      res["CallerUid"] = boost::any(*callerUid);
    }
    if (extendInfo) {
      res["ExtendInfo"] = boost::any(*extendInfo);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (memo) {
      res["Memo"] = boost::any(*memo);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallerParentId") != m.end() && !m["CallerParentId"].empty()) {
      callerParentId = make_shared<string>(boost::any_cast<string>(m["CallerParentId"]));
    }
    if (m.find("CallerType") != m.end() && !m["CallerType"].empty()) {
      callerType = make_shared<string>(boost::any_cast<string>(m["CallerType"]));
    }
    if (m.find("CallerUid") != m.end() && !m["CallerUid"].empty()) {
      callerUid = make_shared<string>(boost::any_cast<string>(m["CallerUid"]));
    }
    if (m.find("ExtendInfo") != m.end() && !m["ExtendInfo"].empty()) {
      extendInfo = make_shared<string>(boost::any_cast<string>(m["ExtendInfo"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<long>(boost::any_cast<long>(m["FileSize"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("Memo") != m.end() && !m["Memo"].empty()) {
      memo = make_shared<string>(boost::any_cast<string>(m["Memo"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~UploadCardResRequest() = default;
};
class UploadCardResResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<string> resourceId{};

  UploadCardResResponseBodyModel() {}

  explicit UploadCardResResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
  }


  virtual ~UploadCardResResponseBodyModel() = default;
};
class UploadCardResResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> accessDeniedDetail{};
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<UploadCardResResponseBodyModel> model{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UploadCardResResponseBody() {}

  explicit UploadCardResResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessDeniedDetail) {
      res["AccessDeniedDetail"] = boost::any(*accessDeniedDetail);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessDeniedDetail") != m.end() && !m["AccessDeniedDetail"].empty()) {
      accessDeniedDetail = make_shared<string>(boost::any_cast<string>(m["AccessDeniedDetail"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        UploadCardResResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<UploadCardResResponseBodyModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UploadCardResResponseBody() = default;
};
class UploadCardResResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UploadCardResResponseBody> body{};

  UploadCardResResponse() {}

  explicit UploadCardResResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UploadCardResResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UploadCardResResponseBody>(model1);
      }
    }
  }


  virtual ~UploadCardResResponse() = default;
};
class UploadCardResWithDyncParamRequest : public Darabonba::Model {
public:
  shared_ptr<string> dynamicParam{};
  shared_ptr<long> expiredTimes{};
  shared_ptr<long> fileSize{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> memo{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> templateCode{};

  UploadCardResWithDyncParamRequest() {}

  explicit UploadCardResWithDyncParamRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dynamicParam) {
      res["DynamicParam"] = boost::any(*dynamicParam);
    }
    if (expiredTimes) {
      res["ExpiredTimes"] = boost::any(*expiredTimes);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (memo) {
      res["Memo"] = boost::any(*memo);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DynamicParam") != m.end() && !m["DynamicParam"].empty()) {
      dynamicParam = make_shared<string>(boost::any_cast<string>(m["DynamicParam"]));
    }
    if (m.find("ExpiredTimes") != m.end() && !m["ExpiredTimes"].empty()) {
      expiredTimes = make_shared<long>(boost::any_cast<long>(m["ExpiredTimes"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<long>(boost::any_cast<long>(m["FileSize"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("Memo") != m.end() && !m["Memo"].empty()) {
      memo = make_shared<string>(boost::any_cast<string>(m["Memo"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
  }


  virtual ~UploadCardResWithDyncParamRequest() = default;
};
class UploadCardResWithDyncParamResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> resourceId{};

  UploadCardResWithDyncParamResponseBodyData() {}

  explicit UploadCardResWithDyncParamResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<long>(boost::any_cast<long>(m["ResourceId"]));
    }
  }


  virtual ~UploadCardResWithDyncParamResponseBodyData() = default;
};
class UploadCardResWithDyncParamResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> accessDeniedDetail{};
  shared_ptr<string> code{};
  shared_ptr<UploadCardResWithDyncParamResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UploadCardResWithDyncParamResponseBody() {}

  explicit UploadCardResWithDyncParamResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessDeniedDetail) {
      res["AccessDeniedDetail"] = boost::any(*accessDeniedDetail);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessDeniedDetail") != m.end() && !m["AccessDeniedDetail"].empty()) {
      accessDeniedDetail = make_shared<string>(boost::any_cast<string>(m["AccessDeniedDetail"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        UploadCardResWithDyncParamResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<UploadCardResWithDyncParamResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UploadCardResWithDyncParamResponseBody() = default;
};
class UploadCardResWithDyncParamResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UploadCardResWithDyncParamResponseBody> body{};

  UploadCardResWithDyncParamResponse() {}

  explicit UploadCardResWithDyncParamResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UploadCardResWithDyncParamResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UploadCardResWithDyncParamResponseBody>(model1);
      }
    }
  }


  virtual ~UploadCardResWithDyncParamResponse() = default;
};
class ValidatYunSmsIdRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> prodCode{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> data{};

  ValidatYunSmsIdRequest() {}

  explicit ValidatYunSmsIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prodCode) {
      res["ProdCode"] = boost::any(*prodCode);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProdCode") != m.end() && !m["ProdCode"].empty()) {
      prodCode = make_shared<string>(boost::any_cast<string>(m["ProdCode"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
  }


  virtual ~ValidatYunSmsIdRequest() = default;
};
class ValidatYunSmsIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  ValidatYunSmsIdResponseBody() {}

  explicit ValidatYunSmsIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~ValidatYunSmsIdResponseBody() = default;
};
class ValidatYunSmsIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ValidatYunSmsIdResponseBody> body{};

  ValidatYunSmsIdResponse() {}

  explicit ValidatYunSmsIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ValidatYunSmsIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ValidatYunSmsIdResponseBody>(model1);
      }
    }
  }


  virtual ~ValidatYunSmsIdResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AddDomainResponse addDomainWithOptions(shared_ptr<AddDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddDomainResponse addDomain(shared_ptr<AddDomainRequest> request);
  AddDomainNewResponse addDomainNewWithOptions(shared_ptr<AddDomainNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddDomainNewResponse addDomainNew(shared_ptr<AddDomainNewRequest> request);
  ApplyExportSmsSendRecordNewResponse applyExportSmsSendRecordNewWithOptions(shared_ptr<ApplyExportSmsSendRecordNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ApplyExportSmsSendRecordNewResponse applyExportSmsSendRecordNew(shared_ptr<ApplyExportSmsSendRecordNewRequest> request);
  BatchCreateSmsSignResponse batchCreateSmsSignWithOptions(shared_ptr<BatchCreateSmsSignRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchCreateSmsSignResponse batchCreateSmsSign(shared_ptr<BatchCreateSmsSignRequest> request);
  BatchDeleteExportSendRecordNewResponse batchDeleteExportSendRecordNewWithOptions(shared_ptr<BatchDeleteExportSendRecordNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchDeleteExportSendRecordNewResponse batchDeleteExportSendRecordNew(shared_ptr<BatchDeleteExportSendRecordNewRequest> request);
  BatchDeleteTaskNewResponse batchDeleteTaskNewWithOptions(shared_ptr<BatchDeleteTaskNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchDeleteTaskNewResponse batchDeleteTaskNew(shared_ptr<BatchDeleteTaskNewRequest> request);
  CalculateSmsLengthNewResponse calculateSmsLengthNewWithOptions(shared_ptr<CalculateSmsLengthNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CalculateSmsLengthNewResponse calculateSmsLengthNew(shared_ptr<CalculateSmsLengthNewRequest> request);
  CancelSmsSignResponse cancelSmsSignWithOptions(shared_ptr<CancelSmsSignRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelSmsSignResponse cancelSmsSign(shared_ptr<CancelSmsSignRequest> request);
  CancelSmsTemplateResponse cancelSmsTemplateWithOptions(shared_ptr<CancelSmsTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelSmsTemplateResponse cancelSmsTemplate(shared_ptr<CancelSmsTemplateRequest> request);
  CancelSmsTemplateNewResponse cancelSmsTemplateNewWithOptions(shared_ptr<CancelSmsTemplateNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelSmsTemplateNewResponse cancelSmsTemplateNew(shared_ptr<CancelSmsTemplateNewRequest> request);
  CheckSmsSignNewResponse checkSmsSignNewWithOptions(shared_ptr<CheckSmsSignNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckSmsSignNewResponse checkSmsSignNew(shared_ptr<CheckSmsSignNewRequest> request);
  CreateAlicomProductResponse createAlicomProductWithOptions(shared_ptr<CreateAlicomProductRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAlicomProductResponse createAlicomProduct(shared_ptr<CreateAlicomProductRequest> request);
  CreateAuthorizationResponse createAuthorizationWithOptions(shared_ptr<CreateAuthorizationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAuthorizationResponse createAuthorization(shared_ptr<CreateAuthorizationRequest> request);
  CreateCardMessageCallbackResponse createCardMessageCallbackWithOptions(shared_ptr<CreateCardMessageCallbackRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCardMessageCallbackResponse createCardMessageCallback(shared_ptr<CreateCardMessageCallbackRequest> request);
  CreateCardMessageQueueResponse createCardMessageQueueWithOptions(shared_ptr<CreateCardMessageQueueRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCardMessageQueueResponse createCardMessageQueue(shared_ptr<CreateCardMessageQueueRequest> request);
  CreateDigitalSmsTemplateNewResponse createDigitalSmsTemplateNewWithOptions(shared_ptr<CreateDigitalSmsTemplateNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDigitalSmsTemplateNewResponse createDigitalSmsTemplateNew(shared_ptr<CreateDigitalSmsTemplateNewRequest> request);
  CreateFileByBizResponse createFileByBizWithOptions(shared_ptr<CreateFileByBizRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFileByBizResponse createFileByBiz(shared_ptr<CreateFileByBizRequest> request);
  CreateFlowLimitResponse createFlowLimitWithOptions(shared_ptr<CreateFlowLimitRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFlowLimitResponse createFlowLimit(shared_ptr<CreateFlowLimitRequest> request);
  CreateFlowLimitNewResponse createFlowLimitNewWithOptions(shared_ptr<CreateFlowLimitNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFlowLimitNewResponse createFlowLimitNew(shared_ptr<CreateFlowLimitNewRequest> request);
  CreateMessageCallbackNewResponse createMessageCallbackNewWithOptions(shared_ptr<CreateMessageCallbackNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMessageCallbackNewResponse createMessageCallbackNew(shared_ptr<CreateMessageCallbackNewRequest> request);
  CreateMessageCallbackTestNewResponse createMessageCallbackTestNewWithOptions(shared_ptr<CreateMessageCallbackTestNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMessageCallbackTestNewResponse createMessageCallbackTestNew(shared_ptr<CreateMessageCallbackTestNewRequest> request);
  CreateMessageQueueNewResponse createMessageQueueNewWithOptions(shared_ptr<CreateMessageQueueNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMessageQueueNewResponse createMessageQueueNew(shared_ptr<CreateMessageQueueNewRequest> request);
  CreatePhoneWhiteListResponse createPhoneWhiteListWithOptions(shared_ptr<CreatePhoneWhiteListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreatePhoneWhiteListResponse createPhoneWhiteList(shared_ptr<CreatePhoneWhiteListRequest> request);
  CreatePhoneWhiteListNewResponse createPhoneWhiteListNewWithOptions(shared_ptr<CreatePhoneWhiteListNewRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreatePhoneWhiteListNewResponse createPhoneWhiteListNew(shared_ptr<CreatePhoneWhiteListNewRequest> request);
  CreatePkgThresholdResponse createPkgThresholdWithOptions(shared_ptr<CreatePkgThresholdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreatePkgThresholdResponse createPkgThreshold(shared_ptr<CreatePkgThresholdRequest> request);
  CreatePkgThresholdNewResponse createPkgThresholdNewWithOptions(shared_ptr<CreatePkgThresholdNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreatePkgThresholdNewResponse createPkgThresholdNew(shared_ptr<CreatePkgThresholdNewRequest> request);
  CreatePrevLimitNewResponse createPrevLimitNewWithOptions(shared_ptr<CreatePrevLimitNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreatePrevLimitNewResponse createPrevLimitNew(shared_ptr<CreatePrevLimitNewRequest> request);
  CreateProductResponse createProductWithOptions(shared_ptr<CreateProductRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateProductResponse createProduct(shared_ptr<CreateProductRequest> request);
  CreateProductNewResponse createProductNewWithOptions(shared_ptr<CreateProductNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateProductNewResponse createProductNew(shared_ptr<CreateProductNewRequest> request);
  CreateShortUrlNewResponse createShortUrlNewWithOptions(shared_ptr<CreateShortUrlNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateShortUrlNewResponse createShortUrlNew(shared_ptr<CreateShortUrlNewRequest> request);
  CreateSmsDetectTaskNewResponse createSmsDetectTaskNewWithOptions(shared_ptr<CreateSmsDetectTaskNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSmsDetectTaskNewResponse createSmsDetectTaskNew(shared_ptr<CreateSmsDetectTaskNewRequest> request);
  CreateSmsInternalApplyResponse createSmsInternalApplyWithOptions(shared_ptr<CreateSmsInternalApplyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSmsInternalApplyResponse createSmsInternalApply(shared_ptr<CreateSmsInternalApplyRequest> request);
  CreateSmsProductForChannelCustResponse createSmsProductForChannelCustWithOptions(shared_ptr<CreateSmsProductForChannelCustRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSmsProductForChannelCustResponse createSmsProductForChannelCust(shared_ptr<CreateSmsProductForChannelCustRequest> request);
  CreateSmsSaasTaskResponse createSmsSaasTaskWithOptions(shared_ptr<CreateSmsSaasTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSmsSaasTaskResponse createSmsSaasTask(shared_ptr<CreateSmsSaasTaskRequest> request);
  CreateSmsSaasTaskNewResponse createSmsSaasTaskNewWithOptions(shared_ptr<CreateSmsSaasTaskNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSmsSaasTaskNewResponse createSmsSaasTaskNew(shared_ptr<CreateSmsSaasTaskNewRequest> request);
  CreateSmsSendFailDetailsDownloadResponse createSmsSendFailDetailsDownloadWithOptions(shared_ptr<CreateSmsSendFailDetailsDownloadRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSmsSendFailDetailsDownloadResponse createSmsSendFailDetailsDownload(shared_ptr<CreateSmsSendFailDetailsDownloadRequest> request);
  CreateSmsSignResponse createSmsSignWithOptions(shared_ptr<CreateSmsSignRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSmsSignResponse createSmsSign(shared_ptr<CreateSmsSignRequest> request);
  CreateSmsSignNewResponse createSmsSignNewWithOptions(shared_ptr<CreateSmsSignNewRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSmsSignNewResponse createSmsSignNew(shared_ptr<CreateSmsSignNewRequest> request);
  CreateSmsTemplateNewResponse createSmsTemplateNewWithOptions(shared_ptr<CreateSmsTemplateNewRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSmsTemplateNewResponse createSmsTemplateNew(shared_ptr<CreateSmsTemplateNewRequest> request);
  CreateWarningThresholdResponse createWarningThresholdWithOptions(shared_ptr<CreateWarningThresholdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateWarningThresholdResponse createWarningThreshold(shared_ptr<CreateWarningThresholdRequest> request);
  CreateWarningThresholdNewResponse createWarningThresholdNewWithOptions(shared_ptr<CreateWarningThresholdNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateWarningThresholdNewResponse createWarningThresholdNew(shared_ptr<CreateWarningThresholdNewRequest> request);
  DelCardSendExportInfoResponse delCardSendExportInfoWithOptions(shared_ptr<DelCardSendExportInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DelCardSendExportInfoResponse delCardSendExportInfo(shared_ptr<DelCardSendExportInfoRequest> request);
  DeleteCardMessageCallbackResponse deleteCardMessageCallbackWithOptions(shared_ptr<DeleteCardMessageCallbackRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCardMessageCallbackResponse deleteCardMessageCallback(shared_ptr<DeleteCardMessageCallbackRequest> request);
  DeleteCardMessageQueueResponse deleteCardMessageQueueWithOptions(shared_ptr<DeleteCardMessageQueueRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCardMessageQueueResponse deleteCardMessageQueue(shared_ptr<DeleteCardMessageQueueRequest> request);
  DeleteContactsResponse deleteContactsWithOptions(shared_ptr<DeleteContactsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteContactsResponse deleteContacts(shared_ptr<DeleteContactsRequest> request);
  DeleteContactsNewResponse deleteContactsNewWithOptions(shared_ptr<DeleteContactsNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteContactsNewResponse deleteContactsNew(shared_ptr<DeleteContactsNewRequest> request);
  DeleteDigitalTemplateNewResponse deleteDigitalTemplateNewWithOptions(shared_ptr<DeleteDigitalTemplateNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDigitalTemplateNewResponse deleteDigitalTemplateNew(shared_ptr<DeleteDigitalTemplateNewRequest> request);
  DeleteMessageCallbackNewResponse deleteMessageCallbackNewWithOptions(shared_ptr<DeleteMessageCallbackNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMessageCallbackNewResponse deleteMessageCallbackNew(shared_ptr<DeleteMessageCallbackNewRequest> request);
  DeleteMessageQueueNewResponse deleteMessageQueueNewWithOptions(shared_ptr<DeleteMessageQueueNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMessageQueueNewResponse deleteMessageQueueNew(shared_ptr<DeleteMessageQueueNewRequest> request);
  DeleteOrCanceleTaskResponse deleteOrCanceleTaskWithOptions(shared_ptr<DeleteOrCanceleTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteOrCanceleTaskResponse deleteOrCanceleTask(shared_ptr<DeleteOrCanceleTaskRequest> request);
  DeleteOrCanceleTaskNewResponse deleteOrCanceleTaskNewWithOptions(shared_ptr<DeleteOrCanceleTaskNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteOrCanceleTaskNewResponse deleteOrCanceleTaskNew(shared_ptr<DeleteOrCanceleTaskNewRequest> request);
  DeletePhoneWhiteListResponse deletePhoneWhiteListWithOptions(shared_ptr<DeletePhoneWhiteListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeletePhoneWhiteListResponse deletePhoneWhiteList(shared_ptr<DeletePhoneWhiteListRequest> request);
  DeletePhoneWhiteListNewResponse deletePhoneWhiteListNewWithOptions(shared_ptr<DeletePhoneWhiteListNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeletePhoneWhiteListNewResponse deletePhoneWhiteListNew(shared_ptr<DeletePhoneWhiteListNewRequest> request);
  DeleteShortUrlNewResponse deleteShortUrlNewWithOptions(shared_ptr<DeleteShortUrlNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteShortUrlNewResponse deleteShortUrlNew(shared_ptr<DeleteShortUrlNewRequest> request);
  DeleteSmsTemplateNewResponse deleteSmsTemplateNewWithOptions(shared_ptr<DeleteSmsTemplateNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSmsTemplateNewResponse deleteSmsTemplateNew(shared_ptr<DeleteSmsTemplateNewRequest> request);
  ExportCardSmsHistoryResponse exportCardSmsHistoryWithOptions(shared_ptr<ExportCardSmsHistoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExportCardSmsHistoryResponse exportCardSmsHistory(shared_ptr<ExportCardSmsHistoryRequest> request);
  ExportCardSmsStatisticsResponse exportCardSmsStatisticsWithOptions(shared_ptr<ExportCardSmsStatisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExportCardSmsStatisticsResponse exportCardSmsStatistics(shared_ptr<ExportCardSmsStatisticsRequest> request);
  ExportCardSmsStatisticsSendResponse exportCardSmsStatisticsSendWithOptions(shared_ptr<ExportCardSmsStatisticsSendRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExportCardSmsStatisticsSendResponse exportCardSmsStatisticsSend(shared_ptr<ExportCardSmsStatisticsSendRequest> request);
  ExportTmpEffectReportDataResponse exportTmpEffectReportDataWithOptions(shared_ptr<ExportTmpEffectReportDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExportTmpEffectReportDataResponse exportTmpEffectReportData(shared_ptr<ExportTmpEffectReportDataRequest> request);
  GetLetterOfAuthorizationResponse getLetterOfAuthorizationWithOptions(shared_ptr<GetLetterOfAuthorizationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetLetterOfAuthorizationResponse getLetterOfAuthorization(shared_ptr<GetLetterOfAuthorizationRequest> request);
  ListPushMsgResponse listPushMsgWithOptions(shared_ptr<ListPushMsgRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPushMsgResponse listPushMsg(shared_ptr<ListPushMsgRequest> request);
  ListTagResourcesResponse listTagResourcesWithOptions(shared_ptr<ListTagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTagResourcesResponse listTagResources(shared_ptr<ListTagResourcesRequest> request);
  OpenShortUrlProductResponse openShortUrlProductWithOptions(shared_ptr<OpenShortUrlProductRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OpenShortUrlProductResponse openShortUrlProduct(shared_ptr<OpenShortUrlProductRequest> request);
  OpenShortUrlProductNewResponse openShortUrlProductNewWithOptions(shared_ptr<OpenShortUrlProductNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OpenShortUrlProductNewResponse openShortUrlProductNew(shared_ptr<OpenShortUrlProductNewRequest> request);
  OpencPrevFlagNewResponse opencPrevFlagNewWithOptions(shared_ptr<OpencPrevFlagNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OpencPrevFlagNewResponse opencPrevFlagNew(shared_ptr<OpencPrevFlagNewRequest> request);
  QueryAnyParamTemplateUserResponse queryAnyParamTemplateUserWithOptions(shared_ptr<QueryAnyParamTemplateUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryAnyParamTemplateUserResponse queryAnyParamTemplateUser(shared_ptr<QueryAnyParamTemplateUserRequest> request);
  QueryAuthorizationResponse queryAuthorizationWithOptions(shared_ptr<QueryAuthorizationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryAuthorizationResponse queryAuthorization(shared_ptr<QueryAuthorizationRequest> request);
  QueryBillingStatisticsResponse queryBillingStatisticsWithOptions(shared_ptr<QueryBillingStatisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryBillingStatisticsResponse queryBillingStatistics(shared_ptr<QueryBillingStatisticsRequest> request);
  QueryCardMessageQueueResponse queryCardMessageQueueWithOptions(shared_ptr<QueryCardMessageQueueRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryCardMessageQueueResponse queryCardMessageQueue(shared_ptr<QueryCardMessageQueueRequest> request);
  QueryCardSendExportInfoResponse queryCardSendExportInfoWithOptions(shared_ptr<QueryCardSendExportInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryCardSendExportInfoResponse queryCardSendExportInfo(shared_ptr<QueryCardSendExportInfoRequest> request);
  QueryCardSmsHistoryResponse queryCardSmsHistoryWithOptions(shared_ptr<QueryCardSmsHistoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryCardSmsHistoryResponse queryCardSmsHistory(shared_ptr<QueryCardSmsHistoryRequest> request);
  QueryCardSmsHistoryDetailResponse queryCardSmsHistoryDetailWithOptions(shared_ptr<QueryCardSmsHistoryDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryCardSmsHistoryDetailResponse queryCardSmsHistoryDetail(shared_ptr<QueryCardSmsHistoryDetailRequest> request);
  QueryCardSmsStatisticsResponse queryCardSmsStatisticsWithOptions(shared_ptr<QueryCardSmsStatisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryCardSmsStatisticsResponse queryCardSmsStatistics(shared_ptr<QueryCardSmsStatisticsRequest> request);
  QueryCardSmsStatisticsListResponse queryCardSmsStatisticsListWithOptions(shared_ptr<QueryCardSmsStatisticsListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryCardSmsStatisticsListResponse queryCardSmsStatisticsList(shared_ptr<QueryCardSmsStatisticsListRequest> request);
  QueryCardSmsStatisticsSendResponse queryCardSmsStatisticsSendWithOptions(shared_ptr<QueryCardSmsStatisticsSendRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryCardSmsStatisticsSendResponse queryCardSmsStatisticsSend(shared_ptr<QueryCardSmsStatisticsSendRequest> request);
  QueryCardSmsStatisticsSendListResponse queryCardSmsStatisticsSendListWithOptions(shared_ptr<QueryCardSmsStatisticsSendListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryCardSmsStatisticsSendListResponse queryCardSmsStatisticsSendList(shared_ptr<QueryCardSmsStatisticsSendListRequest> request);
  QueryCommonCustInfoResponse queryCommonCustInfoWithOptions(shared_ptr<QueryCommonCustInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryCommonCustInfoResponse queryCommonCustInfo(shared_ptr<QueryCommonCustInfoRequest> request);
  QueryContactsListResponse queryContactsListWithOptions(shared_ptr<QueryContactsListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryContactsListResponse queryContactsList(shared_ptr<QueryContactsListRequest> request);
  QueryContactsListNewResponse queryContactsListNewWithOptions(shared_ptr<QueryContactsListNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryContactsListNewResponse queryContactsListNew(shared_ptr<QueryContactsListNewRequest> request);
  QueryDailyBillInfoLeafNewResponse queryDailyBillInfoLeafNewWithOptions(shared_ptr<QueryDailyBillInfoLeafNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDailyBillInfoLeafNewResponse queryDailyBillInfoLeafNew(shared_ptr<QueryDailyBillInfoLeafNewRequest> request);
  QueryDigitalTemplateDetailResponse queryDigitalTemplateDetailWithOptions(shared_ptr<QueryDigitalTemplateDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDigitalTemplateDetailResponse queryDigitalTemplateDetail(shared_ptr<QueryDigitalTemplateDetailRequest> request);
  QueryDigitalTemplateDetailNewResponse queryDigitalTemplateDetailNewWithOptions(shared_ptr<QueryDigitalTemplateDetailNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDigitalTemplateDetailNewResponse queryDigitalTemplateDetailNew(shared_ptr<QueryDigitalTemplateDetailNewRequest> request);
  QueryDigitalTemplateLastRangeResponse queryDigitalTemplateLastRangeWithOptions(shared_ptr<QueryDigitalTemplateLastRangeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDigitalTemplateLastRangeResponse queryDigitalTemplateLastRange(shared_ptr<QueryDigitalTemplateLastRangeRequest> request);
  QueryDigitalTemplateLastRangeNewResponse queryDigitalTemplateLastRangeNewWithOptions(shared_ptr<QueryDigitalTemplateLastRangeNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDigitalTemplateLastRangeNewResponse queryDigitalTemplateLastRangeNew(shared_ptr<QueryDigitalTemplateLastRangeNewRequest> request);
  QueryDigitalTemplatePageListResponse queryDigitalTemplatePageListWithOptions(shared_ptr<QueryDigitalTemplatePageListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDigitalTemplatePageListResponse queryDigitalTemplatePageList(shared_ptr<QueryDigitalTemplatePageListRequest> request);
  QueryDigitalTemplatePageListNewResponse queryDigitalTemplatePageListNewWithOptions(shared_ptr<QueryDigitalTemplatePageListNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDigitalTemplatePageListNewResponse queryDigitalTemplatePageListNew(shared_ptr<QueryDigitalTemplatePageListNewRequest> request);
  QueryDomainListResponse queryDomainListWithOptions(shared_ptr<QueryDomainListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDomainListResponse queryDomainList(shared_ptr<QueryDomainListRequest> request);
  QueryDomainListNewResponse queryDomainListNewWithOptions(shared_ptr<QueryDomainListNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDomainListNewResponse queryDomainListNew(shared_ptr<QueryDomainListNewRequest> request);
  QueryExportSendRecordListNewResponse queryExportSendRecordListNewWithOptions(shared_ptr<QueryExportSendRecordListNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryExportSendRecordListNewResponse queryExportSendRecordListNew(shared_ptr<QueryExportSendRecordListNewRequest> request);
  QueryFailDetailDownloadResponse queryFailDetailDownloadWithOptions(shared_ptr<QueryFailDetailDownloadRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryFailDetailDownloadResponse queryFailDetailDownload(shared_ptr<QueryFailDetailDownloadRequest> request);
  QueryFailDetailDownloadNewResponse queryFailDetailDownloadNewWithOptions(shared_ptr<QueryFailDetailDownloadNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryFailDetailDownloadNewResponse queryFailDetailDownloadNew(shared_ptr<QueryFailDetailDownloadNewRequest> request);
  QueryFlowLimitResponse queryFlowLimitWithOptions(shared_ptr<QueryFlowLimitRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryFlowLimitResponse queryFlowLimit(shared_ptr<QueryFlowLimitRequest> request);
  QueryFlowLimitNewResponse queryFlowLimitNewWithOptions(shared_ptr<QueryFlowLimitNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryFlowLimitNewResponse queryFlowLimitNew(shared_ptr<QueryFlowLimitNewRequest> request);
  QueryIndexColRecordResponse queryIndexColRecordWithOptions(shared_ptr<QueryIndexColRecordRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryIndexColRecordResponse queryIndexColRecord(shared_ptr<QueryIndexColRecordRequest> request);
  QueryLearningStatusNewResponse queryLearningStatusNewWithOptions(shared_ptr<QueryLearningStatusNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryLearningStatusNewResponse queryLearningStatusNew(shared_ptr<QueryLearningStatusNewRequest> request);
  QueryMarketingAssistantStatusResponse queryMarketingAssistantStatusWithOptions(shared_ptr<QueryMarketingAssistantStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMarketingAssistantStatusResponse queryMarketingAssistantStatus(shared_ptr<QueryMarketingAssistantStatusRequest> request);
  QueryMessageCallbackNewResponse queryMessageCallbackNewWithOptions(shared_ptr<QueryMessageCallbackNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMessageCallbackNewResponse queryMessageCallbackNew(shared_ptr<QueryMessageCallbackNewRequest> request);
  QueryMessageQueueNewResponse queryMessageQueueNewWithOptions(shared_ptr<QueryMessageQueueNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMessageQueueNewResponse queryMessageQueueNew(shared_ptr<QueryMessageQueueNewRequest> request);
  QueryMonthlyBillInfoLeafNewResponse queryMonthlyBillInfoLeafNewWithOptions(shared_ptr<QueryMonthlyBillInfoLeafNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMonthlyBillInfoLeafNewResponse queryMonthlyBillInfoLeafNew(shared_ptr<QueryMonthlyBillInfoLeafNewRequest> request);
  QueryMonthlyBillRentalResponse queryMonthlyBillRentalWithOptions(shared_ptr<QueryMonthlyBillRentalRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMonthlyBillRentalResponse queryMonthlyBillRental(shared_ptr<QueryMonthlyBillRentalRequest> request);
  QueryMonthlyBillRentalNewResponse queryMonthlyBillRentalNewWithOptions(shared_ptr<QueryMonthlyBillRentalNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMonthlyBillRentalNewResponse queryMonthlyBillRentalNew(shared_ptr<QueryMonthlyBillRentalNewRequest> request);
  QueryMsgCountResponse queryMsgCountWithOptions(shared_ptr<QueryMsgCountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMsgCountResponse queryMsgCount(shared_ptr<QueryMsgCountRequest> request);
  QueryOpenStatusResponse queryOpenStatusWithOptions(shared_ptr<QueryOpenStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryOpenStatusResponse queryOpenStatus(shared_ptr<QueryOpenStatusRequest> request);
  QueryOpencFlagNewResponse queryOpencFlagNewWithOptions(shared_ptr<QueryOpencFlagNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryOpencFlagNewResponse queryOpencFlagNew(shared_ptr<QueryOpencFlagNewRequest> request);
  QueryPhoneWhiteListResponse queryPhoneWhiteListWithOptions(shared_ptr<QueryPhoneWhiteListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryPhoneWhiteListResponse queryPhoneWhiteList(shared_ptr<QueryPhoneWhiteListRequest> request);
  QueryPhoneWhiteListNewResponse queryPhoneWhiteListNewWithOptions(shared_ptr<QueryPhoneWhiteListNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryPhoneWhiteListNewResponse queryPhoneWhiteListNew(shared_ptr<QueryPhoneWhiteListNewRequest> request);
  QueryPkgThresholdResponse queryPkgThresholdWithOptions(shared_ptr<QueryPkgThresholdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryPkgThresholdResponse queryPkgThreshold(shared_ptr<QueryPkgThresholdRequest> request);
  QueryPkgThresholdNewResponse queryPkgThresholdNewWithOptions(shared_ptr<QueryPkgThresholdNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryPkgThresholdNewResponse queryPkgThresholdNew(shared_ptr<QueryPkgThresholdNewRequest> request);
  QueryPrevLimitNewResponse queryPrevLimitNewWithOptions(shared_ptr<QueryPrevLimitNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryPrevLimitNewResponse queryPrevLimitNew(shared_ptr<QueryPrevLimitNewRequest> request);
  QuerySaasRecordResponse querySaasRecordWithOptions(shared_ptr<QuerySaasRecordRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySaasRecordResponse querySaasRecord(shared_ptr<QuerySaasRecordRequest> request);
  QuerySaasRecordNewResponse querySaasRecordNewWithOptions(shared_ptr<QuerySaasRecordNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySaasRecordNewResponse querySaasRecordNew(shared_ptr<QuerySaasRecordNewRequest> request);
  QuerySendDetailsByPhoneNumResponse querySendDetailsByPhoneNumWithOptions(shared_ptr<QuerySendDetailsByPhoneNumRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySendDetailsByPhoneNumResponse querySendDetailsByPhoneNum(shared_ptr<QuerySendDetailsByPhoneNumRequest> request);
  QuerySendDetailsByPhoneNumNewResponse querySendDetailsByPhoneNumNewWithOptions(shared_ptr<QuerySendDetailsByPhoneNumNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySendDetailsByPhoneNumNewResponse querySendDetailsByPhoneNumNew(shared_ptr<QuerySendDetailsByPhoneNumNewRequest> request);
  QuerySendFailDetailsResponse querySendFailDetailsWithOptions(shared_ptr<QuerySendFailDetailsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySendFailDetailsResponse querySendFailDetails(shared_ptr<QuerySendFailDetailsRequest> request);
  QuerySendFailDetailsNewResponse querySendFailDetailsNewWithOptions(shared_ptr<QuerySendFailDetailsNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySendFailDetailsNewResponse querySendFailDetailsNew(shared_ptr<QuerySendFailDetailsNewRequest> request);
  QuerySendToGlobeStatusResponse querySendToGlobeStatusWithOptions(shared_ptr<QuerySendToGlobeStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySendToGlobeStatusResponse querySendToGlobeStatus(shared_ptr<QuerySendToGlobeStatusRequest> request);
  QueryShortUrlDetailNewResponse queryShortUrlDetailNewWithOptions(shared_ptr<QueryShortUrlDetailNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryShortUrlDetailNewResponse queryShortUrlDetailNew(shared_ptr<QueryShortUrlDetailNewRequest> request);
  QueryShortUrlListNewResponse queryShortUrlListNewWithOptions(shared_ptr<QueryShortUrlListNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryShortUrlListNewResponse queryShortUrlListNew(shared_ptr<QueryShortUrlListNewRequest> request);
  QueryShortUrlStatusResponse queryShortUrlStatusWithOptions(shared_ptr<QueryShortUrlStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryShortUrlStatusResponse queryShortUrlStatus(shared_ptr<QueryShortUrlStatusRequest> request);
  QuerySlsStatusNewResponse querySlsStatusNewWithOptions(shared_ptr<QuerySlsStatusNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySlsStatusNewResponse querySlsStatusNew(shared_ptr<QuerySlsStatusNewRequest> request);
  QuerySmsBaseScreenNewResponse querySmsBaseScreenNewWithOptions(shared_ptr<QuerySmsBaseScreenNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySmsBaseScreenNewResponse querySmsBaseScreenNew(shared_ptr<QuerySmsBaseScreenNewRequest> request);
  QuerySmsDetectCountsResponse querySmsDetectCountsWithOptions(shared_ptr<QuerySmsDetectCountsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySmsDetectCountsResponse querySmsDetectCounts(shared_ptr<QuerySmsDetectCountsRequest> request);
  QuerySmsDetectCountsNewResponse querySmsDetectCountsNewWithOptions(shared_ptr<QuerySmsDetectCountsNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySmsDetectCountsNewResponse querySmsDetectCountsNew(shared_ptr<QuerySmsDetectCountsNewRequest> request);
  QuerySmsDetectListResponse querySmsDetectListWithOptions(shared_ptr<QuerySmsDetectListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySmsDetectListResponse querySmsDetectList(shared_ptr<QuerySmsDetectListRequest> request);
  QuerySmsDetectListNewResponse querySmsDetectListNewWithOptions(shared_ptr<QuerySmsDetectListNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySmsDetectListNewResponse querySmsDetectListNew(shared_ptr<QuerySmsDetectListNewRequest> request);
  QuerySmsPackageDetailResponse querySmsPackageDetailWithOptions(shared_ptr<QuerySmsPackageDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySmsPackageDetailResponse querySmsPackageDetail(shared_ptr<QuerySmsPackageDetailRequest> request);
  QuerySmsPackageDetailNewResponse querySmsPackageDetailNewWithOptions(shared_ptr<QuerySmsPackageDetailNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySmsPackageDetailNewResponse querySmsPackageDetailNew(shared_ptr<QuerySmsPackageDetailNewRequest> request);
  QuerySmsPackageNewResponse querySmsPackageNewWithOptions(shared_ptr<QuerySmsPackageNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySmsPackageNewResponse querySmsPackageNew(shared_ptr<QuerySmsPackageNewRequest> request);
  QuerySmsPackageOrderListResponse querySmsPackageOrderListWithOptions(shared_ptr<QuerySmsPackageOrderListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySmsPackageOrderListResponse querySmsPackageOrderList(shared_ptr<QuerySmsPackageOrderListRequest> request);
  QuerySmsPackageOrderListNewResponse querySmsPackageOrderListNewWithOptions(shared_ptr<QuerySmsPackageOrderListNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySmsPackageOrderListNewResponse querySmsPackageOrderListNew(shared_ptr<QuerySmsPackageOrderListNewRequest> request);
  QuerySmsPackageSummaryResponse querySmsPackageSummaryWithOptions(shared_ptr<QuerySmsPackageSummaryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySmsPackageSummaryResponse querySmsPackageSummary(shared_ptr<QuerySmsPackageSummaryRequest> request);
  QuerySmsPackageSummaryNewResponse querySmsPackageSummaryNewWithOptions(shared_ptr<QuerySmsPackageSummaryNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySmsPackageSummaryNewResponse querySmsPackageSummaryNew(shared_ptr<QuerySmsPackageSummaryNewRequest> request);
  QuerySmsSaasTaskDetailResponse querySmsSaasTaskDetailWithOptions(shared_ptr<QuerySmsSaasTaskDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySmsSaasTaskDetailResponse querySmsSaasTaskDetail(shared_ptr<QuerySmsSaasTaskDetailRequest> request);
  QuerySmsSaasTaskDetailNewResponse querySmsSaasTaskDetailNewWithOptions(shared_ptr<QuerySmsSaasTaskDetailNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySmsSaasTaskDetailNewResponse querySmsSaasTaskDetailNew(shared_ptr<QuerySmsSaasTaskDetailNewRequest> request);
  QuerySmsSaasTaskListResponse querySmsSaasTaskListWithOptions(shared_ptr<QuerySmsSaasTaskListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySmsSaasTaskListResponse querySmsSaasTaskList(shared_ptr<QuerySmsSaasTaskListRequest> request);
  QuerySmsSaasTaskListNewResponse querySmsSaasTaskListNewWithOptions(shared_ptr<QuerySmsSaasTaskListNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySmsSaasTaskListNewResponse querySmsSaasTaskListNew(shared_ptr<QuerySmsSaasTaskListNewRequest> request);
  QuerySmsSendFailDetailsUrlResponse querySmsSendFailDetailsUrlWithOptions(shared_ptr<QuerySmsSendFailDetailsUrlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySmsSendFailDetailsUrlResponse querySmsSendFailDetailsUrl(shared_ptr<QuerySmsSendFailDetailsUrlRequest> request);
  QuerySmsSendFailDetailsUrlNewResponse querySmsSendFailDetailsUrlNewWithOptions(shared_ptr<QuerySmsSendFailDetailsUrlNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySmsSendFailDetailsUrlNewResponse querySmsSendFailDetailsUrlNew(shared_ptr<QuerySmsSendFailDetailsUrlNewRequest> request);
  QuerySmsSignDetailBySignIdNewResponse querySmsSignDetailBySignIdNewWithOptions(shared_ptr<QuerySmsSignDetailBySignIdNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySmsSignDetailBySignIdNewResponse querySmsSignDetailBySignIdNew(shared_ptr<QuerySmsSignDetailBySignIdNewRequest> request);
  QuerySmsSignLastRangeResponse querySmsSignLastRangeWithOptions(shared_ptr<QuerySmsSignLastRangeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySmsSignLastRangeResponse querySmsSignLastRange(shared_ptr<QuerySmsSignLastRangeRequest> request);
  QuerySmsSignLastRangeNewResponse querySmsSignLastRangeNewWithOptions(shared_ptr<QuerySmsSignLastRangeNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySmsSignLastRangeNewResponse querySmsSignLastRangeNew(shared_ptr<QuerySmsSignLastRangeNewRequest> request);
  QuerySmsSignListResponse querySmsSignListWithOptions(shared_ptr<QuerySmsSignListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySmsSignListResponse querySmsSignList(shared_ptr<QuerySmsSignListRequest> request);
  QuerySmsSignListNewResponse querySmsSignListNewWithOptions(shared_ptr<QuerySmsSignListNewRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySmsSignListNewResponse querySmsSignListNew(shared_ptr<QuerySmsSignListNewRequest> request);
  QuerySmsSignValidResponse querySmsSignValidWithOptions(shared_ptr<QuerySmsSignValidRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySmsSignValidResponse querySmsSignValid(shared_ptr<QuerySmsSignValidRequest> request);
  QuerySmsSignValidNewResponse querySmsSignValidNewWithOptions(shared_ptr<QuerySmsSignValidNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySmsSignValidNewResponse querySmsSignValidNew(shared_ptr<QuerySmsSignValidNewRequest> request);
  QuerySmsStatisticsResponse querySmsStatisticsWithOptions(shared_ptr<QuerySmsStatisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySmsStatisticsResponse querySmsStatistics(shared_ptr<QuerySmsStatisticsRequest> request);
  QuerySmsStatisticsByTemplateResponse querySmsStatisticsByTemplateWithOptions(shared_ptr<QuerySmsStatisticsByTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySmsStatisticsByTemplateResponse querySmsStatisticsByTemplate(shared_ptr<QuerySmsStatisticsByTemplateRequest> request);
  QuerySmsStatisticsByTemplateNewResponse querySmsStatisticsByTemplateNewWithOptions(shared_ptr<QuerySmsStatisticsByTemplateNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySmsStatisticsByTemplateNewResponse querySmsStatisticsByTemplateNew(shared_ptr<QuerySmsStatisticsByTemplateNewRequest> request);
  QuerySmsStatisticsNewResponse querySmsStatisticsNewWithOptions(shared_ptr<QuerySmsStatisticsNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySmsStatisticsNewResponse querySmsStatisticsNew(shared_ptr<QuerySmsStatisticsNewRequest> request);
  QuerySmsStatisticsUrlResponse querySmsStatisticsUrlWithOptions(shared_ptr<QuerySmsStatisticsUrlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySmsStatisticsUrlResponse querySmsStatisticsUrl(shared_ptr<QuerySmsStatisticsUrlRequest> request);
  QuerySmsStatisticsUrlNewResponse querySmsStatisticsUrlNewWithOptions(shared_ptr<QuerySmsStatisticsUrlNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySmsStatisticsUrlNewResponse querySmsStatisticsUrlNew(shared_ptr<QuerySmsStatisticsUrlNewRequest> request);
  QuerySmsStepResponse querySmsStepWithOptions(shared_ptr<QuerySmsStepRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySmsStepResponse querySmsStep(shared_ptr<QuerySmsStepRequest> request);
  QuerySmsTemplateByCodeResponse querySmsTemplateByCodeWithOptions(shared_ptr<QuerySmsTemplateByCodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySmsTemplateByCodeResponse querySmsTemplateByCode(shared_ptr<QuerySmsTemplateByCodeRequest> request);
  QuerySmsTemplateByCodeNewResponse querySmsTemplateByCodeNewWithOptions(shared_ptr<QuerySmsTemplateByCodeNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySmsTemplateByCodeNewResponse querySmsTemplateByCodeNew(shared_ptr<QuerySmsTemplateByCodeNewRequest> request);
  QuerySmsTemplateLastRangeResponse querySmsTemplateLastRangeWithOptions(shared_ptr<QuerySmsTemplateLastRangeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySmsTemplateLastRangeResponse querySmsTemplateLastRange(shared_ptr<QuerySmsTemplateLastRangeRequest> request);
  QuerySmsTemplateLastRangeNewResponse querySmsTemplateLastRangeNewWithOptions(shared_ptr<QuerySmsTemplateLastRangeNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySmsTemplateLastRangeNewResponse querySmsTemplateLastRangeNew(shared_ptr<QuerySmsTemplateLastRangeNewRequest> request);
  QuerySmsTemplateListResponse querySmsTemplateListWithOptions(shared_ptr<QuerySmsTemplateListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySmsTemplateListResponse querySmsTemplateList(shared_ptr<QuerySmsTemplateListRequest> request);
  QuerySmsTemplateListNewResponse querySmsTemplateListNewWithOptions(shared_ptr<QuerySmsTemplateListNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySmsTemplateListNewResponse querySmsTemplateListNew(shared_ptr<QuerySmsTemplateListNewRequest> request);
  QuerySmsUserTagsResponse querySmsUserTagsWithOptions(shared_ptr<QuerySmsUserTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySmsUserTagsResponse querySmsUserTags(shared_ptr<QuerySmsUserTagsRequest> request);
  QuerySmsUserTagsNewResponse querySmsUserTagsNewWithOptions(shared_ptr<QuerySmsUserTagsNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySmsUserTagsNewResponse querySmsUserTagsNew(shared_ptr<QuerySmsUserTagsNewRequest> request);
  QueryStandarTemplateCollectionsResponse queryStandarTemplateCollectionsWithOptions(shared_ptr<QueryStandarTemplateCollectionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryStandarTemplateCollectionsResponse queryStandarTemplateCollections(shared_ptr<QueryStandarTemplateCollectionsRequest> request);
  QueryStandarTemplateCollectionsNewResponse queryStandarTemplateCollectionsNewWithOptions(shared_ptr<QueryStandarTemplateCollectionsNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryStandarTemplateCollectionsNewResponse queryStandarTemplateCollectionsNew(shared_ptr<QueryStandarTemplateCollectionsNewRequest> request);
  QueryStandardProtocolResponse queryStandardProtocolWithOptions(shared_ptr<QueryStandardProtocolRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryStandardProtocolResponse queryStandardProtocol(shared_ptr<QueryStandardProtocolRequest> request);
  QueryStandardProtocolListNewResponse queryStandardProtocolListNewWithOptions(shared_ptr<QueryStandardProtocolListNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryStandardProtocolListNewResponse queryStandardProtocolListNew(shared_ptr<QueryStandardProtocolListNewRequest> request);
  QueryTagResourcesResponse queryTagResourcesWithOptions(shared_ptr<QueryTagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryTagResourcesResponse queryTagResources(shared_ptr<QueryTagResourcesRequest> request);
  QueryTagResourcesNewResponse queryTagResourcesNewWithOptions(shared_ptr<QueryTagResourcesNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryTagResourcesNewResponse queryTagResourcesNew(shared_ptr<QueryTagResourcesNewRequest> request);
  QueryTmpEffectReportDataResponse queryTmpEffectReportDataWithOptions(shared_ptr<QueryTmpEffectReportDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryTmpEffectReportDataResponse queryTmpEffectReportData(shared_ptr<QueryTmpEffectReportDataRequest> request);
  QueryTmpEffectReportDayDataResponse queryTmpEffectReportDayDataWithOptions(shared_ptr<QueryTmpEffectReportDayDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryTmpEffectReportDayDataResponse queryTmpEffectReportDayData(shared_ptr<QueryTmpEffectReportDayDataRequest> request);
  QueryUsertagExistenceResponse queryUsertagExistenceWithOptions(shared_ptr<QueryUsertagExistenceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryUsertagExistenceResponse queryUsertagExistence(shared_ptr<QueryUsertagExistenceRequest> request);
  QueryWarningThresholdResponse queryWarningThresholdWithOptions(shared_ptr<QueryWarningThresholdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryWarningThresholdResponse queryWarningThreshold(shared_ptr<QueryWarningThresholdRequest> request);
  QueryWarningThresholdNewResponse queryWarningThresholdNewWithOptions(shared_ptr<QueryWarningThresholdNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryWarningThresholdNewResponse queryWarningThresholdNew(shared_ptr<QueryWarningThresholdNewRequest> request);
  QueryWorkOrdAuditListNewResponse queryWorkOrdAuditListNewWithOptions(shared_ptr<QueryWorkOrdAuditListNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryWorkOrdAuditListNewResponse queryWorkOrdAuditListNew(shared_ptr<QueryWorkOrdAuditListNewRequest> request);
  SaveContactsNewResponse saveContactsNewWithOptions(shared_ptr<SaveContactsNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SaveContactsNewResponse saveContactsNew(shared_ptr<SaveContactsNewRequest> request);
  SaveLearningStatusNewResponse saveLearningStatusNewWithOptions(shared_ptr<SaveLearningStatusNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SaveLearningStatusNewResponse saveLearningStatusNew(shared_ptr<SaveLearningStatusNewRequest> request);
  SelectTagResourceResponse selectTagResourceWithOptions(shared_ptr<SelectTagResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SelectTagResourceResponse selectTagResource(shared_ptr<SelectTagResourceRequest> request);
  SelectTagResourceNewResponse selectTagResourceNewWithOptions(shared_ptr<SelectTagResourceNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SelectTagResourceNewResponse selectTagResourceNew(shared_ptr<SelectTagResourceNewRequest> request);
  SendSmsTestResponse sendSmsTestWithOptions(shared_ptr<SendSmsTestRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SendSmsTestResponse sendSmsTest(shared_ptr<SendSmsTestRequest> request);
  SendSmsTestNewResponse sendSmsTestNewWithOptions(shared_ptr<SendSmsTestNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SendSmsTestNewResponse sendSmsTestNew(shared_ptr<SendSmsTestNewRequest> request);
  SendVerificationResponse sendVerificationWithOptions(shared_ptr<SendVerificationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SendVerificationResponse sendVerification(shared_ptr<SendVerificationRequest> request);
  SendVerificationNewResponse sendVerificationNewWithOptions(shared_ptr<SendVerificationNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SendVerificationNewResponse sendVerificationNew(shared_ptr<SendVerificationNewRequest> request);
  TagResourcesResponse tagResourcesWithOptions(shared_ptr<TagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TagResourcesResponse tagResources(shared_ptr<TagResourcesRequest> request);
  TagResourcesNewResponse tagResourcesNewWithOptions(shared_ptr<TagResourcesNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TagResourcesNewResponse tagResourcesNew(shared_ptr<TagResourcesNewRequest> request);
  TagResourcesSystemTagsResponse tagResourcesSystemTagsWithOptions(shared_ptr<TagResourcesSystemTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TagResourcesSystemTagsResponse tagResourcesSystemTags(shared_ptr<TagResourcesSystemTagsRequest> request);
  UntagResourcesResponse untagResourcesWithOptions(shared_ptr<UntagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UntagResourcesResponse untagResources(shared_ptr<UntagResourcesRequest> request);
  UntagResourcesNewResponse untagResourcesNewWithOptions(shared_ptr<UntagResourcesNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UntagResourcesNewResponse untagResourcesNew(shared_ptr<UntagResourcesNewRequest> request);
  UntagResourcesSystemTagsResponse untagResourcesSystemTagsWithOptions(shared_ptr<UntagResourcesSystemTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UntagResourcesSystemTagsResponse untagResourcesSystemTags(shared_ptr<UntagResourcesSystemTagsRequest> request);
  UpdateIpWhiteListNewResponse updateIpWhiteListNewWithOptions(shared_ptr<UpdateIpWhiteListNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateIpWhiteListNewResponse updateIpWhiteListNew(shared_ptr<UpdateIpWhiteListNewRequest> request);
  UpdatePartnerTemplateNewResponse updatePartnerTemplateNewWithOptions(shared_ptr<UpdatePartnerTemplateNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdatePartnerTemplateNewResponse updatePartnerTemplateNew(shared_ptr<UpdatePartnerTemplateNewRequest> request);
  UpdateSlsStatusNewResponse updateSlsStatusNewWithOptions(shared_ptr<UpdateSlsStatusNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateSlsStatusNewResponse updateSlsStatusNew(shared_ptr<UpdateSlsStatusNewRequest> request);
  UploadCardResResponse uploadCardResWithOptions(shared_ptr<UploadCardResRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UploadCardResResponse uploadCardRes(shared_ptr<UploadCardResRequest> request);
  UploadCardResWithDyncParamResponse uploadCardResWithDyncParamWithOptions(shared_ptr<UploadCardResWithDyncParamRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UploadCardResWithDyncParamResponse uploadCardResWithDyncParam(shared_ptr<UploadCardResWithDyncParamRequest> request);
  ValidatYunSmsIdResponse validatYunSmsIdWithOptions(shared_ptr<ValidatYunSmsIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ValidatYunSmsIdResponse validatYunSmsId(shared_ptr<ValidatYunSmsIdRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Dysms20170620

#endif
