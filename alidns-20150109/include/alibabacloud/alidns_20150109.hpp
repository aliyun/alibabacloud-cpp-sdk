// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_ALIDNS20150109_H_
#define ALIBABACLOUD_ALIDNS20150109_H_

#include <alibabacloud/open_api.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Alidns20150109 {
class AddCustomLineRequestIpSegment : public Darabonba::Model {
public:
  shared_ptr<string> endIp{};
  shared_ptr<string> startIp{};

  AddCustomLineRequestIpSegment() {}

  explicit AddCustomLineRequestIpSegment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endIp) {
      res["EndIp"] = boost::any(*endIp);
    }
    if (startIp) {
      res["StartIp"] = boost::any(*startIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndIp") != m.end() && !m["EndIp"].empty()) {
      endIp = make_shared<string>(boost::any_cast<string>(m["EndIp"]));
    }
    if (m.find("StartIp") != m.end() && !m["StartIp"].empty()) {
      startIp = make_shared<string>(boost::any_cast<string>(m["StartIp"]));
    }
  }


  virtual ~AddCustomLineRequestIpSegment() = default;
};
class AddCustomLineRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<vector<AddCustomLineRequestIpSegment>> ipSegment{};
  shared_ptr<string> lang{};
  shared_ptr<string> lineName{};

  AddCustomLineRequest() {}

  explicit AddCustomLineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ipSegment) {
      vector<boost::any> temp1;
      for(auto item1:*ipSegment){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IpSegment"] = boost::any(temp1);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (lineName) {
      res["LineName"] = boost::any(*lineName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("IpSegment") != m.end() && !m["IpSegment"].empty()) {
      if (typeid(vector<boost::any>) == m["IpSegment"].type()) {
        vector<AddCustomLineRequestIpSegment> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IpSegment"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddCustomLineRequestIpSegment model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ipSegment = make_shared<vector<AddCustomLineRequestIpSegment>>(expect1);
      }
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("LineName") != m.end() && !m["LineName"].empty()) {
      lineName = make_shared<string>(boost::any_cast<string>(m["LineName"]));
    }
  }


  virtual ~AddCustomLineRequest() = default;
};
class AddCustomLineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> lineCode{};
  shared_ptr<long> lineId{};
  shared_ptr<string> requestId{};

  AddCustomLineResponseBody() {}

  explicit AddCustomLineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lineCode) {
      res["LineCode"] = boost::any(*lineCode);
    }
    if (lineId) {
      res["LineId"] = boost::any(*lineId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LineCode") != m.end() && !m["LineCode"].empty()) {
      lineCode = make_shared<string>(boost::any_cast<string>(m["LineCode"]));
    }
    if (m.find("LineId") != m.end() && !m["LineId"].empty()) {
      lineId = make_shared<long>(boost::any_cast<long>(m["LineId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddCustomLineResponseBody() = default;
};
class AddCustomLineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddCustomLineResponseBody> body{};

  AddCustomLineResponse() {}

  explicit AddCustomLineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddCustomLineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddCustomLineResponseBody>(model1);
      }
    }
  }


  virtual ~AddCustomLineResponse() = default;
};
class AddDnsCacheDomainRequestSourceDnsServer : public Darabonba::Model {
public:
  shared_ptr<string> host{};
  shared_ptr<string> port{};

  AddDnsCacheDomainRequestSourceDnsServer() {}

  explicit AddDnsCacheDomainRequestSourceDnsServer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
  }


  virtual ~AddDnsCacheDomainRequestSourceDnsServer() = default;
};
class AddDnsCacheDomainRequest : public Darabonba::Model {
public:
  shared_ptr<long> cacheTtlMax{};
  shared_ptr<long> cacheTtlMin{};
  shared_ptr<string> domainName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> lang{};
  shared_ptr<string> remark{};
  shared_ptr<vector<AddDnsCacheDomainRequestSourceDnsServer>> sourceDnsServer{};
  shared_ptr<string> sourceEdns{};
  shared_ptr<string> sourceProtocol{};

  AddDnsCacheDomainRequest() {}

  explicit AddDnsCacheDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cacheTtlMax) {
      res["CacheTtlMax"] = boost::any(*cacheTtlMax);
    }
    if (cacheTtlMin) {
      res["CacheTtlMin"] = boost::any(*cacheTtlMin);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (sourceDnsServer) {
      vector<boost::any> temp1;
      for(auto item1:*sourceDnsServer){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SourceDnsServer"] = boost::any(temp1);
    }
    if (sourceEdns) {
      res["SourceEdns"] = boost::any(*sourceEdns);
    }
    if (sourceProtocol) {
      res["SourceProtocol"] = boost::any(*sourceProtocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CacheTtlMax") != m.end() && !m["CacheTtlMax"].empty()) {
      cacheTtlMax = make_shared<long>(boost::any_cast<long>(m["CacheTtlMax"]));
    }
    if (m.find("CacheTtlMin") != m.end() && !m["CacheTtlMin"].empty()) {
      cacheTtlMin = make_shared<long>(boost::any_cast<long>(m["CacheTtlMin"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("SourceDnsServer") != m.end() && !m["SourceDnsServer"].empty()) {
      if (typeid(vector<boost::any>) == m["SourceDnsServer"].type()) {
        vector<AddDnsCacheDomainRequestSourceDnsServer> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SourceDnsServer"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddDnsCacheDomainRequestSourceDnsServer model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sourceDnsServer = make_shared<vector<AddDnsCacheDomainRequestSourceDnsServer>>(expect1);
      }
    }
    if (m.find("SourceEdns") != m.end() && !m["SourceEdns"].empty()) {
      sourceEdns = make_shared<string>(boost::any_cast<string>(m["SourceEdns"]));
    }
    if (m.find("SourceProtocol") != m.end() && !m["SourceProtocol"].empty()) {
      sourceProtocol = make_shared<string>(boost::any_cast<string>(m["SourceProtocol"]));
    }
  }


  virtual ~AddDnsCacheDomainRequest() = default;
};
class AddDnsCacheDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddDnsCacheDomainResponseBody() {}

  explicit AddDnsCacheDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddDnsCacheDomainResponseBody() = default;
};
class AddDnsCacheDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddDnsCacheDomainResponseBody> body{};

  AddDnsCacheDomainResponse() {}

  explicit AddDnsCacheDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddDnsCacheDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddDnsCacheDomainResponseBody>(model1);
      }
    }
  }


  virtual ~AddDnsCacheDomainResponse() = default;
};
class AddDnsGtmAccessStrategyRequestDefaultAddrPool : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<long> lbaWeight{};

  AddDnsGtmAccessStrategyRequestDefaultAddrPool() {}

  explicit AddDnsGtmAccessStrategyRequestDefaultAddrPool(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (lbaWeight) {
      res["LbaWeight"] = boost::any(*lbaWeight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("LbaWeight") != m.end() && !m["LbaWeight"].empty()) {
      lbaWeight = make_shared<long>(boost::any_cast<long>(m["LbaWeight"]));
    }
  }


  virtual ~AddDnsGtmAccessStrategyRequestDefaultAddrPool() = default;
};
class AddDnsGtmAccessStrategyRequestFailoverAddrPool : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<long> lbaWeight{};

  AddDnsGtmAccessStrategyRequestFailoverAddrPool() {}

  explicit AddDnsGtmAccessStrategyRequestFailoverAddrPool(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (lbaWeight) {
      res["LbaWeight"] = boost::any(*lbaWeight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("LbaWeight") != m.end() && !m["LbaWeight"].empty()) {
      lbaWeight = make_shared<long>(boost::any_cast<long>(m["LbaWeight"]));
    }
  }


  virtual ~AddDnsGtmAccessStrategyRequestFailoverAddrPool() = default;
};
class AddDnsGtmAccessStrategyRequest : public Darabonba::Model {
public:
  shared_ptr<vector<AddDnsGtmAccessStrategyRequestDefaultAddrPool>> defaultAddrPool{};
  shared_ptr<string> defaultAddrPoolType{};
  shared_ptr<string> defaultLatencyOptimization{};
  shared_ptr<string> defaultLbaStrategy{};
  shared_ptr<long> defaultMaxReturnAddrNum{};
  shared_ptr<long> defaultMinAvailableAddrNum{};
  shared_ptr<vector<AddDnsGtmAccessStrategyRequestFailoverAddrPool>> failoverAddrPool{};
  shared_ptr<string> failoverAddrPoolType{};
  shared_ptr<string> failoverLatencyOptimization{};
  shared_ptr<string> failoverLbaStrategy{};
  shared_ptr<long> failoverMaxReturnAddrNum{};
  shared_ptr<long> failoverMinAvailableAddrNum{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> lang{};
  shared_ptr<string> lines{};
  shared_ptr<string> strategyMode{};
  shared_ptr<string> strategyName{};

  AddDnsGtmAccessStrategyRequest() {}

  explicit AddDnsGtmAccessStrategyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defaultAddrPool) {
      vector<boost::any> temp1;
      for(auto item1:*defaultAddrPool){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DefaultAddrPool"] = boost::any(temp1);
    }
    if (defaultAddrPoolType) {
      res["DefaultAddrPoolType"] = boost::any(*defaultAddrPoolType);
    }
    if (defaultLatencyOptimization) {
      res["DefaultLatencyOptimization"] = boost::any(*defaultLatencyOptimization);
    }
    if (defaultLbaStrategy) {
      res["DefaultLbaStrategy"] = boost::any(*defaultLbaStrategy);
    }
    if (defaultMaxReturnAddrNum) {
      res["DefaultMaxReturnAddrNum"] = boost::any(*defaultMaxReturnAddrNum);
    }
    if (defaultMinAvailableAddrNum) {
      res["DefaultMinAvailableAddrNum"] = boost::any(*defaultMinAvailableAddrNum);
    }
    if (failoverAddrPool) {
      vector<boost::any> temp1;
      for(auto item1:*failoverAddrPool){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FailoverAddrPool"] = boost::any(temp1);
    }
    if (failoverAddrPoolType) {
      res["FailoverAddrPoolType"] = boost::any(*failoverAddrPoolType);
    }
    if (failoverLatencyOptimization) {
      res["FailoverLatencyOptimization"] = boost::any(*failoverLatencyOptimization);
    }
    if (failoverLbaStrategy) {
      res["FailoverLbaStrategy"] = boost::any(*failoverLbaStrategy);
    }
    if (failoverMaxReturnAddrNum) {
      res["FailoverMaxReturnAddrNum"] = boost::any(*failoverMaxReturnAddrNum);
    }
    if (failoverMinAvailableAddrNum) {
      res["FailoverMinAvailableAddrNum"] = boost::any(*failoverMinAvailableAddrNum);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (lines) {
      res["Lines"] = boost::any(*lines);
    }
    if (strategyMode) {
      res["StrategyMode"] = boost::any(*strategyMode);
    }
    if (strategyName) {
      res["StrategyName"] = boost::any(*strategyName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefaultAddrPool") != m.end() && !m["DefaultAddrPool"].empty()) {
      if (typeid(vector<boost::any>) == m["DefaultAddrPool"].type()) {
        vector<AddDnsGtmAccessStrategyRequestDefaultAddrPool> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DefaultAddrPool"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddDnsGtmAccessStrategyRequestDefaultAddrPool model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        defaultAddrPool = make_shared<vector<AddDnsGtmAccessStrategyRequestDefaultAddrPool>>(expect1);
      }
    }
    if (m.find("DefaultAddrPoolType") != m.end() && !m["DefaultAddrPoolType"].empty()) {
      defaultAddrPoolType = make_shared<string>(boost::any_cast<string>(m["DefaultAddrPoolType"]));
    }
    if (m.find("DefaultLatencyOptimization") != m.end() && !m["DefaultLatencyOptimization"].empty()) {
      defaultLatencyOptimization = make_shared<string>(boost::any_cast<string>(m["DefaultLatencyOptimization"]));
    }
    if (m.find("DefaultLbaStrategy") != m.end() && !m["DefaultLbaStrategy"].empty()) {
      defaultLbaStrategy = make_shared<string>(boost::any_cast<string>(m["DefaultLbaStrategy"]));
    }
    if (m.find("DefaultMaxReturnAddrNum") != m.end() && !m["DefaultMaxReturnAddrNum"].empty()) {
      defaultMaxReturnAddrNum = make_shared<long>(boost::any_cast<long>(m["DefaultMaxReturnAddrNum"]));
    }
    if (m.find("DefaultMinAvailableAddrNum") != m.end() && !m["DefaultMinAvailableAddrNum"].empty()) {
      defaultMinAvailableAddrNum = make_shared<long>(boost::any_cast<long>(m["DefaultMinAvailableAddrNum"]));
    }
    if (m.find("FailoverAddrPool") != m.end() && !m["FailoverAddrPool"].empty()) {
      if (typeid(vector<boost::any>) == m["FailoverAddrPool"].type()) {
        vector<AddDnsGtmAccessStrategyRequestFailoverAddrPool> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FailoverAddrPool"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddDnsGtmAccessStrategyRequestFailoverAddrPool model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        failoverAddrPool = make_shared<vector<AddDnsGtmAccessStrategyRequestFailoverAddrPool>>(expect1);
      }
    }
    if (m.find("FailoverAddrPoolType") != m.end() && !m["FailoverAddrPoolType"].empty()) {
      failoverAddrPoolType = make_shared<string>(boost::any_cast<string>(m["FailoverAddrPoolType"]));
    }
    if (m.find("FailoverLatencyOptimization") != m.end() && !m["FailoverLatencyOptimization"].empty()) {
      failoverLatencyOptimization = make_shared<string>(boost::any_cast<string>(m["FailoverLatencyOptimization"]));
    }
    if (m.find("FailoverLbaStrategy") != m.end() && !m["FailoverLbaStrategy"].empty()) {
      failoverLbaStrategy = make_shared<string>(boost::any_cast<string>(m["FailoverLbaStrategy"]));
    }
    if (m.find("FailoverMaxReturnAddrNum") != m.end() && !m["FailoverMaxReturnAddrNum"].empty()) {
      failoverMaxReturnAddrNum = make_shared<long>(boost::any_cast<long>(m["FailoverMaxReturnAddrNum"]));
    }
    if (m.find("FailoverMinAvailableAddrNum") != m.end() && !m["FailoverMinAvailableAddrNum"].empty()) {
      failoverMinAvailableAddrNum = make_shared<long>(boost::any_cast<long>(m["FailoverMinAvailableAddrNum"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Lines") != m.end() && !m["Lines"].empty()) {
      lines = make_shared<string>(boost::any_cast<string>(m["Lines"]));
    }
    if (m.find("StrategyMode") != m.end() && !m["StrategyMode"].empty()) {
      strategyMode = make_shared<string>(boost::any_cast<string>(m["StrategyMode"]));
    }
    if (m.find("StrategyName") != m.end() && !m["StrategyName"].empty()) {
      strategyName = make_shared<string>(boost::any_cast<string>(m["StrategyName"]));
    }
  }


  virtual ~AddDnsGtmAccessStrategyRequest() = default;
};
class AddDnsGtmAccessStrategyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> strategyId{};

  AddDnsGtmAccessStrategyResponseBody() {}

  explicit AddDnsGtmAccessStrategyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (strategyId) {
      res["StrategyId"] = boost::any(*strategyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StrategyId") != m.end() && !m["StrategyId"].empty()) {
      strategyId = make_shared<string>(boost::any_cast<string>(m["StrategyId"]));
    }
  }


  virtual ~AddDnsGtmAccessStrategyResponseBody() = default;
};
class AddDnsGtmAccessStrategyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddDnsGtmAccessStrategyResponseBody> body{};

  AddDnsGtmAccessStrategyResponse() {}

  explicit AddDnsGtmAccessStrategyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddDnsGtmAccessStrategyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddDnsGtmAccessStrategyResponseBody>(model1);
      }
    }
  }


  virtual ~AddDnsGtmAccessStrategyResponse() = default;
};
class AddDnsGtmAddressPoolRequestAddr : public Darabonba::Model {
public:
  shared_ptr<string> addr{};
  shared_ptr<string> attributeInfo{};
  shared_ptr<long> lbaWeight{};
  shared_ptr<string> mode{};
  shared_ptr<string> remark{};

  AddDnsGtmAddressPoolRequestAddr() {}

  explicit AddDnsGtmAddressPoolRequestAddr(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addr) {
      res["Addr"] = boost::any(*addr);
    }
    if (attributeInfo) {
      res["AttributeInfo"] = boost::any(*attributeInfo);
    }
    if (lbaWeight) {
      res["LbaWeight"] = boost::any(*lbaWeight);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Addr") != m.end() && !m["Addr"].empty()) {
      addr = make_shared<string>(boost::any_cast<string>(m["Addr"]));
    }
    if (m.find("AttributeInfo") != m.end() && !m["AttributeInfo"].empty()) {
      attributeInfo = make_shared<string>(boost::any_cast<string>(m["AttributeInfo"]));
    }
    if (m.find("LbaWeight") != m.end() && !m["LbaWeight"].empty()) {
      lbaWeight = make_shared<long>(boost::any_cast<long>(m["LbaWeight"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
  }


  virtual ~AddDnsGtmAddressPoolRequestAddr() = default;
};
class AddDnsGtmAddressPoolRequestIspCityNode : public Darabonba::Model {
public:
  shared_ptr<string> cityCode{};
  shared_ptr<string> ispCode{};

  AddDnsGtmAddressPoolRequestIspCityNode() {}

  explicit AddDnsGtmAddressPoolRequestIspCityNode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cityCode) {
      res["CityCode"] = boost::any(*cityCode);
    }
    if (ispCode) {
      res["IspCode"] = boost::any(*ispCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CityCode") != m.end() && !m["CityCode"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["CityCode"]));
    }
    if (m.find("IspCode") != m.end() && !m["IspCode"].empty()) {
      ispCode = make_shared<string>(boost::any_cast<string>(m["IspCode"]));
    }
  }


  virtual ~AddDnsGtmAddressPoolRequestIspCityNode() = default;
};
class AddDnsGtmAddressPoolRequest : public Darabonba::Model {
public:
  shared_ptr<vector<AddDnsGtmAddressPoolRequestAddr>> addr{};
  shared_ptr<long> evaluationCount{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> interval{};
  shared_ptr<vector<AddDnsGtmAddressPoolRequestIspCityNode>> ispCityNode{};
  shared_ptr<string> lang{};
  shared_ptr<string> lbaStrategy{};
  shared_ptr<string> monitorExtendInfo{};
  shared_ptr<string> monitorStatus{};
  shared_ptr<string> name{};
  shared_ptr<string> protocolType{};
  shared_ptr<long> timeout{};
  shared_ptr<string> type{};

  AddDnsGtmAddressPoolRequest() {}

  explicit AddDnsGtmAddressPoolRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addr) {
      vector<boost::any> temp1;
      for(auto item1:*addr){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Addr"] = boost::any(temp1);
    }
    if (evaluationCount) {
      res["EvaluationCount"] = boost::any(*evaluationCount);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ispCityNode) {
      vector<boost::any> temp1;
      for(auto item1:*ispCityNode){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IspCityNode"] = boost::any(temp1);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (lbaStrategy) {
      res["LbaStrategy"] = boost::any(*lbaStrategy);
    }
    if (monitorExtendInfo) {
      res["MonitorExtendInfo"] = boost::any(*monitorExtendInfo);
    }
    if (monitorStatus) {
      res["MonitorStatus"] = boost::any(*monitorStatus);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (protocolType) {
      res["ProtocolType"] = boost::any(*protocolType);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Addr") != m.end() && !m["Addr"].empty()) {
      if (typeid(vector<boost::any>) == m["Addr"].type()) {
        vector<AddDnsGtmAddressPoolRequestAddr> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Addr"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddDnsGtmAddressPoolRequestAddr model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        addr = make_shared<vector<AddDnsGtmAddressPoolRequestAddr>>(expect1);
      }
    }
    if (m.find("EvaluationCount") != m.end() && !m["EvaluationCount"].empty()) {
      evaluationCount = make_shared<long>(boost::any_cast<long>(m["EvaluationCount"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("IspCityNode") != m.end() && !m["IspCityNode"].empty()) {
      if (typeid(vector<boost::any>) == m["IspCityNode"].type()) {
        vector<AddDnsGtmAddressPoolRequestIspCityNode> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IspCityNode"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddDnsGtmAddressPoolRequestIspCityNode model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ispCityNode = make_shared<vector<AddDnsGtmAddressPoolRequestIspCityNode>>(expect1);
      }
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("LbaStrategy") != m.end() && !m["LbaStrategy"].empty()) {
      lbaStrategy = make_shared<string>(boost::any_cast<string>(m["LbaStrategy"]));
    }
    if (m.find("MonitorExtendInfo") != m.end() && !m["MonitorExtendInfo"].empty()) {
      monitorExtendInfo = make_shared<string>(boost::any_cast<string>(m["MonitorExtendInfo"]));
    }
    if (m.find("MonitorStatus") != m.end() && !m["MonitorStatus"].empty()) {
      monitorStatus = make_shared<string>(boost::any_cast<string>(m["MonitorStatus"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProtocolType") != m.end() && !m["ProtocolType"].empty()) {
      protocolType = make_shared<string>(boost::any_cast<string>(m["ProtocolType"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~AddDnsGtmAddressPoolRequest() = default;
};
class AddDnsGtmAddressPoolResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> addrPoolId{};
  shared_ptr<string> monitorConfigId{};
  shared_ptr<string> requestId{};

  AddDnsGtmAddressPoolResponseBody() {}

  explicit AddDnsGtmAddressPoolResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addrPoolId) {
      res["AddrPoolId"] = boost::any(*addrPoolId);
    }
    if (monitorConfigId) {
      res["MonitorConfigId"] = boost::any(*monitorConfigId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddrPoolId") != m.end() && !m["AddrPoolId"].empty()) {
      addrPoolId = make_shared<string>(boost::any_cast<string>(m["AddrPoolId"]));
    }
    if (m.find("MonitorConfigId") != m.end() && !m["MonitorConfigId"].empty()) {
      monitorConfigId = make_shared<string>(boost::any_cast<string>(m["MonitorConfigId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddDnsGtmAddressPoolResponseBody() = default;
};
class AddDnsGtmAddressPoolResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddDnsGtmAddressPoolResponseBody> body{};

  AddDnsGtmAddressPoolResponse() {}

  explicit AddDnsGtmAddressPoolResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddDnsGtmAddressPoolResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddDnsGtmAddressPoolResponseBody>(model1);
      }
    }
  }


  virtual ~AddDnsGtmAddressPoolResponse() = default;
};
class AddDnsGtmMonitorRequestIspCityNode : public Darabonba::Model {
public:
  shared_ptr<string> cityCode{};
  shared_ptr<string> ispCode{};

  AddDnsGtmMonitorRequestIspCityNode() {}

  explicit AddDnsGtmMonitorRequestIspCityNode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cityCode) {
      res["CityCode"] = boost::any(*cityCode);
    }
    if (ispCode) {
      res["IspCode"] = boost::any(*ispCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CityCode") != m.end() && !m["CityCode"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["CityCode"]));
    }
    if (m.find("IspCode") != m.end() && !m["IspCode"].empty()) {
      ispCode = make_shared<string>(boost::any_cast<string>(m["IspCode"]));
    }
  }


  virtual ~AddDnsGtmMonitorRequestIspCityNode() = default;
};
class AddDnsGtmMonitorRequest : public Darabonba::Model {
public:
  shared_ptr<string> addrPoolId{};
  shared_ptr<long> evaluationCount{};
  shared_ptr<long> interval{};
  shared_ptr<vector<AddDnsGtmMonitorRequestIspCityNode>> ispCityNode{};
  shared_ptr<string> lang{};
  shared_ptr<string> monitorExtendInfo{};
  shared_ptr<string> protocolType{};
  shared_ptr<long> timeout{};

  AddDnsGtmMonitorRequest() {}

  explicit AddDnsGtmMonitorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addrPoolId) {
      res["AddrPoolId"] = boost::any(*addrPoolId);
    }
    if (evaluationCount) {
      res["EvaluationCount"] = boost::any(*evaluationCount);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ispCityNode) {
      vector<boost::any> temp1;
      for(auto item1:*ispCityNode){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IspCityNode"] = boost::any(temp1);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (monitorExtendInfo) {
      res["MonitorExtendInfo"] = boost::any(*monitorExtendInfo);
    }
    if (protocolType) {
      res["ProtocolType"] = boost::any(*protocolType);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddrPoolId") != m.end() && !m["AddrPoolId"].empty()) {
      addrPoolId = make_shared<string>(boost::any_cast<string>(m["AddrPoolId"]));
    }
    if (m.find("EvaluationCount") != m.end() && !m["EvaluationCount"].empty()) {
      evaluationCount = make_shared<long>(boost::any_cast<long>(m["EvaluationCount"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("IspCityNode") != m.end() && !m["IspCityNode"].empty()) {
      if (typeid(vector<boost::any>) == m["IspCityNode"].type()) {
        vector<AddDnsGtmMonitorRequestIspCityNode> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IspCityNode"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddDnsGtmMonitorRequestIspCityNode model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ispCityNode = make_shared<vector<AddDnsGtmMonitorRequestIspCityNode>>(expect1);
      }
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("MonitorExtendInfo") != m.end() && !m["MonitorExtendInfo"].empty()) {
      monitorExtendInfo = make_shared<string>(boost::any_cast<string>(m["MonitorExtendInfo"]));
    }
    if (m.find("ProtocolType") != m.end() && !m["ProtocolType"].empty()) {
      protocolType = make_shared<string>(boost::any_cast<string>(m["ProtocolType"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
  }


  virtual ~AddDnsGtmMonitorRequest() = default;
};
class AddDnsGtmMonitorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> monitorConfigId{};
  shared_ptr<string> requestId{};

  AddDnsGtmMonitorResponseBody() {}

  explicit AddDnsGtmMonitorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (monitorConfigId) {
      res["MonitorConfigId"] = boost::any(*monitorConfigId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MonitorConfigId") != m.end() && !m["MonitorConfigId"].empty()) {
      monitorConfigId = make_shared<string>(boost::any_cast<string>(m["MonitorConfigId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddDnsGtmMonitorResponseBody() = default;
};
class AddDnsGtmMonitorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddDnsGtmMonitorResponseBody> body{};

  AddDnsGtmMonitorResponse() {}

  explicit AddDnsGtmMonitorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddDnsGtmMonitorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddDnsGtmMonitorResponseBody>(model1);
      }
    }
  }


  virtual ~AddDnsGtmMonitorResponse() = default;
};
class AddDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> groupId{};
  shared_ptr<string> lang{};
  shared_ptr<string> resourceGroupId{};

  AddDomainRequest() {}

  explicit AddDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~AddDomainRequest() = default;
};
class AddDomainResponseBodyDnsServers : public Darabonba::Model {
public:
  shared_ptr<vector<string>> dnsServer{};

  AddDomainResponseBodyDnsServers() {}

  explicit AddDomainResponseBodyDnsServers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dnsServer) {
      res["DnsServer"] = boost::any(*dnsServer);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DnsServer") != m.end() && !m["DnsServer"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DnsServer"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DnsServer"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dnsServer = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~AddDomainResponseBodyDnsServers() = default;
};
class AddDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<AddDomainResponseBodyDnsServers> dnsServers{};
  shared_ptr<string> domainId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> punyCode{};
  shared_ptr<string> requestId{};

  AddDomainResponseBody() {}

  explicit AddDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dnsServers) {
      res["DnsServers"] = dnsServers ? boost::any(dnsServers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (domainId) {
      res["DomainId"] = boost::any(*domainId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (punyCode) {
      res["PunyCode"] = boost::any(*punyCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DnsServers") != m.end() && !m["DnsServers"].empty()) {
      if (typeid(map<string, boost::any>) == m["DnsServers"].type()) {
        AddDomainResponseBodyDnsServers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DnsServers"]));
        dnsServers = make_shared<AddDomainResponseBodyDnsServers>(model1);
      }
    }
    if (m.find("DomainId") != m.end() && !m["DomainId"].empty()) {
      domainId = make_shared<string>(boost::any_cast<string>(m["DomainId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("PunyCode") != m.end() && !m["PunyCode"].empty()) {
      punyCode = make_shared<string>(boost::any_cast<string>(m["PunyCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddDomainResponseBody() = default;
};
class AddDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddDomainResponseBody> body{};

  AddDomainResponse() {}

  explicit AddDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddDomainResponseBody>(model1);
      }
    }
  }


  virtual ~AddDomainResponse() = default;
};
class AddDomainBackupRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> lang{};
  shared_ptr<string> periodType{};

  AddDomainBackupRequest() {}

  explicit AddDomainBackupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (periodType) {
      res["PeriodType"] = boost::any(*periodType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PeriodType") != m.end() && !m["PeriodType"].empty()) {
      periodType = make_shared<string>(boost::any_cast<string>(m["PeriodType"]));
    }
  }


  virtual ~AddDomainBackupRequest() = default;
};
class AddDomainBackupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> periodType{};
  shared_ptr<string> requestId{};

  AddDomainBackupResponseBody() {}

  explicit AddDomainBackupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (periodType) {
      res["PeriodType"] = boost::any(*periodType);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("PeriodType") != m.end() && !m["PeriodType"].empty()) {
      periodType = make_shared<string>(boost::any_cast<string>(m["PeriodType"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddDomainBackupResponseBody() = default;
};
class AddDomainBackupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddDomainBackupResponseBody> body{};

  AddDomainBackupResponse() {}

  explicit AddDomainBackupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddDomainBackupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddDomainBackupResponseBody>(model1);
      }
    }
  }


  virtual ~AddDomainBackupResponse() = default;
};
class AddDomainGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupName{};
  shared_ptr<string> lang{};

  AddDomainGroupRequest() {}

  explicit AddDomainGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~AddDomainGroupRequest() = default;
};
class AddDomainGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> requestId{};

  AddDomainGroupResponseBody() {}

  explicit AddDomainGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddDomainGroupResponseBody() = default;
};
class AddDomainGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddDomainGroupResponseBody> body{};

  AddDomainGroupResponse() {}

  explicit AddDomainGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddDomainGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddDomainGroupResponseBody>(model1);
      }
    }
  }


  virtual ~AddDomainGroupResponse() = default;
};
class AddDomainRecordRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> lang{};
  shared_ptr<string> line{};
  shared_ptr<long> priority{};
  shared_ptr<string> RR{};
  shared_ptr<long> TTL{};
  shared_ptr<string> type{};
  shared_ptr<string> userClientIp{};
  shared_ptr<string> value{};

  AddDomainRecordRequest() {}

  explicit AddDomainRecordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (line) {
      res["Line"] = boost::any(*line);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (RR) {
      res["RR"] = boost::any(*RR);
    }
    if (TTL) {
      res["TTL"] = boost::any(*TTL);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (userClientIp) {
      res["UserClientIp"] = boost::any(*userClientIp);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Line") != m.end() && !m["Line"].empty()) {
      line = make_shared<string>(boost::any_cast<string>(m["Line"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("RR") != m.end() && !m["RR"].empty()) {
      RR = make_shared<string>(boost::any_cast<string>(m["RR"]));
    }
    if (m.find("TTL") != m.end() && !m["TTL"].empty()) {
      TTL = make_shared<long>(boost::any_cast<long>(m["TTL"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UserClientIp") != m.end() && !m["UserClientIp"].empty()) {
      userClientIp = make_shared<string>(boost::any_cast<string>(m["UserClientIp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~AddDomainRecordRequest() = default;
};
class AddDomainRecordResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> recordId{};
  shared_ptr<string> requestId{};

  AddDomainRecordResponseBody() {}

  explicit AddDomainRecordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<string>(boost::any_cast<string>(m["RecordId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddDomainRecordResponseBody() = default;
};
class AddDomainRecordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddDomainRecordResponseBody> body{};

  AddDomainRecordResponse() {}

  explicit AddDomainRecordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddDomainRecordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddDomainRecordResponseBody>(model1);
      }
    }
  }


  virtual ~AddDomainRecordResponse() = default;
};
class AddGtmAccessStrategyRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessLines{};
  shared_ptr<string> defaultAddrPoolId{};
  shared_ptr<string> failoverAddrPoolId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> lang{};
  shared_ptr<string> strategyName{};

  AddGtmAccessStrategyRequest() {}

  explicit AddGtmAccessStrategyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessLines) {
      res["AccessLines"] = boost::any(*accessLines);
    }
    if (defaultAddrPoolId) {
      res["DefaultAddrPoolId"] = boost::any(*defaultAddrPoolId);
    }
    if (failoverAddrPoolId) {
      res["FailoverAddrPoolId"] = boost::any(*failoverAddrPoolId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (strategyName) {
      res["StrategyName"] = boost::any(*strategyName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessLines") != m.end() && !m["AccessLines"].empty()) {
      accessLines = make_shared<string>(boost::any_cast<string>(m["AccessLines"]));
    }
    if (m.find("DefaultAddrPoolId") != m.end() && !m["DefaultAddrPoolId"].empty()) {
      defaultAddrPoolId = make_shared<string>(boost::any_cast<string>(m["DefaultAddrPoolId"]));
    }
    if (m.find("FailoverAddrPoolId") != m.end() && !m["FailoverAddrPoolId"].empty()) {
      failoverAddrPoolId = make_shared<string>(boost::any_cast<string>(m["FailoverAddrPoolId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("StrategyName") != m.end() && !m["StrategyName"].empty()) {
      strategyName = make_shared<string>(boost::any_cast<string>(m["StrategyName"]));
    }
  }


  virtual ~AddGtmAccessStrategyRequest() = default;
};
class AddGtmAccessStrategyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> strategyId{};

  AddGtmAccessStrategyResponseBody() {}

  explicit AddGtmAccessStrategyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (strategyId) {
      res["StrategyId"] = boost::any(*strategyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StrategyId") != m.end() && !m["StrategyId"].empty()) {
      strategyId = make_shared<string>(boost::any_cast<string>(m["StrategyId"]));
    }
  }


  virtual ~AddGtmAccessStrategyResponseBody() = default;
};
class AddGtmAccessStrategyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddGtmAccessStrategyResponseBody> body{};

  AddGtmAccessStrategyResponse() {}

  explicit AddGtmAccessStrategyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddGtmAccessStrategyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddGtmAccessStrategyResponseBody>(model1);
      }
    }
  }


  virtual ~AddGtmAccessStrategyResponse() = default;
};
class AddGtmAddressPoolRequestAddr : public Darabonba::Model {
public:
  shared_ptr<long> lbaWeight{};
  shared_ptr<string> mode{};
  shared_ptr<string> value{};

  AddGtmAddressPoolRequestAddr() {}

  explicit AddGtmAddressPoolRequestAddr(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lbaWeight) {
      res["LbaWeight"] = boost::any(*lbaWeight);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LbaWeight") != m.end() && !m["LbaWeight"].empty()) {
      lbaWeight = make_shared<long>(boost::any_cast<long>(m["LbaWeight"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~AddGtmAddressPoolRequestAddr() = default;
};
class AddGtmAddressPoolRequestIspCityNode : public Darabonba::Model {
public:
  shared_ptr<string> cityCode{};
  shared_ptr<string> ispCode{};

  AddGtmAddressPoolRequestIspCityNode() {}

  explicit AddGtmAddressPoolRequestIspCityNode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cityCode) {
      res["CityCode"] = boost::any(*cityCode);
    }
    if (ispCode) {
      res["IspCode"] = boost::any(*ispCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CityCode") != m.end() && !m["CityCode"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["CityCode"]));
    }
    if (m.find("IspCode") != m.end() && !m["IspCode"].empty()) {
      ispCode = make_shared<string>(boost::any_cast<string>(m["IspCode"]));
    }
  }


  virtual ~AddGtmAddressPoolRequestIspCityNode() = default;
};
class AddGtmAddressPoolRequest : public Darabonba::Model {
public:
  shared_ptr<vector<AddGtmAddressPoolRequestAddr>> addr{};
  shared_ptr<long> evaluationCount{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> interval{};
  shared_ptr<vector<AddGtmAddressPoolRequestIspCityNode>> ispCityNode{};
  shared_ptr<string> lang{};
  shared_ptr<long> minAvailableAddrNum{};
  shared_ptr<string> monitorExtendInfo{};
  shared_ptr<string> monitorStatus{};
  shared_ptr<string> name{};
  shared_ptr<string> protocolType{};
  shared_ptr<long> timeout{};
  shared_ptr<string> type{};

  AddGtmAddressPoolRequest() {}

  explicit AddGtmAddressPoolRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addr) {
      vector<boost::any> temp1;
      for(auto item1:*addr){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Addr"] = boost::any(temp1);
    }
    if (evaluationCount) {
      res["EvaluationCount"] = boost::any(*evaluationCount);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ispCityNode) {
      vector<boost::any> temp1;
      for(auto item1:*ispCityNode){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IspCityNode"] = boost::any(temp1);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (minAvailableAddrNum) {
      res["MinAvailableAddrNum"] = boost::any(*minAvailableAddrNum);
    }
    if (monitorExtendInfo) {
      res["MonitorExtendInfo"] = boost::any(*monitorExtendInfo);
    }
    if (monitorStatus) {
      res["MonitorStatus"] = boost::any(*monitorStatus);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (protocolType) {
      res["ProtocolType"] = boost::any(*protocolType);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Addr") != m.end() && !m["Addr"].empty()) {
      if (typeid(vector<boost::any>) == m["Addr"].type()) {
        vector<AddGtmAddressPoolRequestAddr> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Addr"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddGtmAddressPoolRequestAddr model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        addr = make_shared<vector<AddGtmAddressPoolRequestAddr>>(expect1);
      }
    }
    if (m.find("EvaluationCount") != m.end() && !m["EvaluationCount"].empty()) {
      evaluationCount = make_shared<long>(boost::any_cast<long>(m["EvaluationCount"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("IspCityNode") != m.end() && !m["IspCityNode"].empty()) {
      if (typeid(vector<boost::any>) == m["IspCityNode"].type()) {
        vector<AddGtmAddressPoolRequestIspCityNode> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IspCityNode"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddGtmAddressPoolRequestIspCityNode model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ispCityNode = make_shared<vector<AddGtmAddressPoolRequestIspCityNode>>(expect1);
      }
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("MinAvailableAddrNum") != m.end() && !m["MinAvailableAddrNum"].empty()) {
      minAvailableAddrNum = make_shared<long>(boost::any_cast<long>(m["MinAvailableAddrNum"]));
    }
    if (m.find("MonitorExtendInfo") != m.end() && !m["MonitorExtendInfo"].empty()) {
      monitorExtendInfo = make_shared<string>(boost::any_cast<string>(m["MonitorExtendInfo"]));
    }
    if (m.find("MonitorStatus") != m.end() && !m["MonitorStatus"].empty()) {
      monitorStatus = make_shared<string>(boost::any_cast<string>(m["MonitorStatus"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProtocolType") != m.end() && !m["ProtocolType"].empty()) {
      protocolType = make_shared<string>(boost::any_cast<string>(m["ProtocolType"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~AddGtmAddressPoolRequest() = default;
};
class AddGtmAddressPoolResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> addrPoolId{};
  shared_ptr<string> monitorConfigId{};
  shared_ptr<string> requestId{};

  AddGtmAddressPoolResponseBody() {}

  explicit AddGtmAddressPoolResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addrPoolId) {
      res["AddrPoolId"] = boost::any(*addrPoolId);
    }
    if (monitorConfigId) {
      res["MonitorConfigId"] = boost::any(*monitorConfigId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddrPoolId") != m.end() && !m["AddrPoolId"].empty()) {
      addrPoolId = make_shared<string>(boost::any_cast<string>(m["AddrPoolId"]));
    }
    if (m.find("MonitorConfigId") != m.end() && !m["MonitorConfigId"].empty()) {
      monitorConfigId = make_shared<string>(boost::any_cast<string>(m["MonitorConfigId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddGtmAddressPoolResponseBody() = default;
};
class AddGtmAddressPoolResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddGtmAddressPoolResponseBody> body{};

  AddGtmAddressPoolResponse() {}

  explicit AddGtmAddressPoolResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddGtmAddressPoolResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddGtmAddressPoolResponseBody>(model1);
      }
    }
  }


  virtual ~AddGtmAddressPoolResponse() = default;
};
class AddGtmMonitorRequestIspCityNode : public Darabonba::Model {
public:
  shared_ptr<string> cityCode{};
  shared_ptr<string> ispCode{};

  AddGtmMonitorRequestIspCityNode() {}

  explicit AddGtmMonitorRequestIspCityNode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cityCode) {
      res["CityCode"] = boost::any(*cityCode);
    }
    if (ispCode) {
      res["IspCode"] = boost::any(*ispCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CityCode") != m.end() && !m["CityCode"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["CityCode"]));
    }
    if (m.find("IspCode") != m.end() && !m["IspCode"].empty()) {
      ispCode = make_shared<string>(boost::any_cast<string>(m["IspCode"]));
    }
  }


  virtual ~AddGtmMonitorRequestIspCityNode() = default;
};
class AddGtmMonitorRequest : public Darabonba::Model {
public:
  shared_ptr<string> addrPoolId{};
  shared_ptr<long> evaluationCount{};
  shared_ptr<long> interval{};
  shared_ptr<vector<AddGtmMonitorRequestIspCityNode>> ispCityNode{};
  shared_ptr<string> lang{};
  shared_ptr<string> monitorExtendInfo{};
  shared_ptr<string> protocolType{};
  shared_ptr<long> timeout{};

  AddGtmMonitorRequest() {}

  explicit AddGtmMonitorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addrPoolId) {
      res["AddrPoolId"] = boost::any(*addrPoolId);
    }
    if (evaluationCount) {
      res["EvaluationCount"] = boost::any(*evaluationCount);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ispCityNode) {
      vector<boost::any> temp1;
      for(auto item1:*ispCityNode){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IspCityNode"] = boost::any(temp1);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (monitorExtendInfo) {
      res["MonitorExtendInfo"] = boost::any(*monitorExtendInfo);
    }
    if (protocolType) {
      res["ProtocolType"] = boost::any(*protocolType);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddrPoolId") != m.end() && !m["AddrPoolId"].empty()) {
      addrPoolId = make_shared<string>(boost::any_cast<string>(m["AddrPoolId"]));
    }
    if (m.find("EvaluationCount") != m.end() && !m["EvaluationCount"].empty()) {
      evaluationCount = make_shared<long>(boost::any_cast<long>(m["EvaluationCount"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("IspCityNode") != m.end() && !m["IspCityNode"].empty()) {
      if (typeid(vector<boost::any>) == m["IspCityNode"].type()) {
        vector<AddGtmMonitorRequestIspCityNode> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IspCityNode"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddGtmMonitorRequestIspCityNode model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ispCityNode = make_shared<vector<AddGtmMonitorRequestIspCityNode>>(expect1);
      }
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("MonitorExtendInfo") != m.end() && !m["MonitorExtendInfo"].empty()) {
      monitorExtendInfo = make_shared<string>(boost::any_cast<string>(m["MonitorExtendInfo"]));
    }
    if (m.find("ProtocolType") != m.end() && !m["ProtocolType"].empty()) {
      protocolType = make_shared<string>(boost::any_cast<string>(m["ProtocolType"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
  }


  virtual ~AddGtmMonitorRequest() = default;
};
class AddGtmMonitorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> monitorConfigId{};
  shared_ptr<string> requestId{};

  AddGtmMonitorResponseBody() {}

  explicit AddGtmMonitorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (monitorConfigId) {
      res["MonitorConfigId"] = boost::any(*monitorConfigId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MonitorConfigId") != m.end() && !m["MonitorConfigId"].empty()) {
      monitorConfigId = make_shared<string>(boost::any_cast<string>(m["MonitorConfigId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddGtmMonitorResponseBody() = default;
};
class AddGtmMonitorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddGtmMonitorResponseBody> body{};

  AddGtmMonitorResponse() {}

  explicit AddGtmMonitorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddGtmMonitorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddGtmMonitorResponseBody>(model1);
      }
    }
  }


  virtual ~AddGtmMonitorResponse() = default;
};
class AddGtmRecoveryPlanRequest : public Darabonba::Model {
public:
  shared_ptr<string> faultAddrPool{};
  shared_ptr<string> lang{};
  shared_ptr<string> name{};
  shared_ptr<string> remark{};

  AddGtmRecoveryPlanRequest() {}

  explicit AddGtmRecoveryPlanRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (faultAddrPool) {
      res["FaultAddrPool"] = boost::any(*faultAddrPool);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FaultAddrPool") != m.end() && !m["FaultAddrPool"].empty()) {
      faultAddrPool = make_shared<string>(boost::any_cast<string>(m["FaultAddrPool"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
  }


  virtual ~AddGtmRecoveryPlanRequest() = default;
};
class AddGtmRecoveryPlanResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> recoveryPlanId{};
  shared_ptr<string> requestId{};

  AddGtmRecoveryPlanResponseBody() {}

  explicit AddGtmRecoveryPlanResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recoveryPlanId) {
      res["RecoveryPlanId"] = boost::any(*recoveryPlanId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecoveryPlanId") != m.end() && !m["RecoveryPlanId"].empty()) {
      recoveryPlanId = make_shared<string>(boost::any_cast<string>(m["RecoveryPlanId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddGtmRecoveryPlanResponseBody() = default;
};
class AddGtmRecoveryPlanResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddGtmRecoveryPlanResponseBody> body{};

  AddGtmRecoveryPlanResponse() {}

  explicit AddGtmRecoveryPlanResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddGtmRecoveryPlanResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddGtmRecoveryPlanResponseBody>(model1);
      }
    }
  }


  virtual ~AddGtmRecoveryPlanResponse() = default;
};
class BindInstanceDomainsRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainNames{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> lang{};

  BindInstanceDomainsRequest() {}

  explicit BindInstanceDomainsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainNames) {
      res["DomainNames"] = boost::any(*domainNames);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainNames") != m.end() && !m["DomainNames"].empty()) {
      domainNames = make_shared<string>(boost::any_cast<string>(m["DomainNames"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~BindInstanceDomainsRequest() = default;
};
class BindInstanceDomainsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> failedCount{};
  shared_ptr<string> requestId{};
  shared_ptr<long> successCount{};

  BindInstanceDomainsResponseBody() {}

  explicit BindInstanceDomainsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failedCount) {
      res["FailedCount"] = boost::any(*failedCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (successCount) {
      res["SuccessCount"] = boost::any(*successCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailedCount") != m.end() && !m["FailedCount"].empty()) {
      failedCount = make_shared<long>(boost::any_cast<long>(m["FailedCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SuccessCount") != m.end() && !m["SuccessCount"].empty()) {
      successCount = make_shared<long>(boost::any_cast<long>(m["SuccessCount"]));
    }
  }


  virtual ~BindInstanceDomainsResponseBody() = default;
};
class BindInstanceDomainsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BindInstanceDomainsResponseBody> body{};

  BindInstanceDomainsResponse() {}

  explicit BindInstanceDomainsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BindInstanceDomainsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BindInstanceDomainsResponseBody>(model1);
      }
    }
  }


  virtual ~BindInstanceDomainsResponse() = default;
};
class ChangeDomainGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> groupId{};
  shared_ptr<string> lang{};

  ChangeDomainGroupRequest() {}

  explicit ChangeDomainGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~ChangeDomainGroupRequest() = default;
};
class ChangeDomainGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> requestId{};

  ChangeDomainGroupResponseBody() {}

  explicit ChangeDomainGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ChangeDomainGroupResponseBody() = default;
};
class ChangeDomainGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ChangeDomainGroupResponseBody> body{};

  ChangeDomainGroupResponse() {}

  explicit ChangeDomainGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ChangeDomainGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ChangeDomainGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ChangeDomainGroupResponse() = default;
};
class ChangeDomainOfDnsProductRequest : public Darabonba::Model {
public:
  shared_ptr<bool> force{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> lang{};
  shared_ptr<string> newDomain{};
  shared_ptr<string> userClientIp{};

  ChangeDomainOfDnsProductRequest() {}

  explicit ChangeDomainOfDnsProductRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (force) {
      res["Force"] = boost::any(*force);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (newDomain) {
      res["NewDomain"] = boost::any(*newDomain);
    }
    if (userClientIp) {
      res["UserClientIp"] = boost::any(*userClientIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Force") != m.end() && !m["Force"].empty()) {
      force = make_shared<bool>(boost::any_cast<bool>(m["Force"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("NewDomain") != m.end() && !m["NewDomain"].empty()) {
      newDomain = make_shared<string>(boost::any_cast<string>(m["NewDomain"]));
    }
    if (m.find("UserClientIp") != m.end() && !m["UserClientIp"].empty()) {
      userClientIp = make_shared<string>(boost::any_cast<string>(m["UserClientIp"]));
    }
  }


  virtual ~ChangeDomainOfDnsProductRequest() = default;
};
class ChangeDomainOfDnsProductResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> originalDomain{};
  shared_ptr<string> requestId{};

  ChangeDomainOfDnsProductResponseBody() {}

  explicit ChangeDomainOfDnsProductResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (originalDomain) {
      res["OriginalDomain"] = boost::any(*originalDomain);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OriginalDomain") != m.end() && !m["OriginalDomain"].empty()) {
      originalDomain = make_shared<string>(boost::any_cast<string>(m["OriginalDomain"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ChangeDomainOfDnsProductResponseBody() = default;
};
class ChangeDomainOfDnsProductResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ChangeDomainOfDnsProductResponseBody> body{};

  ChangeDomainOfDnsProductResponse() {}

  explicit ChangeDomainOfDnsProductResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ChangeDomainOfDnsProductResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ChangeDomainOfDnsProductResponseBody>(model1);
      }
    }
  }


  virtual ~ChangeDomainOfDnsProductResponse() = default;
};
class CopyGtmConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> copyType{};
  shared_ptr<string> lang{};
  shared_ptr<string> sourceId{};
  shared_ptr<string> targetId{};

  CopyGtmConfigRequest() {}

  explicit CopyGtmConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (copyType) {
      res["CopyType"] = boost::any(*copyType);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (sourceId) {
      res["SourceId"] = boost::any(*sourceId);
    }
    if (targetId) {
      res["TargetId"] = boost::any(*targetId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CopyType") != m.end() && !m["CopyType"].empty()) {
      copyType = make_shared<string>(boost::any_cast<string>(m["CopyType"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("SourceId") != m.end() && !m["SourceId"].empty()) {
      sourceId = make_shared<string>(boost::any_cast<string>(m["SourceId"]));
    }
    if (m.find("TargetId") != m.end() && !m["TargetId"].empty()) {
      targetId = make_shared<string>(boost::any_cast<string>(m["TargetId"]));
    }
  }


  virtual ~CopyGtmConfigRequest() = default;
};
class CopyGtmConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CopyGtmConfigResponseBody() {}

  explicit CopyGtmConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CopyGtmConfigResponseBody() = default;
};
class CopyGtmConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CopyGtmConfigResponseBody> body{};

  CopyGtmConfigResponse() {}

  explicit CopyGtmConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CopyGtmConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CopyGtmConfigResponseBody>(model1);
      }
    }
  }


  virtual ~CopyGtmConfigResponse() = default;
};
class CreateCloudGtmAddressRequestHealthTasks : public Darabonba::Model {
public:
  shared_ptr<long> port{};
  shared_ptr<string> templateId{};

  CreateCloudGtmAddressRequestHealthTasks() {}

  explicit CreateCloudGtmAddressRequestHealthTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~CreateCloudGtmAddressRequestHealthTasks() = default;
};
class CreateCloudGtmAddressRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> address{};
  shared_ptr<string> attributeInfo{};
  shared_ptr<string> availableMode{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> enableStatus{};
  shared_ptr<string> healthJudgement{};
  shared_ptr<vector<CreateCloudGtmAddressRequestHealthTasks>> healthTasks{};
  shared_ptr<string> manualAvailableStatus{};
  shared_ptr<string> name{};
  shared_ptr<string> remark{};
  shared_ptr<string> type{};

  CreateCloudGtmAddressRequest() {}

  explicit CreateCloudGtmAddressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (attributeInfo) {
      res["AttributeInfo"] = boost::any(*attributeInfo);
    }
    if (availableMode) {
      res["AvailableMode"] = boost::any(*availableMode);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (enableStatus) {
      res["EnableStatus"] = boost::any(*enableStatus);
    }
    if (healthJudgement) {
      res["HealthJudgement"] = boost::any(*healthJudgement);
    }
    if (healthTasks) {
      vector<boost::any> temp1;
      for(auto item1:*healthTasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HealthTasks"] = boost::any(temp1);
    }
    if (manualAvailableStatus) {
      res["ManualAvailableStatus"] = boost::any(*manualAvailableStatus);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("AttributeInfo") != m.end() && !m["AttributeInfo"].empty()) {
      attributeInfo = make_shared<string>(boost::any_cast<string>(m["AttributeInfo"]));
    }
    if (m.find("AvailableMode") != m.end() && !m["AvailableMode"].empty()) {
      availableMode = make_shared<string>(boost::any_cast<string>(m["AvailableMode"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("EnableStatus") != m.end() && !m["EnableStatus"].empty()) {
      enableStatus = make_shared<string>(boost::any_cast<string>(m["EnableStatus"]));
    }
    if (m.find("HealthJudgement") != m.end() && !m["HealthJudgement"].empty()) {
      healthJudgement = make_shared<string>(boost::any_cast<string>(m["HealthJudgement"]));
    }
    if (m.find("HealthTasks") != m.end() && !m["HealthTasks"].empty()) {
      if (typeid(vector<boost::any>) == m["HealthTasks"].type()) {
        vector<CreateCloudGtmAddressRequestHealthTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HealthTasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateCloudGtmAddressRequestHealthTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        healthTasks = make_shared<vector<CreateCloudGtmAddressRequestHealthTasks>>(expect1);
      }
    }
    if (m.find("ManualAvailableStatus") != m.end() && !m["ManualAvailableStatus"].empty()) {
      manualAvailableStatus = make_shared<string>(boost::any_cast<string>(m["ManualAvailableStatus"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateCloudGtmAddressRequest() = default;
};
class CreateCloudGtmAddressShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> address{};
  shared_ptr<string> attributeInfo{};
  shared_ptr<string> availableMode{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> enableStatus{};
  shared_ptr<string> healthJudgement{};
  shared_ptr<string> healthTasksShrink{};
  shared_ptr<string> manualAvailableStatus{};
  shared_ptr<string> name{};
  shared_ptr<string> remark{};
  shared_ptr<string> type{};

  CreateCloudGtmAddressShrinkRequest() {}

  explicit CreateCloudGtmAddressShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (attributeInfo) {
      res["AttributeInfo"] = boost::any(*attributeInfo);
    }
    if (availableMode) {
      res["AvailableMode"] = boost::any(*availableMode);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (enableStatus) {
      res["EnableStatus"] = boost::any(*enableStatus);
    }
    if (healthJudgement) {
      res["HealthJudgement"] = boost::any(*healthJudgement);
    }
    if (healthTasksShrink) {
      res["HealthTasks"] = boost::any(*healthTasksShrink);
    }
    if (manualAvailableStatus) {
      res["ManualAvailableStatus"] = boost::any(*manualAvailableStatus);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("AttributeInfo") != m.end() && !m["AttributeInfo"].empty()) {
      attributeInfo = make_shared<string>(boost::any_cast<string>(m["AttributeInfo"]));
    }
    if (m.find("AvailableMode") != m.end() && !m["AvailableMode"].empty()) {
      availableMode = make_shared<string>(boost::any_cast<string>(m["AvailableMode"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("EnableStatus") != m.end() && !m["EnableStatus"].empty()) {
      enableStatus = make_shared<string>(boost::any_cast<string>(m["EnableStatus"]));
    }
    if (m.find("HealthJudgement") != m.end() && !m["HealthJudgement"].empty()) {
      healthJudgement = make_shared<string>(boost::any_cast<string>(m["HealthJudgement"]));
    }
    if (m.find("HealthTasks") != m.end() && !m["HealthTasks"].empty()) {
      healthTasksShrink = make_shared<string>(boost::any_cast<string>(m["HealthTasks"]));
    }
    if (m.find("ManualAvailableStatus") != m.end() && !m["ManualAvailableStatus"].empty()) {
      manualAvailableStatus = make_shared<string>(boost::any_cast<string>(m["ManualAvailableStatus"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateCloudGtmAddressShrinkRequest() = default;
};
class CreateCloudGtmAddressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> addressId{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateCloudGtmAddressResponseBody() {}

  explicit CreateCloudGtmAddressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addressId) {
      res["AddressId"] = boost::any(*addressId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddressId") != m.end() && !m["AddressId"].empty()) {
      addressId = make_shared<string>(boost::any_cast<string>(m["AddressId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateCloudGtmAddressResponseBody() = default;
};
class CreateCloudGtmAddressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCloudGtmAddressResponseBody> body{};

  CreateCloudGtmAddressResponse() {}

  explicit CreateCloudGtmAddressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCloudGtmAddressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCloudGtmAddressResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCloudGtmAddressResponse() = default;
};
class CreateCloudGtmAddressPoolRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> addressPoolName{};
  shared_ptr<string> addressPoolType{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> enableStatus{};
  shared_ptr<string> healthJudgement{};
  shared_ptr<string> remark{};

  CreateCloudGtmAddressPoolRequest() {}

  explicit CreateCloudGtmAddressPoolRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (addressPoolName) {
      res["AddressPoolName"] = boost::any(*addressPoolName);
    }
    if (addressPoolType) {
      res["AddressPoolType"] = boost::any(*addressPoolType);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (enableStatus) {
      res["EnableStatus"] = boost::any(*enableStatus);
    }
    if (healthJudgement) {
      res["HealthJudgement"] = boost::any(*healthJudgement);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AddressPoolName") != m.end() && !m["AddressPoolName"].empty()) {
      addressPoolName = make_shared<string>(boost::any_cast<string>(m["AddressPoolName"]));
    }
    if (m.find("AddressPoolType") != m.end() && !m["AddressPoolType"].empty()) {
      addressPoolType = make_shared<string>(boost::any_cast<string>(m["AddressPoolType"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("EnableStatus") != m.end() && !m["EnableStatus"].empty()) {
      enableStatus = make_shared<string>(boost::any_cast<string>(m["EnableStatus"]));
    }
    if (m.find("HealthJudgement") != m.end() && !m["HealthJudgement"].empty()) {
      healthJudgement = make_shared<string>(boost::any_cast<string>(m["HealthJudgement"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
  }


  virtual ~CreateCloudGtmAddressPoolRequest() = default;
};
class CreateCloudGtmAddressPoolResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> addressPoolId{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateCloudGtmAddressPoolResponseBody() {}

  explicit CreateCloudGtmAddressPoolResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addressPoolId) {
      res["AddressPoolId"] = boost::any(*addressPoolId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddressPoolId") != m.end() && !m["AddressPoolId"].empty()) {
      addressPoolId = make_shared<string>(boost::any_cast<string>(m["AddressPoolId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateCloudGtmAddressPoolResponseBody() = default;
};
class CreateCloudGtmAddressPoolResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCloudGtmAddressPoolResponseBody> body{};

  CreateCloudGtmAddressPoolResponse() {}

  explicit CreateCloudGtmAddressPoolResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCloudGtmAddressPoolResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCloudGtmAddressPoolResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCloudGtmAddressPoolResponse() = default;
};
class CreateCloudGtmInstanceConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> enableStatus{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> remark{};
  shared_ptr<string> scheduleHostname{};
  shared_ptr<string> scheduleRrType{};
  shared_ptr<string> scheduleZoneMode{};
  shared_ptr<string> scheduleZoneName{};
  shared_ptr<long> ttl{};

  CreateCloudGtmInstanceConfigRequest() {}

  explicit CreateCloudGtmInstanceConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (enableStatus) {
      res["EnableStatus"] = boost::any(*enableStatus);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (scheduleHostname) {
      res["ScheduleHostname"] = boost::any(*scheduleHostname);
    }
    if (scheduleRrType) {
      res["ScheduleRrType"] = boost::any(*scheduleRrType);
    }
    if (scheduleZoneMode) {
      res["ScheduleZoneMode"] = boost::any(*scheduleZoneMode);
    }
    if (scheduleZoneName) {
      res["ScheduleZoneName"] = boost::any(*scheduleZoneName);
    }
    if (ttl) {
      res["Ttl"] = boost::any(*ttl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("EnableStatus") != m.end() && !m["EnableStatus"].empty()) {
      enableStatus = make_shared<string>(boost::any_cast<string>(m["EnableStatus"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("ScheduleHostname") != m.end() && !m["ScheduleHostname"].empty()) {
      scheduleHostname = make_shared<string>(boost::any_cast<string>(m["ScheduleHostname"]));
    }
    if (m.find("ScheduleRrType") != m.end() && !m["ScheduleRrType"].empty()) {
      scheduleRrType = make_shared<string>(boost::any_cast<string>(m["ScheduleRrType"]));
    }
    if (m.find("ScheduleZoneMode") != m.end() && !m["ScheduleZoneMode"].empty()) {
      scheduleZoneMode = make_shared<string>(boost::any_cast<string>(m["ScheduleZoneMode"]));
    }
    if (m.find("ScheduleZoneName") != m.end() && !m["ScheduleZoneName"].empty()) {
      scheduleZoneName = make_shared<string>(boost::any_cast<string>(m["ScheduleZoneName"]));
    }
    if (m.find("Ttl") != m.end() && !m["Ttl"].empty()) {
      ttl = make_shared<long>(boost::any_cast<long>(m["Ttl"]));
    }
  }


  virtual ~CreateCloudGtmInstanceConfigRequest() = default;
};
class CreateCloudGtmInstanceConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> configId{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateCloudGtmInstanceConfigResponseBody() {}

  explicit CreateCloudGtmInstanceConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<bool>(boost::any_cast<bool>(m["ConfigId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateCloudGtmInstanceConfigResponseBody() = default;
};
class CreateCloudGtmInstanceConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCloudGtmInstanceConfigResponseBody> body{};

  CreateCloudGtmInstanceConfigResponse() {}

  explicit CreateCloudGtmInstanceConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCloudGtmInstanceConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCloudGtmInstanceConfigResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCloudGtmInstanceConfigResponse() = default;
};
class CreateCloudGtmMonitorTemplateRequestIspCityNodes : public Darabonba::Model {
public:
  shared_ptr<string> cityCode{};
  shared_ptr<string> ispCode{};

  CreateCloudGtmMonitorTemplateRequestIspCityNodes() {}

  explicit CreateCloudGtmMonitorTemplateRequestIspCityNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cityCode) {
      res["CityCode"] = boost::any(*cityCode);
    }
    if (ispCode) {
      res["IspCode"] = boost::any(*ispCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CityCode") != m.end() && !m["CityCode"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["CityCode"]));
    }
    if (m.find("IspCode") != m.end() && !m["IspCode"].empty()) {
      ispCode = make_shared<string>(boost::any_cast<string>(m["IspCode"]));
    }
  }


  virtual ~CreateCloudGtmMonitorTemplateRequestIspCityNodes() = default;
};
class CreateCloudGtmMonitorTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> clientToken{};
  shared_ptr<long> evaluationCount{};
  shared_ptr<string> extendInfo{};
  shared_ptr<long> failureRate{};
  shared_ptr<long> interval{};
  shared_ptr<string> ipVersion{};
  shared_ptr<vector<CreateCloudGtmMonitorTemplateRequestIspCityNodes>> ispCityNodes{};
  shared_ptr<string> name{};
  shared_ptr<string> protocol{};
  shared_ptr<long> timeout{};

  CreateCloudGtmMonitorTemplateRequest() {}

  explicit CreateCloudGtmMonitorTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (evaluationCount) {
      res["EvaluationCount"] = boost::any(*evaluationCount);
    }
    if (extendInfo) {
      res["ExtendInfo"] = boost::any(*extendInfo);
    }
    if (failureRate) {
      res["FailureRate"] = boost::any(*failureRate);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ipVersion) {
      res["IpVersion"] = boost::any(*ipVersion);
    }
    if (ispCityNodes) {
      vector<boost::any> temp1;
      for(auto item1:*ispCityNodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IspCityNodes"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("EvaluationCount") != m.end() && !m["EvaluationCount"].empty()) {
      evaluationCount = make_shared<long>(boost::any_cast<long>(m["EvaluationCount"]));
    }
    if (m.find("ExtendInfo") != m.end() && !m["ExtendInfo"].empty()) {
      extendInfo = make_shared<string>(boost::any_cast<string>(m["ExtendInfo"]));
    }
    if (m.find("FailureRate") != m.end() && !m["FailureRate"].empty()) {
      failureRate = make_shared<long>(boost::any_cast<long>(m["FailureRate"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("IpVersion") != m.end() && !m["IpVersion"].empty()) {
      ipVersion = make_shared<string>(boost::any_cast<string>(m["IpVersion"]));
    }
    if (m.find("IspCityNodes") != m.end() && !m["IspCityNodes"].empty()) {
      if (typeid(vector<boost::any>) == m["IspCityNodes"].type()) {
        vector<CreateCloudGtmMonitorTemplateRequestIspCityNodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IspCityNodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateCloudGtmMonitorTemplateRequestIspCityNodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ispCityNodes = make_shared<vector<CreateCloudGtmMonitorTemplateRequestIspCityNodes>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
  }


  virtual ~CreateCloudGtmMonitorTemplateRequest() = default;
};
class CreateCloudGtmMonitorTemplateShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> clientToken{};
  shared_ptr<long> evaluationCount{};
  shared_ptr<string> extendInfo{};
  shared_ptr<long> failureRate{};
  shared_ptr<long> interval{};
  shared_ptr<string> ipVersion{};
  shared_ptr<string> ispCityNodesShrink{};
  shared_ptr<string> name{};
  shared_ptr<string> protocol{};
  shared_ptr<long> timeout{};

  CreateCloudGtmMonitorTemplateShrinkRequest() {}

  explicit CreateCloudGtmMonitorTemplateShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (evaluationCount) {
      res["EvaluationCount"] = boost::any(*evaluationCount);
    }
    if (extendInfo) {
      res["ExtendInfo"] = boost::any(*extendInfo);
    }
    if (failureRate) {
      res["FailureRate"] = boost::any(*failureRate);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ipVersion) {
      res["IpVersion"] = boost::any(*ipVersion);
    }
    if (ispCityNodesShrink) {
      res["IspCityNodes"] = boost::any(*ispCityNodesShrink);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("EvaluationCount") != m.end() && !m["EvaluationCount"].empty()) {
      evaluationCount = make_shared<long>(boost::any_cast<long>(m["EvaluationCount"]));
    }
    if (m.find("ExtendInfo") != m.end() && !m["ExtendInfo"].empty()) {
      extendInfo = make_shared<string>(boost::any_cast<string>(m["ExtendInfo"]));
    }
    if (m.find("FailureRate") != m.end() && !m["FailureRate"].empty()) {
      failureRate = make_shared<long>(boost::any_cast<long>(m["FailureRate"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("IpVersion") != m.end() && !m["IpVersion"].empty()) {
      ipVersion = make_shared<string>(boost::any_cast<string>(m["IpVersion"]));
    }
    if (m.find("IspCityNodes") != m.end() && !m["IspCityNodes"].empty()) {
      ispCityNodesShrink = make_shared<string>(boost::any_cast<string>(m["IspCityNodes"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
  }


  virtual ~CreateCloudGtmMonitorTemplateShrinkRequest() = default;
};
class CreateCloudGtmMonitorTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> templateId{};

  CreateCloudGtmMonitorTemplateResponseBody() {}

  explicit CreateCloudGtmMonitorTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~CreateCloudGtmMonitorTemplateResponseBody() = default;
};
class CreateCloudGtmMonitorTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCloudGtmMonitorTemplateResponseBody> body{};

  CreateCloudGtmMonitorTemplateResponse() {}

  explicit CreateCloudGtmMonitorTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCloudGtmMonitorTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCloudGtmMonitorTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCloudGtmMonitorTemplateResponse() = default;
};
class CreatePdnsAppKeyRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};

  CreatePdnsAppKeyRequest() {}

  explicit CreatePdnsAppKeyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~CreatePdnsAppKeyRequest() = default;
};
class CreatePdnsAppKeyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreatePdnsAppKeyResponseBody() {}

  explicit CreatePdnsAppKeyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreatePdnsAppKeyResponseBody() = default;
};
class CreatePdnsAppKeyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreatePdnsAppKeyResponseBody> body{};

  CreatePdnsAppKeyResponse() {}

  explicit CreatePdnsAppKeyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreatePdnsAppKeyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreatePdnsAppKeyResponseBody>(model1);
      }
    }
  }


  virtual ~CreatePdnsAppKeyResponse() = default;
};
class CreatePdnsUdpIpSegmentRequest : public Darabonba::Model {
public:
  shared_ptr<string> ip{};
  shared_ptr<string> ipToken{};
  shared_ptr<string> lang{};
  shared_ptr<string> name{};

  CreatePdnsUdpIpSegmentRequest() {}

  explicit CreatePdnsUdpIpSegmentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (ipToken) {
      res["IpToken"] = boost::any(*ipToken);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("IpToken") != m.end() && !m["IpToken"].empty()) {
      ipToken = make_shared<string>(boost::any_cast<string>(m["IpToken"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~CreatePdnsUdpIpSegmentRequest() = default;
};
class CreatePdnsUdpIpSegmentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> validMessage{};

  CreatePdnsUdpIpSegmentResponseBody() {}

  explicit CreatePdnsUdpIpSegmentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (validMessage) {
      res["ValidMessage"] = boost::any(*validMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ValidMessage") != m.end() && !m["ValidMessage"].empty()) {
      validMessage = make_shared<string>(boost::any_cast<string>(m["ValidMessage"]));
    }
  }


  virtual ~CreatePdnsUdpIpSegmentResponseBody() = default;
};
class CreatePdnsUdpIpSegmentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreatePdnsUdpIpSegmentResponseBody> body{};

  CreatePdnsUdpIpSegmentResponse() {}

  explicit CreatePdnsUdpIpSegmentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreatePdnsUdpIpSegmentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreatePdnsUdpIpSegmentResponseBody>(model1);
      }
    }
  }


  virtual ~CreatePdnsUdpIpSegmentResponse() = default;
};
class DeleteCloudGtmAddressRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> addressId{};
  shared_ptr<string> clientToken{};

  DeleteCloudGtmAddressRequest() {}

  explicit DeleteCloudGtmAddressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (addressId) {
      res["AddressId"] = boost::any(*addressId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AddressId") != m.end() && !m["AddressId"].empty()) {
      addressId = make_shared<string>(boost::any_cast<string>(m["AddressId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
  }


  virtual ~DeleteCloudGtmAddressRequest() = default;
};
class DeleteCloudGtmAddressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteCloudGtmAddressResponseBody() {}

  explicit DeleteCloudGtmAddressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteCloudGtmAddressResponseBody() = default;
};
class DeleteCloudGtmAddressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCloudGtmAddressResponseBody> body{};

  DeleteCloudGtmAddressResponse() {}

  explicit DeleteCloudGtmAddressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCloudGtmAddressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCloudGtmAddressResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCloudGtmAddressResponse() = default;
};
class DeleteCloudGtmAddressPoolRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> addressPoolId{};
  shared_ptr<string> clientToken{};

  DeleteCloudGtmAddressPoolRequest() {}

  explicit DeleteCloudGtmAddressPoolRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (addressPoolId) {
      res["AddressPoolId"] = boost::any(*addressPoolId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AddressPoolId") != m.end() && !m["AddressPoolId"].empty()) {
      addressPoolId = make_shared<string>(boost::any_cast<string>(m["AddressPoolId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
  }


  virtual ~DeleteCloudGtmAddressPoolRequest() = default;
};
class DeleteCloudGtmAddressPoolResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> addressPoolId{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteCloudGtmAddressPoolResponseBody() {}

  explicit DeleteCloudGtmAddressPoolResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addressPoolId) {
      res["AddressPoolId"] = boost::any(*addressPoolId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddressPoolId") != m.end() && !m["AddressPoolId"].empty()) {
      addressPoolId = make_shared<string>(boost::any_cast<string>(m["AddressPoolId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteCloudGtmAddressPoolResponseBody() = default;
};
class DeleteCloudGtmAddressPoolResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCloudGtmAddressPoolResponseBody> body{};

  DeleteCloudGtmAddressPoolResponse() {}

  explicit DeleteCloudGtmAddressPoolResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCloudGtmAddressPoolResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCloudGtmAddressPoolResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCloudGtmAddressPoolResponse() = default;
};
class DeleteCloudGtmInstanceConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> configId{};
  shared_ptr<string> instanceId{};

  DeleteCloudGtmInstanceConfigRequest() {}

  explicit DeleteCloudGtmInstanceConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DeleteCloudGtmInstanceConfigRequest() = default;
};
class DeleteCloudGtmInstanceConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteCloudGtmInstanceConfigResponseBody() {}

  explicit DeleteCloudGtmInstanceConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteCloudGtmInstanceConfigResponseBody() = default;
};
class DeleteCloudGtmInstanceConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCloudGtmInstanceConfigResponseBody> body{};

  DeleteCloudGtmInstanceConfigResponse() {}

  explicit DeleteCloudGtmInstanceConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCloudGtmInstanceConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCloudGtmInstanceConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCloudGtmInstanceConfigResponse() = default;
};
class DeleteCloudGtmMonitorTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> templateId{};

  DeleteCloudGtmMonitorTemplateRequest() {}

  explicit DeleteCloudGtmMonitorTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~DeleteCloudGtmMonitorTemplateRequest() = default;
};
class DeleteCloudGtmMonitorTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteCloudGtmMonitorTemplateResponseBody() {}

  explicit DeleteCloudGtmMonitorTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteCloudGtmMonitorTemplateResponseBody() = default;
};
class DeleteCloudGtmMonitorTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCloudGtmMonitorTemplateResponseBody> body{};

  DeleteCloudGtmMonitorTemplateResponse() {}

  explicit DeleteCloudGtmMonitorTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCloudGtmMonitorTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCloudGtmMonitorTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCloudGtmMonitorTemplateResponse() = default;
};
class DeleteCustomLinesRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> lineIds{};

  DeleteCustomLinesRequest() {}

  explicit DeleteCustomLinesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (lineIds) {
      res["LineIds"] = boost::any(*lineIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("LineIds") != m.end() && !m["LineIds"].empty()) {
      lineIds = make_shared<string>(boost::any_cast<string>(m["LineIds"]));
    }
  }


  virtual ~DeleteCustomLinesRequest() = default;
};
class DeleteCustomLinesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteCustomLinesResponseBody() {}

  explicit DeleteCustomLinesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCustomLinesResponseBody() = default;
};
class DeleteCustomLinesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCustomLinesResponseBody> body{};

  DeleteCustomLinesResponse() {}

  explicit DeleteCustomLinesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCustomLinesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCustomLinesResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCustomLinesResponse() = default;
};
class DeleteDnsCacheDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> lang{};

  DeleteDnsCacheDomainRequest() {}

  explicit DeleteDnsCacheDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~DeleteDnsCacheDomainRequest() = default;
};
class DeleteDnsCacheDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDnsCacheDomainResponseBody() {}

  explicit DeleteDnsCacheDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDnsCacheDomainResponseBody() = default;
};
class DeleteDnsCacheDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDnsCacheDomainResponseBody> body{};

  DeleteDnsCacheDomainResponse() {}

  explicit DeleteDnsCacheDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDnsCacheDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDnsCacheDomainResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDnsCacheDomainResponse() = default;
};
class DeleteDnsGtmAccessStrategyRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> strategyId{};

  DeleteDnsGtmAccessStrategyRequest() {}

  explicit DeleteDnsGtmAccessStrategyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (strategyId) {
      res["StrategyId"] = boost::any(*strategyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("StrategyId") != m.end() && !m["StrategyId"].empty()) {
      strategyId = make_shared<string>(boost::any_cast<string>(m["StrategyId"]));
    }
  }


  virtual ~DeleteDnsGtmAccessStrategyRequest() = default;
};
class DeleteDnsGtmAccessStrategyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDnsGtmAccessStrategyResponseBody() {}

  explicit DeleteDnsGtmAccessStrategyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDnsGtmAccessStrategyResponseBody() = default;
};
class DeleteDnsGtmAccessStrategyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDnsGtmAccessStrategyResponseBody> body{};

  DeleteDnsGtmAccessStrategyResponse() {}

  explicit DeleteDnsGtmAccessStrategyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDnsGtmAccessStrategyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDnsGtmAccessStrategyResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDnsGtmAccessStrategyResponse() = default;
};
class DeleteDnsGtmAddressPoolRequest : public Darabonba::Model {
public:
  shared_ptr<string> addrPoolId{};
  shared_ptr<string> lang{};

  DeleteDnsGtmAddressPoolRequest() {}

  explicit DeleteDnsGtmAddressPoolRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addrPoolId) {
      res["AddrPoolId"] = boost::any(*addrPoolId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddrPoolId") != m.end() && !m["AddrPoolId"].empty()) {
      addrPoolId = make_shared<string>(boost::any_cast<string>(m["AddrPoolId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~DeleteDnsGtmAddressPoolRequest() = default;
};
class DeleteDnsGtmAddressPoolResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDnsGtmAddressPoolResponseBody() {}

  explicit DeleteDnsGtmAddressPoolResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDnsGtmAddressPoolResponseBody() = default;
};
class DeleteDnsGtmAddressPoolResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDnsGtmAddressPoolResponseBody> body{};

  DeleteDnsGtmAddressPoolResponse() {}

  explicit DeleteDnsGtmAddressPoolResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDnsGtmAddressPoolResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDnsGtmAddressPoolResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDnsGtmAddressPoolResponse() = default;
};
class DeleteDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> lang{};

  DeleteDomainRequest() {}

  explicit DeleteDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~DeleteDomainRequest() = default;
};
class DeleteDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> requestId{};

  DeleteDomainResponseBody() {}

  explicit DeleteDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDomainResponseBody() = default;
};
class DeleteDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDomainResponseBody> body{};

  DeleteDomainResponse() {}

  explicit DeleteDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDomainResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDomainResponse() = default;
};
class DeleteDomainGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> lang{};

  DeleteDomainGroupRequest() {}

  explicit DeleteDomainGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~DeleteDomainGroupRequest() = default;
};
class DeleteDomainGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> groupName{};
  shared_ptr<string> requestId{};

  DeleteDomainGroupResponseBody() {}

  explicit DeleteDomainGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDomainGroupResponseBody() = default;
};
class DeleteDomainGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDomainGroupResponseBody> body{};

  DeleteDomainGroupResponse() {}

  explicit DeleteDomainGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDomainGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDomainGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDomainGroupResponse() = default;
};
class DeleteDomainRecordRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> recordId{};
  shared_ptr<string> userClientIp{};

  DeleteDomainRecordRequest() {}

  explicit DeleteDomainRecordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (userClientIp) {
      res["UserClientIp"] = boost::any(*userClientIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<string>(boost::any_cast<string>(m["RecordId"]));
    }
    if (m.find("UserClientIp") != m.end() && !m["UserClientIp"].empty()) {
      userClientIp = make_shared<string>(boost::any_cast<string>(m["UserClientIp"]));
    }
  }


  virtual ~DeleteDomainRecordRequest() = default;
};
class DeleteDomainRecordResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> recordId{};
  shared_ptr<string> requestId{};

  DeleteDomainRecordResponseBody() {}

  explicit DeleteDomainRecordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<string>(boost::any_cast<string>(m["RecordId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDomainRecordResponseBody() = default;
};
class DeleteDomainRecordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDomainRecordResponseBody> body{};

  DeleteDomainRecordResponse() {}

  explicit DeleteDomainRecordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDomainRecordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDomainRecordResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDomainRecordResponse() = default;
};
class DeleteGtmAccessStrategyRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> strategyId{};

  DeleteGtmAccessStrategyRequest() {}

  explicit DeleteGtmAccessStrategyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (strategyId) {
      res["StrategyId"] = boost::any(*strategyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("StrategyId") != m.end() && !m["StrategyId"].empty()) {
      strategyId = make_shared<string>(boost::any_cast<string>(m["StrategyId"]));
    }
  }


  virtual ~DeleteGtmAccessStrategyRequest() = default;
};
class DeleteGtmAccessStrategyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteGtmAccessStrategyResponseBody() {}

  explicit DeleteGtmAccessStrategyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteGtmAccessStrategyResponseBody() = default;
};
class DeleteGtmAccessStrategyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteGtmAccessStrategyResponseBody> body{};

  DeleteGtmAccessStrategyResponse() {}

  explicit DeleteGtmAccessStrategyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteGtmAccessStrategyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteGtmAccessStrategyResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteGtmAccessStrategyResponse() = default;
};
class DeleteGtmAddressPoolRequest : public Darabonba::Model {
public:
  shared_ptr<string> addrPoolId{};
  shared_ptr<string> lang{};

  DeleteGtmAddressPoolRequest() {}

  explicit DeleteGtmAddressPoolRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addrPoolId) {
      res["AddrPoolId"] = boost::any(*addrPoolId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddrPoolId") != m.end() && !m["AddrPoolId"].empty()) {
      addrPoolId = make_shared<string>(boost::any_cast<string>(m["AddrPoolId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~DeleteGtmAddressPoolRequest() = default;
};
class DeleteGtmAddressPoolResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteGtmAddressPoolResponseBody() {}

  explicit DeleteGtmAddressPoolResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteGtmAddressPoolResponseBody() = default;
};
class DeleteGtmAddressPoolResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteGtmAddressPoolResponseBody> body{};

  DeleteGtmAddressPoolResponse() {}

  explicit DeleteGtmAddressPoolResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteGtmAddressPoolResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteGtmAddressPoolResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteGtmAddressPoolResponse() = default;
};
class DeleteGtmRecoveryPlanRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> recoveryPlanId{};

  DeleteGtmRecoveryPlanRequest() {}

  explicit DeleteGtmRecoveryPlanRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (recoveryPlanId) {
      res["RecoveryPlanId"] = boost::any(*recoveryPlanId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("RecoveryPlanId") != m.end() && !m["RecoveryPlanId"].empty()) {
      recoveryPlanId = make_shared<long>(boost::any_cast<long>(m["RecoveryPlanId"]));
    }
  }


  virtual ~DeleteGtmRecoveryPlanRequest() = default;
};
class DeleteGtmRecoveryPlanResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteGtmRecoveryPlanResponseBody() {}

  explicit DeleteGtmRecoveryPlanResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteGtmRecoveryPlanResponseBody() = default;
};
class DeleteGtmRecoveryPlanResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteGtmRecoveryPlanResponseBody> body{};

  DeleteGtmRecoveryPlanResponse() {}

  explicit DeleteGtmRecoveryPlanResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteGtmRecoveryPlanResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteGtmRecoveryPlanResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteGtmRecoveryPlanResponse() = default;
};
class DeleteSubDomainRecordsRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> lang{};
  shared_ptr<string> RR{};
  shared_ptr<string> type{};
  shared_ptr<string> userClientIp{};

  DeleteSubDomainRecordsRequest() {}

  explicit DeleteSubDomainRecordsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (RR) {
      res["RR"] = boost::any(*RR);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (userClientIp) {
      res["UserClientIp"] = boost::any(*userClientIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("RR") != m.end() && !m["RR"].empty()) {
      RR = make_shared<string>(boost::any_cast<string>(m["RR"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UserClientIp") != m.end() && !m["UserClientIp"].empty()) {
      userClientIp = make_shared<string>(boost::any_cast<string>(m["UserClientIp"]));
    }
  }


  virtual ~DeleteSubDomainRecordsRequest() = default;
};
class DeleteSubDomainRecordsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> RR{};
  shared_ptr<string> requestId{};
  shared_ptr<string> totalCount{};

  DeleteSubDomainRecordsResponseBody() {}

  explicit DeleteSubDomainRecordsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (RR) {
      res["RR"] = boost::any(*RR);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RR") != m.end() && !m["RR"].empty()) {
      RR = make_shared<string>(boost::any_cast<string>(m["RR"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<string>(boost::any_cast<string>(m["TotalCount"]));
    }
  }


  virtual ~DeleteSubDomainRecordsResponseBody() = default;
};
class DeleteSubDomainRecordsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSubDomainRecordsResponseBody> body{};

  DeleteSubDomainRecordsResponse() {}

  explicit DeleteSubDomainRecordsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSubDomainRecordsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSubDomainRecordsResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSubDomainRecordsResponse() = default;
};
class DescribeBatchResultCountRequest : public Darabonba::Model {
public:
  shared_ptr<string> batchType{};
  shared_ptr<string> lang{};
  shared_ptr<long> taskId{};

  DescribeBatchResultCountRequest() {}

  explicit DescribeBatchResultCountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (batchType) {
      res["BatchType"] = boost::any(*batchType);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BatchType") != m.end() && !m["BatchType"].empty()) {
      batchType = make_shared<string>(boost::any_cast<string>(m["BatchType"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
  }


  virtual ~DescribeBatchResultCountRequest() = default;
};
class DescribeBatchResultCountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> batchType{};
  shared_ptr<long> failedCount{};
  shared_ptr<string> reason{};
  shared_ptr<string> requestId{};
  shared_ptr<long> status{};
  shared_ptr<long> successCount{};
  shared_ptr<long> taskId{};
  shared_ptr<long> totalCount{};

  DescribeBatchResultCountResponseBody() {}

  explicit DescribeBatchResultCountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (batchType) {
      res["BatchType"] = boost::any(*batchType);
    }
    if (failedCount) {
      res["FailedCount"] = boost::any(*failedCount);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (successCount) {
      res["SuccessCount"] = boost::any(*successCount);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BatchType") != m.end() && !m["BatchType"].empty()) {
      batchType = make_shared<string>(boost::any_cast<string>(m["BatchType"]));
    }
    if (m.find("FailedCount") != m.end() && !m["FailedCount"].empty()) {
      failedCount = make_shared<long>(boost::any_cast<long>(m["FailedCount"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("SuccessCount") != m.end() && !m["SuccessCount"].empty()) {
      successCount = make_shared<long>(boost::any_cast<long>(m["SuccessCount"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeBatchResultCountResponseBody() = default;
};
class DescribeBatchResultCountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeBatchResultCountResponseBody> body{};

  DescribeBatchResultCountResponse() {}

  explicit DescribeBatchResultCountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBatchResultCountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBatchResultCountResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBatchResultCountResponse() = default;
};
class DescribeBatchResultDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> batchType{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> status{};
  shared_ptr<long> taskId{};

  DescribeBatchResultDetailRequest() {}

  explicit DescribeBatchResultDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (batchType) {
      res["BatchType"] = boost::any(*batchType);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BatchType") != m.end() && !m["BatchType"].empty()) {
      batchType = make_shared<string>(boost::any_cast<string>(m["BatchType"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
  }


  virtual ~DescribeBatchResultDetailRequest() = default;
};
class DescribeBatchResultDetailResponseBodyBatchResultDetailsBatchResultDetail : public Darabonba::Model {
public:
  shared_ptr<string> batchType{};
  shared_ptr<string> domain{};
  shared_ptr<string> line{};
  shared_ptr<string> newRr{};
  shared_ptr<string> newValue{};
  shared_ptr<string> operateDateStr{};
  shared_ptr<string> priority{};
  shared_ptr<string> reason{};
  shared_ptr<string> recordId{};
  shared_ptr<string> remark{};
  shared_ptr<string> rr{};
  shared_ptr<string> rrStatus{};
  shared_ptr<bool> status{};
  shared_ptr<string> ttl{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  DescribeBatchResultDetailResponseBodyBatchResultDetailsBatchResultDetail() {}

  explicit DescribeBatchResultDetailResponseBodyBatchResultDetailsBatchResultDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (batchType) {
      res["BatchType"] = boost::any(*batchType);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (line) {
      res["Line"] = boost::any(*line);
    }
    if (newRr) {
      res["NewRr"] = boost::any(*newRr);
    }
    if (newValue) {
      res["NewValue"] = boost::any(*newValue);
    }
    if (operateDateStr) {
      res["OperateDateStr"] = boost::any(*operateDateStr);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (rr) {
      res["Rr"] = boost::any(*rr);
    }
    if (rrStatus) {
      res["RrStatus"] = boost::any(*rrStatus);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (ttl) {
      res["Ttl"] = boost::any(*ttl);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BatchType") != m.end() && !m["BatchType"].empty()) {
      batchType = make_shared<string>(boost::any_cast<string>(m["BatchType"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Line") != m.end() && !m["Line"].empty()) {
      line = make_shared<string>(boost::any_cast<string>(m["Line"]));
    }
    if (m.find("NewRr") != m.end() && !m["NewRr"].empty()) {
      newRr = make_shared<string>(boost::any_cast<string>(m["NewRr"]));
    }
    if (m.find("NewValue") != m.end() && !m["NewValue"].empty()) {
      newValue = make_shared<string>(boost::any_cast<string>(m["NewValue"]));
    }
    if (m.find("OperateDateStr") != m.end() && !m["OperateDateStr"].empty()) {
      operateDateStr = make_shared<string>(boost::any_cast<string>(m["OperateDateStr"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<string>(boost::any_cast<string>(m["RecordId"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("Rr") != m.end() && !m["Rr"].empty()) {
      rr = make_shared<string>(boost::any_cast<string>(m["Rr"]));
    }
    if (m.find("RrStatus") != m.end() && !m["RrStatus"].empty()) {
      rrStatus = make_shared<string>(boost::any_cast<string>(m["RrStatus"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<bool>(boost::any_cast<bool>(m["Status"]));
    }
    if (m.find("Ttl") != m.end() && !m["Ttl"].empty()) {
      ttl = make_shared<string>(boost::any_cast<string>(m["Ttl"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeBatchResultDetailResponseBodyBatchResultDetailsBatchResultDetail() = default;
};
class DescribeBatchResultDetailResponseBodyBatchResultDetails : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeBatchResultDetailResponseBodyBatchResultDetailsBatchResultDetail>> batchResultDetail{};

  DescribeBatchResultDetailResponseBodyBatchResultDetails() {}

  explicit DescribeBatchResultDetailResponseBodyBatchResultDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (batchResultDetail) {
      vector<boost::any> temp1;
      for(auto item1:*batchResultDetail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BatchResultDetail"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BatchResultDetail") != m.end() && !m["BatchResultDetail"].empty()) {
      if (typeid(vector<boost::any>) == m["BatchResultDetail"].type()) {
        vector<DescribeBatchResultDetailResponseBodyBatchResultDetailsBatchResultDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BatchResultDetail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeBatchResultDetailResponseBodyBatchResultDetailsBatchResultDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        batchResultDetail = make_shared<vector<DescribeBatchResultDetailResponseBodyBatchResultDetailsBatchResultDetail>>(expect1);
      }
    }
  }


  virtual ~DescribeBatchResultDetailResponseBodyBatchResultDetails() = default;
};
class DescribeBatchResultDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeBatchResultDetailResponseBodyBatchResultDetails> batchResultDetails{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeBatchResultDetailResponseBody() {}

  explicit DescribeBatchResultDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (batchResultDetails) {
      res["BatchResultDetails"] = batchResultDetails ? boost::any(batchResultDetails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BatchResultDetails") != m.end() && !m["BatchResultDetails"].empty()) {
      if (typeid(map<string, boost::any>) == m["BatchResultDetails"].type()) {
        DescribeBatchResultDetailResponseBodyBatchResultDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BatchResultDetails"]));
        batchResultDetails = make_shared<DescribeBatchResultDetailResponseBodyBatchResultDetails>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeBatchResultDetailResponseBody() = default;
};
class DescribeBatchResultDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeBatchResultDetailResponseBody> body{};

  DescribeBatchResultDetailResponse() {}

  explicit DescribeBatchResultDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBatchResultDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBatchResultDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBatchResultDetailResponse() = default;
};
class DescribeCloudGtmAddressRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> addressId{};
  shared_ptr<string> clientToken{};

  DescribeCloudGtmAddressRequest() {}

  explicit DescribeCloudGtmAddressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (addressId) {
      res["AddressId"] = boost::any(*addressId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AddressId") != m.end() && !m["AddressId"].empty()) {
      addressId = make_shared<string>(boost::any_cast<string>(m["AddressId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
  }


  virtual ~DescribeCloudGtmAddressRequest() = default;
};
class DescribeCloudGtmAddressResponseBodyHealthTasksHealthTask : public Darabonba::Model {
public:
  shared_ptr<string> monitorStatus{};
  shared_ptr<long> port{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateName{};

  DescribeCloudGtmAddressResponseBodyHealthTasksHealthTask() {}

  explicit DescribeCloudGtmAddressResponseBodyHealthTasksHealthTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (monitorStatus) {
      res["MonitorStatus"] = boost::any(*monitorStatus);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MonitorStatus") != m.end() && !m["MonitorStatus"].empty()) {
      monitorStatus = make_shared<string>(boost::any_cast<string>(m["MonitorStatus"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
  }


  virtual ~DescribeCloudGtmAddressResponseBodyHealthTasksHealthTask() = default;
};
class DescribeCloudGtmAddressResponseBodyHealthTasks : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCloudGtmAddressResponseBodyHealthTasksHealthTask>> healthTask{};

  DescribeCloudGtmAddressResponseBodyHealthTasks() {}

  explicit DescribeCloudGtmAddressResponseBodyHealthTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (healthTask) {
      vector<boost::any> temp1;
      for(auto item1:*healthTask){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HealthTask"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HealthTask") != m.end() && !m["HealthTask"].empty()) {
      if (typeid(vector<boost::any>) == m["HealthTask"].type()) {
        vector<DescribeCloudGtmAddressResponseBodyHealthTasksHealthTask> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HealthTask"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCloudGtmAddressResponseBodyHealthTasksHealthTask model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        healthTask = make_shared<vector<DescribeCloudGtmAddressResponseBodyHealthTasksHealthTask>>(expect1);
      }
    }
  }


  virtual ~DescribeCloudGtmAddressResponseBodyHealthTasks() = default;
};
class DescribeCloudGtmAddressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> addressId{};
  shared_ptr<string> attributeInfo{};
  shared_ptr<string> availableMode{};
  shared_ptr<string> availableStatus{};
  shared_ptr<string> createTime{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<string> enableStatus{};
  shared_ptr<string> healthJudgement{};
  shared_ptr<string> healthStatus{};
  shared_ptr<DescribeCloudGtmAddressResponseBodyHealthTasks> healthTasks{};
  shared_ptr<string> manualAvailableStatus{};
  shared_ptr<string> name{};
  shared_ptr<string> remark{};
  shared_ptr<string> requestId{};
  shared_ptr<string> type{};
  shared_ptr<string> updateTime{};
  shared_ptr<long> updateTimestamp{};

  DescribeCloudGtmAddressResponseBody() {}

  explicit DescribeCloudGtmAddressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (addressId) {
      res["AddressId"] = boost::any(*addressId);
    }
    if (attributeInfo) {
      res["AttributeInfo"] = boost::any(*attributeInfo);
    }
    if (availableMode) {
      res["AvailableMode"] = boost::any(*availableMode);
    }
    if (availableStatus) {
      res["AvailableStatus"] = boost::any(*availableStatus);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (enableStatus) {
      res["EnableStatus"] = boost::any(*enableStatus);
    }
    if (healthJudgement) {
      res["HealthJudgement"] = boost::any(*healthJudgement);
    }
    if (healthStatus) {
      res["HealthStatus"] = boost::any(*healthStatus);
    }
    if (healthTasks) {
      res["HealthTasks"] = healthTasks ? boost::any(healthTasks->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (manualAvailableStatus) {
      res["ManualAvailableStatus"] = boost::any(*manualAvailableStatus);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (updateTimestamp) {
      res["UpdateTimestamp"] = boost::any(*updateTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("AddressId") != m.end() && !m["AddressId"].empty()) {
      addressId = make_shared<string>(boost::any_cast<string>(m["AddressId"]));
    }
    if (m.find("AttributeInfo") != m.end() && !m["AttributeInfo"].empty()) {
      attributeInfo = make_shared<string>(boost::any_cast<string>(m["AttributeInfo"]));
    }
    if (m.find("AvailableMode") != m.end() && !m["AvailableMode"].empty()) {
      availableMode = make_shared<string>(boost::any_cast<string>(m["AvailableMode"]));
    }
    if (m.find("AvailableStatus") != m.end() && !m["AvailableStatus"].empty()) {
      availableStatus = make_shared<string>(boost::any_cast<string>(m["AvailableStatus"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("EnableStatus") != m.end() && !m["EnableStatus"].empty()) {
      enableStatus = make_shared<string>(boost::any_cast<string>(m["EnableStatus"]));
    }
    if (m.find("HealthJudgement") != m.end() && !m["HealthJudgement"].empty()) {
      healthJudgement = make_shared<string>(boost::any_cast<string>(m["HealthJudgement"]));
    }
    if (m.find("HealthStatus") != m.end() && !m["HealthStatus"].empty()) {
      healthStatus = make_shared<string>(boost::any_cast<string>(m["HealthStatus"]));
    }
    if (m.find("HealthTasks") != m.end() && !m["HealthTasks"].empty()) {
      if (typeid(map<string, boost::any>) == m["HealthTasks"].type()) {
        DescribeCloudGtmAddressResponseBodyHealthTasks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HealthTasks"]));
        healthTasks = make_shared<DescribeCloudGtmAddressResponseBodyHealthTasks>(model1);
      }
    }
    if (m.find("ManualAvailableStatus") != m.end() && !m["ManualAvailableStatus"].empty()) {
      manualAvailableStatus = make_shared<string>(boost::any_cast<string>(m["ManualAvailableStatus"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("UpdateTimestamp") != m.end() && !m["UpdateTimestamp"].empty()) {
      updateTimestamp = make_shared<long>(boost::any_cast<long>(m["UpdateTimestamp"]));
    }
  }


  virtual ~DescribeCloudGtmAddressResponseBody() = default;
};
class DescribeCloudGtmAddressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCloudGtmAddressResponseBody> body{};

  DescribeCloudGtmAddressResponse() {}

  explicit DescribeCloudGtmAddressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCloudGtmAddressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCloudGtmAddressResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCloudGtmAddressResponse() = default;
};
class DescribeCloudGtmAddressPoolRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> addressPoolId{};
  shared_ptr<string> clientToken{};

  DescribeCloudGtmAddressPoolRequest() {}

  explicit DescribeCloudGtmAddressPoolRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (addressPoolId) {
      res["AddressPoolId"] = boost::any(*addressPoolId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AddressPoolId") != m.end() && !m["AddressPoolId"].empty()) {
      addressPoolId = make_shared<string>(boost::any_cast<string>(m["AddressPoolId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
  }


  virtual ~DescribeCloudGtmAddressPoolRequest() = default;
};
class DescribeCloudGtmAddressPoolResponseBodyAddressesAddressHealthTasksHealthTask : public Darabonba::Model {
public:
  shared_ptr<long> port{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateName{};

  DescribeCloudGtmAddressPoolResponseBodyAddressesAddressHealthTasksHealthTask() {}

  explicit DescribeCloudGtmAddressPoolResponseBodyAddressesAddressHealthTasksHealthTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
  }


  virtual ~DescribeCloudGtmAddressPoolResponseBodyAddressesAddressHealthTasksHealthTask() = default;
};
class DescribeCloudGtmAddressPoolResponseBodyAddressesAddressHealthTasks : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCloudGtmAddressPoolResponseBodyAddressesAddressHealthTasksHealthTask>> healthTask{};

  DescribeCloudGtmAddressPoolResponseBodyAddressesAddressHealthTasks() {}

  explicit DescribeCloudGtmAddressPoolResponseBodyAddressesAddressHealthTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (healthTask) {
      vector<boost::any> temp1;
      for(auto item1:*healthTask){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HealthTask"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HealthTask") != m.end() && !m["HealthTask"].empty()) {
      if (typeid(vector<boost::any>) == m["HealthTask"].type()) {
        vector<DescribeCloudGtmAddressPoolResponseBodyAddressesAddressHealthTasksHealthTask> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HealthTask"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCloudGtmAddressPoolResponseBodyAddressesAddressHealthTasksHealthTask model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        healthTask = make_shared<vector<DescribeCloudGtmAddressPoolResponseBodyAddressesAddressHealthTasksHealthTask>>(expect1);
      }
    }
  }


  virtual ~DescribeCloudGtmAddressPoolResponseBodyAddressesAddressHealthTasks() = default;
};
class DescribeCloudGtmAddressPoolResponseBodyAddressesAddressRequestSource : public Darabonba::Model {
public:
  shared_ptr<vector<string>> requestSource{};

  DescribeCloudGtmAddressPoolResponseBodyAddressesAddressRequestSource() {}

  explicit DescribeCloudGtmAddressPoolResponseBodyAddressesAddressRequestSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestSource) {
      res["RequestSource"] = boost::any(*requestSource);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestSource") != m.end() && !m["RequestSource"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RequestSource"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RequestSource"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      requestSource = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeCloudGtmAddressPoolResponseBodyAddressesAddressRequestSource() = default;
};
class DescribeCloudGtmAddressPoolResponseBodyAddressesAddress : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> addressId{};
  shared_ptr<string> attributeInfo{};
  shared_ptr<string> availableMode{};
  shared_ptr<string> availableStatus{};
  shared_ptr<string> createTime{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<string> enableStatus{};
  shared_ptr<string> healthJudgement{};
  shared_ptr<string> healthStatus{};
  shared_ptr<DescribeCloudGtmAddressPoolResponseBodyAddressesAddressHealthTasks> healthTasks{};
  shared_ptr<string> manualAvailableStatus{};
  shared_ptr<string> name{};
  shared_ptr<string> remark{};
  shared_ptr<DescribeCloudGtmAddressPoolResponseBodyAddressesAddressRequestSource> requestSource{};
  shared_ptr<bool> seqNonPreemptiveSchedule{};
  shared_ptr<long> serialNumber{};
  shared_ptr<string> type{};
  shared_ptr<string> updateTime{};
  shared_ptr<long> updateTimestamp{};
  shared_ptr<long> weightValue{};

  DescribeCloudGtmAddressPoolResponseBodyAddressesAddress() {}

  explicit DescribeCloudGtmAddressPoolResponseBodyAddressesAddress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (addressId) {
      res["AddressId"] = boost::any(*addressId);
    }
    if (attributeInfo) {
      res["AttributeInfo"] = boost::any(*attributeInfo);
    }
    if (availableMode) {
      res["AvailableMode"] = boost::any(*availableMode);
    }
    if (availableStatus) {
      res["AvailableStatus"] = boost::any(*availableStatus);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (enableStatus) {
      res["EnableStatus"] = boost::any(*enableStatus);
    }
    if (healthJudgement) {
      res["HealthJudgement"] = boost::any(*healthJudgement);
    }
    if (healthStatus) {
      res["HealthStatus"] = boost::any(*healthStatus);
    }
    if (healthTasks) {
      res["HealthTasks"] = healthTasks ? boost::any(healthTasks->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (manualAvailableStatus) {
      res["ManualAvailableStatus"] = boost::any(*manualAvailableStatus);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (requestSource) {
      res["RequestSource"] = requestSource ? boost::any(requestSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (seqNonPreemptiveSchedule) {
      res["SeqNonPreemptiveSchedule"] = boost::any(*seqNonPreemptiveSchedule);
    }
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (updateTimestamp) {
      res["UpdateTimestamp"] = boost::any(*updateTimestamp);
    }
    if (weightValue) {
      res["WeightValue"] = boost::any(*weightValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("AddressId") != m.end() && !m["AddressId"].empty()) {
      addressId = make_shared<string>(boost::any_cast<string>(m["AddressId"]));
    }
    if (m.find("AttributeInfo") != m.end() && !m["AttributeInfo"].empty()) {
      attributeInfo = make_shared<string>(boost::any_cast<string>(m["AttributeInfo"]));
    }
    if (m.find("AvailableMode") != m.end() && !m["AvailableMode"].empty()) {
      availableMode = make_shared<string>(boost::any_cast<string>(m["AvailableMode"]));
    }
    if (m.find("AvailableStatus") != m.end() && !m["AvailableStatus"].empty()) {
      availableStatus = make_shared<string>(boost::any_cast<string>(m["AvailableStatus"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("EnableStatus") != m.end() && !m["EnableStatus"].empty()) {
      enableStatus = make_shared<string>(boost::any_cast<string>(m["EnableStatus"]));
    }
    if (m.find("HealthJudgement") != m.end() && !m["HealthJudgement"].empty()) {
      healthJudgement = make_shared<string>(boost::any_cast<string>(m["HealthJudgement"]));
    }
    if (m.find("HealthStatus") != m.end() && !m["HealthStatus"].empty()) {
      healthStatus = make_shared<string>(boost::any_cast<string>(m["HealthStatus"]));
    }
    if (m.find("HealthTasks") != m.end() && !m["HealthTasks"].empty()) {
      if (typeid(map<string, boost::any>) == m["HealthTasks"].type()) {
        DescribeCloudGtmAddressPoolResponseBodyAddressesAddressHealthTasks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HealthTasks"]));
        healthTasks = make_shared<DescribeCloudGtmAddressPoolResponseBodyAddressesAddressHealthTasks>(model1);
      }
    }
    if (m.find("ManualAvailableStatus") != m.end() && !m["ManualAvailableStatus"].empty()) {
      manualAvailableStatus = make_shared<string>(boost::any_cast<string>(m["ManualAvailableStatus"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("RequestSource") != m.end() && !m["RequestSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["RequestSource"].type()) {
        DescribeCloudGtmAddressPoolResponseBodyAddressesAddressRequestSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RequestSource"]));
        requestSource = make_shared<DescribeCloudGtmAddressPoolResponseBodyAddressesAddressRequestSource>(model1);
      }
    }
    if (m.find("SeqNonPreemptiveSchedule") != m.end() && !m["SeqNonPreemptiveSchedule"].empty()) {
      seqNonPreemptiveSchedule = make_shared<bool>(boost::any_cast<bool>(m["SeqNonPreemptiveSchedule"]));
    }
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<long>(boost::any_cast<long>(m["SerialNumber"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("UpdateTimestamp") != m.end() && !m["UpdateTimestamp"].empty()) {
      updateTimestamp = make_shared<long>(boost::any_cast<long>(m["UpdateTimestamp"]));
    }
    if (m.find("WeightValue") != m.end() && !m["WeightValue"].empty()) {
      weightValue = make_shared<long>(boost::any_cast<long>(m["WeightValue"]));
    }
  }


  virtual ~DescribeCloudGtmAddressPoolResponseBodyAddressesAddress() = default;
};
class DescribeCloudGtmAddressPoolResponseBodyAddresses : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCloudGtmAddressPoolResponseBodyAddressesAddress>> address{};

  DescribeCloudGtmAddressPoolResponseBodyAddresses() {}

  explicit DescribeCloudGtmAddressPoolResponseBodyAddresses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      vector<boost::any> temp1;
      for(auto item1:*address){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Address"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      if (typeid(vector<boost::any>) == m["Address"].type()) {
        vector<DescribeCloudGtmAddressPoolResponseBodyAddressesAddress> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Address"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCloudGtmAddressPoolResponseBodyAddressesAddress model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        address = make_shared<vector<DescribeCloudGtmAddressPoolResponseBodyAddressesAddress>>(expect1);
      }
    }
  }


  virtual ~DescribeCloudGtmAddressPoolResponseBodyAddresses() = default;
};
class DescribeCloudGtmAddressPoolResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> addressLbStrategy{};
  shared_ptr<string> addressPoolId{};
  shared_ptr<string> addressPoolName{};
  shared_ptr<string> addressPoolType{};
  shared_ptr<DescribeCloudGtmAddressPoolResponseBodyAddresses> addresses{};
  shared_ptr<string> availableStatus{};
  shared_ptr<string> createTime{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<string> enableStatus{};
  shared_ptr<string> healthJudgement{};
  shared_ptr<string> healthStatus{};
  shared_ptr<string> remark{};
  shared_ptr<string> requestId{};
  shared_ptr<string> sequenceLbStrategyMode{};
  shared_ptr<string> updateTime{};
  shared_ptr<long> updateTimestamp{};

  DescribeCloudGtmAddressPoolResponseBody() {}

  explicit DescribeCloudGtmAddressPoolResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addressLbStrategy) {
      res["AddressLbStrategy"] = boost::any(*addressLbStrategy);
    }
    if (addressPoolId) {
      res["AddressPoolId"] = boost::any(*addressPoolId);
    }
    if (addressPoolName) {
      res["AddressPoolName"] = boost::any(*addressPoolName);
    }
    if (addressPoolType) {
      res["AddressPoolType"] = boost::any(*addressPoolType);
    }
    if (addresses) {
      res["Addresses"] = addresses ? boost::any(addresses->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (availableStatus) {
      res["AvailableStatus"] = boost::any(*availableStatus);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (enableStatus) {
      res["EnableStatus"] = boost::any(*enableStatus);
    }
    if (healthJudgement) {
      res["HealthJudgement"] = boost::any(*healthJudgement);
    }
    if (healthStatus) {
      res["HealthStatus"] = boost::any(*healthStatus);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sequenceLbStrategyMode) {
      res["SequenceLbStrategyMode"] = boost::any(*sequenceLbStrategyMode);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (updateTimestamp) {
      res["UpdateTimestamp"] = boost::any(*updateTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddressLbStrategy") != m.end() && !m["AddressLbStrategy"].empty()) {
      addressLbStrategy = make_shared<string>(boost::any_cast<string>(m["AddressLbStrategy"]));
    }
    if (m.find("AddressPoolId") != m.end() && !m["AddressPoolId"].empty()) {
      addressPoolId = make_shared<string>(boost::any_cast<string>(m["AddressPoolId"]));
    }
    if (m.find("AddressPoolName") != m.end() && !m["AddressPoolName"].empty()) {
      addressPoolName = make_shared<string>(boost::any_cast<string>(m["AddressPoolName"]));
    }
    if (m.find("AddressPoolType") != m.end() && !m["AddressPoolType"].empty()) {
      addressPoolType = make_shared<string>(boost::any_cast<string>(m["AddressPoolType"]));
    }
    if (m.find("Addresses") != m.end() && !m["Addresses"].empty()) {
      if (typeid(map<string, boost::any>) == m["Addresses"].type()) {
        DescribeCloudGtmAddressPoolResponseBodyAddresses model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Addresses"]));
        addresses = make_shared<DescribeCloudGtmAddressPoolResponseBodyAddresses>(model1);
      }
    }
    if (m.find("AvailableStatus") != m.end() && !m["AvailableStatus"].empty()) {
      availableStatus = make_shared<string>(boost::any_cast<string>(m["AvailableStatus"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("EnableStatus") != m.end() && !m["EnableStatus"].empty()) {
      enableStatus = make_shared<string>(boost::any_cast<string>(m["EnableStatus"]));
    }
    if (m.find("HealthJudgement") != m.end() && !m["HealthJudgement"].empty()) {
      healthJudgement = make_shared<string>(boost::any_cast<string>(m["HealthJudgement"]));
    }
    if (m.find("HealthStatus") != m.end() && !m["HealthStatus"].empty()) {
      healthStatus = make_shared<string>(boost::any_cast<string>(m["HealthStatus"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SequenceLbStrategyMode") != m.end() && !m["SequenceLbStrategyMode"].empty()) {
      sequenceLbStrategyMode = make_shared<string>(boost::any_cast<string>(m["SequenceLbStrategyMode"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("UpdateTimestamp") != m.end() && !m["UpdateTimestamp"].empty()) {
      updateTimestamp = make_shared<long>(boost::any_cast<long>(m["UpdateTimestamp"]));
    }
  }


  virtual ~DescribeCloudGtmAddressPoolResponseBody() = default;
};
class DescribeCloudGtmAddressPoolResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCloudGtmAddressPoolResponseBody> body{};

  DescribeCloudGtmAddressPoolResponse() {}

  explicit DescribeCloudGtmAddressPoolResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCloudGtmAddressPoolResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCloudGtmAddressPoolResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCloudGtmAddressPoolResponse() = default;
};
class DescribeCloudGtmAddressPoolReferenceRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> addressPoolId{};
  shared_ptr<string> clientToken{};

  DescribeCloudGtmAddressPoolReferenceRequest() {}

  explicit DescribeCloudGtmAddressPoolReferenceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (addressPoolId) {
      res["AddressPoolId"] = boost::any(*addressPoolId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AddressPoolId") != m.end() && !m["AddressPoolId"].empty()) {
      addressPoolId = make_shared<string>(boost::any_cast<string>(m["AddressPoolId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
  }


  virtual ~DescribeCloudGtmAddressPoolReferenceRequest() = default;
};
class DescribeCloudGtmAddressPoolReferenceResponseBodyInstanceConfigsInstanceConfig : public Darabonba::Model {
public:
  shared_ptr<string> addressPoolLbStrategy{};
  shared_ptr<string> availableStatus{};
  shared_ptr<string> configId{};
  shared_ptr<string> enableStatus{};
  shared_ptr<string> healthStatus{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> remark{};
  shared_ptr<string> scheduleDomainName{};
  shared_ptr<string> scheduleHostname{};
  shared_ptr<string> scheduleRrType{};
  shared_ptr<string> scheduleZoneName{};
  shared_ptr<string> sequenceLbStrategyMode{};
  shared_ptr<long> ttl{};
  shared_ptr<string> versionCode{};

  DescribeCloudGtmAddressPoolReferenceResponseBodyInstanceConfigsInstanceConfig() {}

  explicit DescribeCloudGtmAddressPoolReferenceResponseBodyInstanceConfigsInstanceConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addressPoolLbStrategy) {
      res["AddressPoolLbStrategy"] = boost::any(*addressPoolLbStrategy);
    }
    if (availableStatus) {
      res["AvailableStatus"] = boost::any(*availableStatus);
    }
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (enableStatus) {
      res["EnableStatus"] = boost::any(*enableStatus);
    }
    if (healthStatus) {
      res["HealthStatus"] = boost::any(*healthStatus);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (scheduleDomainName) {
      res["ScheduleDomainName"] = boost::any(*scheduleDomainName);
    }
    if (scheduleHostname) {
      res["ScheduleHostname"] = boost::any(*scheduleHostname);
    }
    if (scheduleRrType) {
      res["ScheduleRrType"] = boost::any(*scheduleRrType);
    }
    if (scheduleZoneName) {
      res["ScheduleZoneName"] = boost::any(*scheduleZoneName);
    }
    if (sequenceLbStrategyMode) {
      res["SequenceLbStrategyMode"] = boost::any(*sequenceLbStrategyMode);
    }
    if (ttl) {
      res["Ttl"] = boost::any(*ttl);
    }
    if (versionCode) {
      res["VersionCode"] = boost::any(*versionCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddressPoolLbStrategy") != m.end() && !m["AddressPoolLbStrategy"].empty()) {
      addressPoolLbStrategy = make_shared<string>(boost::any_cast<string>(m["AddressPoolLbStrategy"]));
    }
    if (m.find("AvailableStatus") != m.end() && !m["AvailableStatus"].empty()) {
      availableStatus = make_shared<string>(boost::any_cast<string>(m["AvailableStatus"]));
    }
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("EnableStatus") != m.end() && !m["EnableStatus"].empty()) {
      enableStatus = make_shared<string>(boost::any_cast<string>(m["EnableStatus"]));
    }
    if (m.find("HealthStatus") != m.end() && !m["HealthStatus"].empty()) {
      healthStatus = make_shared<string>(boost::any_cast<string>(m["HealthStatus"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("ScheduleDomainName") != m.end() && !m["ScheduleDomainName"].empty()) {
      scheduleDomainName = make_shared<string>(boost::any_cast<string>(m["ScheduleDomainName"]));
    }
    if (m.find("ScheduleHostname") != m.end() && !m["ScheduleHostname"].empty()) {
      scheduleHostname = make_shared<string>(boost::any_cast<string>(m["ScheduleHostname"]));
    }
    if (m.find("ScheduleRrType") != m.end() && !m["ScheduleRrType"].empty()) {
      scheduleRrType = make_shared<string>(boost::any_cast<string>(m["ScheduleRrType"]));
    }
    if (m.find("ScheduleZoneName") != m.end() && !m["ScheduleZoneName"].empty()) {
      scheduleZoneName = make_shared<string>(boost::any_cast<string>(m["ScheduleZoneName"]));
    }
    if (m.find("SequenceLbStrategyMode") != m.end() && !m["SequenceLbStrategyMode"].empty()) {
      sequenceLbStrategyMode = make_shared<string>(boost::any_cast<string>(m["SequenceLbStrategyMode"]));
    }
    if (m.find("Ttl") != m.end() && !m["Ttl"].empty()) {
      ttl = make_shared<long>(boost::any_cast<long>(m["Ttl"]));
    }
    if (m.find("VersionCode") != m.end() && !m["VersionCode"].empty()) {
      versionCode = make_shared<string>(boost::any_cast<string>(m["VersionCode"]));
    }
  }


  virtual ~DescribeCloudGtmAddressPoolReferenceResponseBodyInstanceConfigsInstanceConfig() = default;
};
class DescribeCloudGtmAddressPoolReferenceResponseBodyInstanceConfigs : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCloudGtmAddressPoolReferenceResponseBodyInstanceConfigsInstanceConfig>> instanceConfig{};

  DescribeCloudGtmAddressPoolReferenceResponseBodyInstanceConfigs() {}

  explicit DescribeCloudGtmAddressPoolReferenceResponseBodyInstanceConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceConfig) {
      vector<boost::any> temp1;
      for(auto item1:*instanceConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceConfig"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceConfig") != m.end() && !m["InstanceConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceConfig"].type()) {
        vector<DescribeCloudGtmAddressPoolReferenceResponseBodyInstanceConfigsInstanceConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCloudGtmAddressPoolReferenceResponseBodyInstanceConfigsInstanceConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceConfig = make_shared<vector<DescribeCloudGtmAddressPoolReferenceResponseBodyInstanceConfigsInstanceConfig>>(expect1);
      }
    }
  }


  virtual ~DescribeCloudGtmAddressPoolReferenceResponseBodyInstanceConfigs() = default;
};
class DescribeCloudGtmAddressPoolReferenceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> addressPoolId{};
  shared_ptr<string> addressPoolName{};
  shared_ptr<DescribeCloudGtmAddressPoolReferenceResponseBodyInstanceConfigs> instanceConfigs{};
  shared_ptr<string> requestId{};

  DescribeCloudGtmAddressPoolReferenceResponseBody() {}

  explicit DescribeCloudGtmAddressPoolReferenceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addressPoolId) {
      res["AddressPoolId"] = boost::any(*addressPoolId);
    }
    if (addressPoolName) {
      res["AddressPoolName"] = boost::any(*addressPoolName);
    }
    if (instanceConfigs) {
      res["InstanceConfigs"] = instanceConfigs ? boost::any(instanceConfigs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddressPoolId") != m.end() && !m["AddressPoolId"].empty()) {
      addressPoolId = make_shared<string>(boost::any_cast<string>(m["AddressPoolId"]));
    }
    if (m.find("AddressPoolName") != m.end() && !m["AddressPoolName"].empty()) {
      addressPoolName = make_shared<string>(boost::any_cast<string>(m["AddressPoolName"]));
    }
    if (m.find("InstanceConfigs") != m.end() && !m["InstanceConfigs"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceConfigs"].type()) {
        DescribeCloudGtmAddressPoolReferenceResponseBodyInstanceConfigs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceConfigs"]));
        instanceConfigs = make_shared<DescribeCloudGtmAddressPoolReferenceResponseBodyInstanceConfigs>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeCloudGtmAddressPoolReferenceResponseBody() = default;
};
class DescribeCloudGtmAddressPoolReferenceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCloudGtmAddressPoolReferenceResponseBody> body{};

  DescribeCloudGtmAddressPoolReferenceResponse() {}

  explicit DescribeCloudGtmAddressPoolReferenceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCloudGtmAddressPoolReferenceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCloudGtmAddressPoolReferenceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCloudGtmAddressPoolReferenceResponse() = default;
};
class DescribeCloudGtmAddressReferenceRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> addressId{};
  shared_ptr<string> clientToken{};

  DescribeCloudGtmAddressReferenceRequest() {}

  explicit DescribeCloudGtmAddressReferenceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (addressId) {
      res["AddressId"] = boost::any(*addressId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AddressId") != m.end() && !m["AddressId"].empty()) {
      addressId = make_shared<string>(boost::any_cast<string>(m["AddressId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
  }


  virtual ~DescribeCloudGtmAddressReferenceRequest() = default;
};
class DescribeCloudGtmAddressReferenceResponseBodyAddressPoolsAddressPoolInstanceConfigsInstanceConfig : public Darabonba::Model {
public:
  shared_ptr<string> addressPoolLbStrategy{};
  shared_ptr<string> availableStatus{};
  shared_ptr<string> configId{};
  shared_ptr<string> enableStatus{};
  shared_ptr<string> healthStatus{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> remark{};
  shared_ptr<string> scheduleDomainName{};
  shared_ptr<string> scheduleHostname{};
  shared_ptr<string> scheduleRrType{};
  shared_ptr<string> scheduleZoneName{};
  shared_ptr<string> sequenceLbStrategyMode{};
  shared_ptr<long> ttl{};
  shared_ptr<string> versionCode{};

  DescribeCloudGtmAddressReferenceResponseBodyAddressPoolsAddressPoolInstanceConfigsInstanceConfig() {}

  explicit DescribeCloudGtmAddressReferenceResponseBodyAddressPoolsAddressPoolInstanceConfigsInstanceConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addressPoolLbStrategy) {
      res["AddressPoolLbStrategy"] = boost::any(*addressPoolLbStrategy);
    }
    if (availableStatus) {
      res["AvailableStatus"] = boost::any(*availableStatus);
    }
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (enableStatus) {
      res["EnableStatus"] = boost::any(*enableStatus);
    }
    if (healthStatus) {
      res["HealthStatus"] = boost::any(*healthStatus);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (scheduleDomainName) {
      res["ScheduleDomainName"] = boost::any(*scheduleDomainName);
    }
    if (scheduleHostname) {
      res["ScheduleHostname"] = boost::any(*scheduleHostname);
    }
    if (scheduleRrType) {
      res["ScheduleRrType"] = boost::any(*scheduleRrType);
    }
    if (scheduleZoneName) {
      res["ScheduleZoneName"] = boost::any(*scheduleZoneName);
    }
    if (sequenceLbStrategyMode) {
      res["SequenceLbStrategyMode"] = boost::any(*sequenceLbStrategyMode);
    }
    if (ttl) {
      res["Ttl"] = boost::any(*ttl);
    }
    if (versionCode) {
      res["VersionCode"] = boost::any(*versionCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddressPoolLbStrategy") != m.end() && !m["AddressPoolLbStrategy"].empty()) {
      addressPoolLbStrategy = make_shared<string>(boost::any_cast<string>(m["AddressPoolLbStrategy"]));
    }
    if (m.find("AvailableStatus") != m.end() && !m["AvailableStatus"].empty()) {
      availableStatus = make_shared<string>(boost::any_cast<string>(m["AvailableStatus"]));
    }
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("EnableStatus") != m.end() && !m["EnableStatus"].empty()) {
      enableStatus = make_shared<string>(boost::any_cast<string>(m["EnableStatus"]));
    }
    if (m.find("HealthStatus") != m.end() && !m["HealthStatus"].empty()) {
      healthStatus = make_shared<string>(boost::any_cast<string>(m["HealthStatus"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("ScheduleDomainName") != m.end() && !m["ScheduleDomainName"].empty()) {
      scheduleDomainName = make_shared<string>(boost::any_cast<string>(m["ScheduleDomainName"]));
    }
    if (m.find("ScheduleHostname") != m.end() && !m["ScheduleHostname"].empty()) {
      scheduleHostname = make_shared<string>(boost::any_cast<string>(m["ScheduleHostname"]));
    }
    if (m.find("ScheduleRrType") != m.end() && !m["ScheduleRrType"].empty()) {
      scheduleRrType = make_shared<string>(boost::any_cast<string>(m["ScheduleRrType"]));
    }
    if (m.find("ScheduleZoneName") != m.end() && !m["ScheduleZoneName"].empty()) {
      scheduleZoneName = make_shared<string>(boost::any_cast<string>(m["ScheduleZoneName"]));
    }
    if (m.find("SequenceLbStrategyMode") != m.end() && !m["SequenceLbStrategyMode"].empty()) {
      sequenceLbStrategyMode = make_shared<string>(boost::any_cast<string>(m["SequenceLbStrategyMode"]));
    }
    if (m.find("Ttl") != m.end() && !m["Ttl"].empty()) {
      ttl = make_shared<long>(boost::any_cast<long>(m["Ttl"]));
    }
    if (m.find("VersionCode") != m.end() && !m["VersionCode"].empty()) {
      versionCode = make_shared<string>(boost::any_cast<string>(m["VersionCode"]));
    }
  }


  virtual ~DescribeCloudGtmAddressReferenceResponseBodyAddressPoolsAddressPoolInstanceConfigsInstanceConfig() = default;
};
class DescribeCloudGtmAddressReferenceResponseBodyAddressPoolsAddressPoolInstanceConfigs : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCloudGtmAddressReferenceResponseBodyAddressPoolsAddressPoolInstanceConfigsInstanceConfig>> instanceConfig{};

  DescribeCloudGtmAddressReferenceResponseBodyAddressPoolsAddressPoolInstanceConfigs() {}

  explicit DescribeCloudGtmAddressReferenceResponseBodyAddressPoolsAddressPoolInstanceConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceConfig) {
      vector<boost::any> temp1;
      for(auto item1:*instanceConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceConfig"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceConfig") != m.end() && !m["InstanceConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceConfig"].type()) {
        vector<DescribeCloudGtmAddressReferenceResponseBodyAddressPoolsAddressPoolInstanceConfigsInstanceConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCloudGtmAddressReferenceResponseBodyAddressPoolsAddressPoolInstanceConfigsInstanceConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceConfig = make_shared<vector<DescribeCloudGtmAddressReferenceResponseBodyAddressPoolsAddressPoolInstanceConfigsInstanceConfig>>(expect1);
      }
    }
  }


  virtual ~DescribeCloudGtmAddressReferenceResponseBodyAddressPoolsAddressPoolInstanceConfigs() = default;
};
class DescribeCloudGtmAddressReferenceResponseBodyAddressPoolsAddressPool : public Darabonba::Model {
public:
  shared_ptr<string> addressLbStrategy{};
  shared_ptr<string> addressPoolId{};
  shared_ptr<string> addressPoolName{};
  shared_ptr<string> addressPoolType{};
  shared_ptr<string> availableStatus{};
  shared_ptr<string> enableStatus{};
  shared_ptr<string> healthJudgement{};
  shared_ptr<string> healthStatus{};
  shared_ptr<DescribeCloudGtmAddressReferenceResponseBodyAddressPoolsAddressPoolInstanceConfigs> instanceConfigs{};
  shared_ptr<string> remark{};
  shared_ptr<string> sequenceLbStrategyMode{};

  DescribeCloudGtmAddressReferenceResponseBodyAddressPoolsAddressPool() {}

  explicit DescribeCloudGtmAddressReferenceResponseBodyAddressPoolsAddressPool(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addressLbStrategy) {
      res["AddressLbStrategy"] = boost::any(*addressLbStrategy);
    }
    if (addressPoolId) {
      res["AddressPoolId"] = boost::any(*addressPoolId);
    }
    if (addressPoolName) {
      res["AddressPoolName"] = boost::any(*addressPoolName);
    }
    if (addressPoolType) {
      res["AddressPoolType"] = boost::any(*addressPoolType);
    }
    if (availableStatus) {
      res["AvailableStatus"] = boost::any(*availableStatus);
    }
    if (enableStatus) {
      res["EnableStatus"] = boost::any(*enableStatus);
    }
    if (healthJudgement) {
      res["HealthJudgement"] = boost::any(*healthJudgement);
    }
    if (healthStatus) {
      res["HealthStatus"] = boost::any(*healthStatus);
    }
    if (instanceConfigs) {
      res["InstanceConfigs"] = instanceConfigs ? boost::any(instanceConfigs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (sequenceLbStrategyMode) {
      res["SequenceLbStrategyMode"] = boost::any(*sequenceLbStrategyMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddressLbStrategy") != m.end() && !m["AddressLbStrategy"].empty()) {
      addressLbStrategy = make_shared<string>(boost::any_cast<string>(m["AddressLbStrategy"]));
    }
    if (m.find("AddressPoolId") != m.end() && !m["AddressPoolId"].empty()) {
      addressPoolId = make_shared<string>(boost::any_cast<string>(m["AddressPoolId"]));
    }
    if (m.find("AddressPoolName") != m.end() && !m["AddressPoolName"].empty()) {
      addressPoolName = make_shared<string>(boost::any_cast<string>(m["AddressPoolName"]));
    }
    if (m.find("AddressPoolType") != m.end() && !m["AddressPoolType"].empty()) {
      addressPoolType = make_shared<string>(boost::any_cast<string>(m["AddressPoolType"]));
    }
    if (m.find("AvailableStatus") != m.end() && !m["AvailableStatus"].empty()) {
      availableStatus = make_shared<string>(boost::any_cast<string>(m["AvailableStatus"]));
    }
    if (m.find("EnableStatus") != m.end() && !m["EnableStatus"].empty()) {
      enableStatus = make_shared<string>(boost::any_cast<string>(m["EnableStatus"]));
    }
    if (m.find("HealthJudgement") != m.end() && !m["HealthJudgement"].empty()) {
      healthJudgement = make_shared<string>(boost::any_cast<string>(m["HealthJudgement"]));
    }
    if (m.find("HealthStatus") != m.end() && !m["HealthStatus"].empty()) {
      healthStatus = make_shared<string>(boost::any_cast<string>(m["HealthStatus"]));
    }
    if (m.find("InstanceConfigs") != m.end() && !m["InstanceConfigs"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceConfigs"].type()) {
        DescribeCloudGtmAddressReferenceResponseBodyAddressPoolsAddressPoolInstanceConfigs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceConfigs"]));
        instanceConfigs = make_shared<DescribeCloudGtmAddressReferenceResponseBodyAddressPoolsAddressPoolInstanceConfigs>(model1);
      }
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("SequenceLbStrategyMode") != m.end() && !m["SequenceLbStrategyMode"].empty()) {
      sequenceLbStrategyMode = make_shared<string>(boost::any_cast<string>(m["SequenceLbStrategyMode"]));
    }
  }


  virtual ~DescribeCloudGtmAddressReferenceResponseBodyAddressPoolsAddressPool() = default;
};
class DescribeCloudGtmAddressReferenceResponseBodyAddressPools : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCloudGtmAddressReferenceResponseBodyAddressPoolsAddressPool>> addressPool{};

  DescribeCloudGtmAddressReferenceResponseBodyAddressPools() {}

  explicit DescribeCloudGtmAddressReferenceResponseBodyAddressPools(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addressPool) {
      vector<boost::any> temp1;
      for(auto item1:*addressPool){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AddressPool"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddressPool") != m.end() && !m["AddressPool"].empty()) {
      if (typeid(vector<boost::any>) == m["AddressPool"].type()) {
        vector<DescribeCloudGtmAddressReferenceResponseBodyAddressPoolsAddressPool> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AddressPool"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCloudGtmAddressReferenceResponseBodyAddressPoolsAddressPool model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        addressPool = make_shared<vector<DescribeCloudGtmAddressReferenceResponseBodyAddressPoolsAddressPool>>(expect1);
      }
    }
  }


  virtual ~DescribeCloudGtmAddressReferenceResponseBodyAddressPools() = default;
};
class DescribeCloudGtmAddressReferenceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> addressId{};
  shared_ptr<DescribeCloudGtmAddressReferenceResponseBodyAddressPools> addressPools{};
  shared_ptr<string> name{};
  shared_ptr<string> requestId{};

  DescribeCloudGtmAddressReferenceResponseBody() {}

  explicit DescribeCloudGtmAddressReferenceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (addressId) {
      res["AddressId"] = boost::any(*addressId);
    }
    if (addressPools) {
      res["AddressPools"] = addressPools ? boost::any(addressPools->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("AddressId") != m.end() && !m["AddressId"].empty()) {
      addressId = make_shared<string>(boost::any_cast<string>(m["AddressId"]));
    }
    if (m.find("AddressPools") != m.end() && !m["AddressPools"].empty()) {
      if (typeid(map<string, boost::any>) == m["AddressPools"].type()) {
        DescribeCloudGtmAddressReferenceResponseBodyAddressPools model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AddressPools"]));
        addressPools = make_shared<DescribeCloudGtmAddressReferenceResponseBodyAddressPools>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeCloudGtmAddressReferenceResponseBody() = default;
};
class DescribeCloudGtmAddressReferenceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCloudGtmAddressReferenceResponseBody> body{};

  DescribeCloudGtmAddressReferenceResponse() {}

  explicit DescribeCloudGtmAddressReferenceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCloudGtmAddressReferenceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCloudGtmAddressReferenceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCloudGtmAddressReferenceResponse() = default;
};
class DescribeCloudGtmGlobalAlertRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> clientToken{};

  DescribeCloudGtmGlobalAlertRequest() {}

  explicit DescribeCloudGtmGlobalAlertRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
  }


  virtual ~DescribeCloudGtmGlobalAlertRequest() = default;
};
class DescribeCloudGtmGlobalAlertResponseBodyAlertConfigAlertConfig : public Darabonba::Model {
public:
  shared_ptr<bool> dingtalkNotice{};
  shared_ptr<bool> emailNotice{};
  shared_ptr<string> noticeType{};
  shared_ptr<bool> smsNotice{};

  DescribeCloudGtmGlobalAlertResponseBodyAlertConfigAlertConfig() {}

  explicit DescribeCloudGtmGlobalAlertResponseBodyAlertConfigAlertConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dingtalkNotice) {
      res["DingtalkNotice"] = boost::any(*dingtalkNotice);
    }
    if (emailNotice) {
      res["EmailNotice"] = boost::any(*emailNotice);
    }
    if (noticeType) {
      res["NoticeType"] = boost::any(*noticeType);
    }
    if (smsNotice) {
      res["SmsNotice"] = boost::any(*smsNotice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DingtalkNotice") != m.end() && !m["DingtalkNotice"].empty()) {
      dingtalkNotice = make_shared<bool>(boost::any_cast<bool>(m["DingtalkNotice"]));
    }
    if (m.find("EmailNotice") != m.end() && !m["EmailNotice"].empty()) {
      emailNotice = make_shared<bool>(boost::any_cast<bool>(m["EmailNotice"]));
    }
    if (m.find("NoticeType") != m.end() && !m["NoticeType"].empty()) {
      noticeType = make_shared<string>(boost::any_cast<string>(m["NoticeType"]));
    }
    if (m.find("SmsNotice") != m.end() && !m["SmsNotice"].empty()) {
      smsNotice = make_shared<bool>(boost::any_cast<bool>(m["SmsNotice"]));
    }
  }


  virtual ~DescribeCloudGtmGlobalAlertResponseBodyAlertConfigAlertConfig() = default;
};
class DescribeCloudGtmGlobalAlertResponseBodyAlertConfig : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCloudGtmGlobalAlertResponseBodyAlertConfigAlertConfig>> alertConfig{};

  DescribeCloudGtmGlobalAlertResponseBodyAlertConfig() {}

  explicit DescribeCloudGtmGlobalAlertResponseBodyAlertConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertConfig) {
      vector<boost::any> temp1;
      for(auto item1:*alertConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlertConfig"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertConfig") != m.end() && !m["AlertConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["AlertConfig"].type()) {
        vector<DescribeCloudGtmGlobalAlertResponseBodyAlertConfigAlertConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlertConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCloudGtmGlobalAlertResponseBodyAlertConfigAlertConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alertConfig = make_shared<vector<DescribeCloudGtmGlobalAlertResponseBodyAlertConfigAlertConfig>>(expect1);
      }
    }
  }


  virtual ~DescribeCloudGtmGlobalAlertResponseBodyAlertConfig() = default;
};
class DescribeCloudGtmGlobalAlertResponseBodyAlertGroup : public Darabonba::Model {
public:
  shared_ptr<vector<string>> alertGroup{};

  DescribeCloudGtmGlobalAlertResponseBodyAlertGroup() {}

  explicit DescribeCloudGtmGlobalAlertResponseBodyAlertGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertGroup) {
      res["AlertGroup"] = boost::any(*alertGroup);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertGroup") != m.end() && !m["AlertGroup"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AlertGroup"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AlertGroup"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      alertGroup = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeCloudGtmGlobalAlertResponseBodyAlertGroup() = default;
};
class DescribeCloudGtmGlobalAlertResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeCloudGtmGlobalAlertResponseBodyAlertConfig> alertConfig{};
  shared_ptr<DescribeCloudGtmGlobalAlertResponseBodyAlertGroup> alertGroup{};
  shared_ptr<string> requestId{};

  DescribeCloudGtmGlobalAlertResponseBody() {}

  explicit DescribeCloudGtmGlobalAlertResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertConfig) {
      res["AlertConfig"] = alertConfig ? boost::any(alertConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (alertGroup) {
      res["AlertGroup"] = alertGroup ? boost::any(alertGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertConfig") != m.end() && !m["AlertConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["AlertConfig"].type()) {
        DescribeCloudGtmGlobalAlertResponseBodyAlertConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AlertConfig"]));
        alertConfig = make_shared<DescribeCloudGtmGlobalAlertResponseBodyAlertConfig>(model1);
      }
    }
    if (m.find("AlertGroup") != m.end() && !m["AlertGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["AlertGroup"].type()) {
        DescribeCloudGtmGlobalAlertResponseBodyAlertGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AlertGroup"]));
        alertGroup = make_shared<DescribeCloudGtmGlobalAlertResponseBodyAlertGroup>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeCloudGtmGlobalAlertResponseBody() = default;
};
class DescribeCloudGtmGlobalAlertResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCloudGtmGlobalAlertResponseBody> body{};

  DescribeCloudGtmGlobalAlertResponse() {}

  explicit DescribeCloudGtmGlobalAlertResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCloudGtmGlobalAlertResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCloudGtmGlobalAlertResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCloudGtmGlobalAlertResponse() = default;
};
class DescribeCloudGtmInstanceConfigAlertRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> configId{};
  shared_ptr<string> instanceId{};

  DescribeCloudGtmInstanceConfigAlertRequest() {}

  explicit DescribeCloudGtmInstanceConfigAlertRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DescribeCloudGtmInstanceConfigAlertRequest() = default;
};
class DescribeCloudGtmInstanceConfigAlertResponseBodyAlertConfigAlertConfig : public Darabonba::Model {
public:
  shared_ptr<bool> dingtalkNotice{};
  shared_ptr<bool> emailNotice{};
  shared_ptr<string> noticeType{};
  shared_ptr<bool> smsNotice{};

  DescribeCloudGtmInstanceConfigAlertResponseBodyAlertConfigAlertConfig() {}

  explicit DescribeCloudGtmInstanceConfigAlertResponseBodyAlertConfigAlertConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dingtalkNotice) {
      res["DingtalkNotice"] = boost::any(*dingtalkNotice);
    }
    if (emailNotice) {
      res["EmailNotice"] = boost::any(*emailNotice);
    }
    if (noticeType) {
      res["NoticeType"] = boost::any(*noticeType);
    }
    if (smsNotice) {
      res["SmsNotice"] = boost::any(*smsNotice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DingtalkNotice") != m.end() && !m["DingtalkNotice"].empty()) {
      dingtalkNotice = make_shared<bool>(boost::any_cast<bool>(m["DingtalkNotice"]));
    }
    if (m.find("EmailNotice") != m.end() && !m["EmailNotice"].empty()) {
      emailNotice = make_shared<bool>(boost::any_cast<bool>(m["EmailNotice"]));
    }
    if (m.find("NoticeType") != m.end() && !m["NoticeType"].empty()) {
      noticeType = make_shared<string>(boost::any_cast<string>(m["NoticeType"]));
    }
    if (m.find("SmsNotice") != m.end() && !m["SmsNotice"].empty()) {
      smsNotice = make_shared<bool>(boost::any_cast<bool>(m["SmsNotice"]));
    }
  }


  virtual ~DescribeCloudGtmInstanceConfigAlertResponseBodyAlertConfigAlertConfig() = default;
};
class DescribeCloudGtmInstanceConfigAlertResponseBodyAlertConfig : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCloudGtmInstanceConfigAlertResponseBodyAlertConfigAlertConfig>> alertConfig{};

  DescribeCloudGtmInstanceConfigAlertResponseBodyAlertConfig() {}

  explicit DescribeCloudGtmInstanceConfigAlertResponseBodyAlertConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertConfig) {
      vector<boost::any> temp1;
      for(auto item1:*alertConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlertConfig"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertConfig") != m.end() && !m["AlertConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["AlertConfig"].type()) {
        vector<DescribeCloudGtmInstanceConfigAlertResponseBodyAlertConfigAlertConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlertConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCloudGtmInstanceConfigAlertResponseBodyAlertConfigAlertConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alertConfig = make_shared<vector<DescribeCloudGtmInstanceConfigAlertResponseBodyAlertConfigAlertConfig>>(expect1);
      }
    }
  }


  virtual ~DescribeCloudGtmInstanceConfigAlertResponseBodyAlertConfig() = default;
};
class DescribeCloudGtmInstanceConfigAlertResponseBodyAlertGroup : public Darabonba::Model {
public:
  shared_ptr<vector<string>> alertGroup{};

  DescribeCloudGtmInstanceConfigAlertResponseBodyAlertGroup() {}

  explicit DescribeCloudGtmInstanceConfigAlertResponseBodyAlertGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertGroup) {
      res["AlertGroup"] = boost::any(*alertGroup);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertGroup") != m.end() && !m["AlertGroup"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AlertGroup"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AlertGroup"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      alertGroup = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeCloudGtmInstanceConfigAlertResponseBodyAlertGroup() = default;
};
class DescribeCloudGtmInstanceConfigAlertResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeCloudGtmInstanceConfigAlertResponseBodyAlertConfig> alertConfig{};
  shared_ptr<DescribeCloudGtmInstanceConfigAlertResponseBodyAlertGroup> alertGroup{};
  shared_ptr<string> alertMode{};
  shared_ptr<string> configId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> requestId{};

  DescribeCloudGtmInstanceConfigAlertResponseBody() {}

  explicit DescribeCloudGtmInstanceConfigAlertResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertConfig) {
      res["AlertConfig"] = alertConfig ? boost::any(alertConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (alertGroup) {
      res["AlertGroup"] = alertGroup ? boost::any(alertGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (alertMode) {
      res["AlertMode"] = boost::any(*alertMode);
    }
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertConfig") != m.end() && !m["AlertConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["AlertConfig"].type()) {
        DescribeCloudGtmInstanceConfigAlertResponseBodyAlertConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AlertConfig"]));
        alertConfig = make_shared<DescribeCloudGtmInstanceConfigAlertResponseBodyAlertConfig>(model1);
      }
    }
    if (m.find("AlertGroup") != m.end() && !m["AlertGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["AlertGroup"].type()) {
        DescribeCloudGtmInstanceConfigAlertResponseBodyAlertGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AlertGroup"]));
        alertGroup = make_shared<DescribeCloudGtmInstanceConfigAlertResponseBodyAlertGroup>(model1);
      }
    }
    if (m.find("AlertMode") != m.end() && !m["AlertMode"].empty()) {
      alertMode = make_shared<string>(boost::any_cast<string>(m["AlertMode"]));
    }
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeCloudGtmInstanceConfigAlertResponseBody() = default;
};
class DescribeCloudGtmInstanceConfigAlertResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCloudGtmInstanceConfigAlertResponseBody> body{};

  DescribeCloudGtmInstanceConfigAlertResponse() {}

  explicit DescribeCloudGtmInstanceConfigAlertResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCloudGtmInstanceConfigAlertResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCloudGtmInstanceConfigAlertResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCloudGtmInstanceConfigAlertResponse() = default;
};
class DescribeCloudGtmInstanceConfigFullInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> configId{};
  shared_ptr<string> instanceId{};

  DescribeCloudGtmInstanceConfigFullInfoRequest() {}

  explicit DescribeCloudGtmInstanceConfigFullInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DescribeCloudGtmInstanceConfigFullInfoRequest() = default;
};
class DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPoolAddressesAddressRequestSource : public Darabonba::Model {
public:
  shared_ptr<vector<string>> requestSource{};

  DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPoolAddressesAddressRequestSource() {}

  explicit DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPoolAddressesAddressRequestSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestSource) {
      res["RequestSource"] = boost::any(*requestSource);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestSource") != m.end() && !m["RequestSource"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RequestSource"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RequestSource"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      requestSource = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPoolAddressesAddressRequestSource() = default;
};
class DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPoolAddressesAddress : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> addressId{};
  shared_ptr<string> attributeInfo{};
  shared_ptr<string> availableMode{};
  shared_ptr<string> availableStatus{};
  shared_ptr<string> createTime{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<string> enableStatus{};
  shared_ptr<string> healthJudgement{};
  shared_ptr<string> healthStatus{};
  shared_ptr<string> manualAvailableStatus{};
  shared_ptr<string> name{};
  shared_ptr<string> remark{};
  shared_ptr<DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPoolAddressesAddressRequestSource> requestSource{};
  shared_ptr<bool> seqNonPreemptiveSchedule{};
  shared_ptr<long> serialNumber{};
  shared_ptr<string> type{};
  shared_ptr<string> updateTime{};
  shared_ptr<long> updateTimestamp{};
  shared_ptr<long> weightValue{};

  DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPoolAddressesAddress() {}

  explicit DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPoolAddressesAddress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (addressId) {
      res["AddressId"] = boost::any(*addressId);
    }
    if (attributeInfo) {
      res["AttributeInfo"] = boost::any(*attributeInfo);
    }
    if (availableMode) {
      res["AvailableMode"] = boost::any(*availableMode);
    }
    if (availableStatus) {
      res["AvailableStatus"] = boost::any(*availableStatus);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (enableStatus) {
      res["EnableStatus"] = boost::any(*enableStatus);
    }
    if (healthJudgement) {
      res["HealthJudgement"] = boost::any(*healthJudgement);
    }
    if (healthStatus) {
      res["HealthStatus"] = boost::any(*healthStatus);
    }
    if (manualAvailableStatus) {
      res["ManualAvailableStatus"] = boost::any(*manualAvailableStatus);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (requestSource) {
      res["RequestSource"] = requestSource ? boost::any(requestSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (seqNonPreemptiveSchedule) {
      res["SeqNonPreemptiveSchedule"] = boost::any(*seqNonPreemptiveSchedule);
    }
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (updateTimestamp) {
      res["UpdateTimestamp"] = boost::any(*updateTimestamp);
    }
    if (weightValue) {
      res["WeightValue"] = boost::any(*weightValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("AddressId") != m.end() && !m["AddressId"].empty()) {
      addressId = make_shared<string>(boost::any_cast<string>(m["AddressId"]));
    }
    if (m.find("AttributeInfo") != m.end() && !m["AttributeInfo"].empty()) {
      attributeInfo = make_shared<string>(boost::any_cast<string>(m["AttributeInfo"]));
    }
    if (m.find("AvailableMode") != m.end() && !m["AvailableMode"].empty()) {
      availableMode = make_shared<string>(boost::any_cast<string>(m["AvailableMode"]));
    }
    if (m.find("AvailableStatus") != m.end() && !m["AvailableStatus"].empty()) {
      availableStatus = make_shared<string>(boost::any_cast<string>(m["AvailableStatus"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("EnableStatus") != m.end() && !m["EnableStatus"].empty()) {
      enableStatus = make_shared<string>(boost::any_cast<string>(m["EnableStatus"]));
    }
    if (m.find("HealthJudgement") != m.end() && !m["HealthJudgement"].empty()) {
      healthJudgement = make_shared<string>(boost::any_cast<string>(m["HealthJudgement"]));
    }
    if (m.find("HealthStatus") != m.end() && !m["HealthStatus"].empty()) {
      healthStatus = make_shared<string>(boost::any_cast<string>(m["HealthStatus"]));
    }
    if (m.find("ManualAvailableStatus") != m.end() && !m["ManualAvailableStatus"].empty()) {
      manualAvailableStatus = make_shared<string>(boost::any_cast<string>(m["ManualAvailableStatus"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("RequestSource") != m.end() && !m["RequestSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["RequestSource"].type()) {
        DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPoolAddressesAddressRequestSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RequestSource"]));
        requestSource = make_shared<DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPoolAddressesAddressRequestSource>(model1);
      }
    }
    if (m.find("SeqNonPreemptiveSchedule") != m.end() && !m["SeqNonPreemptiveSchedule"].empty()) {
      seqNonPreemptiveSchedule = make_shared<bool>(boost::any_cast<bool>(m["SeqNonPreemptiveSchedule"]));
    }
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<long>(boost::any_cast<long>(m["SerialNumber"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("UpdateTimestamp") != m.end() && !m["UpdateTimestamp"].empty()) {
      updateTimestamp = make_shared<long>(boost::any_cast<long>(m["UpdateTimestamp"]));
    }
    if (m.find("WeightValue") != m.end() && !m["WeightValue"].empty()) {
      weightValue = make_shared<long>(boost::any_cast<long>(m["WeightValue"]));
    }
  }


  virtual ~DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPoolAddressesAddress() = default;
};
class DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPoolAddresses : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPoolAddressesAddress>> address{};

  DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPoolAddresses() {}

  explicit DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPoolAddresses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      vector<boost::any> temp1;
      for(auto item1:*address){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Address"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      if (typeid(vector<boost::any>) == m["Address"].type()) {
        vector<DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPoolAddressesAddress> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Address"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPoolAddressesAddress model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        address = make_shared<vector<DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPoolAddressesAddress>>(expect1);
      }
    }
  }


  virtual ~DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPoolAddresses() = default;
};
class DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPoolRequestSource : public Darabonba::Model {
public:
  shared_ptr<vector<string>> requestSource{};

  DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPoolRequestSource() {}

  explicit DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPoolRequestSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestSource) {
      res["RequestSource"] = boost::any(*requestSource);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestSource") != m.end() && !m["RequestSource"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RequestSource"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RequestSource"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      requestSource = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPoolRequestSource() = default;
};
class DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPool : public Darabonba::Model {
public:
  shared_ptr<string> addressLbStrategy{};
  shared_ptr<string> addressPoolId{};
  shared_ptr<string> addressPoolName{};
  shared_ptr<string> addressPoolType{};
  shared_ptr<DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPoolAddresses> addresses{};
  shared_ptr<string> availableStatus{};
  shared_ptr<string> createTime{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<string> enableStatus{};
  shared_ptr<string> healthJudgement{};
  shared_ptr<string> healthStatus{};
  shared_ptr<DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPoolRequestSource> requestSource{};
  shared_ptr<bool> seqNonPreemptiveSchedule{};
  shared_ptr<string> sequenceLbStrategyMode{};
  shared_ptr<long> serialNumber{};
  shared_ptr<string> updateTime{};
  shared_ptr<long> updateTimestamp{};
  shared_ptr<long> weightValue{};

  DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPool() {}

  explicit DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPool(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addressLbStrategy) {
      res["AddressLbStrategy"] = boost::any(*addressLbStrategy);
    }
    if (addressPoolId) {
      res["AddressPoolId"] = boost::any(*addressPoolId);
    }
    if (addressPoolName) {
      res["AddressPoolName"] = boost::any(*addressPoolName);
    }
    if (addressPoolType) {
      res["AddressPoolType"] = boost::any(*addressPoolType);
    }
    if (addresses) {
      res["Addresses"] = addresses ? boost::any(addresses->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (availableStatus) {
      res["AvailableStatus"] = boost::any(*availableStatus);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (enableStatus) {
      res["EnableStatus"] = boost::any(*enableStatus);
    }
    if (healthJudgement) {
      res["HealthJudgement"] = boost::any(*healthJudgement);
    }
    if (healthStatus) {
      res["HealthStatus"] = boost::any(*healthStatus);
    }
    if (requestSource) {
      res["RequestSource"] = requestSource ? boost::any(requestSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (seqNonPreemptiveSchedule) {
      res["SeqNonPreemptiveSchedule"] = boost::any(*seqNonPreemptiveSchedule);
    }
    if (sequenceLbStrategyMode) {
      res["SequenceLbStrategyMode"] = boost::any(*sequenceLbStrategyMode);
    }
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (updateTimestamp) {
      res["UpdateTimestamp"] = boost::any(*updateTimestamp);
    }
    if (weightValue) {
      res["WeightValue"] = boost::any(*weightValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddressLbStrategy") != m.end() && !m["AddressLbStrategy"].empty()) {
      addressLbStrategy = make_shared<string>(boost::any_cast<string>(m["AddressLbStrategy"]));
    }
    if (m.find("AddressPoolId") != m.end() && !m["AddressPoolId"].empty()) {
      addressPoolId = make_shared<string>(boost::any_cast<string>(m["AddressPoolId"]));
    }
    if (m.find("AddressPoolName") != m.end() && !m["AddressPoolName"].empty()) {
      addressPoolName = make_shared<string>(boost::any_cast<string>(m["AddressPoolName"]));
    }
    if (m.find("AddressPoolType") != m.end() && !m["AddressPoolType"].empty()) {
      addressPoolType = make_shared<string>(boost::any_cast<string>(m["AddressPoolType"]));
    }
    if (m.find("Addresses") != m.end() && !m["Addresses"].empty()) {
      if (typeid(map<string, boost::any>) == m["Addresses"].type()) {
        DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPoolAddresses model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Addresses"]));
        addresses = make_shared<DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPoolAddresses>(model1);
      }
    }
    if (m.find("AvailableStatus") != m.end() && !m["AvailableStatus"].empty()) {
      availableStatus = make_shared<string>(boost::any_cast<string>(m["AvailableStatus"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("EnableStatus") != m.end() && !m["EnableStatus"].empty()) {
      enableStatus = make_shared<string>(boost::any_cast<string>(m["EnableStatus"]));
    }
    if (m.find("HealthJudgement") != m.end() && !m["HealthJudgement"].empty()) {
      healthJudgement = make_shared<string>(boost::any_cast<string>(m["HealthJudgement"]));
    }
    if (m.find("HealthStatus") != m.end() && !m["HealthStatus"].empty()) {
      healthStatus = make_shared<string>(boost::any_cast<string>(m["HealthStatus"]));
    }
    if (m.find("RequestSource") != m.end() && !m["RequestSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["RequestSource"].type()) {
        DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPoolRequestSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RequestSource"]));
        requestSource = make_shared<DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPoolRequestSource>(model1);
      }
    }
    if (m.find("SeqNonPreemptiveSchedule") != m.end() && !m["SeqNonPreemptiveSchedule"].empty()) {
      seqNonPreemptiveSchedule = make_shared<bool>(boost::any_cast<bool>(m["SeqNonPreemptiveSchedule"]));
    }
    if (m.find("SequenceLbStrategyMode") != m.end() && !m["SequenceLbStrategyMode"].empty()) {
      sequenceLbStrategyMode = make_shared<string>(boost::any_cast<string>(m["SequenceLbStrategyMode"]));
    }
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<long>(boost::any_cast<long>(m["SerialNumber"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("UpdateTimestamp") != m.end() && !m["UpdateTimestamp"].empty()) {
      updateTimestamp = make_shared<long>(boost::any_cast<long>(m["UpdateTimestamp"]));
    }
    if (m.find("WeightValue") != m.end() && !m["WeightValue"].empty()) {
      weightValue = make_shared<long>(boost::any_cast<long>(m["WeightValue"]));
    }
  }


  virtual ~DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPool() = default;
};
class DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPools : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPool>> addressPool{};

  DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPools() {}

  explicit DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPools(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addressPool) {
      vector<boost::any> temp1;
      for(auto item1:*addressPool){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AddressPool"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddressPool") != m.end() && !m["AddressPool"].empty()) {
      if (typeid(vector<boost::any>) == m["AddressPool"].type()) {
        vector<DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPool> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AddressPool"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPool model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        addressPool = make_shared<vector<DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPool>>(expect1);
      }
    }
  }


  virtual ~DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPools() = default;
};
class DescribeCloudGtmInstanceConfigFullInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> addressPoolLbStrategy{};
  shared_ptr<DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPools> addressPools{};
  shared_ptr<string> alertConfig{};
  shared_ptr<string> alertGroup{};
  shared_ptr<string> availableStatus{};
  shared_ptr<string> commodityCode{};
  shared_ptr<string> configId{};
  shared_ptr<string> createTime{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<string> enableStatus{};
  shared_ptr<string> healthStatus{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> remark{};
  shared_ptr<string> requestId{};
  shared_ptr<string> scheduleDomainName{};
  shared_ptr<string> scheduleHostname{};
  shared_ptr<string> scheduleRrType{};
  shared_ptr<string> scheduleZoneMode{};
  shared_ptr<string> scheduleZoneName{};
  shared_ptr<string> sequenceLbStrategyMode{};
  shared_ptr<long> ttl{};
  shared_ptr<string> updateTime{};
  shared_ptr<long> updateTimestamp{};
  shared_ptr<string> versionCode{};

  DescribeCloudGtmInstanceConfigFullInfoResponseBody() {}

  explicit DescribeCloudGtmInstanceConfigFullInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addressPoolLbStrategy) {
      res["AddressPoolLbStrategy"] = boost::any(*addressPoolLbStrategy);
    }
    if (addressPools) {
      res["AddressPools"] = addressPools ? boost::any(addressPools->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (alertConfig) {
      res["AlertConfig"] = boost::any(*alertConfig);
    }
    if (alertGroup) {
      res["AlertGroup"] = boost::any(*alertGroup);
    }
    if (availableStatus) {
      res["AvailableStatus"] = boost::any(*availableStatus);
    }
    if (commodityCode) {
      res["CommodityCode"] = boost::any(*commodityCode);
    }
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (enableStatus) {
      res["EnableStatus"] = boost::any(*enableStatus);
    }
    if (healthStatus) {
      res["HealthStatus"] = boost::any(*healthStatus);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scheduleDomainName) {
      res["ScheduleDomainName"] = boost::any(*scheduleDomainName);
    }
    if (scheduleHostname) {
      res["ScheduleHostname"] = boost::any(*scheduleHostname);
    }
    if (scheduleRrType) {
      res["ScheduleRrType"] = boost::any(*scheduleRrType);
    }
    if (scheduleZoneMode) {
      res["ScheduleZoneMode"] = boost::any(*scheduleZoneMode);
    }
    if (scheduleZoneName) {
      res["ScheduleZoneName"] = boost::any(*scheduleZoneName);
    }
    if (sequenceLbStrategyMode) {
      res["SequenceLbStrategyMode"] = boost::any(*sequenceLbStrategyMode);
    }
    if (ttl) {
      res["Ttl"] = boost::any(*ttl);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (updateTimestamp) {
      res["UpdateTimestamp"] = boost::any(*updateTimestamp);
    }
    if (versionCode) {
      res["VersionCode"] = boost::any(*versionCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddressPoolLbStrategy") != m.end() && !m["AddressPoolLbStrategy"].empty()) {
      addressPoolLbStrategy = make_shared<string>(boost::any_cast<string>(m["AddressPoolLbStrategy"]));
    }
    if (m.find("AddressPools") != m.end() && !m["AddressPools"].empty()) {
      if (typeid(map<string, boost::any>) == m["AddressPools"].type()) {
        DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPools model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AddressPools"]));
        addressPools = make_shared<DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPools>(model1);
      }
    }
    if (m.find("AlertConfig") != m.end() && !m["AlertConfig"].empty()) {
      alertConfig = make_shared<string>(boost::any_cast<string>(m["AlertConfig"]));
    }
    if (m.find("AlertGroup") != m.end() && !m["AlertGroup"].empty()) {
      alertGroup = make_shared<string>(boost::any_cast<string>(m["AlertGroup"]));
    }
    if (m.find("AvailableStatus") != m.end() && !m["AvailableStatus"].empty()) {
      availableStatus = make_shared<string>(boost::any_cast<string>(m["AvailableStatus"]));
    }
    if (m.find("CommodityCode") != m.end() && !m["CommodityCode"].empty()) {
      commodityCode = make_shared<string>(boost::any_cast<string>(m["CommodityCode"]));
    }
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("EnableStatus") != m.end() && !m["EnableStatus"].empty()) {
      enableStatus = make_shared<string>(boost::any_cast<string>(m["EnableStatus"]));
    }
    if (m.find("HealthStatus") != m.end() && !m["HealthStatus"].empty()) {
      healthStatus = make_shared<string>(boost::any_cast<string>(m["HealthStatus"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScheduleDomainName") != m.end() && !m["ScheduleDomainName"].empty()) {
      scheduleDomainName = make_shared<string>(boost::any_cast<string>(m["ScheduleDomainName"]));
    }
    if (m.find("ScheduleHostname") != m.end() && !m["ScheduleHostname"].empty()) {
      scheduleHostname = make_shared<string>(boost::any_cast<string>(m["ScheduleHostname"]));
    }
    if (m.find("ScheduleRrType") != m.end() && !m["ScheduleRrType"].empty()) {
      scheduleRrType = make_shared<string>(boost::any_cast<string>(m["ScheduleRrType"]));
    }
    if (m.find("ScheduleZoneMode") != m.end() && !m["ScheduleZoneMode"].empty()) {
      scheduleZoneMode = make_shared<string>(boost::any_cast<string>(m["ScheduleZoneMode"]));
    }
    if (m.find("ScheduleZoneName") != m.end() && !m["ScheduleZoneName"].empty()) {
      scheduleZoneName = make_shared<string>(boost::any_cast<string>(m["ScheduleZoneName"]));
    }
    if (m.find("SequenceLbStrategyMode") != m.end() && !m["SequenceLbStrategyMode"].empty()) {
      sequenceLbStrategyMode = make_shared<string>(boost::any_cast<string>(m["SequenceLbStrategyMode"]));
    }
    if (m.find("Ttl") != m.end() && !m["Ttl"].empty()) {
      ttl = make_shared<long>(boost::any_cast<long>(m["Ttl"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("UpdateTimestamp") != m.end() && !m["UpdateTimestamp"].empty()) {
      updateTimestamp = make_shared<long>(boost::any_cast<long>(m["UpdateTimestamp"]));
    }
    if (m.find("VersionCode") != m.end() && !m["VersionCode"].empty()) {
      versionCode = make_shared<string>(boost::any_cast<string>(m["VersionCode"]));
    }
  }


  virtual ~DescribeCloudGtmInstanceConfigFullInfoResponseBody() = default;
};
class DescribeCloudGtmInstanceConfigFullInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCloudGtmInstanceConfigFullInfoResponseBody> body{};

  DescribeCloudGtmInstanceConfigFullInfoResponse() {}

  explicit DescribeCloudGtmInstanceConfigFullInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCloudGtmInstanceConfigFullInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCloudGtmInstanceConfigFullInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCloudGtmInstanceConfigFullInfoResponse() = default;
};
class DescribeCloudGtmMonitorTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> templateId{};

  DescribeCloudGtmMonitorTemplateRequest() {}

  explicit DescribeCloudGtmMonitorTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~DescribeCloudGtmMonitorTemplateRequest() = default;
};
class DescribeCloudGtmMonitorTemplateResponseBodyIspCityNodesIspCityNode : public Darabonba::Model {
public:
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};
  shared_ptr<string> countryCode{};
  shared_ptr<string> countryName{};
  shared_ptr<string> groupName{};
  shared_ptr<string> groupType{};
  shared_ptr<string> ispCode{};
  shared_ptr<string> ispName{};

  DescribeCloudGtmMonitorTemplateResponseBodyIspCityNodesIspCityNode() {}

  explicit DescribeCloudGtmMonitorTemplateResponseBodyIspCityNodesIspCityNode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cityCode) {
      res["CityCode"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["CityName"] = boost::any(*cityName);
    }
    if (countryCode) {
      res["CountryCode"] = boost::any(*countryCode);
    }
    if (countryName) {
      res["CountryName"] = boost::any(*countryName);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (groupType) {
      res["GroupType"] = boost::any(*groupType);
    }
    if (ispCode) {
      res["IspCode"] = boost::any(*ispCode);
    }
    if (ispName) {
      res["IspName"] = boost::any(*ispName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CityCode") != m.end() && !m["CityCode"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["CityCode"]));
    }
    if (m.find("CityName") != m.end() && !m["CityName"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["CityName"]));
    }
    if (m.find("CountryCode") != m.end() && !m["CountryCode"].empty()) {
      countryCode = make_shared<string>(boost::any_cast<string>(m["CountryCode"]));
    }
    if (m.find("CountryName") != m.end() && !m["CountryName"].empty()) {
      countryName = make_shared<string>(boost::any_cast<string>(m["CountryName"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("GroupType") != m.end() && !m["GroupType"].empty()) {
      groupType = make_shared<string>(boost::any_cast<string>(m["GroupType"]));
    }
    if (m.find("IspCode") != m.end() && !m["IspCode"].empty()) {
      ispCode = make_shared<string>(boost::any_cast<string>(m["IspCode"]));
    }
    if (m.find("IspName") != m.end() && !m["IspName"].empty()) {
      ispName = make_shared<string>(boost::any_cast<string>(m["IspName"]));
    }
  }


  virtual ~DescribeCloudGtmMonitorTemplateResponseBodyIspCityNodesIspCityNode() = default;
};
class DescribeCloudGtmMonitorTemplateResponseBodyIspCityNodes : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCloudGtmMonitorTemplateResponseBodyIspCityNodesIspCityNode>> ispCityNode{};

  DescribeCloudGtmMonitorTemplateResponseBodyIspCityNodes() {}

  explicit DescribeCloudGtmMonitorTemplateResponseBodyIspCityNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ispCityNode) {
      vector<boost::any> temp1;
      for(auto item1:*ispCityNode){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IspCityNode"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IspCityNode") != m.end() && !m["IspCityNode"].empty()) {
      if (typeid(vector<boost::any>) == m["IspCityNode"].type()) {
        vector<DescribeCloudGtmMonitorTemplateResponseBodyIspCityNodesIspCityNode> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IspCityNode"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCloudGtmMonitorTemplateResponseBodyIspCityNodesIspCityNode model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ispCityNode = make_shared<vector<DescribeCloudGtmMonitorTemplateResponseBodyIspCityNodesIspCityNode>>(expect1);
      }
    }
  }


  virtual ~DescribeCloudGtmMonitorTemplateResponseBodyIspCityNodes() = default;
};
class DescribeCloudGtmMonitorTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<long> evaluationCount{};
  shared_ptr<string> extendInfo{};
  shared_ptr<long> failureRate{};
  shared_ptr<long> interval{};
  shared_ptr<string> ipVersion{};
  shared_ptr<DescribeCloudGtmMonitorTemplateResponseBodyIspCityNodes> ispCityNodes{};
  shared_ptr<string> name{};
  shared_ptr<string> protocol{};
  shared_ptr<string> remark{};
  shared_ptr<string> requestId{};
  shared_ptr<string> templateId{};
  shared_ptr<long> timeout{};
  shared_ptr<string> updateTime{};
  shared_ptr<long> updateTimestamp{};

  DescribeCloudGtmMonitorTemplateResponseBody() {}

  explicit DescribeCloudGtmMonitorTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (evaluationCount) {
      res["EvaluationCount"] = boost::any(*evaluationCount);
    }
    if (extendInfo) {
      res["ExtendInfo"] = boost::any(*extendInfo);
    }
    if (failureRate) {
      res["FailureRate"] = boost::any(*failureRate);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ipVersion) {
      res["IpVersion"] = boost::any(*ipVersion);
    }
    if (ispCityNodes) {
      res["IspCityNodes"] = ispCityNodes ? boost::any(ispCityNodes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (updateTimestamp) {
      res["UpdateTimestamp"] = boost::any(*updateTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("EvaluationCount") != m.end() && !m["EvaluationCount"].empty()) {
      evaluationCount = make_shared<long>(boost::any_cast<long>(m["EvaluationCount"]));
    }
    if (m.find("ExtendInfo") != m.end() && !m["ExtendInfo"].empty()) {
      extendInfo = make_shared<string>(boost::any_cast<string>(m["ExtendInfo"]));
    }
    if (m.find("FailureRate") != m.end() && !m["FailureRate"].empty()) {
      failureRate = make_shared<long>(boost::any_cast<long>(m["FailureRate"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("IpVersion") != m.end() && !m["IpVersion"].empty()) {
      ipVersion = make_shared<string>(boost::any_cast<string>(m["IpVersion"]));
    }
    if (m.find("IspCityNodes") != m.end() && !m["IspCityNodes"].empty()) {
      if (typeid(map<string, boost::any>) == m["IspCityNodes"].type()) {
        DescribeCloudGtmMonitorTemplateResponseBodyIspCityNodes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IspCityNodes"]));
        ispCityNodes = make_shared<DescribeCloudGtmMonitorTemplateResponseBodyIspCityNodes>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("UpdateTimestamp") != m.end() && !m["UpdateTimestamp"].empty()) {
      updateTimestamp = make_shared<long>(boost::any_cast<long>(m["UpdateTimestamp"]));
    }
  }


  virtual ~DescribeCloudGtmMonitorTemplateResponseBody() = default;
};
class DescribeCloudGtmMonitorTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCloudGtmMonitorTemplateResponseBody> body{};

  DescribeCloudGtmMonitorTemplateResponse() {}

  explicit DescribeCloudGtmMonitorTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCloudGtmMonitorTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCloudGtmMonitorTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCloudGtmMonitorTemplateResponse() = default;
};
class DescribeCloudGtmSummaryRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};

  DescribeCloudGtmSummaryRequest() {}

  explicit DescribeCloudGtmSummaryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
  }


  virtual ~DescribeCloudGtmSummaryRequest() = default;
};
class DescribeCloudGtmSummaryResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> instanceTotalCount{};
  shared_ptr<long> monitorTaskTotalCount{};
  shared_ptr<long> monitorTaskTotalQuota{};
  shared_ptr<string> requestId{};

  DescribeCloudGtmSummaryResponseBody() {}

  explicit DescribeCloudGtmSummaryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceTotalCount) {
      res["InstanceTotalCount"] = boost::any(*instanceTotalCount);
    }
    if (monitorTaskTotalCount) {
      res["MonitorTaskTotalCount"] = boost::any(*monitorTaskTotalCount);
    }
    if (monitorTaskTotalQuota) {
      res["MonitorTaskTotalQuota"] = boost::any(*monitorTaskTotalQuota);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceTotalCount") != m.end() && !m["InstanceTotalCount"].empty()) {
      instanceTotalCount = make_shared<long>(boost::any_cast<long>(m["InstanceTotalCount"]));
    }
    if (m.find("MonitorTaskTotalCount") != m.end() && !m["MonitorTaskTotalCount"].empty()) {
      monitorTaskTotalCount = make_shared<long>(boost::any_cast<long>(m["MonitorTaskTotalCount"]));
    }
    if (m.find("MonitorTaskTotalQuota") != m.end() && !m["MonitorTaskTotalQuota"].empty()) {
      monitorTaskTotalQuota = make_shared<long>(boost::any_cast<long>(m["MonitorTaskTotalQuota"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeCloudGtmSummaryResponseBody() = default;
};
class DescribeCloudGtmSummaryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCloudGtmSummaryResponseBody> body{};

  DescribeCloudGtmSummaryResponse() {}

  explicit DescribeCloudGtmSummaryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCloudGtmSummaryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCloudGtmSummaryResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCloudGtmSummaryResponse() = default;
};
class DescribeCloudGtmSystemLinesResponseBodySystemLinesSystemLine : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> displayName{};
  shared_ptr<bool> isAvailable{};
  shared_ptr<string> name{};
  shared_ptr<string> parentCode{};

  DescribeCloudGtmSystemLinesResponseBodySystemLinesSystemLine() {}

  explicit DescribeCloudGtmSystemLinesResponseBodySystemLinesSystemLine(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (isAvailable) {
      res["IsAvailable"] = boost::any(*isAvailable);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (parentCode) {
      res["ParentCode"] = boost::any(*parentCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("IsAvailable") != m.end() && !m["IsAvailable"].empty()) {
      isAvailable = make_shared<bool>(boost::any_cast<bool>(m["IsAvailable"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ParentCode") != m.end() && !m["ParentCode"].empty()) {
      parentCode = make_shared<string>(boost::any_cast<string>(m["ParentCode"]));
    }
  }


  virtual ~DescribeCloudGtmSystemLinesResponseBodySystemLinesSystemLine() = default;
};
class DescribeCloudGtmSystemLinesResponseBodySystemLines : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCloudGtmSystemLinesResponseBodySystemLinesSystemLine>> systemLine{};

  DescribeCloudGtmSystemLinesResponseBodySystemLines() {}

  explicit DescribeCloudGtmSystemLinesResponseBodySystemLines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (systemLine) {
      vector<boost::any> temp1;
      for(auto item1:*systemLine){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SystemLine"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SystemLine") != m.end() && !m["SystemLine"].empty()) {
      if (typeid(vector<boost::any>) == m["SystemLine"].type()) {
        vector<DescribeCloudGtmSystemLinesResponseBodySystemLinesSystemLine> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SystemLine"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCloudGtmSystemLinesResponseBodySystemLinesSystemLine model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        systemLine = make_shared<vector<DescribeCloudGtmSystemLinesResponseBodySystemLinesSystemLine>>(expect1);
      }
    }
  }


  virtual ~DescribeCloudGtmSystemLinesResponseBodySystemLines() = default;
};
class DescribeCloudGtmSystemLinesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeCloudGtmSystemLinesResponseBodySystemLines> systemLines{};
  shared_ptr<string> systemLinesTree{};

  DescribeCloudGtmSystemLinesResponseBody() {}

  explicit DescribeCloudGtmSystemLinesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (systemLines) {
      res["SystemLines"] = systemLines ? boost::any(systemLines->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (systemLinesTree) {
      res["SystemLinesTree"] = boost::any(*systemLinesTree);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SystemLines") != m.end() && !m["SystemLines"].empty()) {
      if (typeid(map<string, boost::any>) == m["SystemLines"].type()) {
        DescribeCloudGtmSystemLinesResponseBodySystemLines model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SystemLines"]));
        systemLines = make_shared<DescribeCloudGtmSystemLinesResponseBodySystemLines>(model1);
      }
    }
    if (m.find("SystemLinesTree") != m.end() && !m["SystemLinesTree"].empty()) {
      systemLinesTree = make_shared<string>(boost::any_cast<string>(m["SystemLinesTree"]));
    }
  }


  virtual ~DescribeCloudGtmSystemLinesResponseBody() = default;
};
class DescribeCloudGtmSystemLinesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCloudGtmSystemLinesResponseBody> body{};

  DescribeCloudGtmSystemLinesResponse() {}

  explicit DescribeCloudGtmSystemLinesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCloudGtmSystemLinesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCloudGtmSystemLinesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCloudGtmSystemLinesResponse() = default;
};
class DescribeCustomLineRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> lineId{};

  DescribeCustomLineRequest() {}

  explicit DescribeCustomLineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (lineId) {
      res["LineId"] = boost::any(*lineId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("LineId") != m.end() && !m["LineId"].empty()) {
      lineId = make_shared<long>(boost::any_cast<long>(m["LineId"]));
    }
  }


  virtual ~DescribeCustomLineRequest() = default;
};
class DescribeCustomLineResponseBodyIpSegmentList : public Darabonba::Model {
public:
  shared_ptr<string> endIp{};
  shared_ptr<string> startIp{};

  DescribeCustomLineResponseBodyIpSegmentList() {}

  explicit DescribeCustomLineResponseBodyIpSegmentList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endIp) {
      res["EndIp"] = boost::any(*endIp);
    }
    if (startIp) {
      res["StartIp"] = boost::any(*startIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndIp") != m.end() && !m["EndIp"].empty()) {
      endIp = make_shared<string>(boost::any_cast<string>(m["EndIp"]));
    }
    if (m.find("StartIp") != m.end() && !m["StartIp"].empty()) {
      startIp = make_shared<string>(boost::any_cast<string>(m["StartIp"]));
    }
  }


  virtual ~DescribeCustomLineResponseBodyIpSegmentList() = default;
};
class DescribeCustomLineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> domainName{};
  shared_ptr<long> id{};
  shared_ptr<vector<DescribeCustomLineResponseBodyIpSegmentList>> ipSegmentList{};
  shared_ptr<string> name{};
  shared_ptr<string> requestId{};

  DescribeCustomLineResponseBody() {}

  explicit DescribeCustomLineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ipSegmentList) {
      vector<boost::any> temp1;
      for(auto item1:*ipSegmentList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IpSegmentList"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IpSegmentList") != m.end() && !m["IpSegmentList"].empty()) {
      if (typeid(vector<boost::any>) == m["IpSegmentList"].type()) {
        vector<DescribeCustomLineResponseBodyIpSegmentList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IpSegmentList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCustomLineResponseBodyIpSegmentList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ipSegmentList = make_shared<vector<DescribeCustomLineResponseBodyIpSegmentList>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeCustomLineResponseBody() = default;
};
class DescribeCustomLineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCustomLineResponseBody> body{};

  DescribeCustomLineResponse() {}

  explicit DescribeCustomLineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCustomLineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCustomLineResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCustomLineResponse() = default;
};
class DescribeCustomLinesRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeCustomLinesRequest() {}

  explicit DescribeCustomLinesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeCustomLinesRequest() = default;
};
class DescribeCustomLinesResponseBodyCustomLines : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};

  DescribeCustomLinesResponseBodyCustomLines() {}

  explicit DescribeCustomLinesResponseBodyCustomLines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DescribeCustomLinesResponseBodyCustomLines() = default;
};
class DescribeCustomLinesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCustomLinesResponseBodyCustomLines>> customLines{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalItems{};
  shared_ptr<long> totalPages{};

  DescribeCustomLinesResponseBody() {}

  explicit DescribeCustomLinesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customLines) {
      vector<boost::any> temp1;
      for(auto item1:*customLines){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CustomLines"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalItems) {
      res["TotalItems"] = boost::any(*totalItems);
    }
    if (totalPages) {
      res["TotalPages"] = boost::any(*totalPages);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomLines") != m.end() && !m["CustomLines"].empty()) {
      if (typeid(vector<boost::any>) == m["CustomLines"].type()) {
        vector<DescribeCustomLinesResponseBodyCustomLines> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CustomLines"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCustomLinesResponseBodyCustomLines model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        customLines = make_shared<vector<DescribeCustomLinesResponseBodyCustomLines>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalItems") != m.end() && !m["TotalItems"].empty()) {
      totalItems = make_shared<long>(boost::any_cast<long>(m["TotalItems"]));
    }
    if (m.find("TotalPages") != m.end() && !m["TotalPages"].empty()) {
      totalPages = make_shared<long>(boost::any_cast<long>(m["TotalPages"]));
    }
  }


  virtual ~DescribeCustomLinesResponseBody() = default;
};
class DescribeCustomLinesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCustomLinesResponseBody> body{};

  DescribeCustomLinesResponse() {}

  explicit DescribeCustomLinesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCustomLinesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCustomLinesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCustomLinesResponse() = default;
};
class DescribeDNSSLBSubDomainsRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> rr{};
  shared_ptr<string> userClientIp{};

  DescribeDNSSLBSubDomainsRequest() {}

  explicit DescribeDNSSLBSubDomainsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (rr) {
      res["Rr"] = boost::any(*rr);
    }
    if (userClientIp) {
      res["UserClientIp"] = boost::any(*userClientIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Rr") != m.end() && !m["Rr"].empty()) {
      rr = make_shared<string>(boost::any_cast<string>(m["Rr"]));
    }
    if (m.find("UserClientIp") != m.end() && !m["UserClientIp"].empty()) {
      userClientIp = make_shared<string>(boost::any_cast<string>(m["UserClientIp"]));
    }
  }


  virtual ~DescribeDNSSLBSubDomainsRequest() = default;
};
class DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomainLineAlgorithmsLineAlgorithm : public Darabonba::Model {
public:
  shared_ptr<string> line{};
  shared_ptr<bool> open{};

  DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomainLineAlgorithmsLineAlgorithm() {}

  explicit DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomainLineAlgorithmsLineAlgorithm(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (line) {
      res["Line"] = boost::any(*line);
    }
    if (open) {
      res["Open"] = boost::any(*open);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Line") != m.end() && !m["Line"].empty()) {
      line = make_shared<string>(boost::any_cast<string>(m["Line"]));
    }
    if (m.find("Open") != m.end() && !m["Open"].empty()) {
      open = make_shared<bool>(boost::any_cast<bool>(m["Open"]));
    }
  }


  virtual ~DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomainLineAlgorithmsLineAlgorithm() = default;
};
class DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomainLineAlgorithms : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomainLineAlgorithmsLineAlgorithm>> lineAlgorithm{};

  DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomainLineAlgorithms() {}

  explicit DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomainLineAlgorithms(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lineAlgorithm) {
      vector<boost::any> temp1;
      for(auto item1:*lineAlgorithm){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LineAlgorithm"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LineAlgorithm") != m.end() && !m["LineAlgorithm"].empty()) {
      if (typeid(vector<boost::any>) == m["LineAlgorithm"].type()) {
        vector<DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomainLineAlgorithmsLineAlgorithm> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LineAlgorithm"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomainLineAlgorithmsLineAlgorithm model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        lineAlgorithm = make_shared<vector<DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomainLineAlgorithmsLineAlgorithm>>(expect1);
      }
    }
  }


  virtual ~DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomainLineAlgorithms() = default;
};
class DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomain : public Darabonba::Model {
public:
  shared_ptr<DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomainLineAlgorithms> lineAlgorithms{};
  shared_ptr<bool> open{};
  shared_ptr<long> recordCount{};
  shared_ptr<string> subDomain{};
  shared_ptr<string> type{};

  DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomain() {}

  explicit DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomain(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lineAlgorithms) {
      res["LineAlgorithms"] = lineAlgorithms ? boost::any(lineAlgorithms->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (open) {
      res["Open"] = boost::any(*open);
    }
    if (recordCount) {
      res["RecordCount"] = boost::any(*recordCount);
    }
    if (subDomain) {
      res["SubDomain"] = boost::any(*subDomain);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LineAlgorithms") != m.end() && !m["LineAlgorithms"].empty()) {
      if (typeid(map<string, boost::any>) == m["LineAlgorithms"].type()) {
        DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomainLineAlgorithms model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LineAlgorithms"]));
        lineAlgorithms = make_shared<DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomainLineAlgorithms>(model1);
      }
    }
    if (m.find("Open") != m.end() && !m["Open"].empty()) {
      open = make_shared<bool>(boost::any_cast<bool>(m["Open"]));
    }
    if (m.find("RecordCount") != m.end() && !m["RecordCount"].empty()) {
      recordCount = make_shared<long>(boost::any_cast<long>(m["RecordCount"]));
    }
    if (m.find("SubDomain") != m.end() && !m["SubDomain"].empty()) {
      subDomain = make_shared<string>(boost::any_cast<string>(m["SubDomain"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomain() = default;
};
class DescribeDNSSLBSubDomainsResponseBodySlbSubDomains : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomain>> slbSubDomain{};

  DescribeDNSSLBSubDomainsResponseBodySlbSubDomains() {}

  explicit DescribeDNSSLBSubDomainsResponseBodySlbSubDomains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (slbSubDomain) {
      vector<boost::any> temp1;
      for(auto item1:*slbSubDomain){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SlbSubDomain"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SlbSubDomain") != m.end() && !m["SlbSubDomain"].empty()) {
      if (typeid(vector<boost::any>) == m["SlbSubDomain"].type()) {
        vector<DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomain> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SlbSubDomain"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomain model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        slbSubDomain = make_shared<vector<DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomain>>(expect1);
      }
    }
  }


  virtual ~DescribeDNSSLBSubDomainsResponseBodySlbSubDomains() = default;
};
class DescribeDNSSLBSubDomainsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDNSSLBSubDomainsResponseBodySlbSubDomains> slbSubDomains{};
  shared_ptr<long> totalCount{};

  DescribeDNSSLBSubDomainsResponseBody() {}

  explicit DescribeDNSSLBSubDomainsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (slbSubDomains) {
      res["SlbSubDomains"] = slbSubDomains ? boost::any(slbSubDomains->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SlbSubDomains") != m.end() && !m["SlbSubDomains"].empty()) {
      if (typeid(map<string, boost::any>) == m["SlbSubDomains"].type()) {
        DescribeDNSSLBSubDomainsResponseBodySlbSubDomains model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SlbSubDomains"]));
        slbSubDomains = make_shared<DescribeDNSSLBSubDomainsResponseBodySlbSubDomains>(model1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDNSSLBSubDomainsResponseBody() = default;
};
class DescribeDNSSLBSubDomainsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDNSSLBSubDomainsResponseBody> body{};

  DescribeDNSSLBSubDomainsResponse() {}

  explicit DescribeDNSSLBSubDomainsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDNSSLBSubDomainsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDNSSLBSubDomainsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDNSSLBSubDomainsResponse() = default;
};
class DescribeDnsCacheDomainsRequest : public Darabonba::Model {
public:
  shared_ptr<string> keyword{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeDnsCacheDomainsRequest() {}

  explicit DescribeDnsCacheDomainsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeDnsCacheDomainsRequest() = default;
};
class DescribeDnsCacheDomainsResponseBodyDomainsSourceDnsServers : public Darabonba::Model {
public:
  shared_ptr<string> host{};
  shared_ptr<string> port{};

  DescribeDnsCacheDomainsResponseBodyDomainsSourceDnsServers() {}

  explicit DescribeDnsCacheDomainsResponseBodyDomainsSourceDnsServers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
  }


  virtual ~DescribeDnsCacheDomainsResponseBodyDomainsSourceDnsServers() = default;
};
class DescribeDnsCacheDomainsResponseBodyDomains : public Darabonba::Model {
public:
  shared_ptr<long> cacheTtlMax{};
  shared_ptr<long> cacheTtlMin{};
  shared_ptr<string> createTime{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<string> domainId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> expireTime{};
  shared_ptr<long> expireTimestamp{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> remark{};
  shared_ptr<vector<DescribeDnsCacheDomainsResponseBodyDomainsSourceDnsServers>> sourceDnsServers{};
  shared_ptr<string> sourceEdns{};
  shared_ptr<string> sourceProtocol{};
  shared_ptr<string> updateTime{};
  shared_ptr<long> updateTimestamp{};
  shared_ptr<string> versionCode{};

  DescribeDnsCacheDomainsResponseBodyDomains() {}

  explicit DescribeDnsCacheDomainsResponseBodyDomains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cacheTtlMax) {
      res["CacheTtlMax"] = boost::any(*cacheTtlMax);
    }
    if (cacheTtlMin) {
      res["CacheTtlMin"] = boost::any(*cacheTtlMin);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (domainId) {
      res["DomainId"] = boost::any(*domainId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (expireTimestamp) {
      res["ExpireTimestamp"] = boost::any(*expireTimestamp);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (sourceDnsServers) {
      vector<boost::any> temp1;
      for(auto item1:*sourceDnsServers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SourceDnsServers"] = boost::any(temp1);
    }
    if (sourceEdns) {
      res["SourceEdns"] = boost::any(*sourceEdns);
    }
    if (sourceProtocol) {
      res["SourceProtocol"] = boost::any(*sourceProtocol);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (updateTimestamp) {
      res["UpdateTimestamp"] = boost::any(*updateTimestamp);
    }
    if (versionCode) {
      res["VersionCode"] = boost::any(*versionCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CacheTtlMax") != m.end() && !m["CacheTtlMax"].empty()) {
      cacheTtlMax = make_shared<long>(boost::any_cast<long>(m["CacheTtlMax"]));
    }
    if (m.find("CacheTtlMin") != m.end() && !m["CacheTtlMin"].empty()) {
      cacheTtlMin = make_shared<long>(boost::any_cast<long>(m["CacheTtlMin"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("DomainId") != m.end() && !m["DomainId"].empty()) {
      domainId = make_shared<string>(boost::any_cast<string>(m["DomainId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("ExpireTimestamp") != m.end() && !m["ExpireTimestamp"].empty()) {
      expireTimestamp = make_shared<long>(boost::any_cast<long>(m["ExpireTimestamp"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("SourceDnsServers") != m.end() && !m["SourceDnsServers"].empty()) {
      if (typeid(vector<boost::any>) == m["SourceDnsServers"].type()) {
        vector<DescribeDnsCacheDomainsResponseBodyDomainsSourceDnsServers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SourceDnsServers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDnsCacheDomainsResponseBodyDomainsSourceDnsServers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sourceDnsServers = make_shared<vector<DescribeDnsCacheDomainsResponseBodyDomainsSourceDnsServers>>(expect1);
      }
    }
    if (m.find("SourceEdns") != m.end() && !m["SourceEdns"].empty()) {
      sourceEdns = make_shared<string>(boost::any_cast<string>(m["SourceEdns"]));
    }
    if (m.find("SourceProtocol") != m.end() && !m["SourceProtocol"].empty()) {
      sourceProtocol = make_shared<string>(boost::any_cast<string>(m["SourceProtocol"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("UpdateTimestamp") != m.end() && !m["UpdateTimestamp"].empty()) {
      updateTimestamp = make_shared<long>(boost::any_cast<long>(m["UpdateTimestamp"]));
    }
    if (m.find("VersionCode") != m.end() && !m["VersionCode"].empty()) {
      versionCode = make_shared<string>(boost::any_cast<string>(m["VersionCode"]));
    }
  }


  virtual ~DescribeDnsCacheDomainsResponseBodyDomains() = default;
};
class DescribeDnsCacheDomainsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDnsCacheDomainsResponseBodyDomains>> domains{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeDnsCacheDomainsResponseBody() {}

  explicit DescribeDnsCacheDomainsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domains) {
      vector<boost::any> temp1;
      for(auto item1:*domains){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Domains"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domains") != m.end() && !m["Domains"].empty()) {
      if (typeid(vector<boost::any>) == m["Domains"].type()) {
        vector<DescribeDnsCacheDomainsResponseBodyDomains> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Domains"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDnsCacheDomainsResponseBodyDomains model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domains = make_shared<vector<DescribeDnsCacheDomainsResponseBodyDomains>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDnsCacheDomainsResponseBody() = default;
};
class DescribeDnsCacheDomainsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDnsCacheDomainsResponseBody> body{};

  DescribeDnsCacheDomainsResponse() {}

  explicit DescribeDnsCacheDomainsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDnsCacheDomainsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDnsCacheDomainsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDnsCacheDomainsResponse() = default;
};
class DescribeDnsGtmAccessStrategiesRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> strategyMode{};

  DescribeDnsGtmAccessStrategiesRequest() {}

  explicit DescribeDnsGtmAccessStrategiesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (strategyMode) {
      res["StrategyMode"] = boost::any(*strategyMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StrategyMode") != m.end() && !m["StrategyMode"].empty()) {
      strategyMode = make_shared<string>(boost::any_cast<string>(m["StrategyMode"]));
    }
  }


  virtual ~DescribeDnsGtmAccessStrategiesRequest() = default;
};
class DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyEffectiveAddrPoolsEffectiveAddrPool : public Darabonba::Model {
public:
  shared_ptr<long> addrCount{};
  shared_ptr<string> id{};
  shared_ptr<long> lbaWeight{};
  shared_ptr<string> name{};

  DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyEffectiveAddrPoolsEffectiveAddrPool() {}

  explicit DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyEffectiveAddrPoolsEffectiveAddrPool(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addrCount) {
      res["AddrCount"] = boost::any(*addrCount);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (lbaWeight) {
      res["LbaWeight"] = boost::any(*lbaWeight);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddrCount") != m.end() && !m["AddrCount"].empty()) {
      addrCount = make_shared<long>(boost::any_cast<long>(m["AddrCount"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("LbaWeight") != m.end() && !m["LbaWeight"].empty()) {
      lbaWeight = make_shared<long>(boost::any_cast<long>(m["LbaWeight"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyEffectiveAddrPoolsEffectiveAddrPool() = default;
};
class DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyEffectiveAddrPools : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyEffectiveAddrPoolsEffectiveAddrPool>> effectiveAddrPool{};

  DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyEffectiveAddrPools() {}

  explicit DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyEffectiveAddrPools(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (effectiveAddrPool) {
      vector<boost::any> temp1;
      for(auto item1:*effectiveAddrPool){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EffectiveAddrPool"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EffectiveAddrPool") != m.end() && !m["EffectiveAddrPool"].empty()) {
      if (typeid(vector<boost::any>) == m["EffectiveAddrPool"].type()) {
        vector<DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyEffectiveAddrPoolsEffectiveAddrPool> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EffectiveAddrPool"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyEffectiveAddrPoolsEffectiveAddrPool model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        effectiveAddrPool = make_shared<vector<DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyEffectiveAddrPoolsEffectiveAddrPool>>(expect1);
      }
    }
  }


  virtual ~DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyEffectiveAddrPools() = default;
};
class DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyLinesLine : public Darabonba::Model {
public:
  shared_ptr<string> groupCode{};
  shared_ptr<string> groupName{};
  shared_ptr<string> lineCode{};
  shared_ptr<string> lineName{};

  DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyLinesLine() {}

  explicit DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyLinesLine(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupCode) {
      res["GroupCode"] = boost::any(*groupCode);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (lineCode) {
      res["LineCode"] = boost::any(*lineCode);
    }
    if (lineName) {
      res["LineName"] = boost::any(*lineName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupCode") != m.end() && !m["GroupCode"].empty()) {
      groupCode = make_shared<string>(boost::any_cast<string>(m["GroupCode"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("LineCode") != m.end() && !m["LineCode"].empty()) {
      lineCode = make_shared<string>(boost::any_cast<string>(m["LineCode"]));
    }
    if (m.find("LineName") != m.end() && !m["LineName"].empty()) {
      lineName = make_shared<string>(boost::any_cast<string>(m["LineName"]));
    }
  }


  virtual ~DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyLinesLine() = default;
};
class DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyLines : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyLinesLine>> line{};

  DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyLines() {}

  explicit DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyLines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (line) {
      vector<boost::any> temp1;
      for(auto item1:*line){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Line"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Line") != m.end() && !m["Line"].empty()) {
      if (typeid(vector<boost::any>) == m["Line"].type()) {
        vector<DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyLinesLine> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Line"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyLinesLine model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        line = make_shared<vector<DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyLinesLine>>(expect1);
      }
    }
  }


  virtual ~DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyLines() = default;
};
class DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategy : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<string> effectiveAddrPoolGroupType{};
  shared_ptr<string> effectiveAddrPoolType{};
  shared_ptr<DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyEffectiveAddrPools> effectiveAddrPools{};
  shared_ptr<string> effectiveLbaStrategy{};
  shared_ptr<DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyLines> lines{};
  shared_ptr<string> strategyId{};
  shared_ptr<string> strategyName{};

  DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategy() {}

  explicit DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (effectiveAddrPoolGroupType) {
      res["EffectiveAddrPoolGroupType"] = boost::any(*effectiveAddrPoolGroupType);
    }
    if (effectiveAddrPoolType) {
      res["EffectiveAddrPoolType"] = boost::any(*effectiveAddrPoolType);
    }
    if (effectiveAddrPools) {
      res["EffectiveAddrPools"] = effectiveAddrPools ? boost::any(effectiveAddrPools->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (effectiveLbaStrategy) {
      res["EffectiveLbaStrategy"] = boost::any(*effectiveLbaStrategy);
    }
    if (lines) {
      res["Lines"] = lines ? boost::any(lines->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (strategyId) {
      res["StrategyId"] = boost::any(*strategyId);
    }
    if (strategyName) {
      res["StrategyName"] = boost::any(*strategyName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("EffectiveAddrPoolGroupType") != m.end() && !m["EffectiveAddrPoolGroupType"].empty()) {
      effectiveAddrPoolGroupType = make_shared<string>(boost::any_cast<string>(m["EffectiveAddrPoolGroupType"]));
    }
    if (m.find("EffectiveAddrPoolType") != m.end() && !m["EffectiveAddrPoolType"].empty()) {
      effectiveAddrPoolType = make_shared<string>(boost::any_cast<string>(m["EffectiveAddrPoolType"]));
    }
    if (m.find("EffectiveAddrPools") != m.end() && !m["EffectiveAddrPools"].empty()) {
      if (typeid(map<string, boost::any>) == m["EffectiveAddrPools"].type()) {
        DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyEffectiveAddrPools model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EffectiveAddrPools"]));
        effectiveAddrPools = make_shared<DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyEffectiveAddrPools>(model1);
      }
    }
    if (m.find("EffectiveLbaStrategy") != m.end() && !m["EffectiveLbaStrategy"].empty()) {
      effectiveLbaStrategy = make_shared<string>(boost::any_cast<string>(m["EffectiveLbaStrategy"]));
    }
    if (m.find("Lines") != m.end() && !m["Lines"].empty()) {
      if (typeid(map<string, boost::any>) == m["Lines"].type()) {
        DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyLines model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Lines"]));
        lines = make_shared<DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyLines>(model1);
      }
    }
    if (m.find("StrategyId") != m.end() && !m["StrategyId"].empty()) {
      strategyId = make_shared<string>(boost::any_cast<string>(m["StrategyId"]));
    }
    if (m.find("StrategyName") != m.end() && !m["StrategyName"].empty()) {
      strategyName = make_shared<string>(boost::any_cast<string>(m["StrategyName"]));
    }
  }


  virtual ~DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategy() = default;
};
class DescribeDnsGtmAccessStrategiesResponseBodyStrategies : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategy>> strategy{};

  DescribeDnsGtmAccessStrategiesResponseBodyStrategies() {}

  explicit DescribeDnsGtmAccessStrategiesResponseBodyStrategies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (strategy) {
      vector<boost::any> temp1;
      for(auto item1:*strategy){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Strategy"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Strategy") != m.end() && !m["Strategy"].empty()) {
      if (typeid(vector<boost::any>) == m["Strategy"].type()) {
        vector<DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategy> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Strategy"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategy model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        strategy = make_shared<vector<DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategy>>(expect1);
      }
    }
  }


  virtual ~DescribeDnsGtmAccessStrategiesResponseBodyStrategies() = default;
};
class DescribeDnsGtmAccessStrategiesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDnsGtmAccessStrategiesResponseBodyStrategies> strategies{};
  shared_ptr<long> totalItems{};
  shared_ptr<long> totalPages{};

  DescribeDnsGtmAccessStrategiesResponseBody() {}

  explicit DescribeDnsGtmAccessStrategiesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (strategies) {
      res["Strategies"] = strategies ? boost::any(strategies->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalItems) {
      res["TotalItems"] = boost::any(*totalItems);
    }
    if (totalPages) {
      res["TotalPages"] = boost::any(*totalPages);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Strategies") != m.end() && !m["Strategies"].empty()) {
      if (typeid(map<string, boost::any>) == m["Strategies"].type()) {
        DescribeDnsGtmAccessStrategiesResponseBodyStrategies model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Strategies"]));
        strategies = make_shared<DescribeDnsGtmAccessStrategiesResponseBodyStrategies>(model1);
      }
    }
    if (m.find("TotalItems") != m.end() && !m["TotalItems"].empty()) {
      totalItems = make_shared<long>(boost::any_cast<long>(m["TotalItems"]));
    }
    if (m.find("TotalPages") != m.end() && !m["TotalPages"].empty()) {
      totalPages = make_shared<long>(boost::any_cast<long>(m["TotalPages"]));
    }
  }


  virtual ~DescribeDnsGtmAccessStrategiesResponseBody() = default;
};
class DescribeDnsGtmAccessStrategiesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDnsGtmAccessStrategiesResponseBody> body{};

  DescribeDnsGtmAccessStrategiesResponse() {}

  explicit DescribeDnsGtmAccessStrategiesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDnsGtmAccessStrategiesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDnsGtmAccessStrategiesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDnsGtmAccessStrategiesResponse() = default;
};
class DescribeDnsGtmAccessStrategyRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> strategyId{};

  DescribeDnsGtmAccessStrategyRequest() {}

  explicit DescribeDnsGtmAccessStrategyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (strategyId) {
      res["StrategyId"] = boost::any(*strategyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("StrategyId") != m.end() && !m["StrategyId"].empty()) {
      strategyId = make_shared<string>(boost::any_cast<string>(m["StrategyId"]));
    }
  }


  virtual ~DescribeDnsGtmAccessStrategyRequest() = default;
};
class DescribeDnsGtmAccessStrategyResponseBodyDefaultAddrPoolsDefaultAddrPool : public Darabonba::Model {
public:
  shared_ptr<long> addrCount{};
  shared_ptr<string> id{};
  shared_ptr<long> lbaWeight{};
  shared_ptr<string> name{};

  DescribeDnsGtmAccessStrategyResponseBodyDefaultAddrPoolsDefaultAddrPool() {}

  explicit DescribeDnsGtmAccessStrategyResponseBodyDefaultAddrPoolsDefaultAddrPool(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addrCount) {
      res["AddrCount"] = boost::any(*addrCount);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (lbaWeight) {
      res["LbaWeight"] = boost::any(*lbaWeight);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddrCount") != m.end() && !m["AddrCount"].empty()) {
      addrCount = make_shared<long>(boost::any_cast<long>(m["AddrCount"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("LbaWeight") != m.end() && !m["LbaWeight"].empty()) {
      lbaWeight = make_shared<long>(boost::any_cast<long>(m["LbaWeight"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DescribeDnsGtmAccessStrategyResponseBodyDefaultAddrPoolsDefaultAddrPool() = default;
};
class DescribeDnsGtmAccessStrategyResponseBodyDefaultAddrPools : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDnsGtmAccessStrategyResponseBodyDefaultAddrPoolsDefaultAddrPool>> defaultAddrPool{};

  DescribeDnsGtmAccessStrategyResponseBodyDefaultAddrPools() {}

  explicit DescribeDnsGtmAccessStrategyResponseBodyDefaultAddrPools(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defaultAddrPool) {
      vector<boost::any> temp1;
      for(auto item1:*defaultAddrPool){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DefaultAddrPool"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefaultAddrPool") != m.end() && !m["DefaultAddrPool"].empty()) {
      if (typeid(vector<boost::any>) == m["DefaultAddrPool"].type()) {
        vector<DescribeDnsGtmAccessStrategyResponseBodyDefaultAddrPoolsDefaultAddrPool> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DefaultAddrPool"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDnsGtmAccessStrategyResponseBodyDefaultAddrPoolsDefaultAddrPool model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        defaultAddrPool = make_shared<vector<DescribeDnsGtmAccessStrategyResponseBodyDefaultAddrPoolsDefaultAddrPool>>(expect1);
      }
    }
  }


  virtual ~DescribeDnsGtmAccessStrategyResponseBodyDefaultAddrPools() = default;
};
class DescribeDnsGtmAccessStrategyResponseBodyFailoverAddrPoolsFailoverAddrPool : public Darabonba::Model {
public:
  shared_ptr<long> addrCount{};
  shared_ptr<string> id{};
  shared_ptr<long> lbaWeight{};
  shared_ptr<string> name{};

  DescribeDnsGtmAccessStrategyResponseBodyFailoverAddrPoolsFailoverAddrPool() {}

  explicit DescribeDnsGtmAccessStrategyResponseBodyFailoverAddrPoolsFailoverAddrPool(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addrCount) {
      res["AddrCount"] = boost::any(*addrCount);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (lbaWeight) {
      res["LbaWeight"] = boost::any(*lbaWeight);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddrCount") != m.end() && !m["AddrCount"].empty()) {
      addrCount = make_shared<long>(boost::any_cast<long>(m["AddrCount"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("LbaWeight") != m.end() && !m["LbaWeight"].empty()) {
      lbaWeight = make_shared<long>(boost::any_cast<long>(m["LbaWeight"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DescribeDnsGtmAccessStrategyResponseBodyFailoverAddrPoolsFailoverAddrPool() = default;
};
class DescribeDnsGtmAccessStrategyResponseBodyFailoverAddrPools : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDnsGtmAccessStrategyResponseBodyFailoverAddrPoolsFailoverAddrPool>> failoverAddrPool{};

  DescribeDnsGtmAccessStrategyResponseBodyFailoverAddrPools() {}

  explicit DescribeDnsGtmAccessStrategyResponseBodyFailoverAddrPools(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failoverAddrPool) {
      vector<boost::any> temp1;
      for(auto item1:*failoverAddrPool){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FailoverAddrPool"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailoverAddrPool") != m.end() && !m["FailoverAddrPool"].empty()) {
      if (typeid(vector<boost::any>) == m["FailoverAddrPool"].type()) {
        vector<DescribeDnsGtmAccessStrategyResponseBodyFailoverAddrPoolsFailoverAddrPool> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FailoverAddrPool"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDnsGtmAccessStrategyResponseBodyFailoverAddrPoolsFailoverAddrPool model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        failoverAddrPool = make_shared<vector<DescribeDnsGtmAccessStrategyResponseBodyFailoverAddrPoolsFailoverAddrPool>>(expect1);
      }
    }
  }


  virtual ~DescribeDnsGtmAccessStrategyResponseBodyFailoverAddrPools() = default;
};
class DescribeDnsGtmAccessStrategyResponseBodyLinesLine : public Darabonba::Model {
public:
  shared_ptr<string> groupCode{};
  shared_ptr<string> groupName{};
  shared_ptr<string> lineCode{};
  shared_ptr<string> lineName{};

  DescribeDnsGtmAccessStrategyResponseBodyLinesLine() {}

  explicit DescribeDnsGtmAccessStrategyResponseBodyLinesLine(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupCode) {
      res["GroupCode"] = boost::any(*groupCode);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (lineCode) {
      res["LineCode"] = boost::any(*lineCode);
    }
    if (lineName) {
      res["LineName"] = boost::any(*lineName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupCode") != m.end() && !m["GroupCode"].empty()) {
      groupCode = make_shared<string>(boost::any_cast<string>(m["GroupCode"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("LineCode") != m.end() && !m["LineCode"].empty()) {
      lineCode = make_shared<string>(boost::any_cast<string>(m["LineCode"]));
    }
    if (m.find("LineName") != m.end() && !m["LineName"].empty()) {
      lineName = make_shared<string>(boost::any_cast<string>(m["LineName"]));
    }
  }


  virtual ~DescribeDnsGtmAccessStrategyResponseBodyLinesLine() = default;
};
class DescribeDnsGtmAccessStrategyResponseBodyLines : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDnsGtmAccessStrategyResponseBodyLinesLine>> line{};

  DescribeDnsGtmAccessStrategyResponseBodyLines() {}

  explicit DescribeDnsGtmAccessStrategyResponseBodyLines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (line) {
      vector<boost::any> temp1;
      for(auto item1:*line){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Line"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Line") != m.end() && !m["Line"].empty()) {
      if (typeid(vector<boost::any>) == m["Line"].type()) {
        vector<DescribeDnsGtmAccessStrategyResponseBodyLinesLine> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Line"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDnsGtmAccessStrategyResponseBodyLinesLine model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        line = make_shared<vector<DescribeDnsGtmAccessStrategyResponseBodyLinesLine>>(expect1);
      }
    }
  }


  virtual ~DescribeDnsGtmAccessStrategyResponseBodyLines() = default;
};
class DescribeDnsGtmAccessStrategyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> accessMode{};
  shared_ptr<string> createTime{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<string> defaultAddrPoolGroupStatus{};
  shared_ptr<string> defaultAddrPoolType{};
  shared_ptr<DescribeDnsGtmAccessStrategyResponseBodyDefaultAddrPools> defaultAddrPools{};
  shared_ptr<long> defaultAvailableAddrNum{};
  shared_ptr<string> defaultLatencyOptimization{};
  shared_ptr<string> defaultLbaStrategy{};
  shared_ptr<long> defaultMaxReturnAddrNum{};
  shared_ptr<long> defaultMinAvailableAddrNum{};
  shared_ptr<string> effectiveAddrPoolGroupType{};
  shared_ptr<string> failoverAddrPoolGroupStatus{};
  shared_ptr<string> failoverAddrPoolType{};
  shared_ptr<DescribeDnsGtmAccessStrategyResponseBodyFailoverAddrPools> failoverAddrPools{};
  shared_ptr<long> failoverAvailableAddrNum{};
  shared_ptr<string> failoverLatencyOptimization{};
  shared_ptr<string> failoverLbaStrategy{};
  shared_ptr<long> failoverMaxReturnAddrNum{};
  shared_ptr<long> failoverMinAvailableAddrNum{};
  shared_ptr<string> instanceId{};
  shared_ptr<DescribeDnsGtmAccessStrategyResponseBodyLines> lines{};
  shared_ptr<string> requestId{};
  shared_ptr<string> strategyId{};
  shared_ptr<string> strategyMode{};
  shared_ptr<string> strategyName{};

  DescribeDnsGtmAccessStrategyResponseBody() {}

  explicit DescribeDnsGtmAccessStrategyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessMode) {
      res["AccessMode"] = boost::any(*accessMode);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (defaultAddrPoolGroupStatus) {
      res["DefaultAddrPoolGroupStatus"] = boost::any(*defaultAddrPoolGroupStatus);
    }
    if (defaultAddrPoolType) {
      res["DefaultAddrPoolType"] = boost::any(*defaultAddrPoolType);
    }
    if (defaultAddrPools) {
      res["DefaultAddrPools"] = defaultAddrPools ? boost::any(defaultAddrPools->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (defaultAvailableAddrNum) {
      res["DefaultAvailableAddrNum"] = boost::any(*defaultAvailableAddrNum);
    }
    if (defaultLatencyOptimization) {
      res["DefaultLatencyOptimization"] = boost::any(*defaultLatencyOptimization);
    }
    if (defaultLbaStrategy) {
      res["DefaultLbaStrategy"] = boost::any(*defaultLbaStrategy);
    }
    if (defaultMaxReturnAddrNum) {
      res["DefaultMaxReturnAddrNum"] = boost::any(*defaultMaxReturnAddrNum);
    }
    if (defaultMinAvailableAddrNum) {
      res["DefaultMinAvailableAddrNum"] = boost::any(*defaultMinAvailableAddrNum);
    }
    if (effectiveAddrPoolGroupType) {
      res["EffectiveAddrPoolGroupType"] = boost::any(*effectiveAddrPoolGroupType);
    }
    if (failoverAddrPoolGroupStatus) {
      res["FailoverAddrPoolGroupStatus"] = boost::any(*failoverAddrPoolGroupStatus);
    }
    if (failoverAddrPoolType) {
      res["FailoverAddrPoolType"] = boost::any(*failoverAddrPoolType);
    }
    if (failoverAddrPools) {
      res["FailoverAddrPools"] = failoverAddrPools ? boost::any(failoverAddrPools->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (failoverAvailableAddrNum) {
      res["FailoverAvailableAddrNum"] = boost::any(*failoverAvailableAddrNum);
    }
    if (failoverLatencyOptimization) {
      res["FailoverLatencyOptimization"] = boost::any(*failoverLatencyOptimization);
    }
    if (failoverLbaStrategy) {
      res["FailoverLbaStrategy"] = boost::any(*failoverLbaStrategy);
    }
    if (failoverMaxReturnAddrNum) {
      res["FailoverMaxReturnAddrNum"] = boost::any(*failoverMaxReturnAddrNum);
    }
    if (failoverMinAvailableAddrNum) {
      res["FailoverMinAvailableAddrNum"] = boost::any(*failoverMinAvailableAddrNum);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lines) {
      res["Lines"] = lines ? boost::any(lines->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (strategyId) {
      res["StrategyId"] = boost::any(*strategyId);
    }
    if (strategyMode) {
      res["StrategyMode"] = boost::any(*strategyMode);
    }
    if (strategyName) {
      res["StrategyName"] = boost::any(*strategyName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessMode") != m.end() && !m["AccessMode"].empty()) {
      accessMode = make_shared<string>(boost::any_cast<string>(m["AccessMode"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("DefaultAddrPoolGroupStatus") != m.end() && !m["DefaultAddrPoolGroupStatus"].empty()) {
      defaultAddrPoolGroupStatus = make_shared<string>(boost::any_cast<string>(m["DefaultAddrPoolGroupStatus"]));
    }
    if (m.find("DefaultAddrPoolType") != m.end() && !m["DefaultAddrPoolType"].empty()) {
      defaultAddrPoolType = make_shared<string>(boost::any_cast<string>(m["DefaultAddrPoolType"]));
    }
    if (m.find("DefaultAddrPools") != m.end() && !m["DefaultAddrPools"].empty()) {
      if (typeid(map<string, boost::any>) == m["DefaultAddrPools"].type()) {
        DescribeDnsGtmAccessStrategyResponseBodyDefaultAddrPools model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DefaultAddrPools"]));
        defaultAddrPools = make_shared<DescribeDnsGtmAccessStrategyResponseBodyDefaultAddrPools>(model1);
      }
    }
    if (m.find("DefaultAvailableAddrNum") != m.end() && !m["DefaultAvailableAddrNum"].empty()) {
      defaultAvailableAddrNum = make_shared<long>(boost::any_cast<long>(m["DefaultAvailableAddrNum"]));
    }
    if (m.find("DefaultLatencyOptimization") != m.end() && !m["DefaultLatencyOptimization"].empty()) {
      defaultLatencyOptimization = make_shared<string>(boost::any_cast<string>(m["DefaultLatencyOptimization"]));
    }
    if (m.find("DefaultLbaStrategy") != m.end() && !m["DefaultLbaStrategy"].empty()) {
      defaultLbaStrategy = make_shared<string>(boost::any_cast<string>(m["DefaultLbaStrategy"]));
    }
    if (m.find("DefaultMaxReturnAddrNum") != m.end() && !m["DefaultMaxReturnAddrNum"].empty()) {
      defaultMaxReturnAddrNum = make_shared<long>(boost::any_cast<long>(m["DefaultMaxReturnAddrNum"]));
    }
    if (m.find("DefaultMinAvailableAddrNum") != m.end() && !m["DefaultMinAvailableAddrNum"].empty()) {
      defaultMinAvailableAddrNum = make_shared<long>(boost::any_cast<long>(m["DefaultMinAvailableAddrNum"]));
    }
    if (m.find("EffectiveAddrPoolGroupType") != m.end() && !m["EffectiveAddrPoolGroupType"].empty()) {
      effectiveAddrPoolGroupType = make_shared<string>(boost::any_cast<string>(m["EffectiveAddrPoolGroupType"]));
    }
    if (m.find("FailoverAddrPoolGroupStatus") != m.end() && !m["FailoverAddrPoolGroupStatus"].empty()) {
      failoverAddrPoolGroupStatus = make_shared<string>(boost::any_cast<string>(m["FailoverAddrPoolGroupStatus"]));
    }
    if (m.find("FailoverAddrPoolType") != m.end() && !m["FailoverAddrPoolType"].empty()) {
      failoverAddrPoolType = make_shared<string>(boost::any_cast<string>(m["FailoverAddrPoolType"]));
    }
    if (m.find("FailoverAddrPools") != m.end() && !m["FailoverAddrPools"].empty()) {
      if (typeid(map<string, boost::any>) == m["FailoverAddrPools"].type()) {
        DescribeDnsGtmAccessStrategyResponseBodyFailoverAddrPools model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FailoverAddrPools"]));
        failoverAddrPools = make_shared<DescribeDnsGtmAccessStrategyResponseBodyFailoverAddrPools>(model1);
      }
    }
    if (m.find("FailoverAvailableAddrNum") != m.end() && !m["FailoverAvailableAddrNum"].empty()) {
      failoverAvailableAddrNum = make_shared<long>(boost::any_cast<long>(m["FailoverAvailableAddrNum"]));
    }
    if (m.find("FailoverLatencyOptimization") != m.end() && !m["FailoverLatencyOptimization"].empty()) {
      failoverLatencyOptimization = make_shared<string>(boost::any_cast<string>(m["FailoverLatencyOptimization"]));
    }
    if (m.find("FailoverLbaStrategy") != m.end() && !m["FailoverLbaStrategy"].empty()) {
      failoverLbaStrategy = make_shared<string>(boost::any_cast<string>(m["FailoverLbaStrategy"]));
    }
    if (m.find("FailoverMaxReturnAddrNum") != m.end() && !m["FailoverMaxReturnAddrNum"].empty()) {
      failoverMaxReturnAddrNum = make_shared<long>(boost::any_cast<long>(m["FailoverMaxReturnAddrNum"]));
    }
    if (m.find("FailoverMinAvailableAddrNum") != m.end() && !m["FailoverMinAvailableAddrNum"].empty()) {
      failoverMinAvailableAddrNum = make_shared<long>(boost::any_cast<long>(m["FailoverMinAvailableAddrNum"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Lines") != m.end() && !m["Lines"].empty()) {
      if (typeid(map<string, boost::any>) == m["Lines"].type()) {
        DescribeDnsGtmAccessStrategyResponseBodyLines model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Lines"]));
        lines = make_shared<DescribeDnsGtmAccessStrategyResponseBodyLines>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StrategyId") != m.end() && !m["StrategyId"].empty()) {
      strategyId = make_shared<string>(boost::any_cast<string>(m["StrategyId"]));
    }
    if (m.find("StrategyMode") != m.end() && !m["StrategyMode"].empty()) {
      strategyMode = make_shared<string>(boost::any_cast<string>(m["StrategyMode"]));
    }
    if (m.find("StrategyName") != m.end() && !m["StrategyName"].empty()) {
      strategyName = make_shared<string>(boost::any_cast<string>(m["StrategyName"]));
    }
  }


  virtual ~DescribeDnsGtmAccessStrategyResponseBody() = default;
};
class DescribeDnsGtmAccessStrategyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDnsGtmAccessStrategyResponseBody> body{};

  DescribeDnsGtmAccessStrategyResponse() {}

  explicit DescribeDnsGtmAccessStrategyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDnsGtmAccessStrategyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDnsGtmAccessStrategyResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDnsGtmAccessStrategyResponse() = default;
};
class DescribeDnsGtmAccessStrategyAvailableConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> lang{};
  shared_ptr<string> strategyMode{};

  DescribeDnsGtmAccessStrategyAvailableConfigRequest() {}

  explicit DescribeDnsGtmAccessStrategyAvailableConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (strategyMode) {
      res["StrategyMode"] = boost::any(*strategyMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("StrategyMode") != m.end() && !m["StrategyMode"].empty()) {
      strategyMode = make_shared<string>(boost::any_cast<string>(m["StrategyMode"]));
    }
  }


  virtual ~DescribeDnsGtmAccessStrategyAvailableConfigRequest() = default;
};
class DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyDomainAddrPoolsDomainAddrPool : public Darabonba::Model {
public:
  shared_ptr<long> addrCount{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyDomainAddrPoolsDomainAddrPool() {}

  explicit DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyDomainAddrPoolsDomainAddrPool(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addrCount) {
      res["AddrCount"] = boost::any(*addrCount);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddrCount") != m.end() && !m["AddrCount"].empty()) {
      addrCount = make_shared<long>(boost::any_cast<long>(m["AddrCount"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyDomainAddrPoolsDomainAddrPool() = default;
};
class DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyDomainAddrPools : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyDomainAddrPoolsDomainAddrPool>> domainAddrPool{};

  DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyDomainAddrPools() {}

  explicit DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyDomainAddrPools(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainAddrPool) {
      vector<boost::any> temp1;
      for(auto item1:*domainAddrPool){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainAddrPool"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainAddrPool") != m.end() && !m["DomainAddrPool"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainAddrPool"].type()) {
        vector<DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyDomainAddrPoolsDomainAddrPool> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainAddrPool"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyDomainAddrPoolsDomainAddrPool model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainAddrPool = make_shared<vector<DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyDomainAddrPoolsDomainAddrPool>>(expect1);
      }
    }
  }


  virtual ~DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyDomainAddrPools() = default;
};
class DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv4AddrPoolsIpv4AddrPool : public Darabonba::Model {
public:
  shared_ptr<long> addrCount{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv4AddrPoolsIpv4AddrPool() {}

  explicit DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv4AddrPoolsIpv4AddrPool(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addrCount) {
      res["AddrCount"] = boost::any(*addrCount);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddrCount") != m.end() && !m["AddrCount"].empty()) {
      addrCount = make_shared<long>(boost::any_cast<long>(m["AddrCount"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv4AddrPoolsIpv4AddrPool() = default;
};
class DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv4AddrPools : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv4AddrPoolsIpv4AddrPool>> ipv4AddrPool{};

  DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv4AddrPools() {}

  explicit DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv4AddrPools(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipv4AddrPool) {
      vector<boost::any> temp1;
      for(auto item1:*ipv4AddrPool){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Ipv4AddrPool"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ipv4AddrPool") != m.end() && !m["Ipv4AddrPool"].empty()) {
      if (typeid(vector<boost::any>) == m["Ipv4AddrPool"].type()) {
        vector<DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv4AddrPoolsIpv4AddrPool> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Ipv4AddrPool"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv4AddrPoolsIpv4AddrPool model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ipv4AddrPool = make_shared<vector<DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv4AddrPoolsIpv4AddrPool>>(expect1);
      }
    }
  }


  virtual ~DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv4AddrPools() = default;
};
class DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv6AddrPoolsIpv6AddrPool : public Darabonba::Model {
public:
  shared_ptr<long> addrCount{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv6AddrPoolsIpv6AddrPool() {}

  explicit DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv6AddrPoolsIpv6AddrPool(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addrCount) {
      res["AddrCount"] = boost::any(*addrCount);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddrCount") != m.end() && !m["AddrCount"].empty()) {
      addrCount = make_shared<long>(boost::any_cast<long>(m["AddrCount"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv6AddrPoolsIpv6AddrPool() = default;
};
class DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv6AddrPools : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv6AddrPoolsIpv6AddrPool>> ipv6AddrPool{};

  DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv6AddrPools() {}

  explicit DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv6AddrPools(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipv6AddrPool) {
      vector<boost::any> temp1;
      for(auto item1:*ipv6AddrPool){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Ipv6AddrPool"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ipv6AddrPool") != m.end() && !m["Ipv6AddrPool"].empty()) {
      if (typeid(vector<boost::any>) == m["Ipv6AddrPool"].type()) {
        vector<DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv6AddrPoolsIpv6AddrPool> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Ipv6AddrPool"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv6AddrPoolsIpv6AddrPool model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ipv6AddrPool = make_shared<vector<DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv6AddrPoolsIpv6AddrPool>>(expect1);
      }
    }
  }


  virtual ~DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv6AddrPools() = default;
};
class DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyLinesLine : public Darabonba::Model {
public:
  shared_ptr<string> fatherCode{};
  shared_ptr<string> groupCode{};
  shared_ptr<string> groupName{};
  shared_ptr<string> lineCode{};
  shared_ptr<string> lineName{};

  DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyLinesLine() {}

  explicit DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyLinesLine(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fatherCode) {
      res["FatherCode"] = boost::any(*fatherCode);
    }
    if (groupCode) {
      res["GroupCode"] = boost::any(*groupCode);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (lineCode) {
      res["LineCode"] = boost::any(*lineCode);
    }
    if (lineName) {
      res["LineName"] = boost::any(*lineName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FatherCode") != m.end() && !m["FatherCode"].empty()) {
      fatherCode = make_shared<string>(boost::any_cast<string>(m["FatherCode"]));
    }
    if (m.find("GroupCode") != m.end() && !m["GroupCode"].empty()) {
      groupCode = make_shared<string>(boost::any_cast<string>(m["GroupCode"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("LineCode") != m.end() && !m["LineCode"].empty()) {
      lineCode = make_shared<string>(boost::any_cast<string>(m["LineCode"]));
    }
    if (m.find("LineName") != m.end() && !m["LineName"].empty()) {
      lineName = make_shared<string>(boost::any_cast<string>(m["LineName"]));
    }
  }


  virtual ~DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyLinesLine() = default;
};
class DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyLines : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyLinesLine>> line{};

  DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyLines() {}

  explicit DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyLines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (line) {
      vector<boost::any> temp1;
      for(auto item1:*line){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Line"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Line") != m.end() && !m["Line"].empty()) {
      if (typeid(vector<boost::any>) == m["Line"].type()) {
        vector<DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyLinesLine> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Line"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyLinesLine model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        line = make_shared<vector<DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyLinesLine>>(expect1);
      }
    }
  }


  virtual ~DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyLines() = default;
};
class DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedDomainLines : public Darabonba::Model {
public:
  shared_ptr<vector<string>> selectedDomainLine{};

  DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedDomainLines() {}

  explicit DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedDomainLines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (selectedDomainLine) {
      res["SelectedDomainLine"] = boost::any(*selectedDomainLine);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SelectedDomainLine") != m.end() && !m["SelectedDomainLine"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SelectedDomainLine"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SelectedDomainLine"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      selectedDomainLine = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedDomainLines() = default;
};
class DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedIpv4Lines : public Darabonba::Model {
public:
  shared_ptr<vector<string>> selectedIpv4Line{};

  DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedIpv4Lines() {}

  explicit DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedIpv4Lines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (selectedIpv4Line) {
      res["SelectedIpv4Line"] = boost::any(*selectedIpv4Line);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SelectedIpv4Line") != m.end() && !m["SelectedIpv4Line"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SelectedIpv4Line"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SelectedIpv4Line"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      selectedIpv4Line = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedIpv4Lines() = default;
};
class DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedIpv6Lines : public Darabonba::Model {
public:
  shared_ptr<vector<string>> selectedIpv6Line{};

  DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedIpv6Lines() {}

  explicit DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedIpv6Lines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (selectedIpv6Line) {
      res["SelectedIpv6Line"] = boost::any(*selectedIpv6Line);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SelectedIpv6Line") != m.end() && !m["SelectedIpv6Line"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SelectedIpv6Line"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SelectedIpv6Line"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      selectedIpv6Line = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedIpv6Lines() = default;
};
class DescribeDnsGtmAccessStrategyAvailableConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyDomainAddrPools> domainAddrPools{};
  shared_ptr<DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv4AddrPools> ipv4AddrPools{};
  shared_ptr<DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv6AddrPools> ipv6AddrPools{};
  shared_ptr<DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyLines> lines{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedDomainLines> selectedDomainLines{};
  shared_ptr<DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedIpv4Lines> selectedIpv4Lines{};
  shared_ptr<DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedIpv6Lines> selectedIpv6Lines{};
  shared_ptr<bool> suggestSetDefaultLine{};

  DescribeDnsGtmAccessStrategyAvailableConfigResponseBody() {}

  explicit DescribeDnsGtmAccessStrategyAvailableConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainAddrPools) {
      res["DomainAddrPools"] = domainAddrPools ? boost::any(domainAddrPools->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ipv4AddrPools) {
      res["Ipv4AddrPools"] = ipv4AddrPools ? boost::any(ipv4AddrPools->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ipv6AddrPools) {
      res["Ipv6AddrPools"] = ipv6AddrPools ? boost::any(ipv6AddrPools->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (lines) {
      res["Lines"] = lines ? boost::any(lines->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (selectedDomainLines) {
      res["SelectedDomainLines"] = selectedDomainLines ? boost::any(selectedDomainLines->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (selectedIpv4Lines) {
      res["SelectedIpv4Lines"] = selectedIpv4Lines ? boost::any(selectedIpv4Lines->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (selectedIpv6Lines) {
      res["SelectedIpv6Lines"] = selectedIpv6Lines ? boost::any(selectedIpv6Lines->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (suggestSetDefaultLine) {
      res["SuggestSetDefaultLine"] = boost::any(*suggestSetDefaultLine);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainAddrPools") != m.end() && !m["DomainAddrPools"].empty()) {
      if (typeid(map<string, boost::any>) == m["DomainAddrPools"].type()) {
        DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyDomainAddrPools model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DomainAddrPools"]));
        domainAddrPools = make_shared<DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyDomainAddrPools>(model1);
      }
    }
    if (m.find("Ipv4AddrPools") != m.end() && !m["Ipv4AddrPools"].empty()) {
      if (typeid(map<string, boost::any>) == m["Ipv4AddrPools"].type()) {
        DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv4AddrPools model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Ipv4AddrPools"]));
        ipv4AddrPools = make_shared<DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv4AddrPools>(model1);
      }
    }
    if (m.find("Ipv6AddrPools") != m.end() && !m["Ipv6AddrPools"].empty()) {
      if (typeid(map<string, boost::any>) == m["Ipv6AddrPools"].type()) {
        DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv6AddrPools model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Ipv6AddrPools"]));
        ipv6AddrPools = make_shared<DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv6AddrPools>(model1);
      }
    }
    if (m.find("Lines") != m.end() && !m["Lines"].empty()) {
      if (typeid(map<string, boost::any>) == m["Lines"].type()) {
        DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyLines model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Lines"]));
        lines = make_shared<DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyLines>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SelectedDomainLines") != m.end() && !m["SelectedDomainLines"].empty()) {
      if (typeid(map<string, boost::any>) == m["SelectedDomainLines"].type()) {
        DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedDomainLines model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SelectedDomainLines"]));
        selectedDomainLines = make_shared<DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedDomainLines>(model1);
      }
    }
    if (m.find("SelectedIpv4Lines") != m.end() && !m["SelectedIpv4Lines"].empty()) {
      if (typeid(map<string, boost::any>) == m["SelectedIpv4Lines"].type()) {
        DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedIpv4Lines model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SelectedIpv4Lines"]));
        selectedIpv4Lines = make_shared<DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedIpv4Lines>(model1);
      }
    }
    if (m.find("SelectedIpv6Lines") != m.end() && !m["SelectedIpv6Lines"].empty()) {
      if (typeid(map<string, boost::any>) == m["SelectedIpv6Lines"].type()) {
        DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedIpv6Lines model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SelectedIpv6Lines"]));
        selectedIpv6Lines = make_shared<DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedIpv6Lines>(model1);
      }
    }
    if (m.find("SuggestSetDefaultLine") != m.end() && !m["SuggestSetDefaultLine"].empty()) {
      suggestSetDefaultLine = make_shared<bool>(boost::any_cast<bool>(m["SuggestSetDefaultLine"]));
    }
  }


  virtual ~DescribeDnsGtmAccessStrategyAvailableConfigResponseBody() = default;
};
class DescribeDnsGtmAccessStrategyAvailableConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDnsGtmAccessStrategyAvailableConfigResponseBody> body{};

  DescribeDnsGtmAccessStrategyAvailableConfigResponse() {}

  explicit DescribeDnsGtmAccessStrategyAvailableConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDnsGtmAccessStrategyAvailableConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDnsGtmAccessStrategyAvailableConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDnsGtmAccessStrategyAvailableConfigResponse() = default;
};
class DescribeDnsGtmAddrAttributeInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> addrs{};
  shared_ptr<string> lang{};
  shared_ptr<string> type{};

  DescribeDnsGtmAddrAttributeInfoRequest() {}

  explicit DescribeDnsGtmAddrAttributeInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addrs) {
      res["Addrs"] = boost::any(*addrs);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Addrs") != m.end() && !m["Addrs"].empty()) {
      addrs = make_shared<string>(boost::any_cast<string>(m["Addrs"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeDnsGtmAddrAttributeInfoRequest() = default;
};
class DescribeDnsGtmAddrAttributeInfoResponseBodyAddrAddrAttributeInfo : public Darabonba::Model {
public:
  shared_ptr<string> fatherCode{};
  shared_ptr<string> groupCode{};
  shared_ptr<string> groupName{};
  shared_ptr<string> lineCode{};
  shared_ptr<string> lineName{};

  DescribeDnsGtmAddrAttributeInfoResponseBodyAddrAddrAttributeInfo() {}

  explicit DescribeDnsGtmAddrAttributeInfoResponseBodyAddrAddrAttributeInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fatherCode) {
      res["FatherCode"] = boost::any(*fatherCode);
    }
    if (groupCode) {
      res["GroupCode"] = boost::any(*groupCode);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (lineCode) {
      res["LineCode"] = boost::any(*lineCode);
    }
    if (lineName) {
      res["LineName"] = boost::any(*lineName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FatherCode") != m.end() && !m["FatherCode"].empty()) {
      fatherCode = make_shared<string>(boost::any_cast<string>(m["FatherCode"]));
    }
    if (m.find("GroupCode") != m.end() && !m["GroupCode"].empty()) {
      groupCode = make_shared<string>(boost::any_cast<string>(m["GroupCode"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("LineCode") != m.end() && !m["LineCode"].empty()) {
      lineCode = make_shared<string>(boost::any_cast<string>(m["LineCode"]));
    }
    if (m.find("LineName") != m.end() && !m["LineName"].empty()) {
      lineName = make_shared<string>(boost::any_cast<string>(m["LineName"]));
    }
  }


  virtual ~DescribeDnsGtmAddrAttributeInfoResponseBodyAddrAddrAttributeInfo() = default;
};
class DescribeDnsGtmAddrAttributeInfoResponseBodyAddrAddr : public Darabonba::Model {
public:
  shared_ptr<string> addr{};
  shared_ptr<DescribeDnsGtmAddrAttributeInfoResponseBodyAddrAddrAttributeInfo> attributeInfo{};

  DescribeDnsGtmAddrAttributeInfoResponseBodyAddrAddr() {}

  explicit DescribeDnsGtmAddrAttributeInfoResponseBodyAddrAddr(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addr) {
      res["Addr"] = boost::any(*addr);
    }
    if (attributeInfo) {
      res["AttributeInfo"] = attributeInfo ? boost::any(attributeInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Addr") != m.end() && !m["Addr"].empty()) {
      addr = make_shared<string>(boost::any_cast<string>(m["Addr"]));
    }
    if (m.find("AttributeInfo") != m.end() && !m["AttributeInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["AttributeInfo"].type()) {
        DescribeDnsGtmAddrAttributeInfoResponseBodyAddrAddrAttributeInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AttributeInfo"]));
        attributeInfo = make_shared<DescribeDnsGtmAddrAttributeInfoResponseBodyAddrAddrAttributeInfo>(model1);
      }
    }
  }


  virtual ~DescribeDnsGtmAddrAttributeInfoResponseBodyAddrAddr() = default;
};
class DescribeDnsGtmAddrAttributeInfoResponseBodyAddr : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDnsGtmAddrAttributeInfoResponseBodyAddrAddr>> addr{};

  DescribeDnsGtmAddrAttributeInfoResponseBodyAddr() {}

  explicit DescribeDnsGtmAddrAttributeInfoResponseBodyAddr(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addr) {
      vector<boost::any> temp1;
      for(auto item1:*addr){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Addr"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Addr") != m.end() && !m["Addr"].empty()) {
      if (typeid(vector<boost::any>) == m["Addr"].type()) {
        vector<DescribeDnsGtmAddrAttributeInfoResponseBodyAddrAddr> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Addr"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDnsGtmAddrAttributeInfoResponseBodyAddrAddr model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        addr = make_shared<vector<DescribeDnsGtmAddrAttributeInfoResponseBodyAddrAddr>>(expect1);
      }
    }
  }


  virtual ~DescribeDnsGtmAddrAttributeInfoResponseBodyAddr() = default;
};
class DescribeDnsGtmAddrAttributeInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDnsGtmAddrAttributeInfoResponseBodyAddr> addr{};
  shared_ptr<string> requestId{};

  DescribeDnsGtmAddrAttributeInfoResponseBody() {}

  explicit DescribeDnsGtmAddrAttributeInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addr) {
      res["Addr"] = addr ? boost::any(addr->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Addr") != m.end() && !m["Addr"].empty()) {
      if (typeid(map<string, boost::any>) == m["Addr"].type()) {
        DescribeDnsGtmAddrAttributeInfoResponseBodyAddr model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Addr"]));
        addr = make_shared<DescribeDnsGtmAddrAttributeInfoResponseBodyAddr>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDnsGtmAddrAttributeInfoResponseBody() = default;
};
class DescribeDnsGtmAddrAttributeInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDnsGtmAddrAttributeInfoResponseBody> body{};

  DescribeDnsGtmAddrAttributeInfoResponse() {}

  explicit DescribeDnsGtmAddrAttributeInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDnsGtmAddrAttributeInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDnsGtmAddrAttributeInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDnsGtmAddrAttributeInfoResponse() = default;
};
class DescribeDnsGtmAddressPoolAvailableConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> lang{};

  DescribeDnsGtmAddressPoolAvailableConfigRequest() {}

  explicit DescribeDnsGtmAddressPoolAvailableConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~DescribeDnsGtmAddressPoolAvailableConfigRequest() = default;
};
class DescribeDnsGtmAddressPoolAvailableConfigResponseBodyAttributeInfosAttributeInfo : public Darabonba::Model {
public:
  shared_ptr<string> fatherCode{};
  shared_ptr<string> groupCode{};
  shared_ptr<string> groupName{};
  shared_ptr<string> lineCode{};
  shared_ptr<string> lineName{};

  DescribeDnsGtmAddressPoolAvailableConfigResponseBodyAttributeInfosAttributeInfo() {}

  explicit DescribeDnsGtmAddressPoolAvailableConfigResponseBodyAttributeInfosAttributeInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fatherCode) {
      res["FatherCode"] = boost::any(*fatherCode);
    }
    if (groupCode) {
      res["GroupCode"] = boost::any(*groupCode);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (lineCode) {
      res["LineCode"] = boost::any(*lineCode);
    }
    if (lineName) {
      res["LineName"] = boost::any(*lineName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FatherCode") != m.end() && !m["FatherCode"].empty()) {
      fatherCode = make_shared<string>(boost::any_cast<string>(m["FatherCode"]));
    }
    if (m.find("GroupCode") != m.end() && !m["GroupCode"].empty()) {
      groupCode = make_shared<string>(boost::any_cast<string>(m["GroupCode"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("LineCode") != m.end() && !m["LineCode"].empty()) {
      lineCode = make_shared<string>(boost::any_cast<string>(m["LineCode"]));
    }
    if (m.find("LineName") != m.end() && !m["LineName"].empty()) {
      lineName = make_shared<string>(boost::any_cast<string>(m["LineName"]));
    }
  }


  virtual ~DescribeDnsGtmAddressPoolAvailableConfigResponseBodyAttributeInfosAttributeInfo() = default;
};
class DescribeDnsGtmAddressPoolAvailableConfigResponseBodyAttributeInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDnsGtmAddressPoolAvailableConfigResponseBodyAttributeInfosAttributeInfo>> attributeInfo{};

  DescribeDnsGtmAddressPoolAvailableConfigResponseBodyAttributeInfos() {}

  explicit DescribeDnsGtmAddressPoolAvailableConfigResponseBodyAttributeInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attributeInfo) {
      vector<boost::any> temp1;
      for(auto item1:*attributeInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AttributeInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttributeInfo") != m.end() && !m["AttributeInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["AttributeInfo"].type()) {
        vector<DescribeDnsGtmAddressPoolAvailableConfigResponseBodyAttributeInfosAttributeInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AttributeInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDnsGtmAddressPoolAvailableConfigResponseBodyAttributeInfosAttributeInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        attributeInfo = make_shared<vector<DescribeDnsGtmAddressPoolAvailableConfigResponseBodyAttributeInfosAttributeInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeDnsGtmAddressPoolAvailableConfigResponseBodyAttributeInfos() = default;
};
class DescribeDnsGtmAddressPoolAvailableConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDnsGtmAddressPoolAvailableConfigResponseBodyAttributeInfos> attributeInfos{};
  shared_ptr<string> requestId{};

  DescribeDnsGtmAddressPoolAvailableConfigResponseBody() {}

  explicit DescribeDnsGtmAddressPoolAvailableConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attributeInfos) {
      res["AttributeInfos"] = attributeInfos ? boost::any(attributeInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttributeInfos") != m.end() && !m["AttributeInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["AttributeInfos"].type()) {
        DescribeDnsGtmAddressPoolAvailableConfigResponseBodyAttributeInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AttributeInfos"]));
        attributeInfos = make_shared<DescribeDnsGtmAddressPoolAvailableConfigResponseBodyAttributeInfos>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDnsGtmAddressPoolAvailableConfigResponseBody() = default;
};
class DescribeDnsGtmAddressPoolAvailableConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDnsGtmAddressPoolAvailableConfigResponseBody> body{};

  DescribeDnsGtmAddressPoolAvailableConfigResponse() {}

  explicit DescribeDnsGtmAddressPoolAvailableConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDnsGtmAddressPoolAvailableConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDnsGtmAddressPoolAvailableConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDnsGtmAddressPoolAvailableConfigResponse() = default;
};
class DescribeDnsGtmAvailableAlertGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};

  DescribeDnsGtmAvailableAlertGroupRequest() {}

  explicit DescribeDnsGtmAvailableAlertGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~DescribeDnsGtmAvailableAlertGroupRequest() = default;
};
class DescribeDnsGtmAvailableAlertGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> availableAlertGroup{};
  shared_ptr<string> requestId{};

  DescribeDnsGtmAvailableAlertGroupResponseBody() {}

  explicit DescribeDnsGtmAvailableAlertGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availableAlertGroup) {
      res["AvailableAlertGroup"] = boost::any(*availableAlertGroup);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvailableAlertGroup") != m.end() && !m["AvailableAlertGroup"].empty()) {
      availableAlertGroup = make_shared<string>(boost::any_cast<string>(m["AvailableAlertGroup"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDnsGtmAvailableAlertGroupResponseBody() = default;
};
class DescribeDnsGtmAvailableAlertGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDnsGtmAvailableAlertGroupResponseBody> body{};

  DescribeDnsGtmAvailableAlertGroupResponse() {}

  explicit DescribeDnsGtmAvailableAlertGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDnsGtmAvailableAlertGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDnsGtmAvailableAlertGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDnsGtmAvailableAlertGroupResponse() = default;
};
class DescribeDnsGtmInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> lang{};

  DescribeDnsGtmInstanceRequest() {}

  explicit DescribeDnsGtmInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~DescribeDnsGtmInstanceRequest() = default;
};
class DescribeDnsGtmInstanceResponseBodyConfigAlertConfigAlertConfig : public Darabonba::Model {
public:
  shared_ptr<bool> dingtalkNotice{};
  shared_ptr<bool> emailNotice{};
  shared_ptr<string> noticeType{};
  shared_ptr<bool> smsNotice{};

  DescribeDnsGtmInstanceResponseBodyConfigAlertConfigAlertConfig() {}

  explicit DescribeDnsGtmInstanceResponseBodyConfigAlertConfigAlertConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dingtalkNotice) {
      res["DingtalkNotice"] = boost::any(*dingtalkNotice);
    }
    if (emailNotice) {
      res["EmailNotice"] = boost::any(*emailNotice);
    }
    if (noticeType) {
      res["NoticeType"] = boost::any(*noticeType);
    }
    if (smsNotice) {
      res["SmsNotice"] = boost::any(*smsNotice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DingtalkNotice") != m.end() && !m["DingtalkNotice"].empty()) {
      dingtalkNotice = make_shared<bool>(boost::any_cast<bool>(m["DingtalkNotice"]));
    }
    if (m.find("EmailNotice") != m.end() && !m["EmailNotice"].empty()) {
      emailNotice = make_shared<bool>(boost::any_cast<bool>(m["EmailNotice"]));
    }
    if (m.find("NoticeType") != m.end() && !m["NoticeType"].empty()) {
      noticeType = make_shared<string>(boost::any_cast<string>(m["NoticeType"]));
    }
    if (m.find("SmsNotice") != m.end() && !m["SmsNotice"].empty()) {
      smsNotice = make_shared<bool>(boost::any_cast<bool>(m["SmsNotice"]));
    }
  }


  virtual ~DescribeDnsGtmInstanceResponseBodyConfigAlertConfigAlertConfig() = default;
};
class DescribeDnsGtmInstanceResponseBodyConfigAlertConfig : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDnsGtmInstanceResponseBodyConfigAlertConfigAlertConfig>> alertConfig{};

  DescribeDnsGtmInstanceResponseBodyConfigAlertConfig() {}

  explicit DescribeDnsGtmInstanceResponseBodyConfigAlertConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertConfig) {
      vector<boost::any> temp1;
      for(auto item1:*alertConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlertConfig"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertConfig") != m.end() && !m["AlertConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["AlertConfig"].type()) {
        vector<DescribeDnsGtmInstanceResponseBodyConfigAlertConfigAlertConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlertConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDnsGtmInstanceResponseBodyConfigAlertConfigAlertConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alertConfig = make_shared<vector<DescribeDnsGtmInstanceResponseBodyConfigAlertConfigAlertConfig>>(expect1);
      }
    }
  }


  virtual ~DescribeDnsGtmInstanceResponseBodyConfigAlertConfig() = default;
};
class DescribeDnsGtmInstanceResponseBodyConfig : public Darabonba::Model {
public:
  shared_ptr<DescribeDnsGtmInstanceResponseBodyConfigAlertConfig> alertConfig{};
  shared_ptr<string> alertGroup{};
  shared_ptr<string> cnameType{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> pubicZoneName{};
  shared_ptr<string> publicCnameMode{};
  shared_ptr<string> publicRr{};
  shared_ptr<string> publicUserDomainName{};
  shared_ptr<string> strategyMode{};
  shared_ptr<long> ttl{};

  DescribeDnsGtmInstanceResponseBodyConfig() {}

  explicit DescribeDnsGtmInstanceResponseBodyConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertConfig) {
      res["AlertConfig"] = alertConfig ? boost::any(alertConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (alertGroup) {
      res["AlertGroup"] = boost::any(*alertGroup);
    }
    if (cnameType) {
      res["CnameType"] = boost::any(*cnameType);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (pubicZoneName) {
      res["PubicZoneName"] = boost::any(*pubicZoneName);
    }
    if (publicCnameMode) {
      res["PublicCnameMode"] = boost::any(*publicCnameMode);
    }
    if (publicRr) {
      res["PublicRr"] = boost::any(*publicRr);
    }
    if (publicUserDomainName) {
      res["PublicUserDomainName"] = boost::any(*publicUserDomainName);
    }
    if (strategyMode) {
      res["StrategyMode"] = boost::any(*strategyMode);
    }
    if (ttl) {
      res["Ttl"] = boost::any(*ttl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertConfig") != m.end() && !m["AlertConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["AlertConfig"].type()) {
        DescribeDnsGtmInstanceResponseBodyConfigAlertConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AlertConfig"]));
        alertConfig = make_shared<DescribeDnsGtmInstanceResponseBodyConfigAlertConfig>(model1);
      }
    }
    if (m.find("AlertGroup") != m.end() && !m["AlertGroup"].empty()) {
      alertGroup = make_shared<string>(boost::any_cast<string>(m["AlertGroup"]));
    }
    if (m.find("CnameType") != m.end() && !m["CnameType"].empty()) {
      cnameType = make_shared<string>(boost::any_cast<string>(m["CnameType"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("PubicZoneName") != m.end() && !m["PubicZoneName"].empty()) {
      pubicZoneName = make_shared<string>(boost::any_cast<string>(m["PubicZoneName"]));
    }
    if (m.find("PublicCnameMode") != m.end() && !m["PublicCnameMode"].empty()) {
      publicCnameMode = make_shared<string>(boost::any_cast<string>(m["PublicCnameMode"]));
    }
    if (m.find("PublicRr") != m.end() && !m["PublicRr"].empty()) {
      publicRr = make_shared<string>(boost::any_cast<string>(m["PublicRr"]));
    }
    if (m.find("PublicUserDomainName") != m.end() && !m["PublicUserDomainName"].empty()) {
      publicUserDomainName = make_shared<string>(boost::any_cast<string>(m["PublicUserDomainName"]));
    }
    if (m.find("StrategyMode") != m.end() && !m["StrategyMode"].empty()) {
      strategyMode = make_shared<string>(boost::any_cast<string>(m["StrategyMode"]));
    }
    if (m.find("Ttl") != m.end() && !m["Ttl"].empty()) {
      ttl = make_shared<long>(boost::any_cast<long>(m["Ttl"]));
    }
  }


  virtual ~DescribeDnsGtmInstanceResponseBodyConfig() = default;
};
class DescribeDnsGtmInstanceResponseBodyUsedQuota : public Darabonba::Model {
public:
  shared_ptr<long> dingtalkUsedCount{};
  shared_ptr<long> emailUsedCount{};
  shared_ptr<long> smsUsedCount{};
  shared_ptr<long> taskUsedCount{};

  DescribeDnsGtmInstanceResponseBodyUsedQuota() {}

  explicit DescribeDnsGtmInstanceResponseBodyUsedQuota(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dingtalkUsedCount) {
      res["DingtalkUsedCount"] = boost::any(*dingtalkUsedCount);
    }
    if (emailUsedCount) {
      res["EmailUsedCount"] = boost::any(*emailUsedCount);
    }
    if (smsUsedCount) {
      res["SmsUsedCount"] = boost::any(*smsUsedCount);
    }
    if (taskUsedCount) {
      res["TaskUsedCount"] = boost::any(*taskUsedCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DingtalkUsedCount") != m.end() && !m["DingtalkUsedCount"].empty()) {
      dingtalkUsedCount = make_shared<long>(boost::any_cast<long>(m["DingtalkUsedCount"]));
    }
    if (m.find("EmailUsedCount") != m.end() && !m["EmailUsedCount"].empty()) {
      emailUsedCount = make_shared<long>(boost::any_cast<long>(m["EmailUsedCount"]));
    }
    if (m.find("SmsUsedCount") != m.end() && !m["SmsUsedCount"].empty()) {
      smsUsedCount = make_shared<long>(boost::any_cast<long>(m["SmsUsedCount"]));
    }
    if (m.find("TaskUsedCount") != m.end() && !m["TaskUsedCount"].empty()) {
      taskUsedCount = make_shared<long>(boost::any_cast<long>(m["TaskUsedCount"]));
    }
  }


  virtual ~DescribeDnsGtmInstanceResponseBodyUsedQuota() = default;
};
class DescribeDnsGtmInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDnsGtmInstanceResponseBodyConfig> config{};
  shared_ptr<string> createTime{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<string> expireTime{};
  shared_ptr<long> expireTimestamp{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> paymentType{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> smsQuota{};
  shared_ptr<long> taskQuota{};
  shared_ptr<DescribeDnsGtmInstanceResponseBodyUsedQuota> usedQuota{};
  shared_ptr<string> versionCode{};

  DescribeDnsGtmInstanceResponseBody() {}

  explicit DescribeDnsGtmInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = config ? boost::any(config->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (expireTimestamp) {
      res["ExpireTimestamp"] = boost::any(*expireTimestamp);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (paymentType) {
      res["PaymentType"] = boost::any(*paymentType);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (smsQuota) {
      res["SmsQuota"] = boost::any(*smsQuota);
    }
    if (taskQuota) {
      res["TaskQuota"] = boost::any(*taskQuota);
    }
    if (usedQuota) {
      res["UsedQuota"] = usedQuota ? boost::any(usedQuota->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (versionCode) {
      res["VersionCode"] = boost::any(*versionCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      if (typeid(map<string, boost::any>) == m["Config"].type()) {
        DescribeDnsGtmInstanceResponseBodyConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Config"]));
        config = make_shared<DescribeDnsGtmInstanceResponseBodyConfig>(model1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("ExpireTimestamp") != m.end() && !m["ExpireTimestamp"].empty()) {
      expireTimestamp = make_shared<long>(boost::any_cast<long>(m["ExpireTimestamp"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PaymentType") != m.end() && !m["PaymentType"].empty()) {
      paymentType = make_shared<string>(boost::any_cast<string>(m["PaymentType"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SmsQuota") != m.end() && !m["SmsQuota"].empty()) {
      smsQuota = make_shared<long>(boost::any_cast<long>(m["SmsQuota"]));
    }
    if (m.find("TaskQuota") != m.end() && !m["TaskQuota"].empty()) {
      taskQuota = make_shared<long>(boost::any_cast<long>(m["TaskQuota"]));
    }
    if (m.find("UsedQuota") != m.end() && !m["UsedQuota"].empty()) {
      if (typeid(map<string, boost::any>) == m["UsedQuota"].type()) {
        DescribeDnsGtmInstanceResponseBodyUsedQuota model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UsedQuota"]));
        usedQuota = make_shared<DescribeDnsGtmInstanceResponseBodyUsedQuota>(model1);
      }
    }
    if (m.find("VersionCode") != m.end() && !m["VersionCode"].empty()) {
      versionCode = make_shared<string>(boost::any_cast<string>(m["VersionCode"]));
    }
  }


  virtual ~DescribeDnsGtmInstanceResponseBody() = default;
};
class DescribeDnsGtmInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDnsGtmInstanceResponseBody> body{};

  DescribeDnsGtmInstanceResponse() {}

  explicit DescribeDnsGtmInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDnsGtmInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDnsGtmInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDnsGtmInstanceResponse() = default;
};
class DescribeDnsGtmInstanceAddressPoolRequest : public Darabonba::Model {
public:
  shared_ptr<string> addrPoolId{};
  shared_ptr<string> lang{};

  DescribeDnsGtmInstanceAddressPoolRequest() {}

  explicit DescribeDnsGtmInstanceAddressPoolRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addrPoolId) {
      res["AddrPoolId"] = boost::any(*addrPoolId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddrPoolId") != m.end() && !m["AddrPoolId"].empty()) {
      addrPoolId = make_shared<string>(boost::any_cast<string>(m["AddrPoolId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~DescribeDnsGtmInstanceAddressPoolRequest() = default;
};
class DescribeDnsGtmInstanceAddressPoolResponseBodyAddrsAddr : public Darabonba::Model {
public:
  shared_ptr<string> addr{};
  shared_ptr<string> alertStatus{};
  shared_ptr<string> attributeInfo{};
  shared_ptr<string> createTime{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<long> lbaWeight{};
  shared_ptr<string> mode{};
  shared_ptr<string> remark{};
  shared_ptr<string> updateTime{};
  shared_ptr<long> updateTimestamp{};

  DescribeDnsGtmInstanceAddressPoolResponseBodyAddrsAddr() {}

  explicit DescribeDnsGtmInstanceAddressPoolResponseBodyAddrsAddr(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addr) {
      res["Addr"] = boost::any(*addr);
    }
    if (alertStatus) {
      res["AlertStatus"] = boost::any(*alertStatus);
    }
    if (attributeInfo) {
      res["AttributeInfo"] = boost::any(*attributeInfo);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (lbaWeight) {
      res["LbaWeight"] = boost::any(*lbaWeight);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (updateTimestamp) {
      res["UpdateTimestamp"] = boost::any(*updateTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Addr") != m.end() && !m["Addr"].empty()) {
      addr = make_shared<string>(boost::any_cast<string>(m["Addr"]));
    }
    if (m.find("AlertStatus") != m.end() && !m["AlertStatus"].empty()) {
      alertStatus = make_shared<string>(boost::any_cast<string>(m["AlertStatus"]));
    }
    if (m.find("AttributeInfo") != m.end() && !m["AttributeInfo"].empty()) {
      attributeInfo = make_shared<string>(boost::any_cast<string>(m["AttributeInfo"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("LbaWeight") != m.end() && !m["LbaWeight"].empty()) {
      lbaWeight = make_shared<long>(boost::any_cast<long>(m["LbaWeight"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("UpdateTimestamp") != m.end() && !m["UpdateTimestamp"].empty()) {
      updateTimestamp = make_shared<long>(boost::any_cast<long>(m["UpdateTimestamp"]));
    }
  }


  virtual ~DescribeDnsGtmInstanceAddressPoolResponseBodyAddrsAddr() = default;
};
class DescribeDnsGtmInstanceAddressPoolResponseBodyAddrs : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDnsGtmInstanceAddressPoolResponseBodyAddrsAddr>> addr{};

  DescribeDnsGtmInstanceAddressPoolResponseBodyAddrs() {}

  explicit DescribeDnsGtmInstanceAddressPoolResponseBodyAddrs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addr) {
      vector<boost::any> temp1;
      for(auto item1:*addr){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Addr"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Addr") != m.end() && !m["Addr"].empty()) {
      if (typeid(vector<boost::any>) == m["Addr"].type()) {
        vector<DescribeDnsGtmInstanceAddressPoolResponseBodyAddrsAddr> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Addr"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDnsGtmInstanceAddressPoolResponseBodyAddrsAddr model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        addr = make_shared<vector<DescribeDnsGtmInstanceAddressPoolResponseBodyAddrsAddr>>(expect1);
      }
    }
  }


  virtual ~DescribeDnsGtmInstanceAddressPoolResponseBodyAddrs() = default;
};
class DescribeDnsGtmInstanceAddressPoolResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> addrCount{};
  shared_ptr<string> addrPoolId{};
  shared_ptr<DescribeDnsGtmInstanceAddressPoolResponseBodyAddrs> addrs{};
  shared_ptr<string> createTime{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<string> lbaStrategy{};
  shared_ptr<string> monitorConfigId{};
  shared_ptr<string> monitorStatus{};
  shared_ptr<string> name{};
  shared_ptr<string> requestId{};
  shared_ptr<string> type{};
  shared_ptr<string> updateTime{};
  shared_ptr<long> updateTimestamp{};

  DescribeDnsGtmInstanceAddressPoolResponseBody() {}

  explicit DescribeDnsGtmInstanceAddressPoolResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addrCount) {
      res["AddrCount"] = boost::any(*addrCount);
    }
    if (addrPoolId) {
      res["AddrPoolId"] = boost::any(*addrPoolId);
    }
    if (addrs) {
      res["Addrs"] = addrs ? boost::any(addrs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (lbaStrategy) {
      res["LbaStrategy"] = boost::any(*lbaStrategy);
    }
    if (monitorConfigId) {
      res["MonitorConfigId"] = boost::any(*monitorConfigId);
    }
    if (monitorStatus) {
      res["MonitorStatus"] = boost::any(*monitorStatus);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (updateTimestamp) {
      res["UpdateTimestamp"] = boost::any(*updateTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddrCount") != m.end() && !m["AddrCount"].empty()) {
      addrCount = make_shared<long>(boost::any_cast<long>(m["AddrCount"]));
    }
    if (m.find("AddrPoolId") != m.end() && !m["AddrPoolId"].empty()) {
      addrPoolId = make_shared<string>(boost::any_cast<string>(m["AddrPoolId"]));
    }
    if (m.find("Addrs") != m.end() && !m["Addrs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Addrs"].type()) {
        DescribeDnsGtmInstanceAddressPoolResponseBodyAddrs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Addrs"]));
        addrs = make_shared<DescribeDnsGtmInstanceAddressPoolResponseBodyAddrs>(model1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("LbaStrategy") != m.end() && !m["LbaStrategy"].empty()) {
      lbaStrategy = make_shared<string>(boost::any_cast<string>(m["LbaStrategy"]));
    }
    if (m.find("MonitorConfigId") != m.end() && !m["MonitorConfigId"].empty()) {
      monitorConfigId = make_shared<string>(boost::any_cast<string>(m["MonitorConfigId"]));
    }
    if (m.find("MonitorStatus") != m.end() && !m["MonitorStatus"].empty()) {
      monitorStatus = make_shared<string>(boost::any_cast<string>(m["MonitorStatus"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("UpdateTimestamp") != m.end() && !m["UpdateTimestamp"].empty()) {
      updateTimestamp = make_shared<long>(boost::any_cast<long>(m["UpdateTimestamp"]));
    }
  }


  virtual ~DescribeDnsGtmInstanceAddressPoolResponseBody() = default;
};
class DescribeDnsGtmInstanceAddressPoolResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDnsGtmInstanceAddressPoolResponseBody> body{};

  DescribeDnsGtmInstanceAddressPoolResponse() {}

  explicit DescribeDnsGtmInstanceAddressPoolResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDnsGtmInstanceAddressPoolResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDnsGtmInstanceAddressPoolResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDnsGtmInstanceAddressPoolResponse() = default;
};
class DescribeDnsGtmInstanceAddressPoolsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeDnsGtmInstanceAddressPoolsRequest() {}

  explicit DescribeDnsGtmInstanceAddressPoolsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeDnsGtmInstanceAddressPoolsRequest() = default;
};
class DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool : public Darabonba::Model {
public:
  shared_ptr<long> addrCount{};
  shared_ptr<string> addrPoolId{};
  shared_ptr<string> createTime{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<string> lbaStrategy{};
  shared_ptr<string> monitorConfigId{};
  shared_ptr<string> monitorStatus{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> updateTime{};
  shared_ptr<long> updateTimestamp{};

  DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool() {}

  explicit DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addrCount) {
      res["AddrCount"] = boost::any(*addrCount);
    }
    if (addrPoolId) {
      res["AddrPoolId"] = boost::any(*addrPoolId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (lbaStrategy) {
      res["LbaStrategy"] = boost::any(*lbaStrategy);
    }
    if (monitorConfigId) {
      res["MonitorConfigId"] = boost::any(*monitorConfigId);
    }
    if (monitorStatus) {
      res["MonitorStatus"] = boost::any(*monitorStatus);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (updateTimestamp) {
      res["UpdateTimestamp"] = boost::any(*updateTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddrCount") != m.end() && !m["AddrCount"].empty()) {
      addrCount = make_shared<long>(boost::any_cast<long>(m["AddrCount"]));
    }
    if (m.find("AddrPoolId") != m.end() && !m["AddrPoolId"].empty()) {
      addrPoolId = make_shared<string>(boost::any_cast<string>(m["AddrPoolId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("LbaStrategy") != m.end() && !m["LbaStrategy"].empty()) {
      lbaStrategy = make_shared<string>(boost::any_cast<string>(m["LbaStrategy"]));
    }
    if (m.find("MonitorConfigId") != m.end() && !m["MonitorConfigId"].empty()) {
      monitorConfigId = make_shared<string>(boost::any_cast<string>(m["MonitorConfigId"]));
    }
    if (m.find("MonitorStatus") != m.end() && !m["MonitorStatus"].empty()) {
      monitorStatus = make_shared<string>(boost::any_cast<string>(m["MonitorStatus"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("UpdateTimestamp") != m.end() && !m["UpdateTimestamp"].empty()) {
      updateTimestamp = make_shared<long>(boost::any_cast<long>(m["UpdateTimestamp"]));
    }
  }


  virtual ~DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool() = default;
};
class DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPools : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool>> addrPool{};

  DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPools() {}

  explicit DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPools(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addrPool) {
      vector<boost::any> temp1;
      for(auto item1:*addrPool){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AddrPool"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddrPool") != m.end() && !m["AddrPool"].empty()) {
      if (typeid(vector<boost::any>) == m["AddrPool"].type()) {
        vector<DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AddrPool"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        addrPool = make_shared<vector<DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool>>(expect1);
      }
    }
  }


  virtual ~DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPools() = default;
};
class DescribeDnsGtmInstanceAddressPoolsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPools> addrPools{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalItems{};
  shared_ptr<long> totalPages{};

  DescribeDnsGtmInstanceAddressPoolsResponseBody() {}

  explicit DescribeDnsGtmInstanceAddressPoolsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addrPools) {
      res["AddrPools"] = addrPools ? boost::any(addrPools->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalItems) {
      res["TotalItems"] = boost::any(*totalItems);
    }
    if (totalPages) {
      res["TotalPages"] = boost::any(*totalPages);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddrPools") != m.end() && !m["AddrPools"].empty()) {
      if (typeid(map<string, boost::any>) == m["AddrPools"].type()) {
        DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPools model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AddrPools"]));
        addrPools = make_shared<DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPools>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalItems") != m.end() && !m["TotalItems"].empty()) {
      totalItems = make_shared<long>(boost::any_cast<long>(m["TotalItems"]));
    }
    if (m.find("TotalPages") != m.end() && !m["TotalPages"].empty()) {
      totalPages = make_shared<long>(boost::any_cast<long>(m["TotalPages"]));
    }
  }


  virtual ~DescribeDnsGtmInstanceAddressPoolsResponseBody() = default;
};
class DescribeDnsGtmInstanceAddressPoolsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDnsGtmInstanceAddressPoolsResponseBody> body{};

  DescribeDnsGtmInstanceAddressPoolsResponse() {}

  explicit DescribeDnsGtmInstanceAddressPoolsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDnsGtmInstanceAddressPoolsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDnsGtmInstanceAddressPoolsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDnsGtmInstanceAddressPoolsResponse() = default;
};
class DescribeDnsGtmInstanceStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> lang{};

  DescribeDnsGtmInstanceStatusRequest() {}

  explicit DescribeDnsGtmInstanceStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~DescribeDnsGtmInstanceStatusRequest() = default;
};
class DescribeDnsGtmInstanceStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> addrAvailableNum{};
  shared_ptr<long> addrNotAvailableNum{};
  shared_ptr<long> addrPoolGroupNotAvailableNum{};
  shared_ptr<string> requestId{};
  shared_ptr<long> strategyNotAvailableNum{};
  shared_ptr<long> switchToFailoverStrategyNum{};

  DescribeDnsGtmInstanceStatusResponseBody() {}

  explicit DescribeDnsGtmInstanceStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addrAvailableNum) {
      res["AddrAvailableNum"] = boost::any(*addrAvailableNum);
    }
    if (addrNotAvailableNum) {
      res["AddrNotAvailableNum"] = boost::any(*addrNotAvailableNum);
    }
    if (addrPoolGroupNotAvailableNum) {
      res["AddrPoolGroupNotAvailableNum"] = boost::any(*addrPoolGroupNotAvailableNum);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (strategyNotAvailableNum) {
      res["StrategyNotAvailableNum"] = boost::any(*strategyNotAvailableNum);
    }
    if (switchToFailoverStrategyNum) {
      res["SwitchToFailoverStrategyNum"] = boost::any(*switchToFailoverStrategyNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddrAvailableNum") != m.end() && !m["AddrAvailableNum"].empty()) {
      addrAvailableNum = make_shared<long>(boost::any_cast<long>(m["AddrAvailableNum"]));
    }
    if (m.find("AddrNotAvailableNum") != m.end() && !m["AddrNotAvailableNum"].empty()) {
      addrNotAvailableNum = make_shared<long>(boost::any_cast<long>(m["AddrNotAvailableNum"]));
    }
    if (m.find("AddrPoolGroupNotAvailableNum") != m.end() && !m["AddrPoolGroupNotAvailableNum"].empty()) {
      addrPoolGroupNotAvailableNum = make_shared<long>(boost::any_cast<long>(m["AddrPoolGroupNotAvailableNum"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StrategyNotAvailableNum") != m.end() && !m["StrategyNotAvailableNum"].empty()) {
      strategyNotAvailableNum = make_shared<long>(boost::any_cast<long>(m["StrategyNotAvailableNum"]));
    }
    if (m.find("SwitchToFailoverStrategyNum") != m.end() && !m["SwitchToFailoverStrategyNum"].empty()) {
      switchToFailoverStrategyNum = make_shared<long>(boost::any_cast<long>(m["SwitchToFailoverStrategyNum"]));
    }
  }


  virtual ~DescribeDnsGtmInstanceStatusResponseBody() = default;
};
class DescribeDnsGtmInstanceStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDnsGtmInstanceStatusResponseBody> body{};

  DescribeDnsGtmInstanceStatusResponse() {}

  explicit DescribeDnsGtmInstanceStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDnsGtmInstanceStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDnsGtmInstanceStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDnsGtmInstanceStatusResponse() = default;
};
class DescribeDnsGtmInstanceSystemCnameRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> lang{};

  DescribeDnsGtmInstanceSystemCnameRequest() {}

  explicit DescribeDnsGtmInstanceSystemCnameRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~DescribeDnsGtmInstanceSystemCnameRequest() = default;
};
class DescribeDnsGtmInstanceSystemCnameResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> systemCname{};

  DescribeDnsGtmInstanceSystemCnameResponseBody() {}

  explicit DescribeDnsGtmInstanceSystemCnameResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (systemCname) {
      res["SystemCname"] = boost::any(*systemCname);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SystemCname") != m.end() && !m["SystemCname"].empty()) {
      systemCname = make_shared<string>(boost::any_cast<string>(m["SystemCname"]));
    }
  }


  virtual ~DescribeDnsGtmInstanceSystemCnameResponseBody() = default;
};
class DescribeDnsGtmInstanceSystemCnameResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDnsGtmInstanceSystemCnameResponseBody> body{};

  DescribeDnsGtmInstanceSystemCnameResponse() {}

  explicit DescribeDnsGtmInstanceSystemCnameResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDnsGtmInstanceSystemCnameResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDnsGtmInstanceSystemCnameResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDnsGtmInstanceSystemCnameResponse() = default;
};
class DescribeDnsGtmInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> keyword{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceGroupId{};

  DescribeDnsGtmInstancesRequest() {}

  explicit DescribeDnsGtmInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~DescribeDnsGtmInstancesRequest() = default;
};
class DescribeDnsGtmInstancesResponseBodyGtmInstancesConfigAlertConfig : public Darabonba::Model {
public:
  shared_ptr<string> dingtalkNotice{};
  shared_ptr<string> emailNotice{};
  shared_ptr<string> noticeType{};
  shared_ptr<string> smsNotice{};

  DescribeDnsGtmInstancesResponseBodyGtmInstancesConfigAlertConfig() {}

  explicit DescribeDnsGtmInstancesResponseBodyGtmInstancesConfigAlertConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dingtalkNotice) {
      res["DingtalkNotice"] = boost::any(*dingtalkNotice);
    }
    if (emailNotice) {
      res["EmailNotice"] = boost::any(*emailNotice);
    }
    if (noticeType) {
      res["NoticeType"] = boost::any(*noticeType);
    }
    if (smsNotice) {
      res["SmsNotice"] = boost::any(*smsNotice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DingtalkNotice") != m.end() && !m["DingtalkNotice"].empty()) {
      dingtalkNotice = make_shared<string>(boost::any_cast<string>(m["DingtalkNotice"]));
    }
    if (m.find("EmailNotice") != m.end() && !m["EmailNotice"].empty()) {
      emailNotice = make_shared<string>(boost::any_cast<string>(m["EmailNotice"]));
    }
    if (m.find("NoticeType") != m.end() && !m["NoticeType"].empty()) {
      noticeType = make_shared<string>(boost::any_cast<string>(m["NoticeType"]));
    }
    if (m.find("SmsNotice") != m.end() && !m["SmsNotice"].empty()) {
      smsNotice = make_shared<string>(boost::any_cast<string>(m["SmsNotice"]));
    }
  }


  virtual ~DescribeDnsGtmInstancesResponseBodyGtmInstancesConfigAlertConfig() = default;
};
class DescribeDnsGtmInstancesResponseBodyGtmInstancesConfig : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDnsGtmInstancesResponseBodyGtmInstancesConfigAlertConfig>> alertConfig{};
  shared_ptr<string> alertGroup{};
  shared_ptr<string> cnameType{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> publicCnameMode{};
  shared_ptr<string> publicRr{};
  shared_ptr<string> publicUserDomainName{};
  shared_ptr<string> publicZoneName{};
  shared_ptr<string> strategyMode{};
  shared_ptr<long> ttl{};

  DescribeDnsGtmInstancesResponseBodyGtmInstancesConfig() {}

  explicit DescribeDnsGtmInstancesResponseBodyGtmInstancesConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertConfig) {
      vector<boost::any> temp1;
      for(auto item1:*alertConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlertConfig"] = boost::any(temp1);
    }
    if (alertGroup) {
      res["AlertGroup"] = boost::any(*alertGroup);
    }
    if (cnameType) {
      res["CnameType"] = boost::any(*cnameType);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (publicCnameMode) {
      res["PublicCnameMode"] = boost::any(*publicCnameMode);
    }
    if (publicRr) {
      res["PublicRr"] = boost::any(*publicRr);
    }
    if (publicUserDomainName) {
      res["PublicUserDomainName"] = boost::any(*publicUserDomainName);
    }
    if (publicZoneName) {
      res["PublicZoneName"] = boost::any(*publicZoneName);
    }
    if (strategyMode) {
      res["StrategyMode"] = boost::any(*strategyMode);
    }
    if (ttl) {
      res["Ttl"] = boost::any(*ttl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertConfig") != m.end() && !m["AlertConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["AlertConfig"].type()) {
        vector<DescribeDnsGtmInstancesResponseBodyGtmInstancesConfigAlertConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlertConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDnsGtmInstancesResponseBodyGtmInstancesConfigAlertConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alertConfig = make_shared<vector<DescribeDnsGtmInstancesResponseBodyGtmInstancesConfigAlertConfig>>(expect1);
      }
    }
    if (m.find("AlertGroup") != m.end() && !m["AlertGroup"].empty()) {
      alertGroup = make_shared<string>(boost::any_cast<string>(m["AlertGroup"]));
    }
    if (m.find("CnameType") != m.end() && !m["CnameType"].empty()) {
      cnameType = make_shared<string>(boost::any_cast<string>(m["CnameType"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("PublicCnameMode") != m.end() && !m["PublicCnameMode"].empty()) {
      publicCnameMode = make_shared<string>(boost::any_cast<string>(m["PublicCnameMode"]));
    }
    if (m.find("PublicRr") != m.end() && !m["PublicRr"].empty()) {
      publicRr = make_shared<string>(boost::any_cast<string>(m["PublicRr"]));
    }
    if (m.find("PublicUserDomainName") != m.end() && !m["PublicUserDomainName"].empty()) {
      publicUserDomainName = make_shared<string>(boost::any_cast<string>(m["PublicUserDomainName"]));
    }
    if (m.find("PublicZoneName") != m.end() && !m["PublicZoneName"].empty()) {
      publicZoneName = make_shared<string>(boost::any_cast<string>(m["PublicZoneName"]));
    }
    if (m.find("StrategyMode") != m.end() && !m["StrategyMode"].empty()) {
      strategyMode = make_shared<string>(boost::any_cast<string>(m["StrategyMode"]));
    }
    if (m.find("Ttl") != m.end() && !m["Ttl"].empty()) {
      ttl = make_shared<long>(boost::any_cast<long>(m["Ttl"]));
    }
  }


  virtual ~DescribeDnsGtmInstancesResponseBodyGtmInstancesConfig() = default;
};
class DescribeDnsGtmInstancesResponseBodyGtmInstancesUsedQuota : public Darabonba::Model {
public:
  shared_ptr<long> dingtalkUsedCount{};
  shared_ptr<long> emailUsedCount{};
  shared_ptr<long> smsUsedCount{};
  shared_ptr<long> taskUsedCount{};

  DescribeDnsGtmInstancesResponseBodyGtmInstancesUsedQuota() {}

  explicit DescribeDnsGtmInstancesResponseBodyGtmInstancesUsedQuota(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dingtalkUsedCount) {
      res["DingtalkUsedCount"] = boost::any(*dingtalkUsedCount);
    }
    if (emailUsedCount) {
      res["EmailUsedCount"] = boost::any(*emailUsedCount);
    }
    if (smsUsedCount) {
      res["SmsUsedCount"] = boost::any(*smsUsedCount);
    }
    if (taskUsedCount) {
      res["TaskUsedCount"] = boost::any(*taskUsedCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DingtalkUsedCount") != m.end() && !m["DingtalkUsedCount"].empty()) {
      dingtalkUsedCount = make_shared<long>(boost::any_cast<long>(m["DingtalkUsedCount"]));
    }
    if (m.find("EmailUsedCount") != m.end() && !m["EmailUsedCount"].empty()) {
      emailUsedCount = make_shared<long>(boost::any_cast<long>(m["EmailUsedCount"]));
    }
    if (m.find("SmsUsedCount") != m.end() && !m["SmsUsedCount"].empty()) {
      smsUsedCount = make_shared<long>(boost::any_cast<long>(m["SmsUsedCount"]));
    }
    if (m.find("TaskUsedCount") != m.end() && !m["TaskUsedCount"].empty()) {
      taskUsedCount = make_shared<long>(boost::any_cast<long>(m["TaskUsedCount"]));
    }
  }


  virtual ~DescribeDnsGtmInstancesResponseBodyGtmInstancesUsedQuota() = default;
};
class DescribeDnsGtmInstancesResponseBodyGtmInstances : public Darabonba::Model {
public:
  shared_ptr<DescribeDnsGtmInstancesResponseBodyGtmInstancesConfig> config{};
  shared_ptr<string> createTime{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<string> expireTime{};
  shared_ptr<long> expireTimestamp{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> paymentType{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> smsQuota{};
  shared_ptr<long> taskQuota{};
  shared_ptr<DescribeDnsGtmInstancesResponseBodyGtmInstancesUsedQuota> usedQuota{};
  shared_ptr<string> versionCode{};

  DescribeDnsGtmInstancesResponseBodyGtmInstances() {}

  explicit DescribeDnsGtmInstancesResponseBodyGtmInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = config ? boost::any(config->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (expireTimestamp) {
      res["ExpireTimestamp"] = boost::any(*expireTimestamp);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (paymentType) {
      res["PaymentType"] = boost::any(*paymentType);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (smsQuota) {
      res["SmsQuota"] = boost::any(*smsQuota);
    }
    if (taskQuota) {
      res["TaskQuota"] = boost::any(*taskQuota);
    }
    if (usedQuota) {
      res["UsedQuota"] = usedQuota ? boost::any(usedQuota->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (versionCode) {
      res["VersionCode"] = boost::any(*versionCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      if (typeid(map<string, boost::any>) == m["Config"].type()) {
        DescribeDnsGtmInstancesResponseBodyGtmInstancesConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Config"]));
        config = make_shared<DescribeDnsGtmInstancesResponseBodyGtmInstancesConfig>(model1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("ExpireTimestamp") != m.end() && !m["ExpireTimestamp"].empty()) {
      expireTimestamp = make_shared<long>(boost::any_cast<long>(m["ExpireTimestamp"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PaymentType") != m.end() && !m["PaymentType"].empty()) {
      paymentType = make_shared<string>(boost::any_cast<string>(m["PaymentType"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SmsQuota") != m.end() && !m["SmsQuota"].empty()) {
      smsQuota = make_shared<long>(boost::any_cast<long>(m["SmsQuota"]));
    }
    if (m.find("TaskQuota") != m.end() && !m["TaskQuota"].empty()) {
      taskQuota = make_shared<long>(boost::any_cast<long>(m["TaskQuota"]));
    }
    if (m.find("UsedQuota") != m.end() && !m["UsedQuota"].empty()) {
      if (typeid(map<string, boost::any>) == m["UsedQuota"].type()) {
        DescribeDnsGtmInstancesResponseBodyGtmInstancesUsedQuota model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UsedQuota"]));
        usedQuota = make_shared<DescribeDnsGtmInstancesResponseBodyGtmInstancesUsedQuota>(model1);
      }
    }
    if (m.find("VersionCode") != m.end() && !m["VersionCode"].empty()) {
      versionCode = make_shared<string>(boost::any_cast<string>(m["VersionCode"]));
    }
  }


  virtual ~DescribeDnsGtmInstancesResponseBodyGtmInstances() = default;
};
class DescribeDnsGtmInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDnsGtmInstancesResponseBodyGtmInstances>> gtmInstances{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalItems{};
  shared_ptr<long> totalPages{};

  DescribeDnsGtmInstancesResponseBody() {}

  explicit DescribeDnsGtmInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gtmInstances) {
      vector<boost::any> temp1;
      for(auto item1:*gtmInstances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GtmInstances"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalItems) {
      res["TotalItems"] = boost::any(*totalItems);
    }
    if (totalPages) {
      res["TotalPages"] = boost::any(*totalPages);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GtmInstances") != m.end() && !m["GtmInstances"].empty()) {
      if (typeid(vector<boost::any>) == m["GtmInstances"].type()) {
        vector<DescribeDnsGtmInstancesResponseBodyGtmInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GtmInstances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDnsGtmInstancesResponseBodyGtmInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        gtmInstances = make_shared<vector<DescribeDnsGtmInstancesResponseBodyGtmInstances>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalItems") != m.end() && !m["TotalItems"].empty()) {
      totalItems = make_shared<long>(boost::any_cast<long>(m["TotalItems"]));
    }
    if (m.find("TotalPages") != m.end() && !m["TotalPages"].empty()) {
      totalPages = make_shared<long>(boost::any_cast<long>(m["TotalPages"]));
    }
  }


  virtual ~DescribeDnsGtmInstancesResponseBody() = default;
};
class DescribeDnsGtmInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDnsGtmInstancesResponseBody> body{};

  DescribeDnsGtmInstancesResponse() {}

  explicit DescribeDnsGtmInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDnsGtmInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDnsGtmInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDnsGtmInstancesResponse() = default;
};
class DescribeDnsGtmLogsRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTimestamp{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> keyword{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> startTimestamp{};

  DescribeDnsGtmLogsRequest() {}

  explicit DescribeDnsGtmLogsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTimestamp) {
      res["EndTimestamp"] = boost::any(*endTimestamp);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTimestamp) {
      res["StartTimestamp"] = boost::any(*startTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTimestamp") != m.end() && !m["EndTimestamp"].empty()) {
      endTimestamp = make_shared<long>(boost::any_cast<long>(m["EndTimestamp"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTimestamp") != m.end() && !m["StartTimestamp"].empty()) {
      startTimestamp = make_shared<long>(boost::any_cast<long>(m["StartTimestamp"]));
    }
  }


  virtual ~DescribeDnsGtmLogsRequest() = default;
};
class DescribeDnsGtmLogsResponseBodyLogsLog : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> entityId{};
  shared_ptr<string> entityName{};
  shared_ptr<string> entityType{};
  shared_ptr<long> id{};
  shared_ptr<string> operAction{};
  shared_ptr<string> operTime{};
  shared_ptr<long> operTimestamp{};

  DescribeDnsGtmLogsResponseBodyLogsLog() {}

  explicit DescribeDnsGtmLogsResponseBodyLogsLog(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (entityId) {
      res["EntityId"] = boost::any(*entityId);
    }
    if (entityName) {
      res["EntityName"] = boost::any(*entityName);
    }
    if (entityType) {
      res["EntityType"] = boost::any(*entityType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (operAction) {
      res["OperAction"] = boost::any(*operAction);
    }
    if (operTime) {
      res["OperTime"] = boost::any(*operTime);
    }
    if (operTimestamp) {
      res["OperTimestamp"] = boost::any(*operTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("EntityId") != m.end() && !m["EntityId"].empty()) {
      entityId = make_shared<string>(boost::any_cast<string>(m["EntityId"]));
    }
    if (m.find("EntityName") != m.end() && !m["EntityName"].empty()) {
      entityName = make_shared<string>(boost::any_cast<string>(m["EntityName"]));
    }
    if (m.find("EntityType") != m.end() && !m["EntityType"].empty()) {
      entityType = make_shared<string>(boost::any_cast<string>(m["EntityType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("OperAction") != m.end() && !m["OperAction"].empty()) {
      operAction = make_shared<string>(boost::any_cast<string>(m["OperAction"]));
    }
    if (m.find("OperTime") != m.end() && !m["OperTime"].empty()) {
      operTime = make_shared<string>(boost::any_cast<string>(m["OperTime"]));
    }
    if (m.find("OperTimestamp") != m.end() && !m["OperTimestamp"].empty()) {
      operTimestamp = make_shared<long>(boost::any_cast<long>(m["OperTimestamp"]));
    }
  }


  virtual ~DescribeDnsGtmLogsResponseBodyLogsLog() = default;
};
class DescribeDnsGtmLogsResponseBodyLogs : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDnsGtmLogsResponseBodyLogsLog>> log{};

  DescribeDnsGtmLogsResponseBodyLogs() {}

  explicit DescribeDnsGtmLogsResponseBodyLogs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (log) {
      vector<boost::any> temp1;
      for(auto item1:*log){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Log"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Log") != m.end() && !m["Log"].empty()) {
      if (typeid(vector<boost::any>) == m["Log"].type()) {
        vector<DescribeDnsGtmLogsResponseBodyLogsLog> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Log"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDnsGtmLogsResponseBodyLogsLog model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        log = make_shared<vector<DescribeDnsGtmLogsResponseBodyLogsLog>>(expect1);
      }
    }
  }


  virtual ~DescribeDnsGtmLogsResponseBodyLogs() = default;
};
class DescribeDnsGtmLogsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDnsGtmLogsResponseBodyLogs> logs{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalItems{};
  shared_ptr<long> totalPages{};

  DescribeDnsGtmLogsResponseBody() {}

  explicit DescribeDnsGtmLogsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logs) {
      res["Logs"] = logs ? boost::any(logs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalItems) {
      res["TotalItems"] = boost::any(*totalItems);
    }
    if (totalPages) {
      res["TotalPages"] = boost::any(*totalPages);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Logs") != m.end() && !m["Logs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Logs"].type()) {
        DescribeDnsGtmLogsResponseBodyLogs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Logs"]));
        logs = make_shared<DescribeDnsGtmLogsResponseBodyLogs>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalItems") != m.end() && !m["TotalItems"].empty()) {
      totalItems = make_shared<long>(boost::any_cast<long>(m["TotalItems"]));
    }
    if (m.find("TotalPages") != m.end() && !m["TotalPages"].empty()) {
      totalPages = make_shared<long>(boost::any_cast<long>(m["TotalPages"]));
    }
  }


  virtual ~DescribeDnsGtmLogsResponseBody() = default;
};
class DescribeDnsGtmLogsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDnsGtmLogsResponseBody> body{};

  DescribeDnsGtmLogsResponse() {}

  explicit DescribeDnsGtmLogsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDnsGtmLogsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDnsGtmLogsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDnsGtmLogsResponse() = default;
};
class DescribeDnsGtmMonitorAvailableConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};

  DescribeDnsGtmMonitorAvailableConfigRequest() {}

  explicit DescribeDnsGtmMonitorAvailableConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~DescribeDnsGtmMonitorAvailableConfigRequest() = default;
};
class DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodesDomainIpv4IspCityNodeIps : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ip{};

  DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodesDomainIpv4IspCityNodeIps() {}

  explicit DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodesDomainIpv4IspCityNodeIps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Ip"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ip"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ip = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodesDomainIpv4IspCityNodeIps() = default;
};
class DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodesDomainIpv4IspCityNode : public Darabonba::Model {
public:
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};
  shared_ptr<bool> defaultSelected{};
  shared_ptr<string> groupName{};
  shared_ptr<string> groupType{};
  shared_ptr<DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodesDomainIpv4IspCityNodeIps> ips{};
  shared_ptr<string> ispCode{};
  shared_ptr<string> ispName{};

  DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodesDomainIpv4IspCityNode() {}

  explicit DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodesDomainIpv4IspCityNode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cityCode) {
      res["CityCode"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["CityName"] = boost::any(*cityName);
    }
    if (defaultSelected) {
      res["DefaultSelected"] = boost::any(*defaultSelected);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (groupType) {
      res["GroupType"] = boost::any(*groupType);
    }
    if (ips) {
      res["Ips"] = ips ? boost::any(ips->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ispCode) {
      res["IspCode"] = boost::any(*ispCode);
    }
    if (ispName) {
      res["IspName"] = boost::any(*ispName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CityCode") != m.end() && !m["CityCode"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["CityCode"]));
    }
    if (m.find("CityName") != m.end() && !m["CityName"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["CityName"]));
    }
    if (m.find("DefaultSelected") != m.end() && !m["DefaultSelected"].empty()) {
      defaultSelected = make_shared<bool>(boost::any_cast<bool>(m["DefaultSelected"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("GroupType") != m.end() && !m["GroupType"].empty()) {
      groupType = make_shared<string>(boost::any_cast<string>(m["GroupType"]));
    }
    if (m.find("Ips") != m.end() && !m["Ips"].empty()) {
      if (typeid(map<string, boost::any>) == m["Ips"].type()) {
        DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodesDomainIpv4IspCityNodeIps model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Ips"]));
        ips = make_shared<DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodesDomainIpv4IspCityNodeIps>(model1);
      }
    }
    if (m.find("IspCode") != m.end() && !m["IspCode"].empty()) {
      ispCode = make_shared<string>(boost::any_cast<string>(m["IspCode"]));
    }
    if (m.find("IspName") != m.end() && !m["IspName"].empty()) {
      ispName = make_shared<string>(boost::any_cast<string>(m["IspName"]));
    }
  }


  virtual ~DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodesDomainIpv4IspCityNode() = default;
};
class DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodes : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodesDomainIpv4IspCityNode>> domainIpv4IspCityNode{};

  DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodes() {}

  explicit DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainIpv4IspCityNode) {
      vector<boost::any> temp1;
      for(auto item1:*domainIpv4IspCityNode){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainIpv4IspCityNode"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainIpv4IspCityNode") != m.end() && !m["DomainIpv4IspCityNode"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainIpv4IspCityNode"].type()) {
        vector<DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodesDomainIpv4IspCityNode> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainIpv4IspCityNode"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodesDomainIpv4IspCityNode model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainIpv4IspCityNode = make_shared<vector<DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodesDomainIpv4IspCityNode>>(expect1);
      }
    }
  }


  virtual ~DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodes() = default;
};
class DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodesDomainIpv6IspCityNodeIps : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ip{};

  DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodesDomainIpv6IspCityNodeIps() {}

  explicit DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodesDomainIpv6IspCityNodeIps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ip) {
      res["ip"] = boost::any(*ip);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ip") != m.end() && !m["ip"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ip"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ip"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ip = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodesDomainIpv6IspCityNodeIps() = default;
};
class DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodesDomainIpv6IspCityNode : public Darabonba::Model {
public:
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};
  shared_ptr<bool> defaultSelected{};
  shared_ptr<string> groupName{};
  shared_ptr<string> groupType{};
  shared_ptr<DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodesDomainIpv6IspCityNodeIps> ips{};
  shared_ptr<string> ispCode{};
  shared_ptr<string> ispName{};

  DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodesDomainIpv6IspCityNode() {}

  explicit DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodesDomainIpv6IspCityNode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cityCode) {
      res["CityCode"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["CityName"] = boost::any(*cityName);
    }
    if (defaultSelected) {
      res["DefaultSelected"] = boost::any(*defaultSelected);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (groupType) {
      res["GroupType"] = boost::any(*groupType);
    }
    if (ips) {
      res["Ips"] = ips ? boost::any(ips->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ispCode) {
      res["IspCode"] = boost::any(*ispCode);
    }
    if (ispName) {
      res["IspName"] = boost::any(*ispName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CityCode") != m.end() && !m["CityCode"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["CityCode"]));
    }
    if (m.find("CityName") != m.end() && !m["CityName"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["CityName"]));
    }
    if (m.find("DefaultSelected") != m.end() && !m["DefaultSelected"].empty()) {
      defaultSelected = make_shared<bool>(boost::any_cast<bool>(m["DefaultSelected"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("GroupType") != m.end() && !m["GroupType"].empty()) {
      groupType = make_shared<string>(boost::any_cast<string>(m["GroupType"]));
    }
    if (m.find("Ips") != m.end() && !m["Ips"].empty()) {
      if (typeid(map<string, boost::any>) == m["Ips"].type()) {
        DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodesDomainIpv6IspCityNodeIps model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Ips"]));
        ips = make_shared<DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodesDomainIpv6IspCityNodeIps>(model1);
      }
    }
    if (m.find("IspCode") != m.end() && !m["IspCode"].empty()) {
      ispCode = make_shared<string>(boost::any_cast<string>(m["IspCode"]));
    }
    if (m.find("IspName") != m.end() && !m["IspName"].empty()) {
      ispName = make_shared<string>(boost::any_cast<string>(m["IspName"]));
    }
  }


  virtual ~DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodesDomainIpv6IspCityNode() = default;
};
class DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodes : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodesDomainIpv6IspCityNode>> domainIpv6IspCityNode{};

  DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodes() {}

  explicit DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainIpv6IspCityNode) {
      vector<boost::any> temp1;
      for(auto item1:*domainIpv6IspCityNode){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainIpv6IspCityNode"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainIpv6IspCityNode") != m.end() && !m["DomainIpv6IspCityNode"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainIpv6IspCityNode"].type()) {
        vector<DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodesDomainIpv6IspCityNode> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainIpv6IspCityNode"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodesDomainIpv6IspCityNode model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainIpv6IspCityNode = make_shared<vector<DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodesDomainIpv6IspCityNode>>(expect1);
      }
    }
  }


  virtual ~DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodes() = default;
};
class DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodesIpv4IspCityNodeIps : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ip{};

  DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodesIpv4IspCityNodeIps() {}

  explicit DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodesIpv4IspCityNodeIps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Ip"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ip"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ip = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodesIpv4IspCityNodeIps() = default;
};
class DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodesIpv4IspCityNode : public Darabonba::Model {
public:
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};
  shared_ptr<bool> defaultSelected{};
  shared_ptr<string> groupName{};
  shared_ptr<string> groupType{};
  shared_ptr<DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodesIpv4IspCityNodeIps> ips{};
  shared_ptr<string> ispCode{};
  shared_ptr<string> ispName{};

  DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodesIpv4IspCityNode() {}

  explicit DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodesIpv4IspCityNode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cityCode) {
      res["CityCode"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["CityName"] = boost::any(*cityName);
    }
    if (defaultSelected) {
      res["DefaultSelected"] = boost::any(*defaultSelected);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (groupType) {
      res["GroupType"] = boost::any(*groupType);
    }
    if (ips) {
      res["Ips"] = ips ? boost::any(ips->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ispCode) {
      res["IspCode"] = boost::any(*ispCode);
    }
    if (ispName) {
      res["IspName"] = boost::any(*ispName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CityCode") != m.end() && !m["CityCode"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["CityCode"]));
    }
    if (m.find("CityName") != m.end() && !m["CityName"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["CityName"]));
    }
    if (m.find("DefaultSelected") != m.end() && !m["DefaultSelected"].empty()) {
      defaultSelected = make_shared<bool>(boost::any_cast<bool>(m["DefaultSelected"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("GroupType") != m.end() && !m["GroupType"].empty()) {
      groupType = make_shared<string>(boost::any_cast<string>(m["GroupType"]));
    }
    if (m.find("Ips") != m.end() && !m["Ips"].empty()) {
      if (typeid(map<string, boost::any>) == m["Ips"].type()) {
        DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodesIpv4IspCityNodeIps model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Ips"]));
        ips = make_shared<DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodesIpv4IspCityNodeIps>(model1);
      }
    }
    if (m.find("IspCode") != m.end() && !m["IspCode"].empty()) {
      ispCode = make_shared<string>(boost::any_cast<string>(m["IspCode"]));
    }
    if (m.find("IspName") != m.end() && !m["IspName"].empty()) {
      ispName = make_shared<string>(boost::any_cast<string>(m["IspName"]));
    }
  }


  virtual ~DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodesIpv4IspCityNode() = default;
};
class DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodes : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodesIpv4IspCityNode>> ipv4IspCityNode{};

  DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodes() {}

  explicit DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipv4IspCityNode) {
      vector<boost::any> temp1;
      for(auto item1:*ipv4IspCityNode){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Ipv4IspCityNode"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ipv4IspCityNode") != m.end() && !m["Ipv4IspCityNode"].empty()) {
      if (typeid(vector<boost::any>) == m["Ipv4IspCityNode"].type()) {
        vector<DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodesIpv4IspCityNode> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Ipv4IspCityNode"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodesIpv4IspCityNode model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ipv4IspCityNode = make_shared<vector<DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodesIpv4IspCityNode>>(expect1);
      }
    }
  }


  virtual ~DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodes() = default;
};
class DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodesIpv6IspCityNodeIps : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ip{};

  DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodesIpv6IspCityNodeIps() {}

  explicit DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodesIpv6IspCityNodeIps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Ip"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ip"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ip = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodesIpv6IspCityNodeIps() = default;
};
class DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodesIpv6IspCityNode : public Darabonba::Model {
public:
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};
  shared_ptr<bool> defaultSelected{};
  shared_ptr<string> groupName{};
  shared_ptr<string> groupType{};
  shared_ptr<DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodesIpv6IspCityNodeIps> ips{};
  shared_ptr<string> ispCode{};
  shared_ptr<string> ispName{};

  DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodesIpv6IspCityNode() {}

  explicit DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodesIpv6IspCityNode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cityCode) {
      res["CityCode"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["CityName"] = boost::any(*cityName);
    }
    if (defaultSelected) {
      res["DefaultSelected"] = boost::any(*defaultSelected);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (groupType) {
      res["GroupType"] = boost::any(*groupType);
    }
    if (ips) {
      res["Ips"] = ips ? boost::any(ips->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ispCode) {
      res["IspCode"] = boost::any(*ispCode);
    }
    if (ispName) {
      res["IspName"] = boost::any(*ispName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CityCode") != m.end() && !m["CityCode"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["CityCode"]));
    }
    if (m.find("CityName") != m.end() && !m["CityName"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["CityName"]));
    }
    if (m.find("DefaultSelected") != m.end() && !m["DefaultSelected"].empty()) {
      defaultSelected = make_shared<bool>(boost::any_cast<bool>(m["DefaultSelected"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("GroupType") != m.end() && !m["GroupType"].empty()) {
      groupType = make_shared<string>(boost::any_cast<string>(m["GroupType"]));
    }
    if (m.find("Ips") != m.end() && !m["Ips"].empty()) {
      if (typeid(map<string, boost::any>) == m["Ips"].type()) {
        DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodesIpv6IspCityNodeIps model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Ips"]));
        ips = make_shared<DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodesIpv6IspCityNodeIps>(model1);
      }
    }
    if (m.find("IspCode") != m.end() && !m["IspCode"].empty()) {
      ispCode = make_shared<string>(boost::any_cast<string>(m["IspCode"]));
    }
    if (m.find("IspName") != m.end() && !m["IspName"].empty()) {
      ispName = make_shared<string>(boost::any_cast<string>(m["IspName"]));
    }
  }


  virtual ~DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodesIpv6IspCityNode() = default;
};
class DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodes : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodesIpv6IspCityNode>> ipv6IspCityNode{};

  DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodes() {}

  explicit DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipv6IspCityNode) {
      vector<boost::any> temp1;
      for(auto item1:*ipv6IspCityNode){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Ipv6IspCityNode"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ipv6IspCityNode") != m.end() && !m["Ipv6IspCityNode"].empty()) {
      if (typeid(vector<boost::any>) == m["Ipv6IspCityNode"].type()) {
        vector<DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodesIpv6IspCityNode> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Ipv6IspCityNode"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodesIpv6IspCityNode model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ipv6IspCityNode = make_shared<vector<DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodesIpv6IspCityNode>>(expect1);
      }
    }
  }


  virtual ~DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodes() = default;
};
class DescribeDnsGtmMonitorAvailableConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodes> domainIpv4IspCityNodes{};
  shared_ptr<DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodes> domainIpv6IspCityNodes{};
  shared_ptr<DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodes> ipv4IspCityNodes{};
  shared_ptr<DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodes> ipv6IspCityNodes{};
  shared_ptr<string> requestId{};

  DescribeDnsGtmMonitorAvailableConfigResponseBody() {}

  explicit DescribeDnsGtmMonitorAvailableConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainIpv4IspCityNodes) {
      res["DomainIpv4IspCityNodes"] = domainIpv4IspCityNodes ? boost::any(domainIpv4IspCityNodes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (domainIpv6IspCityNodes) {
      res["DomainIpv6IspCityNodes"] = domainIpv6IspCityNodes ? boost::any(domainIpv6IspCityNodes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ipv4IspCityNodes) {
      res["Ipv4IspCityNodes"] = ipv4IspCityNodes ? boost::any(ipv4IspCityNodes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ipv6IspCityNodes) {
      res["Ipv6IspCityNodes"] = ipv6IspCityNodes ? boost::any(ipv6IspCityNodes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainIpv4IspCityNodes") != m.end() && !m["DomainIpv4IspCityNodes"].empty()) {
      if (typeid(map<string, boost::any>) == m["DomainIpv4IspCityNodes"].type()) {
        DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DomainIpv4IspCityNodes"]));
        domainIpv4IspCityNodes = make_shared<DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodes>(model1);
      }
    }
    if (m.find("DomainIpv6IspCityNodes") != m.end() && !m["DomainIpv6IspCityNodes"].empty()) {
      if (typeid(map<string, boost::any>) == m["DomainIpv6IspCityNodes"].type()) {
        DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DomainIpv6IspCityNodes"]));
        domainIpv6IspCityNodes = make_shared<DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodes>(model1);
      }
    }
    if (m.find("Ipv4IspCityNodes") != m.end() && !m["Ipv4IspCityNodes"].empty()) {
      if (typeid(map<string, boost::any>) == m["Ipv4IspCityNodes"].type()) {
        DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Ipv4IspCityNodes"]));
        ipv4IspCityNodes = make_shared<DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodes>(model1);
      }
    }
    if (m.find("Ipv6IspCityNodes") != m.end() && !m["Ipv6IspCityNodes"].empty()) {
      if (typeid(map<string, boost::any>) == m["Ipv6IspCityNodes"].type()) {
        DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Ipv6IspCityNodes"]));
        ipv6IspCityNodes = make_shared<DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodes>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDnsGtmMonitorAvailableConfigResponseBody() = default;
};
class DescribeDnsGtmMonitorAvailableConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDnsGtmMonitorAvailableConfigResponseBody> body{};

  DescribeDnsGtmMonitorAvailableConfigResponse() {}

  explicit DescribeDnsGtmMonitorAvailableConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDnsGtmMonitorAvailableConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDnsGtmMonitorAvailableConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDnsGtmMonitorAvailableConfigResponse() = default;
};
class DescribeDnsGtmMonitorConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> monitorConfigId{};

  DescribeDnsGtmMonitorConfigRequest() {}

  explicit DescribeDnsGtmMonitorConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (monitorConfigId) {
      res["MonitorConfigId"] = boost::any(*monitorConfigId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("MonitorConfigId") != m.end() && !m["MonitorConfigId"].empty()) {
      monitorConfigId = make_shared<string>(boost::any_cast<string>(m["MonitorConfigId"]));
    }
  }


  virtual ~DescribeDnsGtmMonitorConfigRequest() = default;
};
class DescribeDnsGtmMonitorConfigResponseBodyIspCityNodesIspCityNode : public Darabonba::Model {
public:
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};
  shared_ptr<string> countryCode{};
  shared_ptr<string> countryName{};
  shared_ptr<string> ispCode{};
  shared_ptr<string> ispName{};

  DescribeDnsGtmMonitorConfigResponseBodyIspCityNodesIspCityNode() {}

  explicit DescribeDnsGtmMonitorConfigResponseBodyIspCityNodesIspCityNode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cityCode) {
      res["CityCode"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["CityName"] = boost::any(*cityName);
    }
    if (countryCode) {
      res["CountryCode"] = boost::any(*countryCode);
    }
    if (countryName) {
      res["CountryName"] = boost::any(*countryName);
    }
    if (ispCode) {
      res["IspCode"] = boost::any(*ispCode);
    }
    if (ispName) {
      res["IspName"] = boost::any(*ispName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CityCode") != m.end() && !m["CityCode"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["CityCode"]));
    }
    if (m.find("CityName") != m.end() && !m["CityName"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["CityName"]));
    }
    if (m.find("CountryCode") != m.end() && !m["CountryCode"].empty()) {
      countryCode = make_shared<string>(boost::any_cast<string>(m["CountryCode"]));
    }
    if (m.find("CountryName") != m.end() && !m["CountryName"].empty()) {
      countryName = make_shared<string>(boost::any_cast<string>(m["CountryName"]));
    }
    if (m.find("IspCode") != m.end() && !m["IspCode"].empty()) {
      ispCode = make_shared<string>(boost::any_cast<string>(m["IspCode"]));
    }
    if (m.find("IspName") != m.end() && !m["IspName"].empty()) {
      ispName = make_shared<string>(boost::any_cast<string>(m["IspName"]));
    }
  }


  virtual ~DescribeDnsGtmMonitorConfigResponseBodyIspCityNodesIspCityNode() = default;
};
class DescribeDnsGtmMonitorConfigResponseBodyIspCityNodes : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDnsGtmMonitorConfigResponseBodyIspCityNodesIspCityNode>> ispCityNode{};

  DescribeDnsGtmMonitorConfigResponseBodyIspCityNodes() {}

  explicit DescribeDnsGtmMonitorConfigResponseBodyIspCityNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ispCityNode) {
      vector<boost::any> temp1;
      for(auto item1:*ispCityNode){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IspCityNode"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IspCityNode") != m.end() && !m["IspCityNode"].empty()) {
      if (typeid(vector<boost::any>) == m["IspCityNode"].type()) {
        vector<DescribeDnsGtmMonitorConfigResponseBodyIspCityNodesIspCityNode> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IspCityNode"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDnsGtmMonitorConfigResponseBodyIspCityNodesIspCityNode model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ispCityNode = make_shared<vector<DescribeDnsGtmMonitorConfigResponseBodyIspCityNodesIspCityNode>>(expect1);
      }
    }
  }


  virtual ~DescribeDnsGtmMonitorConfigResponseBodyIspCityNodes() = default;
};
class DescribeDnsGtmMonitorConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<long> evaluationCount{};
  shared_ptr<long> interval{};
  shared_ptr<DescribeDnsGtmMonitorConfigResponseBodyIspCityNodes> ispCityNodes{};
  shared_ptr<string> monitorConfigId{};
  shared_ptr<string> monitorExtendInfo{};
  shared_ptr<string> protocolType{};
  shared_ptr<string> requestId{};
  shared_ptr<long> timeout{};
  shared_ptr<string> updateTime{};
  shared_ptr<long> updateTimestamp{};

  DescribeDnsGtmMonitorConfigResponseBody() {}

  explicit DescribeDnsGtmMonitorConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (evaluationCount) {
      res["EvaluationCount"] = boost::any(*evaluationCount);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ispCityNodes) {
      res["IspCityNodes"] = ispCityNodes ? boost::any(ispCityNodes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (monitorConfigId) {
      res["MonitorConfigId"] = boost::any(*monitorConfigId);
    }
    if (monitorExtendInfo) {
      res["MonitorExtendInfo"] = boost::any(*monitorExtendInfo);
    }
    if (protocolType) {
      res["ProtocolType"] = boost::any(*protocolType);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (updateTimestamp) {
      res["UpdateTimestamp"] = boost::any(*updateTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("EvaluationCount") != m.end() && !m["EvaluationCount"].empty()) {
      evaluationCount = make_shared<long>(boost::any_cast<long>(m["EvaluationCount"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("IspCityNodes") != m.end() && !m["IspCityNodes"].empty()) {
      if (typeid(map<string, boost::any>) == m["IspCityNodes"].type()) {
        DescribeDnsGtmMonitorConfigResponseBodyIspCityNodes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IspCityNodes"]));
        ispCityNodes = make_shared<DescribeDnsGtmMonitorConfigResponseBodyIspCityNodes>(model1);
      }
    }
    if (m.find("MonitorConfigId") != m.end() && !m["MonitorConfigId"].empty()) {
      monitorConfigId = make_shared<string>(boost::any_cast<string>(m["MonitorConfigId"]));
    }
    if (m.find("MonitorExtendInfo") != m.end() && !m["MonitorExtendInfo"].empty()) {
      monitorExtendInfo = make_shared<string>(boost::any_cast<string>(m["MonitorExtendInfo"]));
    }
    if (m.find("ProtocolType") != m.end() && !m["ProtocolType"].empty()) {
      protocolType = make_shared<string>(boost::any_cast<string>(m["ProtocolType"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("UpdateTimestamp") != m.end() && !m["UpdateTimestamp"].empty()) {
      updateTimestamp = make_shared<long>(boost::any_cast<long>(m["UpdateTimestamp"]));
    }
  }


  virtual ~DescribeDnsGtmMonitorConfigResponseBody() = default;
};
class DescribeDnsGtmMonitorConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDnsGtmMonitorConfigResponseBody> body{};

  DescribeDnsGtmMonitorConfigResponse() {}

  explicit DescribeDnsGtmMonitorConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDnsGtmMonitorConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDnsGtmMonitorConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDnsGtmMonitorConfigResponse() = default;
};
class DescribeDnsProductInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> lang{};
  shared_ptr<string> userClientIp{};

  DescribeDnsProductInstanceRequest() {}

  explicit DescribeDnsProductInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (userClientIp) {
      res["UserClientIp"] = boost::any(*userClientIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("UserClientIp") != m.end() && !m["UserClientIp"].empty()) {
      userClientIp = make_shared<string>(boost::any_cast<string>(m["UserClientIp"]));
    }
  }


  virtual ~DescribeDnsProductInstanceRequest() = default;
};
class DescribeDnsProductInstanceResponseBodyDnsServers : public Darabonba::Model {
public:
  shared_ptr<vector<string>> dnsServer{};

  DescribeDnsProductInstanceResponseBodyDnsServers() {}

  explicit DescribeDnsProductInstanceResponseBodyDnsServers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dnsServer) {
      res["DnsServer"] = boost::any(*dnsServer);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DnsServer") != m.end() && !m["DnsServer"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DnsServer"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DnsServer"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dnsServer = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeDnsProductInstanceResponseBodyDnsServers() = default;
};
class DescribeDnsProductInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> autoRenewal{};
  shared_ptr<long> bindCount{};
  shared_ptr<long> bindDomainCount{};
  shared_ptr<long> bindDomainUsedCount{};
  shared_ptr<long> bindUsedCount{};
  shared_ptr<long> DDosDefendFlow{};
  shared_ptr<long> DDosDefendQuery{};
  shared_ptr<long> dnsSLBCount{};
  shared_ptr<string> dnsSecurity{};
  shared_ptr<DescribeDnsProductInstanceResponseBodyDnsServers> dnsServers{};
  shared_ptr<string> domain{};
  shared_ptr<string> domainType{};
  shared_ptr<string> endTime{};
  shared_ptr<long> endTimestamp{};
  shared_ptr<bool> gslb{};
  shared_ptr<string> ISPLines{};
  shared_ptr<string> ISPRegionLines{};
  shared_ptr<bool> inBlackHole{};
  shared_ptr<bool> inClean{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> monitorFrequency{};
  shared_ptr<long> monitorNodeCount{};
  shared_ptr<long> monitorTaskCount{};
  shared_ptr<long> overseaDDosDefendFlow{};
  shared_ptr<string> overseaLine{};
  shared_ptr<string> paymentType{};
  shared_ptr<bool> regionLines{};
  shared_ptr<string> requestId{};
  shared_ptr<string> searchEngineLines{};
  shared_ptr<string> startTime{};
  shared_ptr<long> startTimestamp{};
  shared_ptr<long> subDomainLevel{};
  shared_ptr<long> TTLMinValue{};
  shared_ptr<long> URLForwardCount{};
  shared_ptr<string> versionCode{};
  shared_ptr<string> versionName{};

  DescribeDnsProductInstanceResponseBody() {}

  explicit DescribeDnsProductInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRenewal) {
      res["AutoRenewal"] = boost::any(*autoRenewal);
    }
    if (bindCount) {
      res["BindCount"] = boost::any(*bindCount);
    }
    if (bindDomainCount) {
      res["BindDomainCount"] = boost::any(*bindDomainCount);
    }
    if (bindDomainUsedCount) {
      res["BindDomainUsedCount"] = boost::any(*bindDomainUsedCount);
    }
    if (bindUsedCount) {
      res["BindUsedCount"] = boost::any(*bindUsedCount);
    }
    if (DDosDefendFlow) {
      res["DDosDefendFlow"] = boost::any(*DDosDefendFlow);
    }
    if (DDosDefendQuery) {
      res["DDosDefendQuery"] = boost::any(*DDosDefendQuery);
    }
    if (dnsSLBCount) {
      res["DnsSLBCount"] = boost::any(*dnsSLBCount);
    }
    if (dnsSecurity) {
      res["DnsSecurity"] = boost::any(*dnsSecurity);
    }
    if (dnsServers) {
      res["DnsServers"] = dnsServers ? boost::any(dnsServers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (domainType) {
      res["DomainType"] = boost::any(*domainType);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (endTimestamp) {
      res["EndTimestamp"] = boost::any(*endTimestamp);
    }
    if (gslb) {
      res["Gslb"] = boost::any(*gslb);
    }
    if (ISPLines) {
      res["ISPLines"] = boost::any(*ISPLines);
    }
    if (ISPRegionLines) {
      res["ISPRegionLines"] = boost::any(*ISPRegionLines);
    }
    if (inBlackHole) {
      res["InBlackHole"] = boost::any(*inBlackHole);
    }
    if (inClean) {
      res["InClean"] = boost::any(*inClean);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (monitorFrequency) {
      res["MonitorFrequency"] = boost::any(*monitorFrequency);
    }
    if (monitorNodeCount) {
      res["MonitorNodeCount"] = boost::any(*monitorNodeCount);
    }
    if (monitorTaskCount) {
      res["MonitorTaskCount"] = boost::any(*monitorTaskCount);
    }
    if (overseaDDosDefendFlow) {
      res["OverseaDDosDefendFlow"] = boost::any(*overseaDDosDefendFlow);
    }
    if (overseaLine) {
      res["OverseaLine"] = boost::any(*overseaLine);
    }
    if (paymentType) {
      res["PaymentType"] = boost::any(*paymentType);
    }
    if (regionLines) {
      res["RegionLines"] = boost::any(*regionLines);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (searchEngineLines) {
      res["SearchEngineLines"] = boost::any(*searchEngineLines);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (startTimestamp) {
      res["StartTimestamp"] = boost::any(*startTimestamp);
    }
    if (subDomainLevel) {
      res["SubDomainLevel"] = boost::any(*subDomainLevel);
    }
    if (TTLMinValue) {
      res["TTLMinValue"] = boost::any(*TTLMinValue);
    }
    if (URLForwardCount) {
      res["URLForwardCount"] = boost::any(*URLForwardCount);
    }
    if (versionCode) {
      res["VersionCode"] = boost::any(*versionCode);
    }
    if (versionName) {
      res["VersionName"] = boost::any(*versionName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRenewal") != m.end() && !m["AutoRenewal"].empty()) {
      autoRenewal = make_shared<bool>(boost::any_cast<bool>(m["AutoRenewal"]));
    }
    if (m.find("BindCount") != m.end() && !m["BindCount"].empty()) {
      bindCount = make_shared<long>(boost::any_cast<long>(m["BindCount"]));
    }
    if (m.find("BindDomainCount") != m.end() && !m["BindDomainCount"].empty()) {
      bindDomainCount = make_shared<long>(boost::any_cast<long>(m["BindDomainCount"]));
    }
    if (m.find("BindDomainUsedCount") != m.end() && !m["BindDomainUsedCount"].empty()) {
      bindDomainUsedCount = make_shared<long>(boost::any_cast<long>(m["BindDomainUsedCount"]));
    }
    if (m.find("BindUsedCount") != m.end() && !m["BindUsedCount"].empty()) {
      bindUsedCount = make_shared<long>(boost::any_cast<long>(m["BindUsedCount"]));
    }
    if (m.find("DDosDefendFlow") != m.end() && !m["DDosDefendFlow"].empty()) {
      DDosDefendFlow = make_shared<long>(boost::any_cast<long>(m["DDosDefendFlow"]));
    }
    if (m.find("DDosDefendQuery") != m.end() && !m["DDosDefendQuery"].empty()) {
      DDosDefendQuery = make_shared<long>(boost::any_cast<long>(m["DDosDefendQuery"]));
    }
    if (m.find("DnsSLBCount") != m.end() && !m["DnsSLBCount"].empty()) {
      dnsSLBCount = make_shared<long>(boost::any_cast<long>(m["DnsSLBCount"]));
    }
    if (m.find("DnsSecurity") != m.end() && !m["DnsSecurity"].empty()) {
      dnsSecurity = make_shared<string>(boost::any_cast<string>(m["DnsSecurity"]));
    }
    if (m.find("DnsServers") != m.end() && !m["DnsServers"].empty()) {
      if (typeid(map<string, boost::any>) == m["DnsServers"].type()) {
        DescribeDnsProductInstanceResponseBodyDnsServers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DnsServers"]));
        dnsServers = make_shared<DescribeDnsProductInstanceResponseBodyDnsServers>(model1);
      }
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("DomainType") != m.end() && !m["DomainType"].empty()) {
      domainType = make_shared<string>(boost::any_cast<string>(m["DomainType"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("EndTimestamp") != m.end() && !m["EndTimestamp"].empty()) {
      endTimestamp = make_shared<long>(boost::any_cast<long>(m["EndTimestamp"]));
    }
    if (m.find("Gslb") != m.end() && !m["Gslb"].empty()) {
      gslb = make_shared<bool>(boost::any_cast<bool>(m["Gslb"]));
    }
    if (m.find("ISPLines") != m.end() && !m["ISPLines"].empty()) {
      ISPLines = make_shared<string>(boost::any_cast<string>(m["ISPLines"]));
    }
    if (m.find("ISPRegionLines") != m.end() && !m["ISPRegionLines"].empty()) {
      ISPRegionLines = make_shared<string>(boost::any_cast<string>(m["ISPRegionLines"]));
    }
    if (m.find("InBlackHole") != m.end() && !m["InBlackHole"].empty()) {
      inBlackHole = make_shared<bool>(boost::any_cast<bool>(m["InBlackHole"]));
    }
    if (m.find("InClean") != m.end() && !m["InClean"].empty()) {
      inClean = make_shared<bool>(boost::any_cast<bool>(m["InClean"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MonitorFrequency") != m.end() && !m["MonitorFrequency"].empty()) {
      monitorFrequency = make_shared<long>(boost::any_cast<long>(m["MonitorFrequency"]));
    }
    if (m.find("MonitorNodeCount") != m.end() && !m["MonitorNodeCount"].empty()) {
      monitorNodeCount = make_shared<long>(boost::any_cast<long>(m["MonitorNodeCount"]));
    }
    if (m.find("MonitorTaskCount") != m.end() && !m["MonitorTaskCount"].empty()) {
      monitorTaskCount = make_shared<long>(boost::any_cast<long>(m["MonitorTaskCount"]));
    }
    if (m.find("OverseaDDosDefendFlow") != m.end() && !m["OverseaDDosDefendFlow"].empty()) {
      overseaDDosDefendFlow = make_shared<long>(boost::any_cast<long>(m["OverseaDDosDefendFlow"]));
    }
    if (m.find("OverseaLine") != m.end() && !m["OverseaLine"].empty()) {
      overseaLine = make_shared<string>(boost::any_cast<string>(m["OverseaLine"]));
    }
    if (m.find("PaymentType") != m.end() && !m["PaymentType"].empty()) {
      paymentType = make_shared<string>(boost::any_cast<string>(m["PaymentType"]));
    }
    if (m.find("RegionLines") != m.end() && !m["RegionLines"].empty()) {
      regionLines = make_shared<bool>(boost::any_cast<bool>(m["RegionLines"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SearchEngineLines") != m.end() && !m["SearchEngineLines"].empty()) {
      searchEngineLines = make_shared<string>(boost::any_cast<string>(m["SearchEngineLines"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StartTimestamp") != m.end() && !m["StartTimestamp"].empty()) {
      startTimestamp = make_shared<long>(boost::any_cast<long>(m["StartTimestamp"]));
    }
    if (m.find("SubDomainLevel") != m.end() && !m["SubDomainLevel"].empty()) {
      subDomainLevel = make_shared<long>(boost::any_cast<long>(m["SubDomainLevel"]));
    }
    if (m.find("TTLMinValue") != m.end() && !m["TTLMinValue"].empty()) {
      TTLMinValue = make_shared<long>(boost::any_cast<long>(m["TTLMinValue"]));
    }
    if (m.find("URLForwardCount") != m.end() && !m["URLForwardCount"].empty()) {
      URLForwardCount = make_shared<long>(boost::any_cast<long>(m["URLForwardCount"]));
    }
    if (m.find("VersionCode") != m.end() && !m["VersionCode"].empty()) {
      versionCode = make_shared<string>(boost::any_cast<string>(m["VersionCode"]));
    }
    if (m.find("VersionName") != m.end() && !m["VersionName"].empty()) {
      versionName = make_shared<string>(boost::any_cast<string>(m["VersionName"]));
    }
  }


  virtual ~DescribeDnsProductInstanceResponseBody() = default;
};
class DescribeDnsProductInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDnsProductInstanceResponseBody> body{};

  DescribeDnsProductInstanceResponse() {}

  explicit DescribeDnsProductInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDnsProductInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDnsProductInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDnsProductInstanceResponse() = default;
};
class DescribeDnsProductInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> direction{};
  shared_ptr<string> domainType{};
  shared_ptr<string> lang{};
  shared_ptr<string> orderBy{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> userClientIp{};
  shared_ptr<string> versionCode{};

  DescribeDnsProductInstancesRequest() {}

  explicit DescribeDnsProductInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (direction) {
      res["Direction"] = boost::any(*direction);
    }
    if (domainType) {
      res["DomainType"] = boost::any(*domainType);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (userClientIp) {
      res["UserClientIp"] = boost::any(*userClientIp);
    }
    if (versionCode) {
      res["VersionCode"] = boost::any(*versionCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Direction") != m.end() && !m["Direction"].empty()) {
      direction = make_shared<string>(boost::any_cast<string>(m["Direction"]));
    }
    if (m.find("DomainType") != m.end() && !m["DomainType"].empty()) {
      domainType = make_shared<string>(boost::any_cast<string>(m["DomainType"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("UserClientIp") != m.end() && !m["UserClientIp"].empty()) {
      userClientIp = make_shared<string>(boost::any_cast<string>(m["UserClientIp"]));
    }
    if (m.find("VersionCode") != m.end() && !m["VersionCode"].empty()) {
      versionCode = make_shared<string>(boost::any_cast<string>(m["VersionCode"]));
    }
  }


  virtual ~DescribeDnsProductInstancesRequest() = default;
};
class DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct : public Darabonba::Model {
public:
  shared_ptr<bool> autoRenewal{};
  shared_ptr<long> bindCount{};
  shared_ptr<long> bindDomainCount{};
  shared_ptr<long> bindDomainUsedCount{};
  shared_ptr<long> bindUsedCount{};
  shared_ptr<long> DDosDefendFlow{};
  shared_ptr<long> DDosDefendQuery{};
  shared_ptr<long> dnsSLBCount{};
  shared_ptr<string> dnsSecurity{};
  shared_ptr<string> domain{};
  shared_ptr<string> endTime{};
  shared_ptr<long> endTimestamp{};
  shared_ptr<bool> gslb{};
  shared_ptr<string> ISPLines{};
  shared_ptr<string> ISPRegionLines{};
  shared_ptr<bool> inBlackHole{};
  shared_ptr<bool> inClean{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> monitorFrequency{};
  shared_ptr<long> monitorNodeCount{};
  shared_ptr<long> monitorTaskCount{};
  shared_ptr<long> overseaDDosDefendFlow{};
  shared_ptr<string> overseaLine{};
  shared_ptr<string> paymentType{};
  shared_ptr<bool> regionLines{};
  shared_ptr<string> searchEngineLines{};
  shared_ptr<string> startTime{};
  shared_ptr<long> startTimestamp{};
  shared_ptr<long> subDomainLevel{};
  shared_ptr<long> TTLMinValue{};
  shared_ptr<long> URLForwardCount{};
  shared_ptr<string> versionCode{};
  shared_ptr<string> versionName{};

  DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct() {}

  explicit DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRenewal) {
      res["AutoRenewal"] = boost::any(*autoRenewal);
    }
    if (bindCount) {
      res["BindCount"] = boost::any(*bindCount);
    }
    if (bindDomainCount) {
      res["BindDomainCount"] = boost::any(*bindDomainCount);
    }
    if (bindDomainUsedCount) {
      res["BindDomainUsedCount"] = boost::any(*bindDomainUsedCount);
    }
    if (bindUsedCount) {
      res["BindUsedCount"] = boost::any(*bindUsedCount);
    }
    if (DDosDefendFlow) {
      res["DDosDefendFlow"] = boost::any(*DDosDefendFlow);
    }
    if (DDosDefendQuery) {
      res["DDosDefendQuery"] = boost::any(*DDosDefendQuery);
    }
    if (dnsSLBCount) {
      res["DnsSLBCount"] = boost::any(*dnsSLBCount);
    }
    if (dnsSecurity) {
      res["DnsSecurity"] = boost::any(*dnsSecurity);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (endTimestamp) {
      res["EndTimestamp"] = boost::any(*endTimestamp);
    }
    if (gslb) {
      res["Gslb"] = boost::any(*gslb);
    }
    if (ISPLines) {
      res["ISPLines"] = boost::any(*ISPLines);
    }
    if (ISPRegionLines) {
      res["ISPRegionLines"] = boost::any(*ISPRegionLines);
    }
    if (inBlackHole) {
      res["InBlackHole"] = boost::any(*inBlackHole);
    }
    if (inClean) {
      res["InClean"] = boost::any(*inClean);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (monitorFrequency) {
      res["MonitorFrequency"] = boost::any(*monitorFrequency);
    }
    if (monitorNodeCount) {
      res["MonitorNodeCount"] = boost::any(*monitorNodeCount);
    }
    if (monitorTaskCount) {
      res["MonitorTaskCount"] = boost::any(*monitorTaskCount);
    }
    if (overseaDDosDefendFlow) {
      res["OverseaDDosDefendFlow"] = boost::any(*overseaDDosDefendFlow);
    }
    if (overseaLine) {
      res["OverseaLine"] = boost::any(*overseaLine);
    }
    if (paymentType) {
      res["PaymentType"] = boost::any(*paymentType);
    }
    if (regionLines) {
      res["RegionLines"] = boost::any(*regionLines);
    }
    if (searchEngineLines) {
      res["SearchEngineLines"] = boost::any(*searchEngineLines);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (startTimestamp) {
      res["StartTimestamp"] = boost::any(*startTimestamp);
    }
    if (subDomainLevel) {
      res["SubDomainLevel"] = boost::any(*subDomainLevel);
    }
    if (TTLMinValue) {
      res["TTLMinValue"] = boost::any(*TTLMinValue);
    }
    if (URLForwardCount) {
      res["URLForwardCount"] = boost::any(*URLForwardCount);
    }
    if (versionCode) {
      res["VersionCode"] = boost::any(*versionCode);
    }
    if (versionName) {
      res["VersionName"] = boost::any(*versionName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRenewal") != m.end() && !m["AutoRenewal"].empty()) {
      autoRenewal = make_shared<bool>(boost::any_cast<bool>(m["AutoRenewal"]));
    }
    if (m.find("BindCount") != m.end() && !m["BindCount"].empty()) {
      bindCount = make_shared<long>(boost::any_cast<long>(m["BindCount"]));
    }
    if (m.find("BindDomainCount") != m.end() && !m["BindDomainCount"].empty()) {
      bindDomainCount = make_shared<long>(boost::any_cast<long>(m["BindDomainCount"]));
    }
    if (m.find("BindDomainUsedCount") != m.end() && !m["BindDomainUsedCount"].empty()) {
      bindDomainUsedCount = make_shared<long>(boost::any_cast<long>(m["BindDomainUsedCount"]));
    }
    if (m.find("BindUsedCount") != m.end() && !m["BindUsedCount"].empty()) {
      bindUsedCount = make_shared<long>(boost::any_cast<long>(m["BindUsedCount"]));
    }
    if (m.find("DDosDefendFlow") != m.end() && !m["DDosDefendFlow"].empty()) {
      DDosDefendFlow = make_shared<long>(boost::any_cast<long>(m["DDosDefendFlow"]));
    }
    if (m.find("DDosDefendQuery") != m.end() && !m["DDosDefendQuery"].empty()) {
      DDosDefendQuery = make_shared<long>(boost::any_cast<long>(m["DDosDefendQuery"]));
    }
    if (m.find("DnsSLBCount") != m.end() && !m["DnsSLBCount"].empty()) {
      dnsSLBCount = make_shared<long>(boost::any_cast<long>(m["DnsSLBCount"]));
    }
    if (m.find("DnsSecurity") != m.end() && !m["DnsSecurity"].empty()) {
      dnsSecurity = make_shared<string>(boost::any_cast<string>(m["DnsSecurity"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("EndTimestamp") != m.end() && !m["EndTimestamp"].empty()) {
      endTimestamp = make_shared<long>(boost::any_cast<long>(m["EndTimestamp"]));
    }
    if (m.find("Gslb") != m.end() && !m["Gslb"].empty()) {
      gslb = make_shared<bool>(boost::any_cast<bool>(m["Gslb"]));
    }
    if (m.find("ISPLines") != m.end() && !m["ISPLines"].empty()) {
      ISPLines = make_shared<string>(boost::any_cast<string>(m["ISPLines"]));
    }
    if (m.find("ISPRegionLines") != m.end() && !m["ISPRegionLines"].empty()) {
      ISPRegionLines = make_shared<string>(boost::any_cast<string>(m["ISPRegionLines"]));
    }
    if (m.find("InBlackHole") != m.end() && !m["InBlackHole"].empty()) {
      inBlackHole = make_shared<bool>(boost::any_cast<bool>(m["InBlackHole"]));
    }
    if (m.find("InClean") != m.end() && !m["InClean"].empty()) {
      inClean = make_shared<bool>(boost::any_cast<bool>(m["InClean"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MonitorFrequency") != m.end() && !m["MonitorFrequency"].empty()) {
      monitorFrequency = make_shared<long>(boost::any_cast<long>(m["MonitorFrequency"]));
    }
    if (m.find("MonitorNodeCount") != m.end() && !m["MonitorNodeCount"].empty()) {
      monitorNodeCount = make_shared<long>(boost::any_cast<long>(m["MonitorNodeCount"]));
    }
    if (m.find("MonitorTaskCount") != m.end() && !m["MonitorTaskCount"].empty()) {
      monitorTaskCount = make_shared<long>(boost::any_cast<long>(m["MonitorTaskCount"]));
    }
    if (m.find("OverseaDDosDefendFlow") != m.end() && !m["OverseaDDosDefendFlow"].empty()) {
      overseaDDosDefendFlow = make_shared<long>(boost::any_cast<long>(m["OverseaDDosDefendFlow"]));
    }
    if (m.find("OverseaLine") != m.end() && !m["OverseaLine"].empty()) {
      overseaLine = make_shared<string>(boost::any_cast<string>(m["OverseaLine"]));
    }
    if (m.find("PaymentType") != m.end() && !m["PaymentType"].empty()) {
      paymentType = make_shared<string>(boost::any_cast<string>(m["PaymentType"]));
    }
    if (m.find("RegionLines") != m.end() && !m["RegionLines"].empty()) {
      regionLines = make_shared<bool>(boost::any_cast<bool>(m["RegionLines"]));
    }
    if (m.find("SearchEngineLines") != m.end() && !m["SearchEngineLines"].empty()) {
      searchEngineLines = make_shared<string>(boost::any_cast<string>(m["SearchEngineLines"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StartTimestamp") != m.end() && !m["StartTimestamp"].empty()) {
      startTimestamp = make_shared<long>(boost::any_cast<long>(m["StartTimestamp"]));
    }
    if (m.find("SubDomainLevel") != m.end() && !m["SubDomainLevel"].empty()) {
      subDomainLevel = make_shared<long>(boost::any_cast<long>(m["SubDomainLevel"]));
    }
    if (m.find("TTLMinValue") != m.end() && !m["TTLMinValue"].empty()) {
      TTLMinValue = make_shared<long>(boost::any_cast<long>(m["TTLMinValue"]));
    }
    if (m.find("URLForwardCount") != m.end() && !m["URLForwardCount"].empty()) {
      URLForwardCount = make_shared<long>(boost::any_cast<long>(m["URLForwardCount"]));
    }
    if (m.find("VersionCode") != m.end() && !m["VersionCode"].empty()) {
      versionCode = make_shared<string>(boost::any_cast<string>(m["VersionCode"]));
    }
    if (m.find("VersionName") != m.end() && !m["VersionName"].empty()) {
      versionName = make_shared<string>(boost::any_cast<string>(m["VersionName"]));
    }
  }


  virtual ~DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct() = default;
};
class DescribeDnsProductInstancesResponseBodyDnsProducts : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct>> dnsProduct{};

  DescribeDnsProductInstancesResponseBodyDnsProducts() {}

  explicit DescribeDnsProductInstancesResponseBodyDnsProducts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dnsProduct) {
      vector<boost::any> temp1;
      for(auto item1:*dnsProduct){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DnsProduct"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DnsProduct") != m.end() && !m["DnsProduct"].empty()) {
      if (typeid(vector<boost::any>) == m["DnsProduct"].type()) {
        vector<DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DnsProduct"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dnsProduct = make_shared<vector<DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct>>(expect1);
      }
    }
  }


  virtual ~DescribeDnsProductInstancesResponseBodyDnsProducts() = default;
};
class DescribeDnsProductInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDnsProductInstancesResponseBodyDnsProducts> dnsProducts{};
  shared_ptr<string> domainType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeDnsProductInstancesResponseBody() {}

  explicit DescribeDnsProductInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dnsProducts) {
      res["DnsProducts"] = dnsProducts ? boost::any(dnsProducts->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (domainType) {
      res["DomainType"] = boost::any(*domainType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DnsProducts") != m.end() && !m["DnsProducts"].empty()) {
      if (typeid(map<string, boost::any>) == m["DnsProducts"].type()) {
        DescribeDnsProductInstancesResponseBodyDnsProducts model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DnsProducts"]));
        dnsProducts = make_shared<DescribeDnsProductInstancesResponseBodyDnsProducts>(model1);
      }
    }
    if (m.find("DomainType") != m.end() && !m["DomainType"].empty()) {
      domainType = make_shared<string>(boost::any_cast<string>(m["DomainType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDnsProductInstancesResponseBody() = default;
};
class DescribeDnsProductInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDnsProductInstancesResponseBody> body{};

  DescribeDnsProductInstancesResponse() {}

  explicit DescribeDnsProductInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDnsProductInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDnsProductInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDnsProductInstancesResponse() = default;
};
class DescribeDohAccountStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> endDate{};
  shared_ptr<string> lang{};
  shared_ptr<string> startDate{};

  DescribeDohAccountStatisticsRequest() {}

  explicit DescribeDohAccountStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
  }


  virtual ~DescribeDohAccountStatisticsRequest() = default;
};
class DescribeDohAccountStatisticsResponseBodyStatistics : public Darabonba::Model {
public:
  shared_ptr<long> timestamp{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> v4HttpCount{};
  shared_ptr<long> v4HttpsCount{};
  shared_ptr<long> v6HttpCount{};
  shared_ptr<long> v6HttpsCount{};

  DescribeDohAccountStatisticsResponseBodyStatistics() {}

  explicit DescribeDohAccountStatisticsResponseBodyStatistics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (v4HttpCount) {
      res["V4HttpCount"] = boost::any(*v4HttpCount);
    }
    if (v4HttpsCount) {
      res["V4HttpsCount"] = boost::any(*v4HttpsCount);
    }
    if (v6HttpCount) {
      res["V6HttpCount"] = boost::any(*v6HttpCount);
    }
    if (v6HttpsCount) {
      res["V6HttpsCount"] = boost::any(*v6HttpsCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("V4HttpCount") != m.end() && !m["V4HttpCount"].empty()) {
      v4HttpCount = make_shared<long>(boost::any_cast<long>(m["V4HttpCount"]));
    }
    if (m.find("V4HttpsCount") != m.end() && !m["V4HttpsCount"].empty()) {
      v4HttpsCount = make_shared<long>(boost::any_cast<long>(m["V4HttpsCount"]));
    }
    if (m.find("V6HttpCount") != m.end() && !m["V6HttpCount"].empty()) {
      v6HttpCount = make_shared<long>(boost::any_cast<long>(m["V6HttpCount"]));
    }
    if (m.find("V6HttpsCount") != m.end() && !m["V6HttpsCount"].empty()) {
      v6HttpsCount = make_shared<long>(boost::any_cast<long>(m["V6HttpsCount"]));
    }
  }


  virtual ~DescribeDohAccountStatisticsResponseBodyStatistics() = default;
};
class DescribeDohAccountStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeDohAccountStatisticsResponseBodyStatistics>> statistics{};

  DescribeDohAccountStatisticsResponseBody() {}

  explicit DescribeDohAccountStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (statistics) {
      vector<boost::any> temp1;
      for(auto item1:*statistics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Statistics"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      if (typeid(vector<boost::any>) == m["Statistics"].type()) {
        vector<DescribeDohAccountStatisticsResponseBodyStatistics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Statistics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDohAccountStatisticsResponseBodyStatistics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        statistics = make_shared<vector<DescribeDohAccountStatisticsResponseBodyStatistics>>(expect1);
      }
    }
  }


  virtual ~DescribeDohAccountStatisticsResponseBody() = default;
};
class DescribeDohAccountStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDohAccountStatisticsResponseBody> body{};

  DescribeDohAccountStatisticsResponse() {}

  explicit DescribeDohAccountStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDohAccountStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDohAccountStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDohAccountStatisticsResponse() = default;
};
class DescribeDohDomainStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endDate{};
  shared_ptr<string> lang{};
  shared_ptr<string> startDate{};

  DescribeDohDomainStatisticsRequest() {}

  explicit DescribeDohDomainStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
  }


  virtual ~DescribeDohDomainStatisticsRequest() = default;
};
class DescribeDohDomainStatisticsResponseBodyStatistics : public Darabonba::Model {
public:
  shared_ptr<long> timestamp{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> v4HttpCount{};
  shared_ptr<long> v4HttpsCount{};
  shared_ptr<long> v6HttpCount{};
  shared_ptr<long> v6HttpsCount{};

  DescribeDohDomainStatisticsResponseBodyStatistics() {}

  explicit DescribeDohDomainStatisticsResponseBodyStatistics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (v4HttpCount) {
      res["V4HttpCount"] = boost::any(*v4HttpCount);
    }
    if (v4HttpsCount) {
      res["V4HttpsCount"] = boost::any(*v4HttpsCount);
    }
    if (v6HttpCount) {
      res["V6HttpCount"] = boost::any(*v6HttpCount);
    }
    if (v6HttpsCount) {
      res["V6HttpsCount"] = boost::any(*v6HttpsCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("V4HttpCount") != m.end() && !m["V4HttpCount"].empty()) {
      v4HttpCount = make_shared<long>(boost::any_cast<long>(m["V4HttpCount"]));
    }
    if (m.find("V4HttpsCount") != m.end() && !m["V4HttpsCount"].empty()) {
      v4HttpsCount = make_shared<long>(boost::any_cast<long>(m["V4HttpsCount"]));
    }
    if (m.find("V6HttpCount") != m.end() && !m["V6HttpCount"].empty()) {
      v6HttpCount = make_shared<long>(boost::any_cast<long>(m["V6HttpCount"]));
    }
    if (m.find("V6HttpsCount") != m.end() && !m["V6HttpsCount"].empty()) {
      v6HttpsCount = make_shared<long>(boost::any_cast<long>(m["V6HttpsCount"]));
    }
  }


  virtual ~DescribeDohDomainStatisticsResponseBodyStatistics() = default;
};
class DescribeDohDomainStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeDohDomainStatisticsResponseBodyStatistics>> statistics{};

  DescribeDohDomainStatisticsResponseBody() {}

  explicit DescribeDohDomainStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (statistics) {
      vector<boost::any> temp1;
      for(auto item1:*statistics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Statistics"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      if (typeid(vector<boost::any>) == m["Statistics"].type()) {
        vector<DescribeDohDomainStatisticsResponseBodyStatistics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Statistics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDohDomainStatisticsResponseBodyStatistics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        statistics = make_shared<vector<DescribeDohDomainStatisticsResponseBodyStatistics>>(expect1);
      }
    }
  }


  virtual ~DescribeDohDomainStatisticsResponseBody() = default;
};
class DescribeDohDomainStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDohDomainStatisticsResponseBody> body{};

  DescribeDohDomainStatisticsResponse() {}

  explicit DescribeDohDomainStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDohDomainStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDohDomainStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDohDomainStatisticsResponse() = default;
};
class DescribeDohDomainStatisticsSummaryRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endDate{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> startDate{};

  DescribeDohDomainStatisticsSummaryRequest() {}

  explicit DescribeDohDomainStatisticsSummaryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
  }


  virtual ~DescribeDohDomainStatisticsSummaryRequest() = default;
};
class DescribeDohDomainStatisticsSummaryResponseBodyStatistics : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> httpCount{};
  shared_ptr<long> httpsCount{};
  shared_ptr<long> ipCount{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> v4HttpCount{};
  shared_ptr<long> v4HttpsCount{};
  shared_ptr<long> v6HttpCount{};
  shared_ptr<long> v6HttpsCount{};

  DescribeDohDomainStatisticsSummaryResponseBodyStatistics() {}

  explicit DescribeDohDomainStatisticsSummaryResponseBodyStatistics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (httpCount) {
      res["HttpCount"] = boost::any(*httpCount);
    }
    if (httpsCount) {
      res["HttpsCount"] = boost::any(*httpsCount);
    }
    if (ipCount) {
      res["IpCount"] = boost::any(*ipCount);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (v4HttpCount) {
      res["V4HttpCount"] = boost::any(*v4HttpCount);
    }
    if (v4HttpsCount) {
      res["V4HttpsCount"] = boost::any(*v4HttpsCount);
    }
    if (v6HttpCount) {
      res["V6HttpCount"] = boost::any(*v6HttpCount);
    }
    if (v6HttpsCount) {
      res["V6HttpsCount"] = boost::any(*v6HttpsCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("HttpCount") != m.end() && !m["HttpCount"].empty()) {
      httpCount = make_shared<long>(boost::any_cast<long>(m["HttpCount"]));
    }
    if (m.find("HttpsCount") != m.end() && !m["HttpsCount"].empty()) {
      httpsCount = make_shared<long>(boost::any_cast<long>(m["HttpsCount"]));
    }
    if (m.find("IpCount") != m.end() && !m["IpCount"].empty()) {
      ipCount = make_shared<long>(boost::any_cast<long>(m["IpCount"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("V4HttpCount") != m.end() && !m["V4HttpCount"].empty()) {
      v4HttpCount = make_shared<long>(boost::any_cast<long>(m["V4HttpCount"]));
    }
    if (m.find("V4HttpsCount") != m.end() && !m["V4HttpsCount"].empty()) {
      v4HttpsCount = make_shared<long>(boost::any_cast<long>(m["V4HttpsCount"]));
    }
    if (m.find("V6HttpCount") != m.end() && !m["V6HttpCount"].empty()) {
      v6HttpCount = make_shared<long>(boost::any_cast<long>(m["V6HttpCount"]));
    }
    if (m.find("V6HttpsCount") != m.end() && !m["V6HttpsCount"].empty()) {
      v6HttpsCount = make_shared<long>(boost::any_cast<long>(m["V6HttpsCount"]));
    }
  }


  virtual ~DescribeDohDomainStatisticsSummaryResponseBodyStatistics() = default;
};
class DescribeDohDomainStatisticsSummaryResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeDohDomainStatisticsSummaryResponseBodyStatistics>> statistics{};
  shared_ptr<long> totalItems{};
  shared_ptr<long> totalPages{};

  DescribeDohDomainStatisticsSummaryResponseBody() {}

  explicit DescribeDohDomainStatisticsSummaryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (statistics) {
      vector<boost::any> temp1;
      for(auto item1:*statistics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Statistics"] = boost::any(temp1);
    }
    if (totalItems) {
      res["TotalItems"] = boost::any(*totalItems);
    }
    if (totalPages) {
      res["TotalPages"] = boost::any(*totalPages);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      if (typeid(vector<boost::any>) == m["Statistics"].type()) {
        vector<DescribeDohDomainStatisticsSummaryResponseBodyStatistics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Statistics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDohDomainStatisticsSummaryResponseBodyStatistics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        statistics = make_shared<vector<DescribeDohDomainStatisticsSummaryResponseBodyStatistics>>(expect1);
      }
    }
    if (m.find("TotalItems") != m.end() && !m["TotalItems"].empty()) {
      totalItems = make_shared<long>(boost::any_cast<long>(m["TotalItems"]));
    }
    if (m.find("TotalPages") != m.end() && !m["TotalPages"].empty()) {
      totalPages = make_shared<long>(boost::any_cast<long>(m["TotalPages"]));
    }
  }


  virtual ~DescribeDohDomainStatisticsSummaryResponseBody() = default;
};
class DescribeDohDomainStatisticsSummaryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDohDomainStatisticsSummaryResponseBody> body{};

  DescribeDohDomainStatisticsSummaryResponse() {}

  explicit DescribeDohDomainStatisticsSummaryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDohDomainStatisticsSummaryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDohDomainStatisticsSummaryResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDohDomainStatisticsSummaryResponse() = default;
};
class DescribeDohSubDomainStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> endDate{};
  shared_ptr<string> lang{};
  shared_ptr<string> startDate{};
  shared_ptr<string> subDomain{};

  DescribeDohSubDomainStatisticsRequest() {}

  explicit DescribeDohSubDomainStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    if (subDomain) {
      res["SubDomain"] = boost::any(*subDomain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
    if (m.find("SubDomain") != m.end() && !m["SubDomain"].empty()) {
      subDomain = make_shared<string>(boost::any_cast<string>(m["SubDomain"]));
    }
  }


  virtual ~DescribeDohSubDomainStatisticsRequest() = default;
};
class DescribeDohSubDomainStatisticsResponseBodyStatistics : public Darabonba::Model {
public:
  shared_ptr<long> timestamp{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> v4HttpCount{};
  shared_ptr<long> v4HttpsCount{};
  shared_ptr<long> v6HttpCount{};
  shared_ptr<long> v6HttpsCount{};

  DescribeDohSubDomainStatisticsResponseBodyStatistics() {}

  explicit DescribeDohSubDomainStatisticsResponseBodyStatistics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (v4HttpCount) {
      res["V4HttpCount"] = boost::any(*v4HttpCount);
    }
    if (v4HttpsCount) {
      res["V4HttpsCount"] = boost::any(*v4HttpsCount);
    }
    if (v6HttpCount) {
      res["V6HttpCount"] = boost::any(*v6HttpCount);
    }
    if (v6HttpsCount) {
      res["V6HttpsCount"] = boost::any(*v6HttpsCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("V4HttpCount") != m.end() && !m["V4HttpCount"].empty()) {
      v4HttpCount = make_shared<long>(boost::any_cast<long>(m["V4HttpCount"]));
    }
    if (m.find("V4HttpsCount") != m.end() && !m["V4HttpsCount"].empty()) {
      v4HttpsCount = make_shared<long>(boost::any_cast<long>(m["V4HttpsCount"]));
    }
    if (m.find("V6HttpCount") != m.end() && !m["V6HttpCount"].empty()) {
      v6HttpCount = make_shared<long>(boost::any_cast<long>(m["V6HttpCount"]));
    }
    if (m.find("V6HttpsCount") != m.end() && !m["V6HttpsCount"].empty()) {
      v6HttpsCount = make_shared<long>(boost::any_cast<long>(m["V6HttpsCount"]));
    }
  }


  virtual ~DescribeDohSubDomainStatisticsResponseBodyStatistics() = default;
};
class DescribeDohSubDomainStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeDohSubDomainStatisticsResponseBodyStatistics>> statistics{};

  DescribeDohSubDomainStatisticsResponseBody() {}

  explicit DescribeDohSubDomainStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (statistics) {
      vector<boost::any> temp1;
      for(auto item1:*statistics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Statistics"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      if (typeid(vector<boost::any>) == m["Statistics"].type()) {
        vector<DescribeDohSubDomainStatisticsResponseBodyStatistics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Statistics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDohSubDomainStatisticsResponseBodyStatistics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        statistics = make_shared<vector<DescribeDohSubDomainStatisticsResponseBodyStatistics>>(expect1);
      }
    }
  }


  virtual ~DescribeDohSubDomainStatisticsResponseBody() = default;
};
class DescribeDohSubDomainStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDohSubDomainStatisticsResponseBody> body{};

  DescribeDohSubDomainStatisticsResponse() {}

  explicit DescribeDohSubDomainStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDohSubDomainStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDohSubDomainStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDohSubDomainStatisticsResponse() = default;
};
class DescribeDohSubDomainStatisticsSummaryRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endDate{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> startDate{};
  shared_ptr<string> subDomain{};

  DescribeDohSubDomainStatisticsSummaryRequest() {}

  explicit DescribeDohSubDomainStatisticsSummaryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    if (subDomain) {
      res["SubDomain"] = boost::any(*subDomain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
    if (m.find("SubDomain") != m.end() && !m["SubDomain"].empty()) {
      subDomain = make_shared<string>(boost::any_cast<string>(m["SubDomain"]));
    }
  }


  virtual ~DescribeDohSubDomainStatisticsSummaryRequest() = default;
};
class DescribeDohSubDomainStatisticsSummaryResponseBodyStatistics : public Darabonba::Model {
public:
  shared_ptr<long> httpCount{};
  shared_ptr<long> httpsCount{};
  shared_ptr<long> ipCount{};
  shared_ptr<string> subDomain{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> v4HttpCount{};
  shared_ptr<long> v4HttpsCount{};
  shared_ptr<long> v6HttpCount{};
  shared_ptr<long> v6HttpsCount{};

  DescribeDohSubDomainStatisticsSummaryResponseBodyStatistics() {}

  explicit DescribeDohSubDomainStatisticsSummaryResponseBodyStatistics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpCount) {
      res["HttpCount"] = boost::any(*httpCount);
    }
    if (httpsCount) {
      res["HttpsCount"] = boost::any(*httpsCount);
    }
    if (ipCount) {
      res["IpCount"] = boost::any(*ipCount);
    }
    if (subDomain) {
      res["SubDomain"] = boost::any(*subDomain);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (v4HttpCount) {
      res["V4HttpCount"] = boost::any(*v4HttpCount);
    }
    if (v4HttpsCount) {
      res["V4HttpsCount"] = boost::any(*v4HttpsCount);
    }
    if (v6HttpCount) {
      res["V6HttpCount"] = boost::any(*v6HttpCount);
    }
    if (v6HttpsCount) {
      res["V6HttpsCount"] = boost::any(*v6HttpsCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpCount") != m.end() && !m["HttpCount"].empty()) {
      httpCount = make_shared<long>(boost::any_cast<long>(m["HttpCount"]));
    }
    if (m.find("HttpsCount") != m.end() && !m["HttpsCount"].empty()) {
      httpsCount = make_shared<long>(boost::any_cast<long>(m["HttpsCount"]));
    }
    if (m.find("IpCount") != m.end() && !m["IpCount"].empty()) {
      ipCount = make_shared<long>(boost::any_cast<long>(m["IpCount"]));
    }
    if (m.find("SubDomain") != m.end() && !m["SubDomain"].empty()) {
      subDomain = make_shared<string>(boost::any_cast<string>(m["SubDomain"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("V4HttpCount") != m.end() && !m["V4HttpCount"].empty()) {
      v4HttpCount = make_shared<long>(boost::any_cast<long>(m["V4HttpCount"]));
    }
    if (m.find("V4HttpsCount") != m.end() && !m["V4HttpsCount"].empty()) {
      v4HttpsCount = make_shared<long>(boost::any_cast<long>(m["V4HttpsCount"]));
    }
    if (m.find("V6HttpCount") != m.end() && !m["V6HttpCount"].empty()) {
      v6HttpCount = make_shared<long>(boost::any_cast<long>(m["V6HttpCount"]));
    }
    if (m.find("V6HttpsCount") != m.end() && !m["V6HttpsCount"].empty()) {
      v6HttpsCount = make_shared<long>(boost::any_cast<long>(m["V6HttpsCount"]));
    }
  }


  virtual ~DescribeDohSubDomainStatisticsSummaryResponseBodyStatistics() = default;
};
class DescribeDohSubDomainStatisticsSummaryResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeDohSubDomainStatisticsSummaryResponseBodyStatistics>> statistics{};
  shared_ptr<long> totalItems{};
  shared_ptr<long> totalPages{};

  DescribeDohSubDomainStatisticsSummaryResponseBody() {}

  explicit DescribeDohSubDomainStatisticsSummaryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (statistics) {
      vector<boost::any> temp1;
      for(auto item1:*statistics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Statistics"] = boost::any(temp1);
    }
    if (totalItems) {
      res["TotalItems"] = boost::any(*totalItems);
    }
    if (totalPages) {
      res["TotalPages"] = boost::any(*totalPages);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      if (typeid(vector<boost::any>) == m["Statistics"].type()) {
        vector<DescribeDohSubDomainStatisticsSummaryResponseBodyStatistics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Statistics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDohSubDomainStatisticsSummaryResponseBodyStatistics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        statistics = make_shared<vector<DescribeDohSubDomainStatisticsSummaryResponseBodyStatistics>>(expect1);
      }
    }
    if (m.find("TotalItems") != m.end() && !m["TotalItems"].empty()) {
      totalItems = make_shared<long>(boost::any_cast<long>(m["TotalItems"]));
    }
    if (m.find("TotalPages") != m.end() && !m["TotalPages"].empty()) {
      totalPages = make_shared<long>(boost::any_cast<long>(m["TotalPages"]));
    }
  }


  virtual ~DescribeDohSubDomainStatisticsSummaryResponseBody() = default;
};
class DescribeDohSubDomainStatisticsSummaryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDohSubDomainStatisticsSummaryResponseBody> body{};

  DescribeDohSubDomainStatisticsSummaryResponse() {}

  explicit DescribeDohSubDomainStatisticsSummaryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDohSubDomainStatisticsSummaryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDohSubDomainStatisticsSummaryResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDohSubDomainStatisticsSummaryResponse() = default;
};
class DescribeDohUserInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> endDate{};
  shared_ptr<string> lang{};
  shared_ptr<string> startDate{};

  DescribeDohUserInfoRequest() {}

  explicit DescribeDohUserInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
  }


  virtual ~DescribeDohUserInfoRequest() = default;
};
class DescribeDohUserInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> domainCount{};
  shared_ptr<long> pdnsId{};
  shared_ptr<string> requestId{};
  shared_ptr<long> subDomainCount{};

  DescribeDohUserInfoResponseBody() {}

  explicit DescribeDohUserInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainCount) {
      res["DomainCount"] = boost::any(*domainCount);
    }
    if (pdnsId) {
      res["PdnsId"] = boost::any(*pdnsId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subDomainCount) {
      res["SubDomainCount"] = boost::any(*subDomainCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainCount") != m.end() && !m["DomainCount"].empty()) {
      domainCount = make_shared<long>(boost::any_cast<long>(m["DomainCount"]));
    }
    if (m.find("PdnsId") != m.end() && !m["PdnsId"].empty()) {
      pdnsId = make_shared<long>(boost::any_cast<long>(m["PdnsId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubDomainCount") != m.end() && !m["SubDomainCount"].empty()) {
      subDomainCount = make_shared<long>(boost::any_cast<long>(m["SubDomainCount"]));
    }
  }


  virtual ~DescribeDohUserInfoResponseBody() = default;
};
class DescribeDohUserInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDohUserInfoResponseBody> body{};

  DescribeDohUserInfoResponse() {}

  explicit DescribeDohUserInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDohUserInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDohUserInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDohUserInfoResponse() = default;
};
class DescribeDomainDnssecInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> lang{};

  DescribeDomainDnssecInfoRequest() {}

  explicit DescribeDomainDnssecInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~DescribeDomainDnssecInfoRequest() = default;
};
class DescribeDomainDnssecInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> algorithm{};
  shared_ptr<string> digest{};
  shared_ptr<string> digestType{};
  shared_ptr<string> domainName{};
  shared_ptr<string> dsRecord{};
  shared_ptr<string> flags{};
  shared_ptr<string> keyTag{};
  shared_ptr<string> publicKey{};
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};

  DescribeDomainDnssecInfoResponseBody() {}

  explicit DescribeDomainDnssecInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (algorithm) {
      res["Algorithm"] = boost::any(*algorithm);
    }
    if (digest) {
      res["Digest"] = boost::any(*digest);
    }
    if (digestType) {
      res["DigestType"] = boost::any(*digestType);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (dsRecord) {
      res["DsRecord"] = boost::any(*dsRecord);
    }
    if (flags) {
      res["Flags"] = boost::any(*flags);
    }
    if (keyTag) {
      res["KeyTag"] = boost::any(*keyTag);
    }
    if (publicKey) {
      res["PublicKey"] = boost::any(*publicKey);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Algorithm") != m.end() && !m["Algorithm"].empty()) {
      algorithm = make_shared<string>(boost::any_cast<string>(m["Algorithm"]));
    }
    if (m.find("Digest") != m.end() && !m["Digest"].empty()) {
      digest = make_shared<string>(boost::any_cast<string>(m["Digest"]));
    }
    if (m.find("DigestType") != m.end() && !m["DigestType"].empty()) {
      digestType = make_shared<string>(boost::any_cast<string>(m["DigestType"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DsRecord") != m.end() && !m["DsRecord"].empty()) {
      dsRecord = make_shared<string>(boost::any_cast<string>(m["DsRecord"]));
    }
    if (m.find("Flags") != m.end() && !m["Flags"].empty()) {
      flags = make_shared<string>(boost::any_cast<string>(m["Flags"]));
    }
    if (m.find("KeyTag") != m.end() && !m["KeyTag"].empty()) {
      keyTag = make_shared<string>(boost::any_cast<string>(m["KeyTag"]));
    }
    if (m.find("PublicKey") != m.end() && !m["PublicKey"].empty()) {
      publicKey = make_shared<string>(boost::any_cast<string>(m["PublicKey"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDomainDnssecInfoResponseBody() = default;
};
class DescribeDomainDnssecInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainDnssecInfoResponseBody> body{};

  DescribeDomainDnssecInfoResponse() {}

  explicit DescribeDomainDnssecInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainDnssecInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainDnssecInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainDnssecInfoResponse() = default;
};
class DescribeDomainGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> keyWord{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeDomainGroupsRequest() {}

  explicit DescribeDomainGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyWord) {
      res["KeyWord"] = boost::any(*keyWord);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("KeyWord") != m.end() && !m["KeyWord"].empty()) {
      keyWord = make_shared<string>(boost::any_cast<string>(m["KeyWord"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeDomainGroupsRequest() = default;
};
class DescribeDomainGroupsResponseBodyDomainGroupsDomainGroup : public Darabonba::Model {
public:
  shared_ptr<long> domainCount{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};

  DescribeDomainGroupsResponseBodyDomainGroupsDomainGroup() {}

  explicit DescribeDomainGroupsResponseBodyDomainGroupsDomainGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainCount) {
      res["DomainCount"] = boost::any(*domainCount);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainCount") != m.end() && !m["DomainCount"].empty()) {
      domainCount = make_shared<long>(boost::any_cast<long>(m["DomainCount"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
  }


  virtual ~DescribeDomainGroupsResponseBodyDomainGroupsDomainGroup() = default;
};
class DescribeDomainGroupsResponseBodyDomainGroups : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainGroupsResponseBodyDomainGroupsDomainGroup>> domainGroup{};

  DescribeDomainGroupsResponseBodyDomainGroups() {}

  explicit DescribeDomainGroupsResponseBodyDomainGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainGroup) {
      vector<boost::any> temp1;
      for(auto item1:*domainGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainGroup"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainGroup") != m.end() && !m["DomainGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainGroup"].type()) {
        vector<DescribeDomainGroupsResponseBodyDomainGroupsDomainGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainGroupsResponseBodyDomainGroupsDomainGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainGroup = make_shared<vector<DescribeDomainGroupsResponseBodyDomainGroupsDomainGroup>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainGroupsResponseBodyDomainGroups() = default;
};
class DescribeDomainGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDomainGroupsResponseBodyDomainGroups> domainGroups{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeDomainGroupsResponseBody() {}

  explicit DescribeDomainGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainGroups) {
      res["DomainGroups"] = domainGroups ? boost::any(domainGroups->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainGroups") != m.end() && !m["DomainGroups"].empty()) {
      if (typeid(map<string, boost::any>) == m["DomainGroups"].type()) {
        DescribeDomainGroupsResponseBodyDomainGroups model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DomainGroups"]));
        domainGroups = make_shared<DescribeDomainGroupsResponseBodyDomainGroups>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDomainGroupsResponseBody() = default;
};
class DescribeDomainGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainGroupsResponseBody> body{};

  DescribeDomainGroupsResponse() {}

  explicit DescribeDomainGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainGroupsResponse() = default;
};
class DescribeDomainInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> lang{};
  shared_ptr<bool> needDetailAttributes{};

  DescribeDomainInfoRequest() {}

  explicit DescribeDomainInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (needDetailAttributes) {
      res["NeedDetailAttributes"] = boost::any(*needDetailAttributes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("NeedDetailAttributes") != m.end() && !m["NeedDetailAttributes"].empty()) {
      needDetailAttributes = make_shared<bool>(boost::any_cast<bool>(m["NeedDetailAttributes"]));
    }
  }


  virtual ~DescribeDomainInfoRequest() = default;
};
class DescribeDomainInfoResponseBodyAvailableTtls : public Darabonba::Model {
public:
  shared_ptr<vector<string>> availableTtl{};

  DescribeDomainInfoResponseBodyAvailableTtls() {}

  explicit DescribeDomainInfoResponseBodyAvailableTtls(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availableTtl) {
      res["AvailableTtl"] = boost::any(*availableTtl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvailableTtl") != m.end() && !m["AvailableTtl"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AvailableTtl"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AvailableTtl"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      availableTtl = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeDomainInfoResponseBodyAvailableTtls() = default;
};
class DescribeDomainInfoResponseBodyDnsServers : public Darabonba::Model {
public:
  shared_ptr<vector<string>> dnsServer{};

  DescribeDomainInfoResponseBodyDnsServers() {}

  explicit DescribeDomainInfoResponseBodyDnsServers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dnsServer) {
      res["DnsServer"] = boost::any(*dnsServer);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DnsServer") != m.end() && !m["DnsServer"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DnsServer"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DnsServer"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dnsServer = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeDomainInfoResponseBodyDnsServers() = default;
};
class DescribeDomainInfoResponseBodyRecordLinesRecordLine : public Darabonba::Model {
public:
  shared_ptr<string> fatherCode{};
  shared_ptr<string> lineCode{};
  shared_ptr<string> lineDisplayName{};
  shared_ptr<string> lineName{};

  DescribeDomainInfoResponseBodyRecordLinesRecordLine() {}

  explicit DescribeDomainInfoResponseBodyRecordLinesRecordLine(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fatherCode) {
      res["FatherCode"] = boost::any(*fatherCode);
    }
    if (lineCode) {
      res["LineCode"] = boost::any(*lineCode);
    }
    if (lineDisplayName) {
      res["LineDisplayName"] = boost::any(*lineDisplayName);
    }
    if (lineName) {
      res["LineName"] = boost::any(*lineName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FatherCode") != m.end() && !m["FatherCode"].empty()) {
      fatherCode = make_shared<string>(boost::any_cast<string>(m["FatherCode"]));
    }
    if (m.find("LineCode") != m.end() && !m["LineCode"].empty()) {
      lineCode = make_shared<string>(boost::any_cast<string>(m["LineCode"]));
    }
    if (m.find("LineDisplayName") != m.end() && !m["LineDisplayName"].empty()) {
      lineDisplayName = make_shared<string>(boost::any_cast<string>(m["LineDisplayName"]));
    }
    if (m.find("LineName") != m.end() && !m["LineName"].empty()) {
      lineName = make_shared<string>(boost::any_cast<string>(m["LineName"]));
    }
  }


  virtual ~DescribeDomainInfoResponseBodyRecordLinesRecordLine() = default;
};
class DescribeDomainInfoResponseBodyRecordLines : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainInfoResponseBodyRecordLinesRecordLine>> recordLine{};

  DescribeDomainInfoResponseBodyRecordLines() {}

  explicit DescribeDomainInfoResponseBodyRecordLines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recordLine) {
      vector<boost::any> temp1;
      for(auto item1:*recordLine){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RecordLine"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecordLine") != m.end() && !m["RecordLine"].empty()) {
      if (typeid(vector<boost::any>) == m["RecordLine"].type()) {
        vector<DescribeDomainInfoResponseBodyRecordLinesRecordLine> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RecordLine"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainInfoResponseBodyRecordLinesRecordLine model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recordLine = make_shared<vector<DescribeDomainInfoResponseBodyRecordLinesRecordLine>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainInfoResponseBodyRecordLines() = default;
};
class DescribeDomainInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> aliDomain{};
  shared_ptr<DescribeDomainInfoResponseBodyAvailableTtls> availableTtls{};
  shared_ptr<string> createTime{};
  shared_ptr<DescribeDomainInfoResponseBodyDnsServers> dnsServers{};
  shared_ptr<string> domainId{};
  shared_ptr<string> domainLoggingSwitchStatus{};
  shared_ptr<string> domainName{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<bool> inBlackHole{};
  shared_ptr<bool> inClean{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> lineType{};
  shared_ptr<long> minTtl{};
  shared_ptr<string> punyCode{};
  shared_ptr<string> recordLineTreeJson{};
  shared_ptr<DescribeDomainInfoResponseBodyRecordLines> recordLines{};
  shared_ptr<bool> regionLines{};
  shared_ptr<string> remark{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<bool> slaveDns{};
  shared_ptr<bool> subDomain{};
  shared_ptr<string> versionCode{};
  shared_ptr<string> versionName{};

  DescribeDomainInfoResponseBody() {}

  explicit DescribeDomainInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliDomain) {
      res["AliDomain"] = boost::any(*aliDomain);
    }
    if (availableTtls) {
      res["AvailableTtls"] = availableTtls ? boost::any(availableTtls->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dnsServers) {
      res["DnsServers"] = dnsServers ? boost::any(dnsServers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (domainId) {
      res["DomainId"] = boost::any(*domainId);
    }
    if (domainLoggingSwitchStatus) {
      res["DomainLoggingSwitchStatus"] = boost::any(*domainLoggingSwitchStatus);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (inBlackHole) {
      res["InBlackHole"] = boost::any(*inBlackHole);
    }
    if (inClean) {
      res["InClean"] = boost::any(*inClean);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lineType) {
      res["LineType"] = boost::any(*lineType);
    }
    if (minTtl) {
      res["MinTtl"] = boost::any(*minTtl);
    }
    if (punyCode) {
      res["PunyCode"] = boost::any(*punyCode);
    }
    if (recordLineTreeJson) {
      res["RecordLineTreeJson"] = boost::any(*recordLineTreeJson);
    }
    if (recordLines) {
      res["RecordLines"] = recordLines ? boost::any(recordLines->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (regionLines) {
      res["RegionLines"] = boost::any(*regionLines);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (slaveDns) {
      res["SlaveDns"] = boost::any(*slaveDns);
    }
    if (subDomain) {
      res["SubDomain"] = boost::any(*subDomain);
    }
    if (versionCode) {
      res["VersionCode"] = boost::any(*versionCode);
    }
    if (versionName) {
      res["VersionName"] = boost::any(*versionName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliDomain") != m.end() && !m["AliDomain"].empty()) {
      aliDomain = make_shared<bool>(boost::any_cast<bool>(m["AliDomain"]));
    }
    if (m.find("AvailableTtls") != m.end() && !m["AvailableTtls"].empty()) {
      if (typeid(map<string, boost::any>) == m["AvailableTtls"].type()) {
        DescribeDomainInfoResponseBodyAvailableTtls model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AvailableTtls"]));
        availableTtls = make_shared<DescribeDomainInfoResponseBodyAvailableTtls>(model1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DnsServers") != m.end() && !m["DnsServers"].empty()) {
      if (typeid(map<string, boost::any>) == m["DnsServers"].type()) {
        DescribeDomainInfoResponseBodyDnsServers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DnsServers"]));
        dnsServers = make_shared<DescribeDomainInfoResponseBodyDnsServers>(model1);
      }
    }
    if (m.find("DomainId") != m.end() && !m["DomainId"].empty()) {
      domainId = make_shared<string>(boost::any_cast<string>(m["DomainId"]));
    }
    if (m.find("DomainLoggingSwitchStatus") != m.end() && !m["DomainLoggingSwitchStatus"].empty()) {
      domainLoggingSwitchStatus = make_shared<string>(boost::any_cast<string>(m["DomainLoggingSwitchStatus"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("InBlackHole") != m.end() && !m["InBlackHole"].empty()) {
      inBlackHole = make_shared<bool>(boost::any_cast<bool>(m["InBlackHole"]));
    }
    if (m.find("InClean") != m.end() && !m["InClean"].empty()) {
      inClean = make_shared<bool>(boost::any_cast<bool>(m["InClean"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LineType") != m.end() && !m["LineType"].empty()) {
      lineType = make_shared<string>(boost::any_cast<string>(m["LineType"]));
    }
    if (m.find("MinTtl") != m.end() && !m["MinTtl"].empty()) {
      minTtl = make_shared<long>(boost::any_cast<long>(m["MinTtl"]));
    }
    if (m.find("PunyCode") != m.end() && !m["PunyCode"].empty()) {
      punyCode = make_shared<string>(boost::any_cast<string>(m["PunyCode"]));
    }
    if (m.find("RecordLineTreeJson") != m.end() && !m["RecordLineTreeJson"].empty()) {
      recordLineTreeJson = make_shared<string>(boost::any_cast<string>(m["RecordLineTreeJson"]));
    }
    if (m.find("RecordLines") != m.end() && !m["RecordLines"].empty()) {
      if (typeid(map<string, boost::any>) == m["RecordLines"].type()) {
        DescribeDomainInfoResponseBodyRecordLines model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RecordLines"]));
        recordLines = make_shared<DescribeDomainInfoResponseBodyRecordLines>(model1);
      }
    }
    if (m.find("RegionLines") != m.end() && !m["RegionLines"].empty()) {
      regionLines = make_shared<bool>(boost::any_cast<bool>(m["RegionLines"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SlaveDns") != m.end() && !m["SlaveDns"].empty()) {
      slaveDns = make_shared<bool>(boost::any_cast<bool>(m["SlaveDns"]));
    }
    if (m.find("SubDomain") != m.end() && !m["SubDomain"].empty()) {
      subDomain = make_shared<bool>(boost::any_cast<bool>(m["SubDomain"]));
    }
    if (m.find("VersionCode") != m.end() && !m["VersionCode"].empty()) {
      versionCode = make_shared<string>(boost::any_cast<string>(m["VersionCode"]));
    }
    if (m.find("VersionName") != m.end() && !m["VersionName"].empty()) {
      versionName = make_shared<string>(boost::any_cast<string>(m["VersionName"]));
    }
  }


  virtual ~DescribeDomainInfoResponseBody() = default;
};
class DescribeDomainInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainInfoResponseBody> body{};

  DescribeDomainInfoResponse() {}

  explicit DescribeDomainInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainInfoResponse() = default;
};
class DescribeDomainLogsRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> keyWord{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> startDate{};
  shared_ptr<string> type{};
  shared_ptr<string> endDate{};

  DescribeDomainLogsRequest() {}

  explicit DescribeDomainLogsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (keyWord) {
      res["KeyWord"] = boost::any(*keyWord);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (endDate) {
      res["endDate"] = boost::any(*endDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("KeyWord") != m.end() && !m["KeyWord"].empty()) {
      keyWord = make_shared<string>(boost::any_cast<string>(m["KeyWord"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("endDate") != m.end() && !m["endDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["endDate"]));
    }
  }


  virtual ~DescribeDomainLogsRequest() = default;
};
class DescribeDomainLogsResponseBodyDomainLogsDomainLog : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> actionTime{};
  shared_ptr<long> actionTimestamp{};
  shared_ptr<string> clientIp{};
  shared_ptr<string> domainName{};
  shared_ptr<string> message{};
  shared_ptr<string> zoneId{};

  DescribeDomainLogsResponseBodyDomainLogsDomainLog() {}

  explicit DescribeDomainLogsResponseBodyDomainLogsDomainLog(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (actionTime) {
      res["ActionTime"] = boost::any(*actionTime);
    }
    if (actionTimestamp) {
      res["ActionTimestamp"] = boost::any(*actionTimestamp);
    }
    if (clientIp) {
      res["ClientIp"] = boost::any(*clientIp);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("ActionTime") != m.end() && !m["ActionTime"].empty()) {
      actionTime = make_shared<string>(boost::any_cast<string>(m["ActionTime"]));
    }
    if (m.find("ActionTimestamp") != m.end() && !m["ActionTimestamp"].empty()) {
      actionTimestamp = make_shared<long>(boost::any_cast<long>(m["ActionTimestamp"]));
    }
    if (m.find("ClientIp") != m.end() && !m["ClientIp"].empty()) {
      clientIp = make_shared<string>(boost::any_cast<string>(m["ClientIp"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeDomainLogsResponseBodyDomainLogsDomainLog() = default;
};
class DescribeDomainLogsResponseBodyDomainLogs : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainLogsResponseBodyDomainLogsDomainLog>> domainLog{};

  DescribeDomainLogsResponseBodyDomainLogs() {}

  explicit DescribeDomainLogsResponseBodyDomainLogs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainLog) {
      vector<boost::any> temp1;
      for(auto item1:*domainLog){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainLog"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainLog") != m.end() && !m["DomainLog"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainLog"].type()) {
        vector<DescribeDomainLogsResponseBodyDomainLogsDomainLog> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainLog"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainLogsResponseBodyDomainLogsDomainLog model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainLog = make_shared<vector<DescribeDomainLogsResponseBodyDomainLogsDomainLog>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainLogsResponseBodyDomainLogs() = default;
};
class DescribeDomainLogsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDomainLogsResponseBodyDomainLogs> domainLogs{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeDomainLogsResponseBody() {}

  explicit DescribeDomainLogsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainLogs) {
      res["DomainLogs"] = domainLogs ? boost::any(domainLogs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainLogs") != m.end() && !m["DomainLogs"].empty()) {
      if (typeid(map<string, boost::any>) == m["DomainLogs"].type()) {
        DescribeDomainLogsResponseBodyDomainLogs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DomainLogs"]));
        domainLogs = make_shared<DescribeDomainLogsResponseBodyDomainLogs>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDomainLogsResponseBody() = default;
};
class DescribeDomainLogsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainLogsResponseBody> body{};

  DescribeDomainLogsResponse() {}

  explicit DescribeDomainLogsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainLogsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainLogsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainLogsResponse() = default;
};
class DescribeDomainNsRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> lang{};

  DescribeDomainNsRequest() {}

  explicit DescribeDomainNsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~DescribeDomainNsRequest() = default;
};
class DescribeDomainNsResponseBodyDnsServers : public Darabonba::Model {
public:
  shared_ptr<vector<string>> dnsServer{};

  DescribeDomainNsResponseBodyDnsServers() {}

  explicit DescribeDomainNsResponseBodyDnsServers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dnsServer) {
      res["DnsServer"] = boost::any(*dnsServer);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DnsServer") != m.end() && !m["DnsServer"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DnsServer"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DnsServer"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dnsServer = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeDomainNsResponseBodyDnsServers() = default;
};
class DescribeDomainNsResponseBodyExpectDnsServers : public Darabonba::Model {
public:
  shared_ptr<vector<string>> expectDnsServer{};

  DescribeDomainNsResponseBodyExpectDnsServers() {}

  explicit DescribeDomainNsResponseBodyExpectDnsServers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expectDnsServer) {
      res["ExpectDnsServer"] = boost::any(*expectDnsServer);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExpectDnsServer") != m.end() && !m["ExpectDnsServer"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ExpectDnsServer"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExpectDnsServer"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      expectDnsServer = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeDomainNsResponseBodyExpectDnsServers() = default;
};
class DescribeDomainNsResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> allAliDns{};
  shared_ptr<string> detectFailedReasonCode{};
  shared_ptr<DescribeDomainNsResponseBodyDnsServers> dnsServers{};
  shared_ptr<DescribeDomainNsResponseBodyExpectDnsServers> expectDnsServers{};
  shared_ptr<bool> includeAliDns{};
  shared_ptr<string> requestId{};

  DescribeDomainNsResponseBody() {}

  explicit DescribeDomainNsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allAliDns) {
      res["AllAliDns"] = boost::any(*allAliDns);
    }
    if (detectFailedReasonCode) {
      res["DetectFailedReasonCode"] = boost::any(*detectFailedReasonCode);
    }
    if (dnsServers) {
      res["DnsServers"] = dnsServers ? boost::any(dnsServers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (expectDnsServers) {
      res["ExpectDnsServers"] = expectDnsServers ? boost::any(expectDnsServers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (includeAliDns) {
      res["IncludeAliDns"] = boost::any(*includeAliDns);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllAliDns") != m.end() && !m["AllAliDns"].empty()) {
      allAliDns = make_shared<bool>(boost::any_cast<bool>(m["AllAliDns"]));
    }
    if (m.find("DetectFailedReasonCode") != m.end() && !m["DetectFailedReasonCode"].empty()) {
      detectFailedReasonCode = make_shared<string>(boost::any_cast<string>(m["DetectFailedReasonCode"]));
    }
    if (m.find("DnsServers") != m.end() && !m["DnsServers"].empty()) {
      if (typeid(map<string, boost::any>) == m["DnsServers"].type()) {
        DescribeDomainNsResponseBodyDnsServers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DnsServers"]));
        dnsServers = make_shared<DescribeDomainNsResponseBodyDnsServers>(model1);
      }
    }
    if (m.find("ExpectDnsServers") != m.end() && !m["ExpectDnsServers"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExpectDnsServers"].type()) {
        DescribeDomainNsResponseBodyExpectDnsServers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExpectDnsServers"]));
        expectDnsServers = make_shared<DescribeDomainNsResponseBodyExpectDnsServers>(model1);
      }
    }
    if (m.find("IncludeAliDns") != m.end() && !m["IncludeAliDns"].empty()) {
      includeAliDns = make_shared<bool>(boost::any_cast<bool>(m["IncludeAliDns"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDomainNsResponseBody() = default;
};
class DescribeDomainNsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainNsResponseBody> body{};

  DescribeDomainNsResponse() {}

  explicit DescribeDomainNsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainNsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainNsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainNsResponse() = default;
};
class DescribeDomainRecordInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> recordId{};
  shared_ptr<string> userClientIp{};

  DescribeDomainRecordInfoRequest() {}

  explicit DescribeDomainRecordInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (userClientIp) {
      res["UserClientIp"] = boost::any(*userClientIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<string>(boost::any_cast<string>(m["RecordId"]));
    }
    if (m.find("UserClientIp") != m.end() && !m["UserClientIp"].empty()) {
      userClientIp = make_shared<string>(boost::any_cast<string>(m["UserClientIp"]));
    }
  }


  virtual ~DescribeDomainRecordInfoRequest() = default;
};
class DescribeDomainRecordInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> domainId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> line{};
  shared_ptr<bool> locked{};
  shared_ptr<long> priority{};
  shared_ptr<string> punyCode{};
  shared_ptr<string> RR{};
  shared_ptr<string> recordId{};
  shared_ptr<string> remark{};
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};
  shared_ptr<long> TTL{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  DescribeDomainRecordInfoResponseBody() {}

  explicit DescribeDomainRecordInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainId) {
      res["DomainId"] = boost::any(*domainId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (line) {
      res["Line"] = boost::any(*line);
    }
    if (locked) {
      res["Locked"] = boost::any(*locked);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (punyCode) {
      res["PunyCode"] = boost::any(*punyCode);
    }
    if (RR) {
      res["RR"] = boost::any(*RR);
    }
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (TTL) {
      res["TTL"] = boost::any(*TTL);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainId") != m.end() && !m["DomainId"].empty()) {
      domainId = make_shared<string>(boost::any_cast<string>(m["DomainId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Line") != m.end() && !m["Line"].empty()) {
      line = make_shared<string>(boost::any_cast<string>(m["Line"]));
    }
    if (m.find("Locked") != m.end() && !m["Locked"].empty()) {
      locked = make_shared<bool>(boost::any_cast<bool>(m["Locked"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("PunyCode") != m.end() && !m["PunyCode"].empty()) {
      punyCode = make_shared<string>(boost::any_cast<string>(m["PunyCode"]));
    }
    if (m.find("RR") != m.end() && !m["RR"].empty()) {
      RR = make_shared<string>(boost::any_cast<string>(m["RR"]));
    }
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<string>(boost::any_cast<string>(m["RecordId"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TTL") != m.end() && !m["TTL"].empty()) {
      TTL = make_shared<long>(boost::any_cast<long>(m["TTL"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDomainRecordInfoResponseBody() = default;
};
class DescribeDomainRecordInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainRecordInfoResponseBody> body{};

  DescribeDomainRecordInfoResponse() {}

  explicit DescribeDomainRecordInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainRecordInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainRecordInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainRecordInfoResponse() = default;
};
class DescribeDomainRecordsRequest : public Darabonba::Model {
public:
  shared_ptr<string> direction{};
  shared_ptr<string> domainName{};
  shared_ptr<long> groupId{};
  shared_ptr<string> keyWord{};
  shared_ptr<string> lang{};
  shared_ptr<string> line{};
  shared_ptr<string> orderBy{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> RRKeyWord{};
  shared_ptr<string> searchMode{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};
  shared_ptr<string> typeKeyWord{};
  shared_ptr<string> valueKeyWord{};

  DescribeDomainRecordsRequest() {}

  explicit DescribeDomainRecordsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (direction) {
      res["Direction"] = boost::any(*direction);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (keyWord) {
      res["KeyWord"] = boost::any(*keyWord);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (line) {
      res["Line"] = boost::any(*line);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (RRKeyWord) {
      res["RRKeyWord"] = boost::any(*RRKeyWord);
    }
    if (searchMode) {
      res["SearchMode"] = boost::any(*searchMode);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (typeKeyWord) {
      res["TypeKeyWord"] = boost::any(*typeKeyWord);
    }
    if (valueKeyWord) {
      res["ValueKeyWord"] = boost::any(*valueKeyWord);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Direction") != m.end() && !m["Direction"].empty()) {
      direction = make_shared<string>(boost::any_cast<string>(m["Direction"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("KeyWord") != m.end() && !m["KeyWord"].empty()) {
      keyWord = make_shared<string>(boost::any_cast<string>(m["KeyWord"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Line") != m.end() && !m["Line"].empty()) {
      line = make_shared<string>(boost::any_cast<string>(m["Line"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RRKeyWord") != m.end() && !m["RRKeyWord"].empty()) {
      RRKeyWord = make_shared<string>(boost::any_cast<string>(m["RRKeyWord"]));
    }
    if (m.find("SearchMode") != m.end() && !m["SearchMode"].empty()) {
      searchMode = make_shared<string>(boost::any_cast<string>(m["SearchMode"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("TypeKeyWord") != m.end() && !m["TypeKeyWord"].empty()) {
      typeKeyWord = make_shared<string>(boost::any_cast<string>(m["TypeKeyWord"]));
    }
    if (m.find("ValueKeyWord") != m.end() && !m["ValueKeyWord"].empty()) {
      valueKeyWord = make_shared<string>(boost::any_cast<string>(m["ValueKeyWord"]));
    }
  }


  virtual ~DescribeDomainRecordsRequest() = default;
};
class DescribeDomainRecordsResponseBodyDomainRecordsRecord : public Darabonba::Model {
public:
  shared_ptr<long> createTimestamp{};
  shared_ptr<string> domainName{};
  shared_ptr<string> line{};
  shared_ptr<bool> locked{};
  shared_ptr<long> priority{};
  shared_ptr<string> RR{};
  shared_ptr<string> recordId{};
  shared_ptr<string> remark{};
  shared_ptr<string> status{};
  shared_ptr<long> TTL{};
  shared_ptr<string> type{};
  shared_ptr<long> updateTimestamp{};
  shared_ptr<string> value{};
  shared_ptr<long> weight{};

  DescribeDomainRecordsResponseBodyDomainRecordsRecord() {}

  explicit DescribeDomainRecordsResponseBodyDomainRecordsRecord(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (line) {
      res["Line"] = boost::any(*line);
    }
    if (locked) {
      res["Locked"] = boost::any(*locked);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (RR) {
      res["RR"] = boost::any(*RR);
    }
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (TTL) {
      res["TTL"] = boost::any(*TTL);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (updateTimestamp) {
      res["UpdateTimestamp"] = boost::any(*updateTimestamp);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Line") != m.end() && !m["Line"].empty()) {
      line = make_shared<string>(boost::any_cast<string>(m["Line"]));
    }
    if (m.find("Locked") != m.end() && !m["Locked"].empty()) {
      locked = make_shared<bool>(boost::any_cast<bool>(m["Locked"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("RR") != m.end() && !m["RR"].empty()) {
      RR = make_shared<string>(boost::any_cast<string>(m["RR"]));
    }
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<string>(boost::any_cast<string>(m["RecordId"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TTL") != m.end() && !m["TTL"].empty()) {
      TTL = make_shared<long>(boost::any_cast<long>(m["TTL"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UpdateTimestamp") != m.end() && !m["UpdateTimestamp"].empty()) {
      updateTimestamp = make_shared<long>(boost::any_cast<long>(m["UpdateTimestamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~DescribeDomainRecordsResponseBodyDomainRecordsRecord() = default;
};
class DescribeDomainRecordsResponseBodyDomainRecords : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainRecordsResponseBodyDomainRecordsRecord>> record{};

  DescribeDomainRecordsResponseBodyDomainRecords() {}

  explicit DescribeDomainRecordsResponseBodyDomainRecords(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (record) {
      vector<boost::any> temp1;
      for(auto item1:*record){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Record"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Record") != m.end() && !m["Record"].empty()) {
      if (typeid(vector<boost::any>) == m["Record"].type()) {
        vector<DescribeDomainRecordsResponseBodyDomainRecordsRecord> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Record"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainRecordsResponseBodyDomainRecordsRecord model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        record = make_shared<vector<DescribeDomainRecordsResponseBodyDomainRecordsRecord>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainRecordsResponseBodyDomainRecords() = default;
};
class DescribeDomainRecordsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDomainRecordsResponseBodyDomainRecords> domainRecords{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeDomainRecordsResponseBody() {}

  explicit DescribeDomainRecordsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainRecords) {
      res["DomainRecords"] = domainRecords ? boost::any(domainRecords->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainRecords") != m.end() && !m["DomainRecords"].empty()) {
      if (typeid(map<string, boost::any>) == m["DomainRecords"].type()) {
        DescribeDomainRecordsResponseBodyDomainRecords model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DomainRecords"]));
        domainRecords = make_shared<DescribeDomainRecordsResponseBodyDomainRecords>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDomainRecordsResponseBody() = default;
};
class DescribeDomainRecordsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainRecordsResponseBody> body{};

  DescribeDomainRecordsResponse() {}

  explicit DescribeDomainRecordsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainRecordsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainRecordsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainRecordsResponse() = default;
};
class DescribeDomainResolveStatisticsSummaryRequest : public Darabonba::Model {
public:
  shared_ptr<string> direction{};
  shared_ptr<string> endDate{};
  shared_ptr<string> keyword{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchMode{};
  shared_ptr<string> startDate{};
  shared_ptr<long> threshold{};

  DescribeDomainResolveStatisticsSummaryRequest() {}

  explicit DescribeDomainResolveStatisticsSummaryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (direction) {
      res["Direction"] = boost::any(*direction);
    }
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchMode) {
      res["SearchMode"] = boost::any(*searchMode);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Direction") != m.end() && !m["Direction"].empty()) {
      direction = make_shared<string>(boost::any_cast<string>(m["Direction"]));
    }
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchMode") != m.end() && !m["SearchMode"].empty()) {
      searchMode = make_shared<string>(boost::any_cast<string>(m["SearchMode"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<long>(boost::any_cast<long>(m["Threshold"]));
    }
  }


  virtual ~DescribeDomainResolveStatisticsSummaryRequest() = default;
};
class DescribeDomainResolveStatisticsSummaryResponseBodyStatistics : public Darabonba::Model {
public:
  shared_ptr<string> count{};
  shared_ptr<string> domainName{};
  shared_ptr<string> domainType{};

  DescribeDomainResolveStatisticsSummaryResponseBodyStatistics() {}

  explicit DescribeDomainResolveStatisticsSummaryResponseBodyStatistics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainType) {
      res["DomainType"] = boost::any(*domainType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<string>(boost::any_cast<string>(m["Count"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainType") != m.end() && !m["DomainType"].empty()) {
      domainType = make_shared<string>(boost::any_cast<string>(m["DomainType"]));
    }
  }


  virtual ~DescribeDomainResolveStatisticsSummaryResponseBodyStatistics() = default;
};
class DescribeDomainResolveStatisticsSummaryResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeDomainResolveStatisticsSummaryResponseBodyStatistics>> statistics{};
  shared_ptr<long> totalItems{};
  shared_ptr<long> totalPages{};

  DescribeDomainResolveStatisticsSummaryResponseBody() {}

  explicit DescribeDomainResolveStatisticsSummaryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (statistics) {
      vector<boost::any> temp1;
      for(auto item1:*statistics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Statistics"] = boost::any(temp1);
    }
    if (totalItems) {
      res["TotalItems"] = boost::any(*totalItems);
    }
    if (totalPages) {
      res["TotalPages"] = boost::any(*totalPages);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      if (typeid(vector<boost::any>) == m["Statistics"].type()) {
        vector<DescribeDomainResolveStatisticsSummaryResponseBodyStatistics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Statistics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainResolveStatisticsSummaryResponseBodyStatistics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        statistics = make_shared<vector<DescribeDomainResolveStatisticsSummaryResponseBodyStatistics>>(expect1);
      }
    }
    if (m.find("TotalItems") != m.end() && !m["TotalItems"].empty()) {
      totalItems = make_shared<long>(boost::any_cast<long>(m["TotalItems"]));
    }
    if (m.find("TotalPages") != m.end() && !m["TotalPages"].empty()) {
      totalPages = make_shared<long>(boost::any_cast<long>(m["TotalPages"]));
    }
  }


  virtual ~DescribeDomainResolveStatisticsSummaryResponseBody() = default;
};
class DescribeDomainResolveStatisticsSummaryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainResolveStatisticsSummaryResponseBody> body{};

  DescribeDomainResolveStatisticsSummaryResponse() {}

  explicit DescribeDomainResolveStatisticsSummaryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainResolveStatisticsSummaryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainResolveStatisticsSummaryResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainResolveStatisticsSummaryResponse() = default;
};
class DescribeDomainStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> domainType{};
  shared_ptr<string> endDate{};
  shared_ptr<string> lang{};
  shared_ptr<string> startDate{};

  DescribeDomainStatisticsRequest() {}

  explicit DescribeDomainStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainType) {
      res["DomainType"] = boost::any(*domainType);
    }
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainType") != m.end() && !m["DomainType"].empty()) {
      domainType = make_shared<string>(boost::any_cast<string>(m["DomainType"]));
    }
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
  }


  virtual ~DescribeDomainStatisticsRequest() = default;
};
class DescribeDomainStatisticsResponseBodyStatisticsStatistic : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> domainName{};
  shared_ptr<long> timestamp{};

  DescribeDomainStatisticsResponseBodyStatisticsStatistic() {}

  explicit DescribeDomainStatisticsResponseBodyStatisticsStatistic(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
  }


  virtual ~DescribeDomainStatisticsResponseBodyStatisticsStatistic() = default;
};
class DescribeDomainStatisticsResponseBodyStatistics : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainStatisticsResponseBodyStatisticsStatistic>> statistic{};

  DescribeDomainStatisticsResponseBodyStatistics() {}

  explicit DescribeDomainStatisticsResponseBodyStatistics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (statistic) {
      vector<boost::any> temp1;
      for(auto item1:*statistic){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Statistic"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Statistic") != m.end() && !m["Statistic"].empty()) {
      if (typeid(vector<boost::any>) == m["Statistic"].type()) {
        vector<DescribeDomainStatisticsResponseBodyStatisticsStatistic> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Statistic"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainStatisticsResponseBodyStatisticsStatistic model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        statistic = make_shared<vector<DescribeDomainStatisticsResponseBodyStatisticsStatistic>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainStatisticsResponseBodyStatistics() = default;
};
class DescribeDomainStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDomainStatisticsResponseBodyStatistics> statistics{};

  DescribeDomainStatisticsResponseBody() {}

  explicit DescribeDomainStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (statistics) {
      res["Statistics"] = statistics ? boost::any(statistics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      if (typeid(map<string, boost::any>) == m["Statistics"].type()) {
        DescribeDomainStatisticsResponseBodyStatistics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Statistics"]));
        statistics = make_shared<DescribeDomainStatisticsResponseBodyStatistics>(model1);
      }
    }
  }


  virtual ~DescribeDomainStatisticsResponseBody() = default;
};
class DescribeDomainStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainStatisticsResponseBody> body{};

  DescribeDomainStatisticsResponse() {}

  explicit DescribeDomainStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainStatisticsResponse() = default;
};
class DescribeDomainStatisticsSummaryRequest : public Darabonba::Model {
public:
  shared_ptr<string> endDate{};
  shared_ptr<string> keyword{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchMode{};
  shared_ptr<string> startDate{};
  shared_ptr<long> threshold{};

  DescribeDomainStatisticsSummaryRequest() {}

  explicit DescribeDomainStatisticsSummaryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchMode) {
      res["SearchMode"] = boost::any(*searchMode);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchMode") != m.end() && !m["SearchMode"].empty()) {
      searchMode = make_shared<string>(boost::any_cast<string>(m["SearchMode"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<long>(boost::any_cast<long>(m["Threshold"]));
    }
  }


  virtual ~DescribeDomainStatisticsSummaryRequest() = default;
};
class DescribeDomainStatisticsSummaryResponseBodyStatisticsStatistic : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> domainName{};
  shared_ptr<string> domainType{};
  shared_ptr<string> resolveAnalysisStatus{};

  DescribeDomainStatisticsSummaryResponseBodyStatisticsStatistic() {}

  explicit DescribeDomainStatisticsSummaryResponseBodyStatisticsStatistic(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainType) {
      res["DomainType"] = boost::any(*domainType);
    }
    if (resolveAnalysisStatus) {
      res["resolveAnalysisStatus"] = boost::any(*resolveAnalysisStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainType") != m.end() && !m["DomainType"].empty()) {
      domainType = make_shared<string>(boost::any_cast<string>(m["DomainType"]));
    }
    if (m.find("resolveAnalysisStatus") != m.end() && !m["resolveAnalysisStatus"].empty()) {
      resolveAnalysisStatus = make_shared<string>(boost::any_cast<string>(m["resolveAnalysisStatus"]));
    }
  }


  virtual ~DescribeDomainStatisticsSummaryResponseBodyStatisticsStatistic() = default;
};
class DescribeDomainStatisticsSummaryResponseBodyStatistics : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainStatisticsSummaryResponseBodyStatisticsStatistic>> statistic{};

  DescribeDomainStatisticsSummaryResponseBodyStatistics() {}

  explicit DescribeDomainStatisticsSummaryResponseBodyStatistics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (statistic) {
      vector<boost::any> temp1;
      for(auto item1:*statistic){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Statistic"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Statistic") != m.end() && !m["Statistic"].empty()) {
      if (typeid(vector<boost::any>) == m["Statistic"].type()) {
        vector<DescribeDomainStatisticsSummaryResponseBodyStatisticsStatistic> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Statistic"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainStatisticsSummaryResponseBodyStatisticsStatistic model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        statistic = make_shared<vector<DescribeDomainStatisticsSummaryResponseBodyStatisticsStatistic>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainStatisticsSummaryResponseBodyStatistics() = default;
};
class DescribeDomainStatisticsSummaryResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDomainStatisticsSummaryResponseBodyStatistics> statistics{};
  shared_ptr<long> totalItems{};
  shared_ptr<long> totalPages{};

  DescribeDomainStatisticsSummaryResponseBody() {}

  explicit DescribeDomainStatisticsSummaryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (statistics) {
      res["Statistics"] = statistics ? boost::any(statistics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalItems) {
      res["TotalItems"] = boost::any(*totalItems);
    }
    if (totalPages) {
      res["TotalPages"] = boost::any(*totalPages);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      if (typeid(map<string, boost::any>) == m["Statistics"].type()) {
        DescribeDomainStatisticsSummaryResponseBodyStatistics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Statistics"]));
        statistics = make_shared<DescribeDomainStatisticsSummaryResponseBodyStatistics>(model1);
      }
    }
    if (m.find("TotalItems") != m.end() && !m["TotalItems"].empty()) {
      totalItems = make_shared<long>(boost::any_cast<long>(m["TotalItems"]));
    }
    if (m.find("TotalPages") != m.end() && !m["TotalPages"].empty()) {
      totalPages = make_shared<long>(boost::any_cast<long>(m["TotalPages"]));
    }
  }


  virtual ~DescribeDomainStatisticsSummaryResponseBody() = default;
};
class DescribeDomainStatisticsSummaryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainStatisticsSummaryResponseBody> body{};

  DescribeDomainStatisticsSummaryResponse() {}

  explicit DescribeDomainStatisticsSummaryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainStatisticsSummaryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainStatisticsSummaryResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainStatisticsSummaryResponse() = default;
};
class DescribeDomainsRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> keyWord{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> searchMode{};
  shared_ptr<bool> starmark{};

  DescribeDomainsRequest() {}

  explicit DescribeDomainsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (keyWord) {
      res["KeyWord"] = boost::any(*keyWord);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (searchMode) {
      res["SearchMode"] = boost::any(*searchMode);
    }
    if (starmark) {
      res["Starmark"] = boost::any(*starmark);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("KeyWord") != m.end() && !m["KeyWord"].empty()) {
      keyWord = make_shared<string>(boost::any_cast<string>(m["KeyWord"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SearchMode") != m.end() && !m["SearchMode"].empty()) {
      searchMode = make_shared<string>(boost::any_cast<string>(m["SearchMode"]));
    }
    if (m.find("Starmark") != m.end() && !m["Starmark"].empty()) {
      starmark = make_shared<bool>(boost::any_cast<bool>(m["Starmark"]));
    }
  }


  virtual ~DescribeDomainsRequest() = default;
};
class DescribeDomainsResponseBodyDomainsDomainDnsServers : public Darabonba::Model {
public:
  shared_ptr<vector<string>> dnsServer{};

  DescribeDomainsResponseBodyDomainsDomainDnsServers() {}

  explicit DescribeDomainsResponseBodyDomainsDomainDnsServers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dnsServer) {
      res["DnsServer"] = boost::any(*dnsServer);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DnsServer") != m.end() && !m["DnsServer"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DnsServer"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DnsServer"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dnsServer = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeDomainsResponseBodyDomainsDomainDnsServers() = default;
};
class DescribeDomainsResponseBodyDomainsDomainTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeDomainsResponseBodyDomainsDomainTagsTag() {}

  explicit DescribeDomainsResponseBodyDomainsDomainTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDomainsResponseBodyDomainsDomainTagsTag() = default;
};
class DescribeDomainsResponseBodyDomainsDomainTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainsResponseBodyDomainsDomainTagsTag>> tag{};

  DescribeDomainsResponseBodyDomainsDomainTags() {}

  explicit DescribeDomainsResponseBodyDomainsDomainTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeDomainsResponseBodyDomainsDomainTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainsResponseBodyDomainsDomainTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeDomainsResponseBodyDomainsDomainTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainsResponseBodyDomainsDomainTags() = default;
};
class DescribeDomainsResponseBodyDomainsDomain : public Darabonba::Model {
public:
  shared_ptr<bool> aliDomain{};
  shared_ptr<string> createTime{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<DescribeDomainsResponseBodyDomainsDomainDnsServers> dnsServers{};
  shared_ptr<string> domainId{};
  shared_ptr<string> domainLoggingSwitchStatus{};
  shared_ptr<string> domainName{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> instanceEndTime{};
  shared_ptr<bool> instanceExpired{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> punyCode{};
  shared_ptr<long> recordCount{};
  shared_ptr<string> registrantEmail{};
  shared_ptr<string> remark{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<bool> starmark{};
  shared_ptr<DescribeDomainsResponseBodyDomainsDomainTags> tags{};
  shared_ptr<string> versionCode{};
  shared_ptr<string> versionName{};

  DescribeDomainsResponseBodyDomainsDomain() {}

  explicit DescribeDomainsResponseBodyDomainsDomain(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliDomain) {
      res["AliDomain"] = boost::any(*aliDomain);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (dnsServers) {
      res["DnsServers"] = dnsServers ? boost::any(dnsServers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (domainId) {
      res["DomainId"] = boost::any(*domainId);
    }
    if (domainLoggingSwitchStatus) {
      res["DomainLoggingSwitchStatus"] = boost::any(*domainLoggingSwitchStatus);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (instanceEndTime) {
      res["InstanceEndTime"] = boost::any(*instanceEndTime);
    }
    if (instanceExpired) {
      res["InstanceExpired"] = boost::any(*instanceExpired);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (punyCode) {
      res["PunyCode"] = boost::any(*punyCode);
    }
    if (recordCount) {
      res["RecordCount"] = boost::any(*recordCount);
    }
    if (registrantEmail) {
      res["RegistrantEmail"] = boost::any(*registrantEmail);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (starmark) {
      res["Starmark"] = boost::any(*starmark);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (versionCode) {
      res["VersionCode"] = boost::any(*versionCode);
    }
    if (versionName) {
      res["VersionName"] = boost::any(*versionName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliDomain") != m.end() && !m["AliDomain"].empty()) {
      aliDomain = make_shared<bool>(boost::any_cast<bool>(m["AliDomain"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("DnsServers") != m.end() && !m["DnsServers"].empty()) {
      if (typeid(map<string, boost::any>) == m["DnsServers"].type()) {
        DescribeDomainsResponseBodyDomainsDomainDnsServers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DnsServers"]));
        dnsServers = make_shared<DescribeDomainsResponseBodyDomainsDomainDnsServers>(model1);
      }
    }
    if (m.find("DomainId") != m.end() && !m["DomainId"].empty()) {
      domainId = make_shared<string>(boost::any_cast<string>(m["DomainId"]));
    }
    if (m.find("DomainLoggingSwitchStatus") != m.end() && !m["DomainLoggingSwitchStatus"].empty()) {
      domainLoggingSwitchStatus = make_shared<string>(boost::any_cast<string>(m["DomainLoggingSwitchStatus"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("InstanceEndTime") != m.end() && !m["InstanceEndTime"].empty()) {
      instanceEndTime = make_shared<string>(boost::any_cast<string>(m["InstanceEndTime"]));
    }
    if (m.find("InstanceExpired") != m.end() && !m["InstanceExpired"].empty()) {
      instanceExpired = make_shared<bool>(boost::any_cast<bool>(m["InstanceExpired"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PunyCode") != m.end() && !m["PunyCode"].empty()) {
      punyCode = make_shared<string>(boost::any_cast<string>(m["PunyCode"]));
    }
    if (m.find("RecordCount") != m.end() && !m["RecordCount"].empty()) {
      recordCount = make_shared<long>(boost::any_cast<long>(m["RecordCount"]));
    }
    if (m.find("RegistrantEmail") != m.end() && !m["RegistrantEmail"].empty()) {
      registrantEmail = make_shared<string>(boost::any_cast<string>(m["RegistrantEmail"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Starmark") != m.end() && !m["Starmark"].empty()) {
      starmark = make_shared<bool>(boost::any_cast<bool>(m["Starmark"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeDomainsResponseBodyDomainsDomainTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeDomainsResponseBodyDomainsDomainTags>(model1);
      }
    }
    if (m.find("VersionCode") != m.end() && !m["VersionCode"].empty()) {
      versionCode = make_shared<string>(boost::any_cast<string>(m["VersionCode"]));
    }
    if (m.find("VersionName") != m.end() && !m["VersionName"].empty()) {
      versionName = make_shared<string>(boost::any_cast<string>(m["VersionName"]));
    }
  }


  virtual ~DescribeDomainsResponseBodyDomainsDomain() = default;
};
class DescribeDomainsResponseBodyDomains : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainsResponseBodyDomainsDomain>> domain{};

  DescribeDomainsResponseBodyDomains() {}

  explicit DescribeDomainsResponseBodyDomains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      vector<boost::any> temp1;
      for(auto item1:*domain){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Domain"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      if (typeid(vector<boost::any>) == m["Domain"].type()) {
        vector<DescribeDomainsResponseBodyDomainsDomain> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Domain"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainsResponseBodyDomainsDomain model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domain = make_shared<vector<DescribeDomainsResponseBodyDomainsDomain>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainsResponseBodyDomains() = default;
};
class DescribeDomainsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDomainsResponseBodyDomains> domains{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeDomainsResponseBody() {}

  explicit DescribeDomainsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domains) {
      res["Domains"] = domains ? boost::any(domains->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domains") != m.end() && !m["Domains"].empty()) {
      if (typeid(map<string, boost::any>) == m["Domains"].type()) {
        DescribeDomainsResponseBodyDomains model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Domains"]));
        domains = make_shared<DescribeDomainsResponseBodyDomains>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDomainsResponseBody() = default;
};
class DescribeDomainsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainsResponseBody> body{};

  DescribeDomainsResponse() {}

  explicit DescribeDomainsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainsResponse() = default;
};
class DescribeGtmAccessStrategiesRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeGtmAccessStrategiesRequest() {}

  explicit DescribeGtmAccessStrategiesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeGtmAccessStrategiesRequest() = default;
};
class DescribeGtmAccessStrategiesResponseBodyStrategiesStrategyLinesLine : public Darabonba::Model {
public:
  shared_ptr<string> groupCode{};
  shared_ptr<string> groupName{};
  shared_ptr<string> lineCode{};
  shared_ptr<string> lineName{};

  DescribeGtmAccessStrategiesResponseBodyStrategiesStrategyLinesLine() {}

  explicit DescribeGtmAccessStrategiesResponseBodyStrategiesStrategyLinesLine(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupCode) {
      res["GroupCode"] = boost::any(*groupCode);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (lineCode) {
      res["LineCode"] = boost::any(*lineCode);
    }
    if (lineName) {
      res["LineName"] = boost::any(*lineName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupCode") != m.end() && !m["GroupCode"].empty()) {
      groupCode = make_shared<string>(boost::any_cast<string>(m["GroupCode"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("LineCode") != m.end() && !m["LineCode"].empty()) {
      lineCode = make_shared<string>(boost::any_cast<string>(m["LineCode"]));
    }
    if (m.find("LineName") != m.end() && !m["LineName"].empty()) {
      lineName = make_shared<string>(boost::any_cast<string>(m["LineName"]));
    }
  }


  virtual ~DescribeGtmAccessStrategiesResponseBodyStrategiesStrategyLinesLine() = default;
};
class DescribeGtmAccessStrategiesResponseBodyStrategiesStrategyLines : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeGtmAccessStrategiesResponseBodyStrategiesStrategyLinesLine>> line{};

  DescribeGtmAccessStrategiesResponseBodyStrategiesStrategyLines() {}

  explicit DescribeGtmAccessStrategiesResponseBodyStrategiesStrategyLines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (line) {
      vector<boost::any> temp1;
      for(auto item1:*line){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Line"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Line") != m.end() && !m["Line"].empty()) {
      if (typeid(vector<boost::any>) == m["Line"].type()) {
        vector<DescribeGtmAccessStrategiesResponseBodyStrategiesStrategyLinesLine> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Line"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGtmAccessStrategiesResponseBodyStrategiesStrategyLinesLine model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        line = make_shared<vector<DescribeGtmAccessStrategiesResponseBodyStrategiesStrategyLinesLine>>(expect1);
      }
    }
  }


  virtual ~DescribeGtmAccessStrategiesResponseBodyStrategiesStrategyLines() = default;
};
class DescribeGtmAccessStrategiesResponseBodyStrategiesStrategy : public Darabonba::Model {
public:
  shared_ptr<string> accessMode{};
  shared_ptr<string> accessStatus{};
  shared_ptr<string> createTime{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<string> defaultAddrPoolId{};
  shared_ptr<string> defaultAddrPoolMonitorStatus{};
  shared_ptr<string> defaultAddrPoolName{};
  shared_ptr<string> defaultAddrPoolStatus{};
  shared_ptr<string> failoverAddrPoolId{};
  shared_ptr<string> failoverAddrPoolMonitorStatus{};
  shared_ptr<string> failoverAddrPoolName{};
  shared_ptr<string> failoverAddrPoolStatus{};
  shared_ptr<string> instanceId{};
  shared_ptr<DescribeGtmAccessStrategiesResponseBodyStrategiesStrategyLines> lines{};
  shared_ptr<string> strategyId{};
  shared_ptr<string> strategyMode{};
  shared_ptr<string> strategyName{};

  DescribeGtmAccessStrategiesResponseBodyStrategiesStrategy() {}

  explicit DescribeGtmAccessStrategiesResponseBodyStrategiesStrategy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessMode) {
      res["AccessMode"] = boost::any(*accessMode);
    }
    if (accessStatus) {
      res["AccessStatus"] = boost::any(*accessStatus);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (defaultAddrPoolId) {
      res["DefaultAddrPoolId"] = boost::any(*defaultAddrPoolId);
    }
    if (defaultAddrPoolMonitorStatus) {
      res["DefaultAddrPoolMonitorStatus"] = boost::any(*defaultAddrPoolMonitorStatus);
    }
    if (defaultAddrPoolName) {
      res["DefaultAddrPoolName"] = boost::any(*defaultAddrPoolName);
    }
    if (defaultAddrPoolStatus) {
      res["DefaultAddrPoolStatus"] = boost::any(*defaultAddrPoolStatus);
    }
    if (failoverAddrPoolId) {
      res["FailoverAddrPoolId"] = boost::any(*failoverAddrPoolId);
    }
    if (failoverAddrPoolMonitorStatus) {
      res["FailoverAddrPoolMonitorStatus"] = boost::any(*failoverAddrPoolMonitorStatus);
    }
    if (failoverAddrPoolName) {
      res["FailoverAddrPoolName"] = boost::any(*failoverAddrPoolName);
    }
    if (failoverAddrPoolStatus) {
      res["FailoverAddrPoolStatus"] = boost::any(*failoverAddrPoolStatus);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lines) {
      res["Lines"] = lines ? boost::any(lines->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (strategyId) {
      res["StrategyId"] = boost::any(*strategyId);
    }
    if (strategyMode) {
      res["StrategyMode"] = boost::any(*strategyMode);
    }
    if (strategyName) {
      res["StrategyName"] = boost::any(*strategyName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessMode") != m.end() && !m["AccessMode"].empty()) {
      accessMode = make_shared<string>(boost::any_cast<string>(m["AccessMode"]));
    }
    if (m.find("AccessStatus") != m.end() && !m["AccessStatus"].empty()) {
      accessStatus = make_shared<string>(boost::any_cast<string>(m["AccessStatus"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("DefaultAddrPoolId") != m.end() && !m["DefaultAddrPoolId"].empty()) {
      defaultAddrPoolId = make_shared<string>(boost::any_cast<string>(m["DefaultAddrPoolId"]));
    }
    if (m.find("DefaultAddrPoolMonitorStatus") != m.end() && !m["DefaultAddrPoolMonitorStatus"].empty()) {
      defaultAddrPoolMonitorStatus = make_shared<string>(boost::any_cast<string>(m["DefaultAddrPoolMonitorStatus"]));
    }
    if (m.find("DefaultAddrPoolName") != m.end() && !m["DefaultAddrPoolName"].empty()) {
      defaultAddrPoolName = make_shared<string>(boost::any_cast<string>(m["DefaultAddrPoolName"]));
    }
    if (m.find("DefaultAddrPoolStatus") != m.end() && !m["DefaultAddrPoolStatus"].empty()) {
      defaultAddrPoolStatus = make_shared<string>(boost::any_cast<string>(m["DefaultAddrPoolStatus"]));
    }
    if (m.find("FailoverAddrPoolId") != m.end() && !m["FailoverAddrPoolId"].empty()) {
      failoverAddrPoolId = make_shared<string>(boost::any_cast<string>(m["FailoverAddrPoolId"]));
    }
    if (m.find("FailoverAddrPoolMonitorStatus") != m.end() && !m["FailoverAddrPoolMonitorStatus"].empty()) {
      failoverAddrPoolMonitorStatus = make_shared<string>(boost::any_cast<string>(m["FailoverAddrPoolMonitorStatus"]));
    }
    if (m.find("FailoverAddrPoolName") != m.end() && !m["FailoverAddrPoolName"].empty()) {
      failoverAddrPoolName = make_shared<string>(boost::any_cast<string>(m["FailoverAddrPoolName"]));
    }
    if (m.find("FailoverAddrPoolStatus") != m.end() && !m["FailoverAddrPoolStatus"].empty()) {
      failoverAddrPoolStatus = make_shared<string>(boost::any_cast<string>(m["FailoverAddrPoolStatus"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Lines") != m.end() && !m["Lines"].empty()) {
      if (typeid(map<string, boost::any>) == m["Lines"].type()) {
        DescribeGtmAccessStrategiesResponseBodyStrategiesStrategyLines model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Lines"]));
        lines = make_shared<DescribeGtmAccessStrategiesResponseBodyStrategiesStrategyLines>(model1);
      }
    }
    if (m.find("StrategyId") != m.end() && !m["StrategyId"].empty()) {
      strategyId = make_shared<string>(boost::any_cast<string>(m["StrategyId"]));
    }
    if (m.find("StrategyMode") != m.end() && !m["StrategyMode"].empty()) {
      strategyMode = make_shared<string>(boost::any_cast<string>(m["StrategyMode"]));
    }
    if (m.find("StrategyName") != m.end() && !m["StrategyName"].empty()) {
      strategyName = make_shared<string>(boost::any_cast<string>(m["StrategyName"]));
    }
  }


  virtual ~DescribeGtmAccessStrategiesResponseBodyStrategiesStrategy() = default;
};
class DescribeGtmAccessStrategiesResponseBodyStrategies : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeGtmAccessStrategiesResponseBodyStrategiesStrategy>> strategy{};

  DescribeGtmAccessStrategiesResponseBodyStrategies() {}

  explicit DescribeGtmAccessStrategiesResponseBodyStrategies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (strategy) {
      vector<boost::any> temp1;
      for(auto item1:*strategy){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Strategy"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Strategy") != m.end() && !m["Strategy"].empty()) {
      if (typeid(vector<boost::any>) == m["Strategy"].type()) {
        vector<DescribeGtmAccessStrategiesResponseBodyStrategiesStrategy> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Strategy"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGtmAccessStrategiesResponseBodyStrategiesStrategy model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        strategy = make_shared<vector<DescribeGtmAccessStrategiesResponseBodyStrategiesStrategy>>(expect1);
      }
    }
  }


  virtual ~DescribeGtmAccessStrategiesResponseBodyStrategies() = default;
};
class DescribeGtmAccessStrategiesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeGtmAccessStrategiesResponseBodyStrategies> strategies{};
  shared_ptr<long> totalItems{};
  shared_ptr<long> totalPages{};

  DescribeGtmAccessStrategiesResponseBody() {}

  explicit DescribeGtmAccessStrategiesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (strategies) {
      res["Strategies"] = strategies ? boost::any(strategies->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalItems) {
      res["TotalItems"] = boost::any(*totalItems);
    }
    if (totalPages) {
      res["TotalPages"] = boost::any(*totalPages);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Strategies") != m.end() && !m["Strategies"].empty()) {
      if (typeid(map<string, boost::any>) == m["Strategies"].type()) {
        DescribeGtmAccessStrategiesResponseBodyStrategies model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Strategies"]));
        strategies = make_shared<DescribeGtmAccessStrategiesResponseBodyStrategies>(model1);
      }
    }
    if (m.find("TotalItems") != m.end() && !m["TotalItems"].empty()) {
      totalItems = make_shared<long>(boost::any_cast<long>(m["TotalItems"]));
    }
    if (m.find("TotalPages") != m.end() && !m["TotalPages"].empty()) {
      totalPages = make_shared<long>(boost::any_cast<long>(m["TotalPages"]));
    }
  }


  virtual ~DescribeGtmAccessStrategiesResponseBody() = default;
};
class DescribeGtmAccessStrategiesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeGtmAccessStrategiesResponseBody> body{};

  DescribeGtmAccessStrategiesResponse() {}

  explicit DescribeGtmAccessStrategiesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeGtmAccessStrategiesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeGtmAccessStrategiesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeGtmAccessStrategiesResponse() = default;
};
class DescribeGtmAccessStrategyRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> strategyId{};

  DescribeGtmAccessStrategyRequest() {}

  explicit DescribeGtmAccessStrategyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (strategyId) {
      res["StrategyId"] = boost::any(*strategyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("StrategyId") != m.end() && !m["StrategyId"].empty()) {
      strategyId = make_shared<string>(boost::any_cast<string>(m["StrategyId"]));
    }
  }


  virtual ~DescribeGtmAccessStrategyRequest() = default;
};
class DescribeGtmAccessStrategyResponseBodyLinesLine : public Darabonba::Model {
public:
  shared_ptr<string> groupCode{};
  shared_ptr<string> groupName{};
  shared_ptr<string> lineCode{};
  shared_ptr<string> lineName{};

  DescribeGtmAccessStrategyResponseBodyLinesLine() {}

  explicit DescribeGtmAccessStrategyResponseBodyLinesLine(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupCode) {
      res["GroupCode"] = boost::any(*groupCode);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (lineCode) {
      res["LineCode"] = boost::any(*lineCode);
    }
    if (lineName) {
      res["LineName"] = boost::any(*lineName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupCode") != m.end() && !m["GroupCode"].empty()) {
      groupCode = make_shared<string>(boost::any_cast<string>(m["GroupCode"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("LineCode") != m.end() && !m["LineCode"].empty()) {
      lineCode = make_shared<string>(boost::any_cast<string>(m["LineCode"]));
    }
    if (m.find("LineName") != m.end() && !m["LineName"].empty()) {
      lineName = make_shared<string>(boost::any_cast<string>(m["LineName"]));
    }
  }


  virtual ~DescribeGtmAccessStrategyResponseBodyLinesLine() = default;
};
class DescribeGtmAccessStrategyResponseBodyLines : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeGtmAccessStrategyResponseBodyLinesLine>> line{};

  DescribeGtmAccessStrategyResponseBodyLines() {}

  explicit DescribeGtmAccessStrategyResponseBodyLines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (line) {
      vector<boost::any> temp1;
      for(auto item1:*line){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Line"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Line") != m.end() && !m["Line"].empty()) {
      if (typeid(vector<boost::any>) == m["Line"].type()) {
        vector<DescribeGtmAccessStrategyResponseBodyLinesLine> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Line"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGtmAccessStrategyResponseBodyLinesLine model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        line = make_shared<vector<DescribeGtmAccessStrategyResponseBodyLinesLine>>(expect1);
      }
    }
  }


  virtual ~DescribeGtmAccessStrategyResponseBodyLines() = default;
};
class DescribeGtmAccessStrategyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> accessMode{};
  shared_ptr<string> accessStatus{};
  shared_ptr<string> defaultAddrPoolMonitorStatus{};
  shared_ptr<string> defaultAddrPoolName{};
  shared_ptr<string> defaultAddrPoolStatus{};
  shared_ptr<string> defultAddrPoolId{};
  shared_ptr<string> failoverAddrPoolId{};
  shared_ptr<string> failoverAddrPoolMonitorStatus{};
  shared_ptr<string> failoverAddrPoolName{};
  shared_ptr<string> failoverAddrPoolStatus{};
  shared_ptr<string> instanceId{};
  shared_ptr<DescribeGtmAccessStrategyResponseBodyLines> lines{};
  shared_ptr<string> requestId{};
  shared_ptr<string> strategyId{};
  shared_ptr<string> strategyMode{};
  shared_ptr<string> strategyName{};

  DescribeGtmAccessStrategyResponseBody() {}

  explicit DescribeGtmAccessStrategyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessMode) {
      res["AccessMode"] = boost::any(*accessMode);
    }
    if (accessStatus) {
      res["AccessStatus"] = boost::any(*accessStatus);
    }
    if (defaultAddrPoolMonitorStatus) {
      res["DefaultAddrPoolMonitorStatus"] = boost::any(*defaultAddrPoolMonitorStatus);
    }
    if (defaultAddrPoolName) {
      res["DefaultAddrPoolName"] = boost::any(*defaultAddrPoolName);
    }
    if (defaultAddrPoolStatus) {
      res["DefaultAddrPoolStatus"] = boost::any(*defaultAddrPoolStatus);
    }
    if (defultAddrPoolId) {
      res["DefultAddrPoolId"] = boost::any(*defultAddrPoolId);
    }
    if (failoverAddrPoolId) {
      res["FailoverAddrPoolId"] = boost::any(*failoverAddrPoolId);
    }
    if (failoverAddrPoolMonitorStatus) {
      res["FailoverAddrPoolMonitorStatus"] = boost::any(*failoverAddrPoolMonitorStatus);
    }
    if (failoverAddrPoolName) {
      res["FailoverAddrPoolName"] = boost::any(*failoverAddrPoolName);
    }
    if (failoverAddrPoolStatus) {
      res["FailoverAddrPoolStatus"] = boost::any(*failoverAddrPoolStatus);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lines) {
      res["Lines"] = lines ? boost::any(lines->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (strategyId) {
      res["StrategyId"] = boost::any(*strategyId);
    }
    if (strategyMode) {
      res["StrategyMode"] = boost::any(*strategyMode);
    }
    if (strategyName) {
      res["StrategyName"] = boost::any(*strategyName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessMode") != m.end() && !m["AccessMode"].empty()) {
      accessMode = make_shared<string>(boost::any_cast<string>(m["AccessMode"]));
    }
    if (m.find("AccessStatus") != m.end() && !m["AccessStatus"].empty()) {
      accessStatus = make_shared<string>(boost::any_cast<string>(m["AccessStatus"]));
    }
    if (m.find("DefaultAddrPoolMonitorStatus") != m.end() && !m["DefaultAddrPoolMonitorStatus"].empty()) {
      defaultAddrPoolMonitorStatus = make_shared<string>(boost::any_cast<string>(m["DefaultAddrPoolMonitorStatus"]));
    }
    if (m.find("DefaultAddrPoolName") != m.end() && !m["DefaultAddrPoolName"].empty()) {
      defaultAddrPoolName = make_shared<string>(boost::any_cast<string>(m["DefaultAddrPoolName"]));
    }
    if (m.find("DefaultAddrPoolStatus") != m.end() && !m["DefaultAddrPoolStatus"].empty()) {
      defaultAddrPoolStatus = make_shared<string>(boost::any_cast<string>(m["DefaultAddrPoolStatus"]));
    }
    if (m.find("DefultAddrPoolId") != m.end() && !m["DefultAddrPoolId"].empty()) {
      defultAddrPoolId = make_shared<string>(boost::any_cast<string>(m["DefultAddrPoolId"]));
    }
    if (m.find("FailoverAddrPoolId") != m.end() && !m["FailoverAddrPoolId"].empty()) {
      failoverAddrPoolId = make_shared<string>(boost::any_cast<string>(m["FailoverAddrPoolId"]));
    }
    if (m.find("FailoverAddrPoolMonitorStatus") != m.end() && !m["FailoverAddrPoolMonitorStatus"].empty()) {
      failoverAddrPoolMonitorStatus = make_shared<string>(boost::any_cast<string>(m["FailoverAddrPoolMonitorStatus"]));
    }
    if (m.find("FailoverAddrPoolName") != m.end() && !m["FailoverAddrPoolName"].empty()) {
      failoverAddrPoolName = make_shared<string>(boost::any_cast<string>(m["FailoverAddrPoolName"]));
    }
    if (m.find("FailoverAddrPoolStatus") != m.end() && !m["FailoverAddrPoolStatus"].empty()) {
      failoverAddrPoolStatus = make_shared<string>(boost::any_cast<string>(m["FailoverAddrPoolStatus"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Lines") != m.end() && !m["Lines"].empty()) {
      if (typeid(map<string, boost::any>) == m["Lines"].type()) {
        DescribeGtmAccessStrategyResponseBodyLines model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Lines"]));
        lines = make_shared<DescribeGtmAccessStrategyResponseBodyLines>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StrategyId") != m.end() && !m["StrategyId"].empty()) {
      strategyId = make_shared<string>(boost::any_cast<string>(m["StrategyId"]));
    }
    if (m.find("StrategyMode") != m.end() && !m["StrategyMode"].empty()) {
      strategyMode = make_shared<string>(boost::any_cast<string>(m["StrategyMode"]));
    }
    if (m.find("StrategyName") != m.end() && !m["StrategyName"].empty()) {
      strategyName = make_shared<string>(boost::any_cast<string>(m["StrategyName"]));
    }
  }


  virtual ~DescribeGtmAccessStrategyResponseBody() = default;
};
class DescribeGtmAccessStrategyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeGtmAccessStrategyResponseBody> body{};

  DescribeGtmAccessStrategyResponse() {}

  explicit DescribeGtmAccessStrategyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeGtmAccessStrategyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeGtmAccessStrategyResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeGtmAccessStrategyResponse() = default;
};
class DescribeGtmAccessStrategyAvailableConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> lang{};

  DescribeGtmAccessStrategyAvailableConfigRequest() {}

  explicit DescribeGtmAccessStrategyAvailableConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~DescribeGtmAccessStrategyAvailableConfigRequest() = default;
};
class DescribeGtmAccessStrategyAvailableConfigResponseBodyAddrPoolsAddrPool : public Darabonba::Model {
public:
  shared_ptr<string> addrPoolId{};
  shared_ptr<string> addrPoolName{};

  DescribeGtmAccessStrategyAvailableConfigResponseBodyAddrPoolsAddrPool() {}

  explicit DescribeGtmAccessStrategyAvailableConfigResponseBodyAddrPoolsAddrPool(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addrPoolId) {
      res["AddrPoolId"] = boost::any(*addrPoolId);
    }
    if (addrPoolName) {
      res["AddrPoolName"] = boost::any(*addrPoolName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddrPoolId") != m.end() && !m["AddrPoolId"].empty()) {
      addrPoolId = make_shared<string>(boost::any_cast<string>(m["AddrPoolId"]));
    }
    if (m.find("AddrPoolName") != m.end() && !m["AddrPoolName"].empty()) {
      addrPoolName = make_shared<string>(boost::any_cast<string>(m["AddrPoolName"]));
    }
  }


  virtual ~DescribeGtmAccessStrategyAvailableConfigResponseBodyAddrPoolsAddrPool() = default;
};
class DescribeGtmAccessStrategyAvailableConfigResponseBodyAddrPools : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeGtmAccessStrategyAvailableConfigResponseBodyAddrPoolsAddrPool>> addrPool{};

  DescribeGtmAccessStrategyAvailableConfigResponseBodyAddrPools() {}

  explicit DescribeGtmAccessStrategyAvailableConfigResponseBodyAddrPools(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addrPool) {
      vector<boost::any> temp1;
      for(auto item1:*addrPool){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AddrPool"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddrPool") != m.end() && !m["AddrPool"].empty()) {
      if (typeid(vector<boost::any>) == m["AddrPool"].type()) {
        vector<DescribeGtmAccessStrategyAvailableConfigResponseBodyAddrPoolsAddrPool> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AddrPool"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGtmAccessStrategyAvailableConfigResponseBodyAddrPoolsAddrPool model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        addrPool = make_shared<vector<DescribeGtmAccessStrategyAvailableConfigResponseBodyAddrPoolsAddrPool>>(expect1);
      }
    }
  }


  virtual ~DescribeGtmAccessStrategyAvailableConfigResponseBodyAddrPools() = default;
};
class DescribeGtmAccessStrategyAvailableConfigResponseBodyLinesLine : public Darabonba::Model {
public:
  shared_ptr<string> fatherCode{};
  shared_ptr<string> groupCode{};
  shared_ptr<string> groupName{};
  shared_ptr<string> lineCode{};
  shared_ptr<string> lineName{};
  shared_ptr<string> status{};

  DescribeGtmAccessStrategyAvailableConfigResponseBodyLinesLine() {}

  explicit DescribeGtmAccessStrategyAvailableConfigResponseBodyLinesLine(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fatherCode) {
      res["FatherCode"] = boost::any(*fatherCode);
    }
    if (groupCode) {
      res["GroupCode"] = boost::any(*groupCode);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (lineCode) {
      res["LineCode"] = boost::any(*lineCode);
    }
    if (lineName) {
      res["LineName"] = boost::any(*lineName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FatherCode") != m.end() && !m["FatherCode"].empty()) {
      fatherCode = make_shared<string>(boost::any_cast<string>(m["FatherCode"]));
    }
    if (m.find("GroupCode") != m.end() && !m["GroupCode"].empty()) {
      groupCode = make_shared<string>(boost::any_cast<string>(m["GroupCode"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("LineCode") != m.end() && !m["LineCode"].empty()) {
      lineCode = make_shared<string>(boost::any_cast<string>(m["LineCode"]));
    }
    if (m.find("LineName") != m.end() && !m["LineName"].empty()) {
      lineName = make_shared<string>(boost::any_cast<string>(m["LineName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeGtmAccessStrategyAvailableConfigResponseBodyLinesLine() = default;
};
class DescribeGtmAccessStrategyAvailableConfigResponseBodyLines : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeGtmAccessStrategyAvailableConfigResponseBodyLinesLine>> line{};

  DescribeGtmAccessStrategyAvailableConfigResponseBodyLines() {}

  explicit DescribeGtmAccessStrategyAvailableConfigResponseBodyLines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (line) {
      vector<boost::any> temp1;
      for(auto item1:*line){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Line"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Line") != m.end() && !m["Line"].empty()) {
      if (typeid(vector<boost::any>) == m["Line"].type()) {
        vector<DescribeGtmAccessStrategyAvailableConfigResponseBodyLinesLine> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Line"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGtmAccessStrategyAvailableConfigResponseBodyLinesLine model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        line = make_shared<vector<DescribeGtmAccessStrategyAvailableConfigResponseBodyLinesLine>>(expect1);
      }
    }
  }


  virtual ~DescribeGtmAccessStrategyAvailableConfigResponseBodyLines() = default;
};
class DescribeGtmAccessStrategyAvailableConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeGtmAccessStrategyAvailableConfigResponseBodyAddrPools> addrPools{};
  shared_ptr<DescribeGtmAccessStrategyAvailableConfigResponseBodyLines> lines{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> suggestSetDefaultLine{};

  DescribeGtmAccessStrategyAvailableConfigResponseBody() {}

  explicit DescribeGtmAccessStrategyAvailableConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addrPools) {
      res["AddrPools"] = addrPools ? boost::any(addrPools->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (lines) {
      res["Lines"] = lines ? boost::any(lines->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (suggestSetDefaultLine) {
      res["SuggestSetDefaultLine"] = boost::any(*suggestSetDefaultLine);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddrPools") != m.end() && !m["AddrPools"].empty()) {
      if (typeid(map<string, boost::any>) == m["AddrPools"].type()) {
        DescribeGtmAccessStrategyAvailableConfigResponseBodyAddrPools model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AddrPools"]));
        addrPools = make_shared<DescribeGtmAccessStrategyAvailableConfigResponseBodyAddrPools>(model1);
      }
    }
    if (m.find("Lines") != m.end() && !m["Lines"].empty()) {
      if (typeid(map<string, boost::any>) == m["Lines"].type()) {
        DescribeGtmAccessStrategyAvailableConfigResponseBodyLines model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Lines"]));
        lines = make_shared<DescribeGtmAccessStrategyAvailableConfigResponseBodyLines>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SuggestSetDefaultLine") != m.end() && !m["SuggestSetDefaultLine"].empty()) {
      suggestSetDefaultLine = make_shared<bool>(boost::any_cast<bool>(m["SuggestSetDefaultLine"]));
    }
  }


  virtual ~DescribeGtmAccessStrategyAvailableConfigResponseBody() = default;
};
class DescribeGtmAccessStrategyAvailableConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeGtmAccessStrategyAvailableConfigResponseBody> body{};

  DescribeGtmAccessStrategyAvailableConfigResponse() {}

  explicit DescribeGtmAccessStrategyAvailableConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeGtmAccessStrategyAvailableConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeGtmAccessStrategyAvailableConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeGtmAccessStrategyAvailableConfigResponse() = default;
};
class DescribeGtmAvailableAlertGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};

  DescribeGtmAvailableAlertGroupRequest() {}

  explicit DescribeGtmAvailableAlertGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~DescribeGtmAvailableAlertGroupRequest() = default;
};
class DescribeGtmAvailableAlertGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> availableAlertGroup{};
  shared_ptr<string> requestId{};

  DescribeGtmAvailableAlertGroupResponseBody() {}

  explicit DescribeGtmAvailableAlertGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availableAlertGroup) {
      res["AvailableAlertGroup"] = boost::any(*availableAlertGroup);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvailableAlertGroup") != m.end() && !m["AvailableAlertGroup"].empty()) {
      availableAlertGroup = make_shared<string>(boost::any_cast<string>(m["AvailableAlertGroup"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeGtmAvailableAlertGroupResponseBody() = default;
};
class DescribeGtmAvailableAlertGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeGtmAvailableAlertGroupResponseBody> body{};

  DescribeGtmAvailableAlertGroupResponse() {}

  explicit DescribeGtmAvailableAlertGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeGtmAvailableAlertGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeGtmAvailableAlertGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeGtmAvailableAlertGroupResponse() = default;
};
class DescribeGtmInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> lang{};
  shared_ptr<bool> needDetailAttributes{};

  DescribeGtmInstanceRequest() {}

  explicit DescribeGtmInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (needDetailAttributes) {
      res["NeedDetailAttributes"] = boost::any(*needDetailAttributes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("NeedDetailAttributes") != m.end() && !m["NeedDetailAttributes"].empty()) {
      needDetailAttributes = make_shared<bool>(boost::any_cast<bool>(m["NeedDetailAttributes"]));
    }
  }


  virtual ~DescribeGtmInstanceRequest() = default;
};
class DescribeGtmInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> accessStrategyNum{};
  shared_ptr<long> addressPoolNum{};
  shared_ptr<string> alertGroup{};
  shared_ptr<string> cname{};
  shared_ptr<string> cnameMode{};
  shared_ptr<string> createTime{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<string> expireTime{};
  shared_ptr<long> expireTimestamp{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> lbaStrategy{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> ttl{};
  shared_ptr<string> userDomainName{};
  shared_ptr<string> versionCode{};

  DescribeGtmInstanceResponseBody() {}

  explicit DescribeGtmInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessStrategyNum) {
      res["AccessStrategyNum"] = boost::any(*accessStrategyNum);
    }
    if (addressPoolNum) {
      res["AddressPoolNum"] = boost::any(*addressPoolNum);
    }
    if (alertGroup) {
      res["AlertGroup"] = boost::any(*alertGroup);
    }
    if (cname) {
      res["Cname"] = boost::any(*cname);
    }
    if (cnameMode) {
      res["CnameMode"] = boost::any(*cnameMode);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (expireTimestamp) {
      res["ExpireTimestamp"] = boost::any(*expireTimestamp);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (lbaStrategy) {
      res["LbaStrategy"] = boost::any(*lbaStrategy);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (ttl) {
      res["Ttl"] = boost::any(*ttl);
    }
    if (userDomainName) {
      res["UserDomainName"] = boost::any(*userDomainName);
    }
    if (versionCode) {
      res["VersionCode"] = boost::any(*versionCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessStrategyNum") != m.end() && !m["AccessStrategyNum"].empty()) {
      accessStrategyNum = make_shared<long>(boost::any_cast<long>(m["AccessStrategyNum"]));
    }
    if (m.find("AddressPoolNum") != m.end() && !m["AddressPoolNum"].empty()) {
      addressPoolNum = make_shared<long>(boost::any_cast<long>(m["AddressPoolNum"]));
    }
    if (m.find("AlertGroup") != m.end() && !m["AlertGroup"].empty()) {
      alertGroup = make_shared<string>(boost::any_cast<string>(m["AlertGroup"]));
    }
    if (m.find("Cname") != m.end() && !m["Cname"].empty()) {
      cname = make_shared<string>(boost::any_cast<string>(m["Cname"]));
    }
    if (m.find("CnameMode") != m.end() && !m["CnameMode"].empty()) {
      cnameMode = make_shared<string>(boost::any_cast<string>(m["CnameMode"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("ExpireTimestamp") != m.end() && !m["ExpireTimestamp"].empty()) {
      expireTimestamp = make_shared<long>(boost::any_cast<long>(m["ExpireTimestamp"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("LbaStrategy") != m.end() && !m["LbaStrategy"].empty()) {
      lbaStrategy = make_shared<string>(boost::any_cast<string>(m["LbaStrategy"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Ttl") != m.end() && !m["Ttl"].empty()) {
      ttl = make_shared<long>(boost::any_cast<long>(m["Ttl"]));
    }
    if (m.find("UserDomainName") != m.end() && !m["UserDomainName"].empty()) {
      userDomainName = make_shared<string>(boost::any_cast<string>(m["UserDomainName"]));
    }
    if (m.find("VersionCode") != m.end() && !m["VersionCode"].empty()) {
      versionCode = make_shared<string>(boost::any_cast<string>(m["VersionCode"]));
    }
  }


  virtual ~DescribeGtmInstanceResponseBody() = default;
};
class DescribeGtmInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeGtmInstanceResponseBody> body{};

  DescribeGtmInstanceResponse() {}

  explicit DescribeGtmInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeGtmInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeGtmInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeGtmInstanceResponse() = default;
};
class DescribeGtmInstanceAddressPoolRequest : public Darabonba::Model {
public:
  shared_ptr<string> addrPoolId{};
  shared_ptr<string> lang{};

  DescribeGtmInstanceAddressPoolRequest() {}

  explicit DescribeGtmInstanceAddressPoolRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addrPoolId) {
      res["AddrPoolId"] = boost::any(*addrPoolId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddrPoolId") != m.end() && !m["AddrPoolId"].empty()) {
      addrPoolId = make_shared<string>(boost::any_cast<string>(m["AddrPoolId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~DescribeGtmInstanceAddressPoolRequest() = default;
};
class DescribeGtmInstanceAddressPoolResponseBodyAddrsAddr : public Darabonba::Model {
public:
  shared_ptr<long> addrId{};
  shared_ptr<string> alertStatus{};
  shared_ptr<string> createTime{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<long> lbaWeight{};
  shared_ptr<string> mode{};
  shared_ptr<string> updateTime{};
  shared_ptr<long> updateTimestamp{};
  shared_ptr<string> value{};

  DescribeGtmInstanceAddressPoolResponseBodyAddrsAddr() {}

  explicit DescribeGtmInstanceAddressPoolResponseBodyAddrsAddr(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addrId) {
      res["AddrId"] = boost::any(*addrId);
    }
    if (alertStatus) {
      res["AlertStatus"] = boost::any(*alertStatus);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (lbaWeight) {
      res["LbaWeight"] = boost::any(*lbaWeight);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (updateTimestamp) {
      res["UpdateTimestamp"] = boost::any(*updateTimestamp);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddrId") != m.end() && !m["AddrId"].empty()) {
      addrId = make_shared<long>(boost::any_cast<long>(m["AddrId"]));
    }
    if (m.find("AlertStatus") != m.end() && !m["AlertStatus"].empty()) {
      alertStatus = make_shared<string>(boost::any_cast<string>(m["AlertStatus"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("LbaWeight") != m.end() && !m["LbaWeight"].empty()) {
      lbaWeight = make_shared<long>(boost::any_cast<long>(m["LbaWeight"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("UpdateTimestamp") != m.end() && !m["UpdateTimestamp"].empty()) {
      updateTimestamp = make_shared<long>(boost::any_cast<long>(m["UpdateTimestamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeGtmInstanceAddressPoolResponseBodyAddrsAddr() = default;
};
class DescribeGtmInstanceAddressPoolResponseBodyAddrs : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeGtmInstanceAddressPoolResponseBodyAddrsAddr>> addr{};

  DescribeGtmInstanceAddressPoolResponseBodyAddrs() {}

  explicit DescribeGtmInstanceAddressPoolResponseBodyAddrs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addr) {
      vector<boost::any> temp1;
      for(auto item1:*addr){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Addr"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Addr") != m.end() && !m["Addr"].empty()) {
      if (typeid(vector<boost::any>) == m["Addr"].type()) {
        vector<DescribeGtmInstanceAddressPoolResponseBodyAddrsAddr> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Addr"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGtmInstanceAddressPoolResponseBodyAddrsAddr model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        addr = make_shared<vector<DescribeGtmInstanceAddressPoolResponseBodyAddrsAddr>>(expect1);
      }
    }
  }


  virtual ~DescribeGtmInstanceAddressPoolResponseBodyAddrs() = default;
};
class DescribeGtmInstanceAddressPoolResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> addrCount{};
  shared_ptr<string> addrPoolId{};
  shared_ptr<DescribeGtmInstanceAddressPoolResponseBodyAddrs> addrs{};
  shared_ptr<string> createTime{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<long> minAvailableAddrNum{};
  shared_ptr<string> monitorConfigId{};
  shared_ptr<string> monitorStatus{};
  shared_ptr<string> name{};
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};
  shared_ptr<string> updateTime{};
  shared_ptr<long> updateTimestamp{};

  DescribeGtmInstanceAddressPoolResponseBody() {}

  explicit DescribeGtmInstanceAddressPoolResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addrCount) {
      res["AddrCount"] = boost::any(*addrCount);
    }
    if (addrPoolId) {
      res["AddrPoolId"] = boost::any(*addrPoolId);
    }
    if (addrs) {
      res["Addrs"] = addrs ? boost::any(addrs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (minAvailableAddrNum) {
      res["MinAvailableAddrNum"] = boost::any(*minAvailableAddrNum);
    }
    if (monitorConfigId) {
      res["MonitorConfigId"] = boost::any(*monitorConfigId);
    }
    if (monitorStatus) {
      res["MonitorStatus"] = boost::any(*monitorStatus);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (updateTimestamp) {
      res["UpdateTimestamp"] = boost::any(*updateTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddrCount") != m.end() && !m["AddrCount"].empty()) {
      addrCount = make_shared<long>(boost::any_cast<long>(m["AddrCount"]));
    }
    if (m.find("AddrPoolId") != m.end() && !m["AddrPoolId"].empty()) {
      addrPoolId = make_shared<string>(boost::any_cast<string>(m["AddrPoolId"]));
    }
    if (m.find("Addrs") != m.end() && !m["Addrs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Addrs"].type()) {
        DescribeGtmInstanceAddressPoolResponseBodyAddrs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Addrs"]));
        addrs = make_shared<DescribeGtmInstanceAddressPoolResponseBodyAddrs>(model1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("MinAvailableAddrNum") != m.end() && !m["MinAvailableAddrNum"].empty()) {
      minAvailableAddrNum = make_shared<long>(boost::any_cast<long>(m["MinAvailableAddrNum"]));
    }
    if (m.find("MonitorConfigId") != m.end() && !m["MonitorConfigId"].empty()) {
      monitorConfigId = make_shared<string>(boost::any_cast<string>(m["MonitorConfigId"]));
    }
    if (m.find("MonitorStatus") != m.end() && !m["MonitorStatus"].empty()) {
      monitorStatus = make_shared<string>(boost::any_cast<string>(m["MonitorStatus"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("UpdateTimestamp") != m.end() && !m["UpdateTimestamp"].empty()) {
      updateTimestamp = make_shared<long>(boost::any_cast<long>(m["UpdateTimestamp"]));
    }
  }


  virtual ~DescribeGtmInstanceAddressPoolResponseBody() = default;
};
class DescribeGtmInstanceAddressPoolResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeGtmInstanceAddressPoolResponseBody> body{};

  DescribeGtmInstanceAddressPoolResponse() {}

  explicit DescribeGtmInstanceAddressPoolResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeGtmInstanceAddressPoolResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeGtmInstanceAddressPoolResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeGtmInstanceAddressPoolResponse() = default;
};
class DescribeGtmInstanceAddressPoolsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeGtmInstanceAddressPoolsRequest() {}

  explicit DescribeGtmInstanceAddressPoolsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeGtmInstanceAddressPoolsRequest() = default;
};
class DescribeGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool : public Darabonba::Model {
public:
  shared_ptr<long> addrCount{};
  shared_ptr<string> addrPoolId{};
  shared_ptr<string> createTime{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<long> minAvailableAddrNum{};
  shared_ptr<string> monitorConfigId{};
  shared_ptr<string> monitorStatus{};
  shared_ptr<string> name{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};
  shared_ptr<string> updateTime{};
  shared_ptr<long> updateTimestamp{};

  DescribeGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool() {}

  explicit DescribeGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addrCount) {
      res["AddrCount"] = boost::any(*addrCount);
    }
    if (addrPoolId) {
      res["AddrPoolId"] = boost::any(*addrPoolId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (minAvailableAddrNum) {
      res["MinAvailableAddrNum"] = boost::any(*minAvailableAddrNum);
    }
    if (monitorConfigId) {
      res["MonitorConfigId"] = boost::any(*monitorConfigId);
    }
    if (monitorStatus) {
      res["MonitorStatus"] = boost::any(*monitorStatus);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (updateTimestamp) {
      res["UpdateTimestamp"] = boost::any(*updateTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddrCount") != m.end() && !m["AddrCount"].empty()) {
      addrCount = make_shared<long>(boost::any_cast<long>(m["AddrCount"]));
    }
    if (m.find("AddrPoolId") != m.end() && !m["AddrPoolId"].empty()) {
      addrPoolId = make_shared<string>(boost::any_cast<string>(m["AddrPoolId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("MinAvailableAddrNum") != m.end() && !m["MinAvailableAddrNum"].empty()) {
      minAvailableAddrNum = make_shared<long>(boost::any_cast<long>(m["MinAvailableAddrNum"]));
    }
    if (m.find("MonitorConfigId") != m.end() && !m["MonitorConfigId"].empty()) {
      monitorConfigId = make_shared<string>(boost::any_cast<string>(m["MonitorConfigId"]));
    }
    if (m.find("MonitorStatus") != m.end() && !m["MonitorStatus"].empty()) {
      monitorStatus = make_shared<string>(boost::any_cast<string>(m["MonitorStatus"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("UpdateTimestamp") != m.end() && !m["UpdateTimestamp"].empty()) {
      updateTimestamp = make_shared<long>(boost::any_cast<long>(m["UpdateTimestamp"]));
    }
  }


  virtual ~DescribeGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool() = default;
};
class DescribeGtmInstanceAddressPoolsResponseBodyAddrPools : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool>> addrPool{};

  DescribeGtmInstanceAddressPoolsResponseBodyAddrPools() {}

  explicit DescribeGtmInstanceAddressPoolsResponseBodyAddrPools(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addrPool) {
      vector<boost::any> temp1;
      for(auto item1:*addrPool){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AddrPool"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddrPool") != m.end() && !m["AddrPool"].empty()) {
      if (typeid(vector<boost::any>) == m["AddrPool"].type()) {
        vector<DescribeGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AddrPool"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        addrPool = make_shared<vector<DescribeGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool>>(expect1);
      }
    }
  }


  virtual ~DescribeGtmInstanceAddressPoolsResponseBodyAddrPools() = default;
};
class DescribeGtmInstanceAddressPoolsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeGtmInstanceAddressPoolsResponseBodyAddrPools> addrPools{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalItems{};
  shared_ptr<long> totalPages{};

  DescribeGtmInstanceAddressPoolsResponseBody() {}

  explicit DescribeGtmInstanceAddressPoolsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addrPools) {
      res["AddrPools"] = addrPools ? boost::any(addrPools->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalItems) {
      res["TotalItems"] = boost::any(*totalItems);
    }
    if (totalPages) {
      res["TotalPages"] = boost::any(*totalPages);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddrPools") != m.end() && !m["AddrPools"].empty()) {
      if (typeid(map<string, boost::any>) == m["AddrPools"].type()) {
        DescribeGtmInstanceAddressPoolsResponseBodyAddrPools model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AddrPools"]));
        addrPools = make_shared<DescribeGtmInstanceAddressPoolsResponseBodyAddrPools>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalItems") != m.end() && !m["TotalItems"].empty()) {
      totalItems = make_shared<long>(boost::any_cast<long>(m["TotalItems"]));
    }
    if (m.find("TotalPages") != m.end() && !m["TotalPages"].empty()) {
      totalPages = make_shared<long>(boost::any_cast<long>(m["TotalPages"]));
    }
  }


  virtual ~DescribeGtmInstanceAddressPoolsResponseBody() = default;
};
class DescribeGtmInstanceAddressPoolsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeGtmInstanceAddressPoolsResponseBody> body{};

  DescribeGtmInstanceAddressPoolsResponse() {}

  explicit DescribeGtmInstanceAddressPoolsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeGtmInstanceAddressPoolsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeGtmInstanceAddressPoolsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeGtmInstanceAddressPoolsResponse() = default;
};
class DescribeGtmInstanceStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> lang{};

  DescribeGtmInstanceStatusRequest() {}

  explicit DescribeGtmInstanceStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~DescribeGtmInstanceStatusRequest() = default;
};
class DescribeGtmInstanceStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> addrNotAvailableNum{};
  shared_ptr<long> addrPoolNotAvailableNum{};
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};
  shared_ptr<string> statusReason{};
  shared_ptr<long> strategyNotAvailableNum{};
  shared_ptr<long> switchToFailoverStrategyNum{};

  DescribeGtmInstanceStatusResponseBody() {}

  explicit DescribeGtmInstanceStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addrNotAvailableNum) {
      res["AddrNotAvailableNum"] = boost::any(*addrNotAvailableNum);
    }
    if (addrPoolNotAvailableNum) {
      res["AddrPoolNotAvailableNum"] = boost::any(*addrPoolNotAvailableNum);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (statusReason) {
      res["StatusReason"] = boost::any(*statusReason);
    }
    if (strategyNotAvailableNum) {
      res["StrategyNotAvailableNum"] = boost::any(*strategyNotAvailableNum);
    }
    if (switchToFailoverStrategyNum) {
      res["SwitchToFailoverStrategyNum"] = boost::any(*switchToFailoverStrategyNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddrNotAvailableNum") != m.end() && !m["AddrNotAvailableNum"].empty()) {
      addrNotAvailableNum = make_shared<long>(boost::any_cast<long>(m["AddrNotAvailableNum"]));
    }
    if (m.find("AddrPoolNotAvailableNum") != m.end() && !m["AddrPoolNotAvailableNum"].empty()) {
      addrPoolNotAvailableNum = make_shared<long>(boost::any_cast<long>(m["AddrPoolNotAvailableNum"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StatusReason") != m.end() && !m["StatusReason"].empty()) {
      statusReason = make_shared<string>(boost::any_cast<string>(m["StatusReason"]));
    }
    if (m.find("StrategyNotAvailableNum") != m.end() && !m["StrategyNotAvailableNum"].empty()) {
      strategyNotAvailableNum = make_shared<long>(boost::any_cast<long>(m["StrategyNotAvailableNum"]));
    }
    if (m.find("SwitchToFailoverStrategyNum") != m.end() && !m["SwitchToFailoverStrategyNum"].empty()) {
      switchToFailoverStrategyNum = make_shared<long>(boost::any_cast<long>(m["SwitchToFailoverStrategyNum"]));
    }
  }


  virtual ~DescribeGtmInstanceStatusResponseBody() = default;
};
class DescribeGtmInstanceStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeGtmInstanceStatusResponseBody> body{};

  DescribeGtmInstanceStatusResponse() {}

  explicit DescribeGtmInstanceStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeGtmInstanceStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeGtmInstanceStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeGtmInstanceStatusResponse() = default;
};
class DescribeGtmInstanceSystemCnameRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> lang{};

  DescribeGtmInstanceSystemCnameRequest() {}

  explicit DescribeGtmInstanceSystemCnameRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~DescribeGtmInstanceSystemCnameRequest() = default;
};
class DescribeGtmInstanceSystemCnameResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> systemCname{};

  DescribeGtmInstanceSystemCnameResponseBody() {}

  explicit DescribeGtmInstanceSystemCnameResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (systemCname) {
      res["SystemCname"] = boost::any(*systemCname);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SystemCname") != m.end() && !m["SystemCname"].empty()) {
      systemCname = make_shared<string>(boost::any_cast<string>(m["SystemCname"]));
    }
  }


  virtual ~DescribeGtmInstanceSystemCnameResponseBody() = default;
};
class DescribeGtmInstanceSystemCnameResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeGtmInstanceSystemCnameResponseBody> body{};

  DescribeGtmInstanceSystemCnameResponse() {}

  explicit DescribeGtmInstanceSystemCnameResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeGtmInstanceSystemCnameResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeGtmInstanceSystemCnameResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeGtmInstanceSystemCnameResponse() = default;
};
class DescribeGtmInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> keyword{};
  shared_ptr<string> lang{};
  shared_ptr<bool> needDetailAttributes{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceGroupId{};

  DescribeGtmInstancesRequest() {}

  explicit DescribeGtmInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (needDetailAttributes) {
      res["NeedDetailAttributes"] = boost::any(*needDetailAttributes);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("NeedDetailAttributes") != m.end() && !m["NeedDetailAttributes"].empty()) {
      needDetailAttributes = make_shared<bool>(boost::any_cast<bool>(m["NeedDetailAttributes"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~DescribeGtmInstancesRequest() = default;
};
class DescribeGtmInstancesResponseBodyGtmInstancesGtmInstance : public Darabonba::Model {
public:
  shared_ptr<long> accessStrategyNum{};
  shared_ptr<long> addressPoolNum{};
  shared_ptr<string> alertGroup{};
  shared_ptr<string> cname{};
  shared_ptr<string> cnameMode{};
  shared_ptr<string> createTime{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<string> expireTime{};
  shared_ptr<long> expireTimestamp{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> lbaStrategy{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> ttl{};
  shared_ptr<string> userDomainName{};
  shared_ptr<string> versionCode{};

  DescribeGtmInstancesResponseBodyGtmInstancesGtmInstance() {}

  explicit DescribeGtmInstancesResponseBodyGtmInstancesGtmInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessStrategyNum) {
      res["AccessStrategyNum"] = boost::any(*accessStrategyNum);
    }
    if (addressPoolNum) {
      res["AddressPoolNum"] = boost::any(*addressPoolNum);
    }
    if (alertGroup) {
      res["AlertGroup"] = boost::any(*alertGroup);
    }
    if (cname) {
      res["Cname"] = boost::any(*cname);
    }
    if (cnameMode) {
      res["CnameMode"] = boost::any(*cnameMode);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (expireTimestamp) {
      res["ExpireTimestamp"] = boost::any(*expireTimestamp);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (lbaStrategy) {
      res["LbaStrategy"] = boost::any(*lbaStrategy);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (ttl) {
      res["Ttl"] = boost::any(*ttl);
    }
    if (userDomainName) {
      res["UserDomainName"] = boost::any(*userDomainName);
    }
    if (versionCode) {
      res["VersionCode"] = boost::any(*versionCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessStrategyNum") != m.end() && !m["AccessStrategyNum"].empty()) {
      accessStrategyNum = make_shared<long>(boost::any_cast<long>(m["AccessStrategyNum"]));
    }
    if (m.find("AddressPoolNum") != m.end() && !m["AddressPoolNum"].empty()) {
      addressPoolNum = make_shared<long>(boost::any_cast<long>(m["AddressPoolNum"]));
    }
    if (m.find("AlertGroup") != m.end() && !m["AlertGroup"].empty()) {
      alertGroup = make_shared<string>(boost::any_cast<string>(m["AlertGroup"]));
    }
    if (m.find("Cname") != m.end() && !m["Cname"].empty()) {
      cname = make_shared<string>(boost::any_cast<string>(m["Cname"]));
    }
    if (m.find("CnameMode") != m.end() && !m["CnameMode"].empty()) {
      cnameMode = make_shared<string>(boost::any_cast<string>(m["CnameMode"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("ExpireTimestamp") != m.end() && !m["ExpireTimestamp"].empty()) {
      expireTimestamp = make_shared<long>(boost::any_cast<long>(m["ExpireTimestamp"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("LbaStrategy") != m.end() && !m["LbaStrategy"].empty()) {
      lbaStrategy = make_shared<string>(boost::any_cast<string>(m["LbaStrategy"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Ttl") != m.end() && !m["Ttl"].empty()) {
      ttl = make_shared<long>(boost::any_cast<long>(m["Ttl"]));
    }
    if (m.find("UserDomainName") != m.end() && !m["UserDomainName"].empty()) {
      userDomainName = make_shared<string>(boost::any_cast<string>(m["UserDomainName"]));
    }
    if (m.find("VersionCode") != m.end() && !m["VersionCode"].empty()) {
      versionCode = make_shared<string>(boost::any_cast<string>(m["VersionCode"]));
    }
  }


  virtual ~DescribeGtmInstancesResponseBodyGtmInstancesGtmInstance() = default;
};
class DescribeGtmInstancesResponseBodyGtmInstances : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeGtmInstancesResponseBodyGtmInstancesGtmInstance>> gtmInstance{};

  DescribeGtmInstancesResponseBodyGtmInstances() {}

  explicit DescribeGtmInstancesResponseBodyGtmInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gtmInstance) {
      vector<boost::any> temp1;
      for(auto item1:*gtmInstance){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GtmInstance"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GtmInstance") != m.end() && !m["GtmInstance"].empty()) {
      if (typeid(vector<boost::any>) == m["GtmInstance"].type()) {
        vector<DescribeGtmInstancesResponseBodyGtmInstancesGtmInstance> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GtmInstance"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGtmInstancesResponseBodyGtmInstancesGtmInstance model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        gtmInstance = make_shared<vector<DescribeGtmInstancesResponseBodyGtmInstancesGtmInstance>>(expect1);
      }
    }
  }


  virtual ~DescribeGtmInstancesResponseBodyGtmInstances() = default;
};
class DescribeGtmInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeGtmInstancesResponseBodyGtmInstances> gtmInstances{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalItems{};
  shared_ptr<long> totalPages{};

  DescribeGtmInstancesResponseBody() {}

  explicit DescribeGtmInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gtmInstances) {
      res["GtmInstances"] = gtmInstances ? boost::any(gtmInstances->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalItems) {
      res["TotalItems"] = boost::any(*totalItems);
    }
    if (totalPages) {
      res["TotalPages"] = boost::any(*totalPages);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GtmInstances") != m.end() && !m["GtmInstances"].empty()) {
      if (typeid(map<string, boost::any>) == m["GtmInstances"].type()) {
        DescribeGtmInstancesResponseBodyGtmInstances model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GtmInstances"]));
        gtmInstances = make_shared<DescribeGtmInstancesResponseBodyGtmInstances>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalItems") != m.end() && !m["TotalItems"].empty()) {
      totalItems = make_shared<long>(boost::any_cast<long>(m["TotalItems"]));
    }
    if (m.find("TotalPages") != m.end() && !m["TotalPages"].empty()) {
      totalPages = make_shared<long>(boost::any_cast<long>(m["TotalPages"]));
    }
  }


  virtual ~DescribeGtmInstancesResponseBody() = default;
};
class DescribeGtmInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeGtmInstancesResponseBody> body{};

  DescribeGtmInstancesResponse() {}

  explicit DescribeGtmInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeGtmInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeGtmInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeGtmInstancesResponse() = default;
};
class DescribeGtmLogsRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTimestamp{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> keyword{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> startTimestamp{};

  DescribeGtmLogsRequest() {}

  explicit DescribeGtmLogsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTimestamp) {
      res["EndTimestamp"] = boost::any(*endTimestamp);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTimestamp) {
      res["StartTimestamp"] = boost::any(*startTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTimestamp") != m.end() && !m["EndTimestamp"].empty()) {
      endTimestamp = make_shared<long>(boost::any_cast<long>(m["EndTimestamp"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTimestamp") != m.end() && !m["StartTimestamp"].empty()) {
      startTimestamp = make_shared<long>(boost::any_cast<long>(m["StartTimestamp"]));
    }
  }


  virtual ~DescribeGtmLogsRequest() = default;
};
class DescribeGtmLogsResponseBodyLogsLog : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> entityId{};
  shared_ptr<string> entityName{};
  shared_ptr<string> entityType{};
  shared_ptr<long> id{};
  shared_ptr<string> operAction{};
  shared_ptr<string> operIp{};
  shared_ptr<string> operTime{};
  shared_ptr<long> operTimestamp{};

  DescribeGtmLogsResponseBodyLogsLog() {}

  explicit DescribeGtmLogsResponseBodyLogsLog(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (entityId) {
      res["EntityId"] = boost::any(*entityId);
    }
    if (entityName) {
      res["EntityName"] = boost::any(*entityName);
    }
    if (entityType) {
      res["EntityType"] = boost::any(*entityType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (operAction) {
      res["OperAction"] = boost::any(*operAction);
    }
    if (operIp) {
      res["OperIp"] = boost::any(*operIp);
    }
    if (operTime) {
      res["OperTime"] = boost::any(*operTime);
    }
    if (operTimestamp) {
      res["OperTimestamp"] = boost::any(*operTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("EntityId") != m.end() && !m["EntityId"].empty()) {
      entityId = make_shared<string>(boost::any_cast<string>(m["EntityId"]));
    }
    if (m.find("EntityName") != m.end() && !m["EntityName"].empty()) {
      entityName = make_shared<string>(boost::any_cast<string>(m["EntityName"]));
    }
    if (m.find("EntityType") != m.end() && !m["EntityType"].empty()) {
      entityType = make_shared<string>(boost::any_cast<string>(m["EntityType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("OperAction") != m.end() && !m["OperAction"].empty()) {
      operAction = make_shared<string>(boost::any_cast<string>(m["OperAction"]));
    }
    if (m.find("OperIp") != m.end() && !m["OperIp"].empty()) {
      operIp = make_shared<string>(boost::any_cast<string>(m["OperIp"]));
    }
    if (m.find("OperTime") != m.end() && !m["OperTime"].empty()) {
      operTime = make_shared<string>(boost::any_cast<string>(m["OperTime"]));
    }
    if (m.find("OperTimestamp") != m.end() && !m["OperTimestamp"].empty()) {
      operTimestamp = make_shared<long>(boost::any_cast<long>(m["OperTimestamp"]));
    }
  }


  virtual ~DescribeGtmLogsResponseBodyLogsLog() = default;
};
class DescribeGtmLogsResponseBodyLogs : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeGtmLogsResponseBodyLogsLog>> log{};

  DescribeGtmLogsResponseBodyLogs() {}

  explicit DescribeGtmLogsResponseBodyLogs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (log) {
      vector<boost::any> temp1;
      for(auto item1:*log){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Log"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Log") != m.end() && !m["Log"].empty()) {
      if (typeid(vector<boost::any>) == m["Log"].type()) {
        vector<DescribeGtmLogsResponseBodyLogsLog> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Log"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGtmLogsResponseBodyLogsLog model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        log = make_shared<vector<DescribeGtmLogsResponseBodyLogsLog>>(expect1);
      }
    }
  }


  virtual ~DescribeGtmLogsResponseBodyLogs() = default;
};
class DescribeGtmLogsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeGtmLogsResponseBodyLogs> logs{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalItems{};
  shared_ptr<long> totalPages{};

  DescribeGtmLogsResponseBody() {}

  explicit DescribeGtmLogsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logs) {
      res["Logs"] = logs ? boost::any(logs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalItems) {
      res["TotalItems"] = boost::any(*totalItems);
    }
    if (totalPages) {
      res["TotalPages"] = boost::any(*totalPages);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Logs") != m.end() && !m["Logs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Logs"].type()) {
        DescribeGtmLogsResponseBodyLogs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Logs"]));
        logs = make_shared<DescribeGtmLogsResponseBodyLogs>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalItems") != m.end() && !m["TotalItems"].empty()) {
      totalItems = make_shared<long>(boost::any_cast<long>(m["TotalItems"]));
    }
    if (m.find("TotalPages") != m.end() && !m["TotalPages"].empty()) {
      totalPages = make_shared<long>(boost::any_cast<long>(m["TotalPages"]));
    }
  }


  virtual ~DescribeGtmLogsResponseBody() = default;
};
class DescribeGtmLogsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeGtmLogsResponseBody> body{};

  DescribeGtmLogsResponse() {}

  explicit DescribeGtmLogsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeGtmLogsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeGtmLogsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeGtmLogsResponse() = default;
};
class DescribeGtmMonitorAvailableConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};

  DescribeGtmMonitorAvailableConfigRequest() {}

  explicit DescribeGtmMonitorAvailableConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~DescribeGtmMonitorAvailableConfigRequest() = default;
};
class DescribeGtmMonitorAvailableConfigResponseBodyIspCityNodesIspCityNode : public Darabonba::Model {
public:
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};
  shared_ptr<bool> defaultSelected{};
  shared_ptr<string> groupName{};
  shared_ptr<string> groupType{};
  shared_ptr<string> ispCode{};
  shared_ptr<string> ispName{};
  shared_ptr<bool> mainland{};

  DescribeGtmMonitorAvailableConfigResponseBodyIspCityNodesIspCityNode() {}

  explicit DescribeGtmMonitorAvailableConfigResponseBodyIspCityNodesIspCityNode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cityCode) {
      res["CityCode"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["CityName"] = boost::any(*cityName);
    }
    if (defaultSelected) {
      res["DefaultSelected"] = boost::any(*defaultSelected);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (groupType) {
      res["GroupType"] = boost::any(*groupType);
    }
    if (ispCode) {
      res["IspCode"] = boost::any(*ispCode);
    }
    if (ispName) {
      res["IspName"] = boost::any(*ispName);
    }
    if (mainland) {
      res["Mainland"] = boost::any(*mainland);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CityCode") != m.end() && !m["CityCode"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["CityCode"]));
    }
    if (m.find("CityName") != m.end() && !m["CityName"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["CityName"]));
    }
    if (m.find("DefaultSelected") != m.end() && !m["DefaultSelected"].empty()) {
      defaultSelected = make_shared<bool>(boost::any_cast<bool>(m["DefaultSelected"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("GroupType") != m.end() && !m["GroupType"].empty()) {
      groupType = make_shared<string>(boost::any_cast<string>(m["GroupType"]));
    }
    if (m.find("IspCode") != m.end() && !m["IspCode"].empty()) {
      ispCode = make_shared<string>(boost::any_cast<string>(m["IspCode"]));
    }
    if (m.find("IspName") != m.end() && !m["IspName"].empty()) {
      ispName = make_shared<string>(boost::any_cast<string>(m["IspName"]));
    }
    if (m.find("Mainland") != m.end() && !m["Mainland"].empty()) {
      mainland = make_shared<bool>(boost::any_cast<bool>(m["Mainland"]));
    }
  }


  virtual ~DescribeGtmMonitorAvailableConfigResponseBodyIspCityNodesIspCityNode() = default;
};
class DescribeGtmMonitorAvailableConfigResponseBodyIspCityNodes : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeGtmMonitorAvailableConfigResponseBodyIspCityNodesIspCityNode>> ispCityNode{};

  DescribeGtmMonitorAvailableConfigResponseBodyIspCityNodes() {}

  explicit DescribeGtmMonitorAvailableConfigResponseBodyIspCityNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ispCityNode) {
      vector<boost::any> temp1;
      for(auto item1:*ispCityNode){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IspCityNode"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IspCityNode") != m.end() && !m["IspCityNode"].empty()) {
      if (typeid(vector<boost::any>) == m["IspCityNode"].type()) {
        vector<DescribeGtmMonitorAvailableConfigResponseBodyIspCityNodesIspCityNode> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IspCityNode"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGtmMonitorAvailableConfigResponseBodyIspCityNodesIspCityNode model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ispCityNode = make_shared<vector<DescribeGtmMonitorAvailableConfigResponseBodyIspCityNodesIspCityNode>>(expect1);
      }
    }
  }


  virtual ~DescribeGtmMonitorAvailableConfigResponseBodyIspCityNodes() = default;
};
class DescribeGtmMonitorAvailableConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeGtmMonitorAvailableConfigResponseBodyIspCityNodes> ispCityNodes{};
  shared_ptr<string> requestId{};

  DescribeGtmMonitorAvailableConfigResponseBody() {}

  explicit DescribeGtmMonitorAvailableConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ispCityNodes) {
      res["IspCityNodes"] = ispCityNodes ? boost::any(ispCityNodes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IspCityNodes") != m.end() && !m["IspCityNodes"].empty()) {
      if (typeid(map<string, boost::any>) == m["IspCityNodes"].type()) {
        DescribeGtmMonitorAvailableConfigResponseBodyIspCityNodes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IspCityNodes"]));
        ispCityNodes = make_shared<DescribeGtmMonitorAvailableConfigResponseBodyIspCityNodes>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeGtmMonitorAvailableConfigResponseBody() = default;
};
class DescribeGtmMonitorAvailableConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeGtmMonitorAvailableConfigResponseBody> body{};

  DescribeGtmMonitorAvailableConfigResponse() {}

  explicit DescribeGtmMonitorAvailableConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeGtmMonitorAvailableConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeGtmMonitorAvailableConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeGtmMonitorAvailableConfigResponse() = default;
};
class DescribeGtmMonitorConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> monitorConfigId{};

  DescribeGtmMonitorConfigRequest() {}

  explicit DescribeGtmMonitorConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (monitorConfigId) {
      res["MonitorConfigId"] = boost::any(*monitorConfigId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("MonitorConfigId") != m.end() && !m["MonitorConfigId"].empty()) {
      monitorConfigId = make_shared<string>(boost::any_cast<string>(m["MonitorConfigId"]));
    }
  }


  virtual ~DescribeGtmMonitorConfigRequest() = default;
};
class DescribeGtmMonitorConfigResponseBodyIspCityNodesIspCityNode : public Darabonba::Model {
public:
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};
  shared_ptr<string> countryCode{};
  shared_ptr<string> countryName{};
  shared_ptr<string> ispCode{};
  shared_ptr<string> ispName{};

  DescribeGtmMonitorConfigResponseBodyIspCityNodesIspCityNode() {}

  explicit DescribeGtmMonitorConfigResponseBodyIspCityNodesIspCityNode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cityCode) {
      res["CityCode"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["CityName"] = boost::any(*cityName);
    }
    if (countryCode) {
      res["CountryCode"] = boost::any(*countryCode);
    }
    if (countryName) {
      res["CountryName"] = boost::any(*countryName);
    }
    if (ispCode) {
      res["IspCode"] = boost::any(*ispCode);
    }
    if (ispName) {
      res["IspName"] = boost::any(*ispName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CityCode") != m.end() && !m["CityCode"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["CityCode"]));
    }
    if (m.find("CityName") != m.end() && !m["CityName"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["CityName"]));
    }
    if (m.find("CountryCode") != m.end() && !m["CountryCode"].empty()) {
      countryCode = make_shared<string>(boost::any_cast<string>(m["CountryCode"]));
    }
    if (m.find("CountryName") != m.end() && !m["CountryName"].empty()) {
      countryName = make_shared<string>(boost::any_cast<string>(m["CountryName"]));
    }
    if (m.find("IspCode") != m.end() && !m["IspCode"].empty()) {
      ispCode = make_shared<string>(boost::any_cast<string>(m["IspCode"]));
    }
    if (m.find("IspName") != m.end() && !m["IspName"].empty()) {
      ispName = make_shared<string>(boost::any_cast<string>(m["IspName"]));
    }
  }


  virtual ~DescribeGtmMonitorConfigResponseBodyIspCityNodesIspCityNode() = default;
};
class DescribeGtmMonitorConfigResponseBodyIspCityNodes : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeGtmMonitorConfigResponseBodyIspCityNodesIspCityNode>> ispCityNode{};

  DescribeGtmMonitorConfigResponseBodyIspCityNodes() {}

  explicit DescribeGtmMonitorConfigResponseBodyIspCityNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ispCityNode) {
      vector<boost::any> temp1;
      for(auto item1:*ispCityNode){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IspCityNode"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IspCityNode") != m.end() && !m["IspCityNode"].empty()) {
      if (typeid(vector<boost::any>) == m["IspCityNode"].type()) {
        vector<DescribeGtmMonitorConfigResponseBodyIspCityNodesIspCityNode> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IspCityNode"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGtmMonitorConfigResponseBodyIspCityNodesIspCityNode model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ispCityNode = make_shared<vector<DescribeGtmMonitorConfigResponseBodyIspCityNodesIspCityNode>>(expect1);
      }
    }
  }


  virtual ~DescribeGtmMonitorConfigResponseBodyIspCityNodes() = default;
};
class DescribeGtmMonitorConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<long> evaluationCount{};
  shared_ptr<long> interval{};
  shared_ptr<DescribeGtmMonitorConfigResponseBodyIspCityNodes> ispCityNodes{};
  shared_ptr<string> monitorConfigId{};
  shared_ptr<string> monitorExtendInfo{};
  shared_ptr<string> protocolType{};
  shared_ptr<string> requestId{};
  shared_ptr<long> timeout{};
  shared_ptr<string> updateTime{};
  shared_ptr<long> updateTimestamp{};

  DescribeGtmMonitorConfigResponseBody() {}

  explicit DescribeGtmMonitorConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (evaluationCount) {
      res["EvaluationCount"] = boost::any(*evaluationCount);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ispCityNodes) {
      res["IspCityNodes"] = ispCityNodes ? boost::any(ispCityNodes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (monitorConfigId) {
      res["MonitorConfigId"] = boost::any(*monitorConfigId);
    }
    if (monitorExtendInfo) {
      res["MonitorExtendInfo"] = boost::any(*monitorExtendInfo);
    }
    if (protocolType) {
      res["ProtocolType"] = boost::any(*protocolType);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (updateTimestamp) {
      res["UpdateTimestamp"] = boost::any(*updateTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("EvaluationCount") != m.end() && !m["EvaluationCount"].empty()) {
      evaluationCount = make_shared<long>(boost::any_cast<long>(m["EvaluationCount"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("IspCityNodes") != m.end() && !m["IspCityNodes"].empty()) {
      if (typeid(map<string, boost::any>) == m["IspCityNodes"].type()) {
        DescribeGtmMonitorConfigResponseBodyIspCityNodes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IspCityNodes"]));
        ispCityNodes = make_shared<DescribeGtmMonitorConfigResponseBodyIspCityNodes>(model1);
      }
    }
    if (m.find("MonitorConfigId") != m.end() && !m["MonitorConfigId"].empty()) {
      monitorConfigId = make_shared<string>(boost::any_cast<string>(m["MonitorConfigId"]));
    }
    if (m.find("MonitorExtendInfo") != m.end() && !m["MonitorExtendInfo"].empty()) {
      monitorExtendInfo = make_shared<string>(boost::any_cast<string>(m["MonitorExtendInfo"]));
    }
    if (m.find("ProtocolType") != m.end() && !m["ProtocolType"].empty()) {
      protocolType = make_shared<string>(boost::any_cast<string>(m["ProtocolType"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("UpdateTimestamp") != m.end() && !m["UpdateTimestamp"].empty()) {
      updateTimestamp = make_shared<long>(boost::any_cast<long>(m["UpdateTimestamp"]));
    }
  }


  virtual ~DescribeGtmMonitorConfigResponseBody() = default;
};
class DescribeGtmMonitorConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeGtmMonitorConfigResponseBody> body{};

  DescribeGtmMonitorConfigResponse() {}

  explicit DescribeGtmMonitorConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeGtmMonitorConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeGtmMonitorConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeGtmMonitorConfigResponse() = default;
};
class DescribeGtmRecoveryPlanRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> recoveryPlanId{};

  DescribeGtmRecoveryPlanRequest() {}

  explicit DescribeGtmRecoveryPlanRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (recoveryPlanId) {
      res["RecoveryPlanId"] = boost::any(*recoveryPlanId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("RecoveryPlanId") != m.end() && !m["RecoveryPlanId"].empty()) {
      recoveryPlanId = make_shared<long>(boost::any_cast<long>(m["RecoveryPlanId"]));
    }
  }


  virtual ~DescribeGtmRecoveryPlanRequest() = default;
};
class DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPoolAddrsAddr : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> mode{};
  shared_ptr<string> value{};

  DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPoolAddrsAddr() {}

  explicit DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPoolAddrsAddr(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPoolAddrsAddr() = default;
};
class DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPoolAddrs : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPoolAddrsAddr>> addr{};

  DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPoolAddrs() {}

  explicit DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPoolAddrs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addr) {
      vector<boost::any> temp1;
      for(auto item1:*addr){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Addr"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Addr") != m.end() && !m["Addr"].empty()) {
      if (typeid(vector<boost::any>) == m["Addr"].type()) {
        vector<DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPoolAddrsAddr> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Addr"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPoolAddrsAddr model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        addr = make_shared<vector<DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPoolAddrsAddr>>(expect1);
      }
    }
  }


  virtual ~DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPoolAddrs() = default;
};
class DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPool : public Darabonba::Model {
public:
  shared_ptr<string> addrPoolId{};
  shared_ptr<string> addrPoolName{};
  shared_ptr<DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPoolAddrs> addrs{};
  shared_ptr<string> instanceId{};

  DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPool() {}

  explicit DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPool(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addrPoolId) {
      res["AddrPoolId"] = boost::any(*addrPoolId);
    }
    if (addrPoolName) {
      res["AddrPoolName"] = boost::any(*addrPoolName);
    }
    if (addrs) {
      res["Addrs"] = addrs ? boost::any(addrs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddrPoolId") != m.end() && !m["AddrPoolId"].empty()) {
      addrPoolId = make_shared<string>(boost::any_cast<string>(m["AddrPoolId"]));
    }
    if (m.find("AddrPoolName") != m.end() && !m["AddrPoolName"].empty()) {
      addrPoolName = make_shared<string>(boost::any_cast<string>(m["AddrPoolName"]));
    }
    if (m.find("Addrs") != m.end() && !m["Addrs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Addrs"].type()) {
        DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPoolAddrs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Addrs"]));
        addrs = make_shared<DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPoolAddrs>(model1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPool() = default;
};
class DescribeGtmRecoveryPlanResponseBodyFaultAddrPools : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPool>> faultAddrPool{};

  DescribeGtmRecoveryPlanResponseBodyFaultAddrPools() {}

  explicit DescribeGtmRecoveryPlanResponseBodyFaultAddrPools(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (faultAddrPool) {
      vector<boost::any> temp1;
      for(auto item1:*faultAddrPool){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FaultAddrPool"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FaultAddrPool") != m.end() && !m["FaultAddrPool"].empty()) {
      if (typeid(vector<boost::any>) == m["FaultAddrPool"].type()) {
        vector<DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPool> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FaultAddrPool"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPool model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        faultAddrPool = make_shared<vector<DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPool>>(expect1);
      }
    }
  }


  virtual ~DescribeGtmRecoveryPlanResponseBodyFaultAddrPools() = default;
};
class DescribeGtmRecoveryPlanResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<long> faultAddrPoolNum{};
  shared_ptr<DescribeGtmRecoveryPlanResponseBodyFaultAddrPools> faultAddrPools{};
  shared_ptr<string> lastExecuteTime{};
  shared_ptr<long> lastExecuteTimestamp{};
  shared_ptr<string> lastRollbackTime{};
  shared_ptr<long> lastRollbackTimestamp{};
  shared_ptr<string> name{};
  shared_ptr<long> recoveryPlanId{};
  shared_ptr<string> remark{};
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};
  shared_ptr<string> updateTime{};
  shared_ptr<long> updateTimestamp{};

  DescribeGtmRecoveryPlanResponseBody() {}

  explicit DescribeGtmRecoveryPlanResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (faultAddrPoolNum) {
      res["FaultAddrPoolNum"] = boost::any(*faultAddrPoolNum);
    }
    if (faultAddrPools) {
      res["FaultAddrPools"] = faultAddrPools ? boost::any(faultAddrPools->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (lastExecuteTime) {
      res["LastExecuteTime"] = boost::any(*lastExecuteTime);
    }
    if (lastExecuteTimestamp) {
      res["LastExecuteTimestamp"] = boost::any(*lastExecuteTimestamp);
    }
    if (lastRollbackTime) {
      res["LastRollbackTime"] = boost::any(*lastRollbackTime);
    }
    if (lastRollbackTimestamp) {
      res["LastRollbackTimestamp"] = boost::any(*lastRollbackTimestamp);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (recoveryPlanId) {
      res["RecoveryPlanId"] = boost::any(*recoveryPlanId);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (updateTimestamp) {
      res["UpdateTimestamp"] = boost::any(*updateTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("FaultAddrPoolNum") != m.end() && !m["FaultAddrPoolNum"].empty()) {
      faultAddrPoolNum = make_shared<long>(boost::any_cast<long>(m["FaultAddrPoolNum"]));
    }
    if (m.find("FaultAddrPools") != m.end() && !m["FaultAddrPools"].empty()) {
      if (typeid(map<string, boost::any>) == m["FaultAddrPools"].type()) {
        DescribeGtmRecoveryPlanResponseBodyFaultAddrPools model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FaultAddrPools"]));
        faultAddrPools = make_shared<DescribeGtmRecoveryPlanResponseBodyFaultAddrPools>(model1);
      }
    }
    if (m.find("LastExecuteTime") != m.end() && !m["LastExecuteTime"].empty()) {
      lastExecuteTime = make_shared<string>(boost::any_cast<string>(m["LastExecuteTime"]));
    }
    if (m.find("LastExecuteTimestamp") != m.end() && !m["LastExecuteTimestamp"].empty()) {
      lastExecuteTimestamp = make_shared<long>(boost::any_cast<long>(m["LastExecuteTimestamp"]));
    }
    if (m.find("LastRollbackTime") != m.end() && !m["LastRollbackTime"].empty()) {
      lastRollbackTime = make_shared<string>(boost::any_cast<string>(m["LastRollbackTime"]));
    }
    if (m.find("LastRollbackTimestamp") != m.end() && !m["LastRollbackTimestamp"].empty()) {
      lastRollbackTimestamp = make_shared<long>(boost::any_cast<long>(m["LastRollbackTimestamp"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RecoveryPlanId") != m.end() && !m["RecoveryPlanId"].empty()) {
      recoveryPlanId = make_shared<long>(boost::any_cast<long>(m["RecoveryPlanId"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("UpdateTimestamp") != m.end() && !m["UpdateTimestamp"].empty()) {
      updateTimestamp = make_shared<long>(boost::any_cast<long>(m["UpdateTimestamp"]));
    }
  }


  virtual ~DescribeGtmRecoveryPlanResponseBody() = default;
};
class DescribeGtmRecoveryPlanResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeGtmRecoveryPlanResponseBody> body{};

  DescribeGtmRecoveryPlanResponse() {}

  explicit DescribeGtmRecoveryPlanResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeGtmRecoveryPlanResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeGtmRecoveryPlanResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeGtmRecoveryPlanResponse() = default;
};
class DescribeGtmRecoveryPlanAvailableConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};

  DescribeGtmRecoveryPlanAvailableConfigRequest() {}

  explicit DescribeGtmRecoveryPlanAvailableConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~DescribeGtmRecoveryPlanAvailableConfigRequest() = default;
};
class DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstanceAddrPoolsAddrPool : public Darabonba::Model {
public:
  shared_ptr<string> addrPoolId{};
  shared_ptr<string> name{};

  DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstanceAddrPoolsAddrPool() {}

  explicit DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstanceAddrPoolsAddrPool(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addrPoolId) {
      res["AddrPoolId"] = boost::any(*addrPoolId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddrPoolId") != m.end() && !m["AddrPoolId"].empty()) {
      addrPoolId = make_shared<string>(boost::any_cast<string>(m["AddrPoolId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstanceAddrPoolsAddrPool() = default;
};
class DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstanceAddrPools : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstanceAddrPoolsAddrPool>> addrPool{};

  DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstanceAddrPools() {}

  explicit DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstanceAddrPools(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addrPool) {
      vector<boost::any> temp1;
      for(auto item1:*addrPool){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AddrPool"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddrPool") != m.end() && !m["AddrPool"].empty()) {
      if (typeid(vector<boost::any>) == m["AddrPool"].type()) {
        vector<DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstanceAddrPoolsAddrPool> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AddrPool"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstanceAddrPoolsAddrPool model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        addrPool = make_shared<vector<DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstanceAddrPoolsAddrPool>>(expect1);
      }
    }
  }


  virtual ~DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstanceAddrPools() = default;
};
class DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstance : public Darabonba::Model {
public:
  shared_ptr<DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstanceAddrPools> addrPools{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};

  DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstance() {}

  explicit DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addrPools) {
      res["AddrPools"] = addrPools ? boost::any(addrPools->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddrPools") != m.end() && !m["AddrPools"].empty()) {
      if (typeid(map<string, boost::any>) == m["AddrPools"].type()) {
        DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstanceAddrPools model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AddrPools"]));
        addrPools = make_shared<DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstanceAddrPools>(model1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
  }


  virtual ~DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstance() = default;
};
class DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstances : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstance>> instance{};

  DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstances() {}

  explicit DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instance) {
      vector<boost::any> temp1;
      for(auto item1:*instance){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Instance"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Instance") != m.end() && !m["Instance"].empty()) {
      if (typeid(vector<boost::any>) == m["Instance"].type()) {
        vector<DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstance> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Instance"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstance model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instance = make_shared<vector<DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstance>>(expect1);
      }
    }
  }


  virtual ~DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstances() = default;
};
class DescribeGtmRecoveryPlanAvailableConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstances> instances{};
  shared_ptr<string> requestId{};

  DescribeGtmRecoveryPlanAvailableConfigResponseBody() {}

  explicit DescribeGtmRecoveryPlanAvailableConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instances) {
      res["Instances"] = instances ? boost::any(instances->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      if (typeid(map<string, boost::any>) == m["Instances"].type()) {
        DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstances model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Instances"]));
        instances = make_shared<DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstances>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeGtmRecoveryPlanAvailableConfigResponseBody() = default;
};
class DescribeGtmRecoveryPlanAvailableConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeGtmRecoveryPlanAvailableConfigResponseBody> body{};

  DescribeGtmRecoveryPlanAvailableConfigResponse() {}

  explicit DescribeGtmRecoveryPlanAvailableConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeGtmRecoveryPlanAvailableConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeGtmRecoveryPlanAvailableConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeGtmRecoveryPlanAvailableConfigResponse() = default;
};
class DescribeGtmRecoveryPlansRequest : public Darabonba::Model {
public:
  shared_ptr<string> keyword{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeGtmRecoveryPlansRequest() {}

  explicit DescribeGtmRecoveryPlansRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeGtmRecoveryPlansRequest() = default;
};
class DescribeGtmRecoveryPlansResponseBodyRecoveryPlansRecoveryPlan : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<long> faultAddrPoolNum{};
  shared_ptr<string> lastExecuteTime{};
  shared_ptr<long> lastExecuteTimestamp{};
  shared_ptr<string> lastRollbackTime{};
  shared_ptr<long> lastRollbackTimestamp{};
  shared_ptr<string> name{};
  shared_ptr<long> recoveryPlanId{};
  shared_ptr<string> remark{};
  shared_ptr<string> status{};
  shared_ptr<string> updateTime{};
  shared_ptr<long> updateTimestamp{};

  DescribeGtmRecoveryPlansResponseBodyRecoveryPlansRecoveryPlan() {}

  explicit DescribeGtmRecoveryPlansResponseBodyRecoveryPlansRecoveryPlan(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (faultAddrPoolNum) {
      res["FaultAddrPoolNum"] = boost::any(*faultAddrPoolNum);
    }
    if (lastExecuteTime) {
      res["LastExecuteTime"] = boost::any(*lastExecuteTime);
    }
    if (lastExecuteTimestamp) {
      res["LastExecuteTimestamp"] = boost::any(*lastExecuteTimestamp);
    }
    if (lastRollbackTime) {
      res["LastRollbackTime"] = boost::any(*lastRollbackTime);
    }
    if (lastRollbackTimestamp) {
      res["LastRollbackTimestamp"] = boost::any(*lastRollbackTimestamp);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (recoveryPlanId) {
      res["RecoveryPlanId"] = boost::any(*recoveryPlanId);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (updateTimestamp) {
      res["UpdateTimestamp"] = boost::any(*updateTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("FaultAddrPoolNum") != m.end() && !m["FaultAddrPoolNum"].empty()) {
      faultAddrPoolNum = make_shared<long>(boost::any_cast<long>(m["FaultAddrPoolNum"]));
    }
    if (m.find("LastExecuteTime") != m.end() && !m["LastExecuteTime"].empty()) {
      lastExecuteTime = make_shared<string>(boost::any_cast<string>(m["LastExecuteTime"]));
    }
    if (m.find("LastExecuteTimestamp") != m.end() && !m["LastExecuteTimestamp"].empty()) {
      lastExecuteTimestamp = make_shared<long>(boost::any_cast<long>(m["LastExecuteTimestamp"]));
    }
    if (m.find("LastRollbackTime") != m.end() && !m["LastRollbackTime"].empty()) {
      lastRollbackTime = make_shared<string>(boost::any_cast<string>(m["LastRollbackTime"]));
    }
    if (m.find("LastRollbackTimestamp") != m.end() && !m["LastRollbackTimestamp"].empty()) {
      lastRollbackTimestamp = make_shared<long>(boost::any_cast<long>(m["LastRollbackTimestamp"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RecoveryPlanId") != m.end() && !m["RecoveryPlanId"].empty()) {
      recoveryPlanId = make_shared<long>(boost::any_cast<long>(m["RecoveryPlanId"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("UpdateTimestamp") != m.end() && !m["UpdateTimestamp"].empty()) {
      updateTimestamp = make_shared<long>(boost::any_cast<long>(m["UpdateTimestamp"]));
    }
  }


  virtual ~DescribeGtmRecoveryPlansResponseBodyRecoveryPlansRecoveryPlan() = default;
};
class DescribeGtmRecoveryPlansResponseBodyRecoveryPlans : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeGtmRecoveryPlansResponseBodyRecoveryPlansRecoveryPlan>> recoveryPlan{};

  DescribeGtmRecoveryPlansResponseBodyRecoveryPlans() {}

  explicit DescribeGtmRecoveryPlansResponseBodyRecoveryPlans(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recoveryPlan) {
      vector<boost::any> temp1;
      for(auto item1:*recoveryPlan){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RecoveryPlan"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecoveryPlan") != m.end() && !m["RecoveryPlan"].empty()) {
      if (typeid(vector<boost::any>) == m["RecoveryPlan"].type()) {
        vector<DescribeGtmRecoveryPlansResponseBodyRecoveryPlansRecoveryPlan> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RecoveryPlan"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGtmRecoveryPlansResponseBodyRecoveryPlansRecoveryPlan model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recoveryPlan = make_shared<vector<DescribeGtmRecoveryPlansResponseBodyRecoveryPlansRecoveryPlan>>(expect1);
      }
    }
  }


  virtual ~DescribeGtmRecoveryPlansResponseBodyRecoveryPlans() = default;
};
class DescribeGtmRecoveryPlansResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<DescribeGtmRecoveryPlansResponseBodyRecoveryPlans> recoveryPlans{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalItems{};
  shared_ptr<long> totalPages{};

  DescribeGtmRecoveryPlansResponseBody() {}

  explicit DescribeGtmRecoveryPlansResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (recoveryPlans) {
      res["RecoveryPlans"] = recoveryPlans ? boost::any(recoveryPlans->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalItems) {
      res["TotalItems"] = boost::any(*totalItems);
    }
    if (totalPages) {
      res["TotalPages"] = boost::any(*totalPages);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RecoveryPlans") != m.end() && !m["RecoveryPlans"].empty()) {
      if (typeid(map<string, boost::any>) == m["RecoveryPlans"].type()) {
        DescribeGtmRecoveryPlansResponseBodyRecoveryPlans model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RecoveryPlans"]));
        recoveryPlans = make_shared<DescribeGtmRecoveryPlansResponseBodyRecoveryPlans>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalItems") != m.end() && !m["TotalItems"].empty()) {
      totalItems = make_shared<long>(boost::any_cast<long>(m["TotalItems"]));
    }
    if (m.find("TotalPages") != m.end() && !m["TotalPages"].empty()) {
      totalPages = make_shared<long>(boost::any_cast<long>(m["TotalPages"]));
    }
  }


  virtual ~DescribeGtmRecoveryPlansResponseBody() = default;
};
class DescribeGtmRecoveryPlansResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeGtmRecoveryPlansResponseBody> body{};

  DescribeGtmRecoveryPlansResponse() {}

  explicit DescribeGtmRecoveryPlansResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeGtmRecoveryPlansResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeGtmRecoveryPlansResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeGtmRecoveryPlansResponse() = default;
};
class DescribeInstanceDomainsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeInstanceDomainsRequest() {}

  explicit DescribeInstanceDomainsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeInstanceDomainsRequest() = default;
};
class DescribeInstanceDomainsResponseBodyInstanceDomains : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<string> domainName{};

  DescribeInstanceDomainsResponseBodyInstanceDomains() {}

  explicit DescribeInstanceDomainsResponseBodyInstanceDomains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
  }


  virtual ~DescribeInstanceDomainsResponseBodyInstanceDomains() = default;
};
class DescribeInstanceDomainsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstanceDomainsResponseBodyInstanceDomains>> instanceDomains{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalItems{};
  shared_ptr<long> totalPages{};

  DescribeInstanceDomainsResponseBody() {}

  explicit DescribeInstanceDomainsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceDomains) {
      vector<boost::any> temp1;
      for(auto item1:*instanceDomains){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceDomains"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalItems) {
      res["TotalItems"] = boost::any(*totalItems);
    }
    if (totalPages) {
      res["TotalPages"] = boost::any(*totalPages);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceDomains") != m.end() && !m["InstanceDomains"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceDomains"].type()) {
        vector<DescribeInstanceDomainsResponseBodyInstanceDomains> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceDomains"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceDomainsResponseBodyInstanceDomains model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceDomains = make_shared<vector<DescribeInstanceDomainsResponseBodyInstanceDomains>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalItems") != m.end() && !m["TotalItems"].empty()) {
      totalItems = make_shared<long>(boost::any_cast<long>(m["TotalItems"]));
    }
    if (m.find("TotalPages") != m.end() && !m["TotalPages"].empty()) {
      totalPages = make_shared<long>(boost::any_cast<long>(m["TotalPages"]));
    }
  }


  virtual ~DescribeInstanceDomainsResponseBody() = default;
};
class DescribeInstanceDomainsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstanceDomainsResponseBody> body{};

  DescribeInstanceDomainsResponse() {}

  explicit DescribeInstanceDomainsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceDomainsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceDomainsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceDomainsResponse() = default;
};
class DescribeInternetDnsLogsRequest : public Darabonba::Model {
public:
  shared_ptr<long> accountId{};
  shared_ptr<string> domainName{};
  shared_ptr<long> endTimestamp{};
  shared_ptr<string> lang{};
  shared_ptr<string> module{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> queryCondition{};
  shared_ptr<long> startTimestamp{};

  DescribeInternetDnsLogsRequest() {}

  explicit DescribeInternetDnsLogsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTimestamp) {
      res["EndTimestamp"] = boost::any(*endTimestamp);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (module) {
      res["Module"] = boost::any(*module);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (queryCondition) {
      res["QueryCondition"] = boost::any(*queryCondition);
    }
    if (startTimestamp) {
      res["StartTimestamp"] = boost::any(*startTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<long>(boost::any_cast<long>(m["AccountId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTimestamp") != m.end() && !m["EndTimestamp"].empty()) {
      endTimestamp = make_shared<long>(boost::any_cast<long>(m["EndTimestamp"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Module") != m.end() && !m["Module"].empty()) {
      module = make_shared<string>(boost::any_cast<string>(m["Module"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("QueryCondition") != m.end() && !m["QueryCondition"].empty()) {
      queryCondition = make_shared<string>(boost::any_cast<string>(m["QueryCondition"]));
    }
    if (m.find("StartTimestamp") != m.end() && !m["StartTimestamp"].empty()) {
      startTimestamp = make_shared<long>(boost::any_cast<long>(m["StartTimestamp"]));
    }
  }


  virtual ~DescribeInternetDnsLogsRequest() = default;
};
class DescribeInternetDnsLogsResponseBodyLogsLogValue : public Darabonba::Model {
public:
  shared_ptr<vector<string>> value{};

  DescribeInternetDnsLogsResponseBodyLogsLogValue() {}

  explicit DescribeInternetDnsLogsResponseBodyLogsLogValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Value"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Value"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      value = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeInternetDnsLogsResponseBodyLogsLogValue() = default;
};
class DescribeInternetDnsLogsResponseBodyLogsLog : public Darabonba::Model {
public:
  shared_ptr<string> dnsMsgId{};
  shared_ptr<long> logTime{};
  shared_ptr<string> protocol{};
  shared_ptr<string> queryName{};
  shared_ptr<string> queryType{};
  shared_ptr<long> rt{};
  shared_ptr<string> serverIp{};
  shared_ptr<string> sourceIp{};
  shared_ptr<string> status{};
  shared_ptr<string> subnetIp{};
  shared_ptr<DescribeInternetDnsLogsResponseBodyLogsLogValue> value{};
  shared_ptr<string> zoneName{};

  DescribeInternetDnsLogsResponseBodyLogsLog() {}

  explicit DescribeInternetDnsLogsResponseBodyLogsLog(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dnsMsgId) {
      res["DnsMsgId"] = boost::any(*dnsMsgId);
    }
    if (logTime) {
      res["LogTime"] = boost::any(*logTime);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (queryName) {
      res["QueryName"] = boost::any(*queryName);
    }
    if (queryType) {
      res["QueryType"] = boost::any(*queryType);
    }
    if (rt) {
      res["Rt"] = boost::any(*rt);
    }
    if (serverIp) {
      res["ServerIp"] = boost::any(*serverIp);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (subnetIp) {
      res["SubnetIp"] = boost::any(*subnetIp);
    }
    if (value) {
      res["Value"] = value ? boost::any(value->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (zoneName) {
      res["ZoneName"] = boost::any(*zoneName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DnsMsgId") != m.end() && !m["DnsMsgId"].empty()) {
      dnsMsgId = make_shared<string>(boost::any_cast<string>(m["DnsMsgId"]));
    }
    if (m.find("LogTime") != m.end() && !m["LogTime"].empty()) {
      logTime = make_shared<long>(boost::any_cast<long>(m["LogTime"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("QueryName") != m.end() && !m["QueryName"].empty()) {
      queryName = make_shared<string>(boost::any_cast<string>(m["QueryName"]));
    }
    if (m.find("QueryType") != m.end() && !m["QueryType"].empty()) {
      queryType = make_shared<string>(boost::any_cast<string>(m["QueryType"]));
    }
    if (m.find("Rt") != m.end() && !m["Rt"].empty()) {
      rt = make_shared<long>(boost::any_cast<long>(m["Rt"]));
    }
    if (m.find("ServerIp") != m.end() && !m["ServerIp"].empty()) {
      serverIp = make_shared<string>(boost::any_cast<string>(m["ServerIp"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SubnetIp") != m.end() && !m["SubnetIp"].empty()) {
      subnetIp = make_shared<string>(boost::any_cast<string>(m["SubnetIp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      if (typeid(map<string, boost::any>) == m["Value"].type()) {
        DescribeInternetDnsLogsResponseBodyLogsLogValue model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Value"]));
        value = make_shared<DescribeInternetDnsLogsResponseBodyLogsLogValue>(model1);
      }
    }
    if (m.find("ZoneName") != m.end() && !m["ZoneName"].empty()) {
      zoneName = make_shared<string>(boost::any_cast<string>(m["ZoneName"]));
    }
  }


  virtual ~DescribeInternetDnsLogsResponseBodyLogsLog() = default;
};
class DescribeInternetDnsLogsResponseBodyLogs : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInternetDnsLogsResponseBodyLogsLog>> log{};

  DescribeInternetDnsLogsResponseBodyLogs() {}

  explicit DescribeInternetDnsLogsResponseBodyLogs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (log) {
      vector<boost::any> temp1;
      for(auto item1:*log){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Log"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Log") != m.end() && !m["Log"].empty()) {
      if (typeid(vector<boost::any>) == m["Log"].type()) {
        vector<DescribeInternetDnsLogsResponseBodyLogsLog> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Log"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInternetDnsLogsResponseBodyLogsLog model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        log = make_shared<vector<DescribeInternetDnsLogsResponseBodyLogsLog>>(expect1);
      }
    }
  }


  virtual ~DescribeInternetDnsLogsResponseBodyLogs() = default;
};
class DescribeInternetDnsLogsResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> complete{};
  shared_ptr<long> curPage{};
  shared_ptr<DescribeInternetDnsLogsResponseBodyLogs> logs{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalPage{};
  shared_ptr<long> totalSize{};

  DescribeInternetDnsLogsResponseBody() {}

  explicit DescribeInternetDnsLogsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (complete) {
      res["Complete"] = boost::any(*complete);
    }
    if (curPage) {
      res["CurPage"] = boost::any(*curPage);
    }
    if (logs) {
      res["Logs"] = logs ? boost::any(logs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalPage) {
      res["TotalPage"] = boost::any(*totalPage);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Complete") != m.end() && !m["Complete"].empty()) {
      complete = make_shared<bool>(boost::any_cast<bool>(m["Complete"]));
    }
    if (m.find("CurPage") != m.end() && !m["CurPage"].empty()) {
      curPage = make_shared<long>(boost::any_cast<long>(m["CurPage"]));
    }
    if (m.find("Logs") != m.end() && !m["Logs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Logs"].type()) {
        DescribeInternetDnsLogsResponseBodyLogs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Logs"]));
        logs = make_shared<DescribeInternetDnsLogsResponseBodyLogs>(model1);
      }
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalPage") != m.end() && !m["TotalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["TotalPage"]));
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
  }


  virtual ~DescribeInternetDnsLogsResponseBody() = default;
};
class DescribeInternetDnsLogsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInternetDnsLogsResponseBody> body{};

  DescribeInternetDnsLogsResponse() {}

  explicit DescribeInternetDnsLogsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInternetDnsLogsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInternetDnsLogsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInternetDnsLogsResponse() = default;
};
class DescribeIspFlushCacheInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> direction{};
  shared_ptr<string> isp{};
  shared_ptr<string> keyword{};
  shared_ptr<string> lang{};
  shared_ptr<string> orderBy{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> type{};

  DescribeIspFlushCacheInstancesRequest() {}

  explicit DescribeIspFlushCacheInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (direction) {
      res["Direction"] = boost::any(*direction);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Direction") != m.end() && !m["Direction"].empty()) {
      direction = make_shared<string>(boost::any_cast<string>(m["Direction"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeIspFlushCacheInstancesRequest() = default;
};
class DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstancesQuotaInfo : public Darabonba::Model {
public:
  shared_ptr<long> instanceQuota{};
  shared_ptr<long> instanceQuotaUsed{};

  DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstancesQuotaInfo() {}

  explicit DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstancesQuotaInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceQuota) {
      res["InstanceQuota"] = boost::any(*instanceQuota);
    }
    if (instanceQuotaUsed) {
      res["InstanceQuotaUsed"] = boost::any(*instanceQuotaUsed);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceQuota") != m.end() && !m["InstanceQuota"].empty()) {
      instanceQuota = make_shared<long>(boost::any_cast<long>(m["InstanceQuota"]));
    }
    if (m.find("InstanceQuotaUsed") != m.end() && !m["InstanceQuotaUsed"].empty()) {
      instanceQuotaUsed = make_shared<long>(boost::any_cast<long>(m["InstanceQuotaUsed"]));
    }
  }


  virtual ~DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstancesQuotaInfo() = default;
};
class DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstances : public Darabonba::Model {
public:
  shared_ptr<string> expireTime{};
  shared_ptr<long> expireTimestamp{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> isp{};
  shared_ptr<DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstancesQuotaInfo> quotaInfo{};
  shared_ptr<string> status{};
  shared_ptr<string> versionCode{};

  DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstances() {}

  explicit DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (expireTimestamp) {
      res["ExpireTimestamp"] = boost::any(*expireTimestamp);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (quotaInfo) {
      res["QuotaInfo"] = quotaInfo ? boost::any(quotaInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (versionCode) {
      res["VersionCode"] = boost::any(*versionCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("ExpireTimestamp") != m.end() && !m["ExpireTimestamp"].empty()) {
      expireTimestamp = make_shared<long>(boost::any_cast<long>(m["ExpireTimestamp"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("QuotaInfo") != m.end() && !m["QuotaInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["QuotaInfo"].type()) {
        DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstancesQuotaInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["QuotaInfo"]));
        quotaInfo = make_shared<DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstancesQuotaInfo>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("VersionCode") != m.end() && !m["VersionCode"].empty()) {
      versionCode = make_shared<string>(boost::any_cast<string>(m["VersionCode"]));
    }
  }


  virtual ~DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstances() = default;
};
class DescribeIspFlushCacheInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstances>> ispFlushCacheInstances{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalItems{};
  shared_ptr<long> totalPages{};

  DescribeIspFlushCacheInstancesResponseBody() {}

  explicit DescribeIspFlushCacheInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ispFlushCacheInstances) {
      vector<boost::any> temp1;
      for(auto item1:*ispFlushCacheInstances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IspFlushCacheInstances"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalItems) {
      res["TotalItems"] = boost::any(*totalItems);
    }
    if (totalPages) {
      res["TotalPages"] = boost::any(*totalPages);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IspFlushCacheInstances") != m.end() && !m["IspFlushCacheInstances"].empty()) {
      if (typeid(vector<boost::any>) == m["IspFlushCacheInstances"].type()) {
        vector<DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IspFlushCacheInstances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ispFlushCacheInstances = make_shared<vector<DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstances>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalItems") != m.end() && !m["TotalItems"].empty()) {
      totalItems = make_shared<long>(boost::any_cast<long>(m["TotalItems"]));
    }
    if (m.find("TotalPages") != m.end() && !m["TotalPages"].empty()) {
      totalPages = make_shared<long>(boost::any_cast<long>(m["TotalPages"]));
    }
  }


  virtual ~DescribeIspFlushCacheInstancesResponseBody() = default;
};
class DescribeIspFlushCacheInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeIspFlushCacheInstancesResponseBody> body{};

  DescribeIspFlushCacheInstancesResponse() {}

  explicit DescribeIspFlushCacheInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeIspFlushCacheInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeIspFlushCacheInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeIspFlushCacheInstancesResponse() = default;
};
class DescribeIspFlushCacheRemainQuotaRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};

  DescribeIspFlushCacheRemainQuotaRequest() {}

  explicit DescribeIspFlushCacheRemainQuotaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~DescribeIspFlushCacheRemainQuotaRequest() = default;
};
class DescribeIspFlushCacheRemainQuotaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> telecomRemainQuota{};

  DescribeIspFlushCacheRemainQuotaResponseBody() {}

  explicit DescribeIspFlushCacheRemainQuotaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (telecomRemainQuota) {
      res["TelecomRemainQuota"] = boost::any(*telecomRemainQuota);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TelecomRemainQuota") != m.end() && !m["TelecomRemainQuota"].empty()) {
      telecomRemainQuota = make_shared<long>(boost::any_cast<long>(m["TelecomRemainQuota"]));
    }
  }


  virtual ~DescribeIspFlushCacheRemainQuotaResponseBody() = default;
};
class DescribeIspFlushCacheRemainQuotaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeIspFlushCacheRemainQuotaResponseBody> body{};

  DescribeIspFlushCacheRemainQuotaResponse() {}

  explicit DescribeIspFlushCacheRemainQuotaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeIspFlushCacheRemainQuotaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeIspFlushCacheRemainQuotaResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeIspFlushCacheRemainQuotaResponse() = default;
};
class DescribeIspFlushCacheTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> taskId{};

  DescribeIspFlushCacheTaskRequest() {}

  explicit DescribeIspFlushCacheTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~DescribeIspFlushCacheTaskRequest() = default;
};
class DescribeIspFlushCacheTaskResponseBodyFlushCacheResultsDnsNodesAnswers : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> record{};
  shared_ptr<long> ttl{};
  shared_ptr<string> type{};

  DescribeIspFlushCacheTaskResponseBodyFlushCacheResultsDnsNodesAnswers() {}

  explicit DescribeIspFlushCacheTaskResponseBodyFlushCacheResultsDnsNodesAnswers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (record) {
      res["Record"] = boost::any(*record);
    }
    if (ttl) {
      res["Ttl"] = boost::any(*ttl);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Record") != m.end() && !m["Record"].empty()) {
      record = make_shared<string>(boost::any_cast<string>(m["Record"]));
    }
    if (m.find("Ttl") != m.end() && !m["Ttl"].empty()) {
      ttl = make_shared<long>(boost::any_cast<long>(m["Ttl"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeIspFlushCacheTaskResponseBodyFlushCacheResultsDnsNodesAnswers() = default;
};
class DescribeIspFlushCacheTaskResponseBodyFlushCacheResultsDnsNodes : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeIspFlushCacheTaskResponseBodyFlushCacheResultsDnsNodesAnswers>> answers{};
  shared_ptr<string> nodeIp{};
  shared_ptr<string> spName{};
  shared_ptr<string> status{};

  DescribeIspFlushCacheTaskResponseBodyFlushCacheResultsDnsNodes() {}

  explicit DescribeIspFlushCacheTaskResponseBodyFlushCacheResultsDnsNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (answers) {
      vector<boost::any> temp1;
      for(auto item1:*answers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Answers"] = boost::any(temp1);
    }
    if (nodeIp) {
      res["NodeIp"] = boost::any(*nodeIp);
    }
    if (spName) {
      res["SpName"] = boost::any(*spName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Answers") != m.end() && !m["Answers"].empty()) {
      if (typeid(vector<boost::any>) == m["Answers"].type()) {
        vector<DescribeIspFlushCacheTaskResponseBodyFlushCacheResultsDnsNodesAnswers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Answers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeIspFlushCacheTaskResponseBodyFlushCacheResultsDnsNodesAnswers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        answers = make_shared<vector<DescribeIspFlushCacheTaskResponseBodyFlushCacheResultsDnsNodesAnswers>>(expect1);
      }
    }
    if (m.find("NodeIp") != m.end() && !m["NodeIp"].empty()) {
      nodeIp = make_shared<string>(boost::any_cast<string>(m["NodeIp"]));
    }
    if (m.find("SpName") != m.end() && !m["SpName"].empty()) {
      spName = make_shared<string>(boost::any_cast<string>(m["SpName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeIspFlushCacheTaskResponseBodyFlushCacheResultsDnsNodes() = default;
};
class DescribeIspFlushCacheTaskResponseBodyFlushCacheResults : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeIspFlushCacheTaskResponseBodyFlushCacheResultsDnsNodes>> dnsNodes{};
  shared_ptr<string> province{};

  DescribeIspFlushCacheTaskResponseBodyFlushCacheResults() {}

  explicit DescribeIspFlushCacheTaskResponseBodyFlushCacheResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dnsNodes) {
      vector<boost::any> temp1;
      for(auto item1:*dnsNodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DnsNodes"] = boost::any(temp1);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DnsNodes") != m.end() && !m["DnsNodes"].empty()) {
      if (typeid(vector<boost::any>) == m["DnsNodes"].type()) {
        vector<DescribeIspFlushCacheTaskResponseBodyFlushCacheResultsDnsNodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DnsNodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeIspFlushCacheTaskResponseBodyFlushCacheResultsDnsNodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dnsNodes = make_shared<vector<DescribeIspFlushCacheTaskResponseBodyFlushCacheResultsDnsNodes>>(expect1);
      }
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
  }


  virtual ~DescribeIspFlushCacheTaskResponseBodyFlushCacheResults() = default;
};
class DescribeIspFlushCacheTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<string> domainName{};
  shared_ptr<vector<DescribeIspFlushCacheTaskResponseBodyFlushCacheResults>> flushCacheResults{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> isp{};
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskStatus{};

  DescribeIspFlushCacheTaskResponseBody() {}

  explicit DescribeIspFlushCacheTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (flushCacheResults) {
      vector<boost::any> temp1;
      for(auto item1:*flushCacheResults){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FlushCacheResults"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("FlushCacheResults") != m.end() && !m["FlushCacheResults"].empty()) {
      if (typeid(vector<boost::any>) == m["FlushCacheResults"].type()) {
        vector<DescribeIspFlushCacheTaskResponseBodyFlushCacheResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FlushCacheResults"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeIspFlushCacheTaskResponseBodyFlushCacheResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        flushCacheResults = make_shared<vector<DescribeIspFlushCacheTaskResponseBodyFlushCacheResults>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<string>(boost::any_cast<string>(m["TaskStatus"]));
    }
  }


  virtual ~DescribeIspFlushCacheTaskResponseBody() = default;
};
class DescribeIspFlushCacheTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeIspFlushCacheTaskResponseBody> body{};

  DescribeIspFlushCacheTaskResponse() {}

  explicit DescribeIspFlushCacheTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeIspFlushCacheTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeIspFlushCacheTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeIspFlushCacheTaskResponse() = default;
};
class DescribeIspFlushCacheTasksRequest : public Darabonba::Model {
public:
  shared_ptr<string> direction{};
  shared_ptr<string> domainName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> isp{};
  shared_ptr<string> lang{};
  shared_ptr<string> orderBy{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeIspFlushCacheTasksRequest() {}

  explicit DescribeIspFlushCacheTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (direction) {
      res["Direction"] = boost::any(*direction);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Direction") != m.end() && !m["Direction"].empty()) {
      direction = make_shared<string>(boost::any_cast<string>(m["Direction"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeIspFlushCacheTasksRequest() = default;
};
class DescribeIspFlushCacheTasksResponseBodyIspFlushCacheTasks : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<string> domainName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> isp{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskStatus{};

  DescribeIspFlushCacheTasksResponseBodyIspFlushCacheTasks() {}

  explicit DescribeIspFlushCacheTasksResponseBodyIspFlushCacheTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<string>(boost::any_cast<string>(m["TaskStatus"]));
    }
  }


  virtual ~DescribeIspFlushCacheTasksResponseBodyIspFlushCacheTasks() = default;
};
class DescribeIspFlushCacheTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeIspFlushCacheTasksResponseBodyIspFlushCacheTasks>> ispFlushCacheTasks{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalItems{};
  shared_ptr<long> totalPages{};

  DescribeIspFlushCacheTasksResponseBody() {}

  explicit DescribeIspFlushCacheTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ispFlushCacheTasks) {
      vector<boost::any> temp1;
      for(auto item1:*ispFlushCacheTasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IspFlushCacheTasks"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalItems) {
      res["TotalItems"] = boost::any(*totalItems);
    }
    if (totalPages) {
      res["TotalPages"] = boost::any(*totalPages);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IspFlushCacheTasks") != m.end() && !m["IspFlushCacheTasks"].empty()) {
      if (typeid(vector<boost::any>) == m["IspFlushCacheTasks"].type()) {
        vector<DescribeIspFlushCacheTasksResponseBodyIspFlushCacheTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IspFlushCacheTasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeIspFlushCacheTasksResponseBodyIspFlushCacheTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ispFlushCacheTasks = make_shared<vector<DescribeIspFlushCacheTasksResponseBodyIspFlushCacheTasks>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalItems") != m.end() && !m["TotalItems"].empty()) {
      totalItems = make_shared<long>(boost::any_cast<long>(m["TotalItems"]));
    }
    if (m.find("TotalPages") != m.end() && !m["TotalPages"].empty()) {
      totalPages = make_shared<long>(boost::any_cast<long>(m["TotalPages"]));
    }
  }


  virtual ~DescribeIspFlushCacheTasksResponseBody() = default;
};
class DescribeIspFlushCacheTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeIspFlushCacheTasksResponseBody> body{};

  DescribeIspFlushCacheTasksResponse() {}

  explicit DescribeIspFlushCacheTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeIspFlushCacheTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeIspFlushCacheTasksResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeIspFlushCacheTasksResponse() = default;
};
class DescribePdnsAccountSummaryRequest : public Darabonba::Model {
public:
  shared_ptr<string> endDate{};
  shared_ptr<string> lang{};
  shared_ptr<string> startDate{};

  DescribePdnsAccountSummaryRequest() {}

  explicit DescribePdnsAccountSummaryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
  }


  virtual ~DescribePdnsAccountSummaryRequest() = default;
};
class DescribePdnsAccountSummaryResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> domainCount{};
  shared_ptr<long> httpCount{};
  shared_ptr<long> httpsCount{};
  shared_ptr<long> subDomainCount{};
  shared_ptr<long> threatCount{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> userId{};

  DescribePdnsAccountSummaryResponseBodyData() {}

  explicit DescribePdnsAccountSummaryResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainCount) {
      res["DomainCount"] = boost::any(*domainCount);
    }
    if (httpCount) {
      res["HttpCount"] = boost::any(*httpCount);
    }
    if (httpsCount) {
      res["HttpsCount"] = boost::any(*httpsCount);
    }
    if (subDomainCount) {
      res["SubDomainCount"] = boost::any(*subDomainCount);
    }
    if (threatCount) {
      res["ThreatCount"] = boost::any(*threatCount);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainCount") != m.end() && !m["DomainCount"].empty()) {
      domainCount = make_shared<long>(boost::any_cast<long>(m["DomainCount"]));
    }
    if (m.find("HttpCount") != m.end() && !m["HttpCount"].empty()) {
      httpCount = make_shared<long>(boost::any_cast<long>(m["HttpCount"]));
    }
    if (m.find("HttpsCount") != m.end() && !m["HttpsCount"].empty()) {
      httpsCount = make_shared<long>(boost::any_cast<long>(m["HttpsCount"]));
    }
    if (m.find("SubDomainCount") != m.end() && !m["SubDomainCount"].empty()) {
      subDomainCount = make_shared<long>(boost::any_cast<long>(m["SubDomainCount"]));
    }
    if (m.find("ThreatCount") != m.end() && !m["ThreatCount"].empty()) {
      threatCount = make_shared<long>(boost::any_cast<long>(m["ThreatCount"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["UserId"]));
    }
  }


  virtual ~DescribePdnsAccountSummaryResponseBodyData() = default;
};
class DescribePdnsAccountSummaryResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribePdnsAccountSummaryResponseBodyData> data{};
  shared_ptr<string> requestId{};

  DescribePdnsAccountSummaryResponseBody() {}

  explicit DescribePdnsAccountSummaryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribePdnsAccountSummaryResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribePdnsAccountSummaryResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribePdnsAccountSummaryResponseBody() = default;
};
class DescribePdnsAccountSummaryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePdnsAccountSummaryResponseBody> body{};

  DescribePdnsAccountSummaryResponse() {}

  explicit DescribePdnsAccountSummaryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePdnsAccountSummaryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePdnsAccountSummaryResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePdnsAccountSummaryResponse() = default;
};
class DescribePdnsAppKeyRequest : public Darabonba::Model {
public:
  shared_ptr<string> appKeyId{};
  shared_ptr<string> authCode{};
  shared_ptr<string> lang{};

  DescribePdnsAppKeyRequest() {}

  explicit DescribePdnsAppKeyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appKeyId) {
      res["AppKeyId"] = boost::any(*appKeyId);
    }
    if (authCode) {
      res["AuthCode"] = boost::any(*authCode);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppKeyId") != m.end() && !m["AppKeyId"].empty()) {
      appKeyId = make_shared<string>(boost::any_cast<string>(m["AppKeyId"]));
    }
    if (m.find("AuthCode") != m.end() && !m["AuthCode"].empty()) {
      authCode = make_shared<string>(boost::any_cast<string>(m["AuthCode"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~DescribePdnsAppKeyRequest() = default;
};
class DescribePdnsAppKeyResponseBodyAppKey : public Darabonba::Model {
public:
  shared_ptr<string> appKeyId{};
  shared_ptr<string> appKeySecret{};
  shared_ptr<string> createDate{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<string> state{};

  DescribePdnsAppKeyResponseBodyAppKey() {}

  explicit DescribePdnsAppKeyResponseBodyAppKey(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appKeyId) {
      res["AppKeyId"] = boost::any(*appKeyId);
    }
    if (appKeySecret) {
      res["AppKeySecret"] = boost::any(*appKeySecret);
    }
    if (createDate) {
      res["CreateDate"] = boost::any(*createDate);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppKeyId") != m.end() && !m["AppKeyId"].empty()) {
      appKeyId = make_shared<string>(boost::any_cast<string>(m["AppKeyId"]));
    }
    if (m.find("AppKeySecret") != m.end() && !m["AppKeySecret"].empty()) {
      appKeySecret = make_shared<string>(boost::any_cast<string>(m["AppKeySecret"]));
    }
    if (m.find("CreateDate") != m.end() && !m["CreateDate"].empty()) {
      createDate = make_shared<string>(boost::any_cast<string>(m["CreateDate"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~DescribePdnsAppKeyResponseBodyAppKey() = default;
};
class DescribePdnsAppKeyResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribePdnsAppKeyResponseBodyAppKey> appKey{};
  shared_ptr<string> requestId{};

  DescribePdnsAppKeyResponseBody() {}

  explicit DescribePdnsAppKeyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appKey) {
      res["AppKey"] = appKey ? boost::any(appKey->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppKey") != m.end() && !m["AppKey"].empty()) {
      if (typeid(map<string, boost::any>) == m["AppKey"].type()) {
        DescribePdnsAppKeyResponseBodyAppKey model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AppKey"]));
        appKey = make_shared<DescribePdnsAppKeyResponseBodyAppKey>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribePdnsAppKeyResponseBody() = default;
};
class DescribePdnsAppKeyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePdnsAppKeyResponseBody> body{};

  DescribePdnsAppKeyResponse() {}

  explicit DescribePdnsAppKeyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePdnsAppKeyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePdnsAppKeyResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePdnsAppKeyResponse() = default;
};
class DescribePdnsAppKeysRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};

  DescribePdnsAppKeysRequest() {}

  explicit DescribePdnsAppKeysRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~DescribePdnsAppKeysRequest() = default;
};
class DescribePdnsAppKeysResponseBodyAppKeys : public Darabonba::Model {
public:
  shared_ptr<string> appKeyId{};
  shared_ptr<string> createDate{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<string> state{};

  DescribePdnsAppKeysResponseBodyAppKeys() {}

  explicit DescribePdnsAppKeysResponseBodyAppKeys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appKeyId) {
      res["AppKeyId"] = boost::any(*appKeyId);
    }
    if (createDate) {
      res["CreateDate"] = boost::any(*createDate);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppKeyId") != m.end() && !m["AppKeyId"].empty()) {
      appKeyId = make_shared<string>(boost::any_cast<string>(m["AppKeyId"]));
    }
    if (m.find("CreateDate") != m.end() && !m["CreateDate"].empty()) {
      createDate = make_shared<string>(boost::any_cast<string>(m["CreateDate"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~DescribePdnsAppKeysResponseBodyAppKeys() = default;
};
class DescribePdnsAppKeysResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePdnsAppKeysResponseBodyAppKeys>> appKeys{};
  shared_ptr<string> requestId{};

  DescribePdnsAppKeysResponseBody() {}

  explicit DescribePdnsAppKeysResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appKeys) {
      vector<boost::any> temp1;
      for(auto item1:*appKeys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AppKeys"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppKeys") != m.end() && !m["AppKeys"].empty()) {
      if (typeid(vector<boost::any>) == m["AppKeys"].type()) {
        vector<DescribePdnsAppKeysResponseBodyAppKeys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AppKeys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePdnsAppKeysResponseBodyAppKeys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        appKeys = make_shared<vector<DescribePdnsAppKeysResponseBodyAppKeys>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribePdnsAppKeysResponseBody() = default;
};
class DescribePdnsAppKeysResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePdnsAppKeysResponseBody> body{};

  DescribePdnsAppKeysResponse() {}

  explicit DescribePdnsAppKeysResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePdnsAppKeysResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePdnsAppKeysResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePdnsAppKeysResponse() = default;
};
class DescribePdnsOperateLogsRequest : public Darabonba::Model {
public:
  shared_ptr<string> actionType{};
  shared_ptr<string> endDate{};
  shared_ptr<string> keyword{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> startDate{};

  DescribePdnsOperateLogsRequest() {}

  explicit DescribePdnsOperateLogsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionType) {
      res["ActionType"] = boost::any(*actionType);
    }
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionType") != m.end() && !m["ActionType"].empty()) {
      actionType = make_shared<string>(boost::any_cast<string>(m["ActionType"]));
    }
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
  }


  virtual ~DescribePdnsOperateLogsRequest() = default;
};
class DescribePdnsOperateLogsResponseBodyLogs : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> operateTime{};
  shared_ptr<string> type{};
  shared_ptr<string> content{};

  DescribePdnsOperateLogsResponseBodyLogs() {}

  explicit DescribePdnsOperateLogsResponseBodyLogs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (operateTime) {
      res["OperateTime"] = boost::any(*operateTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (content) {
      res["content"] = boost::any(*content);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("OperateTime") != m.end() && !m["OperateTime"].empty()) {
      operateTime = make_shared<string>(boost::any_cast<string>(m["OperateTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
  }


  virtual ~DescribePdnsOperateLogsResponseBodyLogs() = default;
};
class DescribePdnsOperateLogsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePdnsOperateLogsResponseBodyLogs>> logs{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribePdnsOperateLogsResponseBody() {}

  explicit DescribePdnsOperateLogsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logs) {
      vector<boost::any> temp1;
      for(auto item1:*logs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Logs"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Logs") != m.end() && !m["Logs"].empty()) {
      if (typeid(vector<boost::any>) == m["Logs"].type()) {
        vector<DescribePdnsOperateLogsResponseBodyLogs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Logs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePdnsOperateLogsResponseBodyLogs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logs = make_shared<vector<DescribePdnsOperateLogsResponseBodyLogs>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribePdnsOperateLogsResponseBody() = default;
};
class DescribePdnsOperateLogsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePdnsOperateLogsResponseBody> body{};

  DescribePdnsOperateLogsResponse() {}

  explicit DescribePdnsOperateLogsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePdnsOperateLogsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePdnsOperateLogsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePdnsOperateLogsResponse() = default;
};
class DescribePdnsRequestStatisticRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endDate{};
  shared_ptr<string> lang{};
  shared_ptr<string> startDate{};
  shared_ptr<string> subDomain{};

  DescribePdnsRequestStatisticRequest() {}

  explicit DescribePdnsRequestStatisticRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    if (subDomain) {
      res["SubDomain"] = boost::any(*subDomain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
    if (m.find("SubDomain") != m.end() && !m["SubDomain"].empty()) {
      subDomain = make_shared<string>(boost::any_cast<string>(m["SubDomain"]));
    }
  }


  virtual ~DescribePdnsRequestStatisticRequest() = default;
};
class DescribePdnsRequestStatisticResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> dohTotalCount{};
  shared_ptr<long> httpCount{};
  shared_ptr<long> httpsCount{};
  shared_ptr<long> ipCount{};
  shared_ptr<long> timestamp{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> udpTotalCount{};
  shared_ptr<long> v4Count{};
  shared_ptr<long> v4HttpCount{};
  shared_ptr<long> v4HttpsCount{};
  shared_ptr<long> v6Count{};
  shared_ptr<long> v6HttpCount{};
  shared_ptr<long> v6HttpsCount{};

  DescribePdnsRequestStatisticResponseBodyData() {}

  explicit DescribePdnsRequestStatisticResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dohTotalCount) {
      res["DohTotalCount"] = boost::any(*dohTotalCount);
    }
    if (httpCount) {
      res["HttpCount"] = boost::any(*httpCount);
    }
    if (httpsCount) {
      res["HttpsCount"] = boost::any(*httpsCount);
    }
    if (ipCount) {
      res["IpCount"] = boost::any(*ipCount);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (udpTotalCount) {
      res["UdpTotalCount"] = boost::any(*udpTotalCount);
    }
    if (v4Count) {
      res["V4Count"] = boost::any(*v4Count);
    }
    if (v4HttpCount) {
      res["V4HttpCount"] = boost::any(*v4HttpCount);
    }
    if (v4HttpsCount) {
      res["V4HttpsCount"] = boost::any(*v4HttpsCount);
    }
    if (v6Count) {
      res["V6Count"] = boost::any(*v6Count);
    }
    if (v6HttpCount) {
      res["V6HttpCount"] = boost::any(*v6HttpCount);
    }
    if (v6HttpsCount) {
      res["V6HttpsCount"] = boost::any(*v6HttpsCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DohTotalCount") != m.end() && !m["DohTotalCount"].empty()) {
      dohTotalCount = make_shared<long>(boost::any_cast<long>(m["DohTotalCount"]));
    }
    if (m.find("HttpCount") != m.end() && !m["HttpCount"].empty()) {
      httpCount = make_shared<long>(boost::any_cast<long>(m["HttpCount"]));
    }
    if (m.find("HttpsCount") != m.end() && !m["HttpsCount"].empty()) {
      httpsCount = make_shared<long>(boost::any_cast<long>(m["HttpsCount"]));
    }
    if (m.find("IpCount") != m.end() && !m["IpCount"].empty()) {
      ipCount = make_shared<long>(boost::any_cast<long>(m["IpCount"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("UdpTotalCount") != m.end() && !m["UdpTotalCount"].empty()) {
      udpTotalCount = make_shared<long>(boost::any_cast<long>(m["UdpTotalCount"]));
    }
    if (m.find("V4Count") != m.end() && !m["V4Count"].empty()) {
      v4Count = make_shared<long>(boost::any_cast<long>(m["V4Count"]));
    }
    if (m.find("V4HttpCount") != m.end() && !m["V4HttpCount"].empty()) {
      v4HttpCount = make_shared<long>(boost::any_cast<long>(m["V4HttpCount"]));
    }
    if (m.find("V4HttpsCount") != m.end() && !m["V4HttpsCount"].empty()) {
      v4HttpsCount = make_shared<long>(boost::any_cast<long>(m["V4HttpsCount"]));
    }
    if (m.find("V6Count") != m.end() && !m["V6Count"].empty()) {
      v6Count = make_shared<long>(boost::any_cast<long>(m["V6Count"]));
    }
    if (m.find("V6HttpCount") != m.end() && !m["V6HttpCount"].empty()) {
      v6HttpCount = make_shared<long>(boost::any_cast<long>(m["V6HttpCount"]));
    }
    if (m.find("V6HttpsCount") != m.end() && !m["V6HttpsCount"].empty()) {
      v6HttpsCount = make_shared<long>(boost::any_cast<long>(m["V6HttpsCount"]));
    }
  }


  virtual ~DescribePdnsRequestStatisticResponseBodyData() = default;
};
class DescribePdnsRequestStatisticResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePdnsRequestStatisticResponseBodyData>> data{};
  shared_ptr<string> requestId{};

  DescribePdnsRequestStatisticResponseBody() {}

  explicit DescribePdnsRequestStatisticResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribePdnsRequestStatisticResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePdnsRequestStatisticResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribePdnsRequestStatisticResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribePdnsRequestStatisticResponseBody() = default;
};
class DescribePdnsRequestStatisticResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePdnsRequestStatisticResponseBody> body{};

  DescribePdnsRequestStatisticResponse() {}

  explicit DescribePdnsRequestStatisticResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePdnsRequestStatisticResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePdnsRequestStatisticResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePdnsRequestStatisticResponse() = default;
};
class DescribePdnsRequestStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endDate{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> startDate{};
  shared_ptr<string> subDomain{};
  shared_ptr<string> type{};

  DescribePdnsRequestStatisticsRequest() {}

  explicit DescribePdnsRequestStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    if (subDomain) {
      res["SubDomain"] = boost::any(*subDomain);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
    if (m.find("SubDomain") != m.end() && !m["SubDomain"].empty()) {
      subDomain = make_shared<string>(boost::any_cast<string>(m["SubDomain"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribePdnsRequestStatisticsRequest() = default;
};
class DescribePdnsRequestStatisticsResponseBodyDataThreatInfo : public Darabonba::Model {
public:
  shared_ptr<string> threatLevel{};
  shared_ptr<string> threatType{};

  DescribePdnsRequestStatisticsResponseBodyDataThreatInfo() {}

  explicit DescribePdnsRequestStatisticsResponseBodyDataThreatInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (threatLevel) {
      res["ThreatLevel"] = boost::any(*threatLevel);
    }
    if (threatType) {
      res["ThreatType"] = boost::any(*threatType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ThreatLevel") != m.end() && !m["ThreatLevel"].empty()) {
      threatLevel = make_shared<string>(boost::any_cast<string>(m["ThreatLevel"]));
    }
    if (m.find("ThreatType") != m.end() && !m["ThreatType"].empty()) {
      threatType = make_shared<string>(boost::any_cast<string>(m["ThreatType"]));
    }
  }


  virtual ~DescribePdnsRequestStatisticsResponseBodyDataThreatInfo() = default;
};
class DescribePdnsRequestStatisticsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> dohTotalCount{};
  shared_ptr<string> domainName{};
  shared_ptr<long> httpCount{};
  shared_ptr<long> httpsCount{};
  shared_ptr<long> ipCount{};
  shared_ptr<string> maxThreatLevel{};
  shared_ptr<string> subDomain{};
  shared_ptr<long> threatCount{};
  shared_ptr<vector<DescribePdnsRequestStatisticsResponseBodyDataThreatInfo>> threatInfo{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> udpTotalCount{};
  shared_ptr<long> v4Count{};
  shared_ptr<long> v4HttpCount{};
  shared_ptr<long> v4HttpsCount{};
  shared_ptr<long> v6Count{};
  shared_ptr<long> v6HttpCount{};
  shared_ptr<long> v6HttpsCount{};

  DescribePdnsRequestStatisticsResponseBodyData() {}

  explicit DescribePdnsRequestStatisticsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dohTotalCount) {
      res["DohTotalCount"] = boost::any(*dohTotalCount);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (httpCount) {
      res["HttpCount"] = boost::any(*httpCount);
    }
    if (httpsCount) {
      res["HttpsCount"] = boost::any(*httpsCount);
    }
    if (ipCount) {
      res["IpCount"] = boost::any(*ipCount);
    }
    if (maxThreatLevel) {
      res["MaxThreatLevel"] = boost::any(*maxThreatLevel);
    }
    if (subDomain) {
      res["SubDomain"] = boost::any(*subDomain);
    }
    if (threatCount) {
      res["ThreatCount"] = boost::any(*threatCount);
    }
    if (threatInfo) {
      vector<boost::any> temp1;
      for(auto item1:*threatInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ThreatInfo"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (udpTotalCount) {
      res["UdpTotalCount"] = boost::any(*udpTotalCount);
    }
    if (v4Count) {
      res["V4Count"] = boost::any(*v4Count);
    }
    if (v4HttpCount) {
      res["V4HttpCount"] = boost::any(*v4HttpCount);
    }
    if (v4HttpsCount) {
      res["V4HttpsCount"] = boost::any(*v4HttpsCount);
    }
    if (v6Count) {
      res["V6Count"] = boost::any(*v6Count);
    }
    if (v6HttpCount) {
      res["V6HttpCount"] = boost::any(*v6HttpCount);
    }
    if (v6HttpsCount) {
      res["V6HttpsCount"] = boost::any(*v6HttpsCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DohTotalCount") != m.end() && !m["DohTotalCount"].empty()) {
      dohTotalCount = make_shared<long>(boost::any_cast<long>(m["DohTotalCount"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("HttpCount") != m.end() && !m["HttpCount"].empty()) {
      httpCount = make_shared<long>(boost::any_cast<long>(m["HttpCount"]));
    }
    if (m.find("HttpsCount") != m.end() && !m["HttpsCount"].empty()) {
      httpsCount = make_shared<long>(boost::any_cast<long>(m["HttpsCount"]));
    }
    if (m.find("IpCount") != m.end() && !m["IpCount"].empty()) {
      ipCount = make_shared<long>(boost::any_cast<long>(m["IpCount"]));
    }
    if (m.find("MaxThreatLevel") != m.end() && !m["MaxThreatLevel"].empty()) {
      maxThreatLevel = make_shared<string>(boost::any_cast<string>(m["MaxThreatLevel"]));
    }
    if (m.find("SubDomain") != m.end() && !m["SubDomain"].empty()) {
      subDomain = make_shared<string>(boost::any_cast<string>(m["SubDomain"]));
    }
    if (m.find("ThreatCount") != m.end() && !m["ThreatCount"].empty()) {
      threatCount = make_shared<long>(boost::any_cast<long>(m["ThreatCount"]));
    }
    if (m.find("ThreatInfo") != m.end() && !m["ThreatInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ThreatInfo"].type()) {
        vector<DescribePdnsRequestStatisticsResponseBodyDataThreatInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ThreatInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePdnsRequestStatisticsResponseBodyDataThreatInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        threatInfo = make_shared<vector<DescribePdnsRequestStatisticsResponseBodyDataThreatInfo>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("UdpTotalCount") != m.end() && !m["UdpTotalCount"].empty()) {
      udpTotalCount = make_shared<long>(boost::any_cast<long>(m["UdpTotalCount"]));
    }
    if (m.find("V4Count") != m.end() && !m["V4Count"].empty()) {
      v4Count = make_shared<long>(boost::any_cast<long>(m["V4Count"]));
    }
    if (m.find("V4HttpCount") != m.end() && !m["V4HttpCount"].empty()) {
      v4HttpCount = make_shared<long>(boost::any_cast<long>(m["V4HttpCount"]));
    }
    if (m.find("V4HttpsCount") != m.end() && !m["V4HttpsCount"].empty()) {
      v4HttpsCount = make_shared<long>(boost::any_cast<long>(m["V4HttpsCount"]));
    }
    if (m.find("V6Count") != m.end() && !m["V6Count"].empty()) {
      v6Count = make_shared<long>(boost::any_cast<long>(m["V6Count"]));
    }
    if (m.find("V6HttpCount") != m.end() && !m["V6HttpCount"].empty()) {
      v6HttpCount = make_shared<long>(boost::any_cast<long>(m["V6HttpCount"]));
    }
    if (m.find("V6HttpsCount") != m.end() && !m["V6HttpsCount"].empty()) {
      v6HttpsCount = make_shared<long>(boost::any_cast<long>(m["V6HttpsCount"]));
    }
  }


  virtual ~DescribePdnsRequestStatisticsResponseBodyData() = default;
};
class DescribePdnsRequestStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePdnsRequestStatisticsResponseBodyData>> data{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribePdnsRequestStatisticsResponseBody() {}

  explicit DescribePdnsRequestStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribePdnsRequestStatisticsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePdnsRequestStatisticsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribePdnsRequestStatisticsResponseBodyData>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribePdnsRequestStatisticsResponseBody() = default;
};
class DescribePdnsRequestStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePdnsRequestStatisticsResponseBody> body{};

  DescribePdnsRequestStatisticsResponse() {}

  explicit DescribePdnsRequestStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePdnsRequestStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePdnsRequestStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePdnsRequestStatisticsResponse() = default;
};
class DescribePdnsThreatLogsRequest : public Darabonba::Model {
public:
  shared_ptr<string> endDate{};
  shared_ptr<string> keyword{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> startDate{};
  shared_ptr<string> threatLevel{};
  shared_ptr<string> threatSourceIp{};
  shared_ptr<string> threatType{};

  DescribePdnsThreatLogsRequest() {}

  explicit DescribePdnsThreatLogsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    if (threatLevel) {
      res["ThreatLevel"] = boost::any(*threatLevel);
    }
    if (threatSourceIp) {
      res["ThreatSourceIp"] = boost::any(*threatSourceIp);
    }
    if (threatType) {
      res["ThreatType"] = boost::any(*threatType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
    if (m.find("ThreatLevel") != m.end() && !m["ThreatLevel"].empty()) {
      threatLevel = make_shared<string>(boost::any_cast<string>(m["ThreatLevel"]));
    }
    if (m.find("ThreatSourceIp") != m.end() && !m["ThreatSourceIp"].empty()) {
      threatSourceIp = make_shared<string>(boost::any_cast<string>(m["ThreatSourceIp"]));
    }
    if (m.find("ThreatType") != m.end() && !m["ThreatType"].empty()) {
      threatType = make_shared<string>(boost::any_cast<string>(m["ThreatType"]));
    }
  }


  virtual ~DescribePdnsThreatLogsRequest() = default;
};
class DescribePdnsThreatLogsResponseBodyLogs : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<string> subDomain{};
  shared_ptr<string> threatLevel{};
  shared_ptr<string> threatTime{};
  shared_ptr<string> threatType{};

  DescribePdnsThreatLogsResponseBodyLogs() {}

  explicit DescribePdnsThreatLogsResponseBodyLogs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (subDomain) {
      res["SubDomain"] = boost::any(*subDomain);
    }
    if (threatLevel) {
      res["ThreatLevel"] = boost::any(*threatLevel);
    }
    if (threatTime) {
      res["ThreatTime"] = boost::any(*threatTime);
    }
    if (threatType) {
      res["ThreatType"] = boost::any(*threatType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("SubDomain") != m.end() && !m["SubDomain"].empty()) {
      subDomain = make_shared<string>(boost::any_cast<string>(m["SubDomain"]));
    }
    if (m.find("ThreatLevel") != m.end() && !m["ThreatLevel"].empty()) {
      threatLevel = make_shared<string>(boost::any_cast<string>(m["ThreatLevel"]));
    }
    if (m.find("ThreatTime") != m.end() && !m["ThreatTime"].empty()) {
      threatTime = make_shared<string>(boost::any_cast<string>(m["ThreatTime"]));
    }
    if (m.find("ThreatType") != m.end() && !m["ThreatType"].empty()) {
      threatType = make_shared<string>(boost::any_cast<string>(m["ThreatType"]));
    }
  }


  virtual ~DescribePdnsThreatLogsResponseBodyLogs() = default;
};
class DescribePdnsThreatLogsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePdnsThreatLogsResponseBodyLogs>> logs{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribePdnsThreatLogsResponseBody() {}

  explicit DescribePdnsThreatLogsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logs) {
      vector<boost::any> temp1;
      for(auto item1:*logs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Logs"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Logs") != m.end() && !m["Logs"].empty()) {
      if (typeid(vector<boost::any>) == m["Logs"].type()) {
        vector<DescribePdnsThreatLogsResponseBodyLogs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Logs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePdnsThreatLogsResponseBodyLogs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logs = make_shared<vector<DescribePdnsThreatLogsResponseBodyLogs>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribePdnsThreatLogsResponseBody() = default;
};
class DescribePdnsThreatLogsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePdnsThreatLogsResponseBody> body{};

  DescribePdnsThreatLogsResponse() {}

  explicit DescribePdnsThreatLogsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePdnsThreatLogsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePdnsThreatLogsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePdnsThreatLogsResponse() = default;
};
class DescribePdnsThreatStatisticRequest : public Darabonba::Model {
public:
  shared_ptr<string> endDate{};
  shared_ptr<string> lang{};
  shared_ptr<string> startDate{};
  shared_ptr<string> threatSourceIp{};

  DescribePdnsThreatStatisticRequest() {}

  explicit DescribePdnsThreatStatisticRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    if (threatSourceIp) {
      res["ThreatSourceIp"] = boost::any(*threatSourceIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
    if (m.find("ThreatSourceIp") != m.end() && !m["ThreatSourceIp"].empty()) {
      threatSourceIp = make_shared<string>(boost::any_cast<string>(m["ThreatSourceIp"]));
    }
  }


  virtual ~DescribePdnsThreatStatisticRequest() = default;
};
class DescribePdnsThreatStatisticResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> dohTotalCount{};
  shared_ptr<string> threatLevel{};
  shared_ptr<string> threatType{};
  shared_ptr<long> timestamp{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> udpTotalCount{};

  DescribePdnsThreatStatisticResponseBodyData() {}

  explicit DescribePdnsThreatStatisticResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dohTotalCount) {
      res["DohTotalCount"] = boost::any(*dohTotalCount);
    }
    if (threatLevel) {
      res["ThreatLevel"] = boost::any(*threatLevel);
    }
    if (threatType) {
      res["ThreatType"] = boost::any(*threatType);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (udpTotalCount) {
      res["UdpTotalCount"] = boost::any(*udpTotalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DohTotalCount") != m.end() && !m["DohTotalCount"].empty()) {
      dohTotalCount = make_shared<long>(boost::any_cast<long>(m["DohTotalCount"]));
    }
    if (m.find("ThreatLevel") != m.end() && !m["ThreatLevel"].empty()) {
      threatLevel = make_shared<string>(boost::any_cast<string>(m["ThreatLevel"]));
    }
    if (m.find("ThreatType") != m.end() && !m["ThreatType"].empty()) {
      threatType = make_shared<string>(boost::any_cast<string>(m["ThreatType"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("UdpTotalCount") != m.end() && !m["UdpTotalCount"].empty()) {
      udpTotalCount = make_shared<long>(boost::any_cast<long>(m["UdpTotalCount"]));
    }
  }


  virtual ~DescribePdnsThreatStatisticResponseBodyData() = default;
};
class DescribePdnsThreatStatisticResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePdnsThreatStatisticResponseBodyData>> data{};
  shared_ptr<string> requestId{};

  DescribePdnsThreatStatisticResponseBody() {}

  explicit DescribePdnsThreatStatisticResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribePdnsThreatStatisticResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePdnsThreatStatisticResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribePdnsThreatStatisticResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribePdnsThreatStatisticResponseBody() = default;
};
class DescribePdnsThreatStatisticResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePdnsThreatStatisticResponseBody> body{};

  DescribePdnsThreatStatisticResponse() {}

  explicit DescribePdnsThreatStatisticResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePdnsThreatStatisticResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePdnsThreatStatisticResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePdnsThreatStatisticResponse() = default;
};
class DescribePdnsThreatStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> direction{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endDate{};
  shared_ptr<string> lang{};
  shared_ptr<string> orderBy{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> startDate{};
  shared_ptr<string> subDomain{};
  shared_ptr<string> threatLevel{};
  shared_ptr<string> threatSourceIp{};
  shared_ptr<string> threatType{};
  shared_ptr<string> type{};

  DescribePdnsThreatStatisticsRequest() {}

  explicit DescribePdnsThreatStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (direction) {
      res["Direction"] = boost::any(*direction);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    if (subDomain) {
      res["SubDomain"] = boost::any(*subDomain);
    }
    if (threatLevel) {
      res["ThreatLevel"] = boost::any(*threatLevel);
    }
    if (threatSourceIp) {
      res["ThreatSourceIp"] = boost::any(*threatSourceIp);
    }
    if (threatType) {
      res["ThreatType"] = boost::any(*threatType);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Direction") != m.end() && !m["Direction"].empty()) {
      direction = make_shared<string>(boost::any_cast<string>(m["Direction"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
    if (m.find("SubDomain") != m.end() && !m["SubDomain"].empty()) {
      subDomain = make_shared<string>(boost::any_cast<string>(m["SubDomain"]));
    }
    if (m.find("ThreatLevel") != m.end() && !m["ThreatLevel"].empty()) {
      threatLevel = make_shared<string>(boost::any_cast<string>(m["ThreatLevel"]));
    }
    if (m.find("ThreatSourceIp") != m.end() && !m["ThreatSourceIp"].empty()) {
      threatSourceIp = make_shared<string>(boost::any_cast<string>(m["ThreatSourceIp"]));
    }
    if (m.find("ThreatType") != m.end() && !m["ThreatType"].empty()) {
      threatType = make_shared<string>(boost::any_cast<string>(m["ThreatType"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribePdnsThreatStatisticsRequest() = default;
};
class DescribePdnsThreatStatisticsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> dohTotalCount{};
  shared_ptr<long> domainCount{};
  shared_ptr<string> domainName{};
  shared_ptr<long> latestThreatTime{};
  shared_ptr<string> maxThreatLevel{};
  shared_ptr<string> sourceIp{};
  shared_ptr<string> subDomain{};
  shared_ptr<string> threatLevel{};
  shared_ptr<string> threatType{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> udpTotalCount{};

  DescribePdnsThreatStatisticsResponseBodyData() {}

  explicit DescribePdnsThreatStatisticsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dohTotalCount) {
      res["DohTotalCount"] = boost::any(*dohTotalCount);
    }
    if (domainCount) {
      res["DomainCount"] = boost::any(*domainCount);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (latestThreatTime) {
      res["LatestThreatTime"] = boost::any(*latestThreatTime);
    }
    if (maxThreatLevel) {
      res["MaxThreatLevel"] = boost::any(*maxThreatLevel);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (subDomain) {
      res["SubDomain"] = boost::any(*subDomain);
    }
    if (threatLevel) {
      res["ThreatLevel"] = boost::any(*threatLevel);
    }
    if (threatType) {
      res["ThreatType"] = boost::any(*threatType);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (udpTotalCount) {
      res["UdpTotalCount"] = boost::any(*udpTotalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DohTotalCount") != m.end() && !m["DohTotalCount"].empty()) {
      dohTotalCount = make_shared<long>(boost::any_cast<long>(m["DohTotalCount"]));
    }
    if (m.find("DomainCount") != m.end() && !m["DomainCount"].empty()) {
      domainCount = make_shared<long>(boost::any_cast<long>(m["DomainCount"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("LatestThreatTime") != m.end() && !m["LatestThreatTime"].empty()) {
      latestThreatTime = make_shared<long>(boost::any_cast<long>(m["LatestThreatTime"]));
    }
    if (m.find("MaxThreatLevel") != m.end() && !m["MaxThreatLevel"].empty()) {
      maxThreatLevel = make_shared<string>(boost::any_cast<string>(m["MaxThreatLevel"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("SubDomain") != m.end() && !m["SubDomain"].empty()) {
      subDomain = make_shared<string>(boost::any_cast<string>(m["SubDomain"]));
    }
    if (m.find("ThreatLevel") != m.end() && !m["ThreatLevel"].empty()) {
      threatLevel = make_shared<string>(boost::any_cast<string>(m["ThreatLevel"]));
    }
    if (m.find("ThreatType") != m.end() && !m["ThreatType"].empty()) {
      threatType = make_shared<string>(boost::any_cast<string>(m["ThreatType"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("UdpTotalCount") != m.end() && !m["UdpTotalCount"].empty()) {
      udpTotalCount = make_shared<long>(boost::any_cast<long>(m["UdpTotalCount"]));
    }
  }


  virtual ~DescribePdnsThreatStatisticsResponseBodyData() = default;
};
class DescribePdnsThreatStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePdnsThreatStatisticsResponseBodyData>> data{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribePdnsThreatStatisticsResponseBody() {}

  explicit DescribePdnsThreatStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribePdnsThreatStatisticsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePdnsThreatStatisticsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribePdnsThreatStatisticsResponseBodyData>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribePdnsThreatStatisticsResponseBody() = default;
};
class DescribePdnsThreatStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePdnsThreatStatisticsResponseBody> body{};

  DescribePdnsThreatStatisticsResponse() {}

  explicit DescribePdnsThreatStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePdnsThreatStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePdnsThreatStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePdnsThreatStatisticsResponse() = default;
};
class DescribePdnsUdpIpSegmentsRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribePdnsUdpIpSegmentsRequest() {}

  explicit DescribePdnsUdpIpSegmentsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribePdnsUdpIpSegmentsRequest() = default;
};
class DescribePdnsUdpIpSegmentsResponseBodyIpSegments : public Darabonba::Model {
public:
  shared_ptr<string> createDate{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<string> id{};
  shared_ptr<string> ip{};
  shared_ptr<long> mask{};
  shared_ptr<string> name{};
  shared_ptr<string> secretKey{};
  shared_ptr<string> state{};
  shared_ptr<string> updateDate{};

  DescribePdnsUdpIpSegmentsResponseBodyIpSegments() {}

  explicit DescribePdnsUdpIpSegmentsResponseBodyIpSegments(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createDate) {
      res["CreateDate"] = boost::any(*createDate);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (mask) {
      res["Mask"] = boost::any(*mask);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (secretKey) {
      res["SecretKey"] = boost::any(*secretKey);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (updateDate) {
      res["UpdateDate"] = boost::any(*updateDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateDate") != m.end() && !m["CreateDate"].empty()) {
      createDate = make_shared<string>(boost::any_cast<string>(m["CreateDate"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Mask") != m.end() && !m["Mask"].empty()) {
      mask = make_shared<long>(boost::any_cast<long>(m["Mask"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SecretKey") != m.end() && !m["SecretKey"].empty()) {
      secretKey = make_shared<string>(boost::any_cast<string>(m["SecretKey"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("UpdateDate") != m.end() && !m["UpdateDate"].empty()) {
      updateDate = make_shared<string>(boost::any_cast<string>(m["UpdateDate"]));
    }
  }


  virtual ~DescribePdnsUdpIpSegmentsResponseBodyIpSegments() = default;
};
class DescribePdnsUdpIpSegmentsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePdnsUdpIpSegmentsResponseBodyIpSegments>> ipSegments{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<string> totalPages{};

  DescribePdnsUdpIpSegmentsResponseBody() {}

  explicit DescribePdnsUdpIpSegmentsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipSegments) {
      vector<boost::any> temp1;
      for(auto item1:*ipSegments){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IpSegments"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (totalPages) {
      res["TotalPages"] = boost::any(*totalPages);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpSegments") != m.end() && !m["IpSegments"].empty()) {
      if (typeid(vector<boost::any>) == m["IpSegments"].type()) {
        vector<DescribePdnsUdpIpSegmentsResponseBodyIpSegments> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IpSegments"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePdnsUdpIpSegmentsResponseBodyIpSegments model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ipSegments = make_shared<vector<DescribePdnsUdpIpSegmentsResponseBodyIpSegments>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("TotalPages") != m.end() && !m["TotalPages"].empty()) {
      totalPages = make_shared<string>(boost::any_cast<string>(m["TotalPages"]));
    }
  }


  virtual ~DescribePdnsUdpIpSegmentsResponseBody() = default;
};
class DescribePdnsUdpIpSegmentsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePdnsUdpIpSegmentsResponseBody> body{};

  DescribePdnsUdpIpSegmentsResponse() {}

  explicit DescribePdnsUdpIpSegmentsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePdnsUdpIpSegmentsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePdnsUdpIpSegmentsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePdnsUdpIpSegmentsResponse() = default;
};
class DescribePdnsUserInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};

  DescribePdnsUserInfoRequest() {}

  explicit DescribePdnsUserInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~DescribePdnsUserInfoRequest() = default;
};
class DescribePdnsUserInfoResponseBodyUserInfo : public Darabonba::Model {
public:
  shared_ptr<string> availableService{};
  shared_ptr<long> pdnsId{};
  shared_ptr<string> secretKey{};
  shared_ptr<string> serviceType{};
  shared_ptr<string> state{};
  shared_ptr<string> statisticSwitchStatus{};
  shared_ptr<string> stoppedService{};

  DescribePdnsUserInfoResponseBodyUserInfo() {}

  explicit DescribePdnsUserInfoResponseBodyUserInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availableService) {
      res["AvailableService"] = boost::any(*availableService);
    }
    if (pdnsId) {
      res["PdnsId"] = boost::any(*pdnsId);
    }
    if (secretKey) {
      res["SecretKey"] = boost::any(*secretKey);
    }
    if (serviceType) {
      res["ServiceType"] = boost::any(*serviceType);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (statisticSwitchStatus) {
      res["StatisticSwitchStatus"] = boost::any(*statisticSwitchStatus);
    }
    if (stoppedService) {
      res["StoppedService"] = boost::any(*stoppedService);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvailableService") != m.end() && !m["AvailableService"].empty()) {
      availableService = make_shared<string>(boost::any_cast<string>(m["AvailableService"]));
    }
    if (m.find("PdnsId") != m.end() && !m["PdnsId"].empty()) {
      pdnsId = make_shared<long>(boost::any_cast<long>(m["PdnsId"]));
    }
    if (m.find("SecretKey") != m.end() && !m["SecretKey"].empty()) {
      secretKey = make_shared<string>(boost::any_cast<string>(m["SecretKey"]));
    }
    if (m.find("ServiceType") != m.end() && !m["ServiceType"].empty()) {
      serviceType = make_shared<string>(boost::any_cast<string>(m["ServiceType"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("StatisticSwitchStatus") != m.end() && !m["StatisticSwitchStatus"].empty()) {
      statisticSwitchStatus = make_shared<string>(boost::any_cast<string>(m["StatisticSwitchStatus"]));
    }
    if (m.find("StoppedService") != m.end() && !m["StoppedService"].empty()) {
      stoppedService = make_shared<string>(boost::any_cast<string>(m["StoppedService"]));
    }
  }


  virtual ~DescribePdnsUserInfoResponseBodyUserInfo() = default;
};
class DescribePdnsUserInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribePdnsUserInfoResponseBodyUserInfo> userInfo{};

  DescribePdnsUserInfoResponseBody() {}

  explicit DescribePdnsUserInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (userInfo) {
      res["UserInfo"] = userInfo ? boost::any(userInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UserInfo") != m.end() && !m["UserInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserInfo"].type()) {
        DescribePdnsUserInfoResponseBodyUserInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserInfo"]));
        userInfo = make_shared<DescribePdnsUserInfoResponseBodyUserInfo>(model1);
      }
    }
  }


  virtual ~DescribePdnsUserInfoResponseBody() = default;
};
class DescribePdnsUserInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePdnsUserInfoResponseBody> body{};

  DescribePdnsUserInfoResponse() {}

  explicit DescribePdnsUserInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePdnsUserInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePdnsUserInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePdnsUserInfoResponse() = default;
};
class DescribeRecordLogsRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> keyWord{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> startDate{};
  shared_ptr<string> userClientIp{};
  shared_ptr<string> endDate{};

  DescribeRecordLogsRequest() {}

  explicit DescribeRecordLogsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (keyWord) {
      res["KeyWord"] = boost::any(*keyWord);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    if (userClientIp) {
      res["UserClientIp"] = boost::any(*userClientIp);
    }
    if (endDate) {
      res["endDate"] = boost::any(*endDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("KeyWord") != m.end() && !m["KeyWord"].empty()) {
      keyWord = make_shared<string>(boost::any_cast<string>(m["KeyWord"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
    if (m.find("UserClientIp") != m.end() && !m["UserClientIp"].empty()) {
      userClientIp = make_shared<string>(boost::any_cast<string>(m["UserClientIp"]));
    }
    if (m.find("endDate") != m.end() && !m["endDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["endDate"]));
    }
  }


  virtual ~DescribeRecordLogsRequest() = default;
};
class DescribeRecordLogsResponseBodyRecordLogsRecordLog : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> actionTime{};
  shared_ptr<long> actionTimestamp{};
  shared_ptr<string> clientIp{};
  shared_ptr<string> message{};

  DescribeRecordLogsResponseBodyRecordLogsRecordLog() {}

  explicit DescribeRecordLogsResponseBodyRecordLogsRecordLog(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (actionTime) {
      res["ActionTime"] = boost::any(*actionTime);
    }
    if (actionTimestamp) {
      res["ActionTimestamp"] = boost::any(*actionTimestamp);
    }
    if (clientIp) {
      res["ClientIp"] = boost::any(*clientIp);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("ActionTime") != m.end() && !m["ActionTime"].empty()) {
      actionTime = make_shared<string>(boost::any_cast<string>(m["ActionTime"]));
    }
    if (m.find("ActionTimestamp") != m.end() && !m["ActionTimestamp"].empty()) {
      actionTimestamp = make_shared<long>(boost::any_cast<long>(m["ActionTimestamp"]));
    }
    if (m.find("ClientIp") != m.end() && !m["ClientIp"].empty()) {
      clientIp = make_shared<string>(boost::any_cast<string>(m["ClientIp"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~DescribeRecordLogsResponseBodyRecordLogsRecordLog() = default;
};
class DescribeRecordLogsResponseBodyRecordLogs : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRecordLogsResponseBodyRecordLogsRecordLog>> recordLog{};

  DescribeRecordLogsResponseBodyRecordLogs() {}

  explicit DescribeRecordLogsResponseBodyRecordLogs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recordLog) {
      vector<boost::any> temp1;
      for(auto item1:*recordLog){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RecordLog"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecordLog") != m.end() && !m["RecordLog"].empty()) {
      if (typeid(vector<boost::any>) == m["RecordLog"].type()) {
        vector<DescribeRecordLogsResponseBodyRecordLogsRecordLog> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RecordLog"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRecordLogsResponseBodyRecordLogsRecordLog model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recordLog = make_shared<vector<DescribeRecordLogsResponseBodyRecordLogsRecordLog>>(expect1);
      }
    }
  }


  virtual ~DescribeRecordLogsResponseBodyRecordLogs() = default;
};
class DescribeRecordLogsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<DescribeRecordLogsResponseBodyRecordLogs> recordLogs{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeRecordLogsResponseBody() {}

  explicit DescribeRecordLogsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (recordLogs) {
      res["RecordLogs"] = recordLogs ? boost::any(recordLogs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RecordLogs") != m.end() && !m["RecordLogs"].empty()) {
      if (typeid(map<string, boost::any>) == m["RecordLogs"].type()) {
        DescribeRecordLogsResponseBodyRecordLogs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RecordLogs"]));
        recordLogs = make_shared<DescribeRecordLogsResponseBodyRecordLogs>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeRecordLogsResponseBody() = default;
};
class DescribeRecordLogsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRecordLogsResponseBody> body{};

  DescribeRecordLogsResponse() {}

  explicit DescribeRecordLogsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRecordLogsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRecordLogsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRecordLogsResponse() = default;
};
class DescribeRecordResolveStatisticsSummaryRequest : public Darabonba::Model {
public:
  shared_ptr<string> direction{};
  shared_ptr<string> domainName{};
  shared_ptr<string> domainType{};
  shared_ptr<string> endDate{};
  shared_ptr<string> keyword{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchMode{};
  shared_ptr<string> startDate{};
  shared_ptr<long> threshold{};

  DescribeRecordResolveStatisticsSummaryRequest() {}

  explicit DescribeRecordResolveStatisticsSummaryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (direction) {
      res["Direction"] = boost::any(*direction);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainType) {
      res["DomainType"] = boost::any(*domainType);
    }
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchMode) {
      res["SearchMode"] = boost::any(*searchMode);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Direction") != m.end() && !m["Direction"].empty()) {
      direction = make_shared<string>(boost::any_cast<string>(m["Direction"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainType") != m.end() && !m["DomainType"].empty()) {
      domainType = make_shared<string>(boost::any_cast<string>(m["DomainType"]));
    }
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchMode") != m.end() && !m["SearchMode"].empty()) {
      searchMode = make_shared<string>(boost::any_cast<string>(m["SearchMode"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<long>(boost::any_cast<long>(m["Threshold"]));
    }
  }


  virtual ~DescribeRecordResolveStatisticsSummaryRequest() = default;
};
class DescribeRecordResolveStatisticsSummaryResponseBodyStatistics : public Darabonba::Model {
public:
  shared_ptr<string> count{};
  shared_ptr<string> domainName{};
  shared_ptr<string> domainType{};
  shared_ptr<string> subDomain{};

  DescribeRecordResolveStatisticsSummaryResponseBodyStatistics() {}

  explicit DescribeRecordResolveStatisticsSummaryResponseBodyStatistics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainType) {
      res["DomainType"] = boost::any(*domainType);
    }
    if (subDomain) {
      res["SubDomain"] = boost::any(*subDomain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<string>(boost::any_cast<string>(m["Count"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainType") != m.end() && !m["DomainType"].empty()) {
      domainType = make_shared<string>(boost::any_cast<string>(m["DomainType"]));
    }
    if (m.find("SubDomain") != m.end() && !m["SubDomain"].empty()) {
      subDomain = make_shared<string>(boost::any_cast<string>(m["SubDomain"]));
    }
  }


  virtual ~DescribeRecordResolveStatisticsSummaryResponseBodyStatistics() = default;
};
class DescribeRecordResolveStatisticsSummaryResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeRecordResolveStatisticsSummaryResponseBodyStatistics>> statistics{};
  shared_ptr<long> totalItems{};
  shared_ptr<long> totalPages{};

  DescribeRecordResolveStatisticsSummaryResponseBody() {}

  explicit DescribeRecordResolveStatisticsSummaryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (statistics) {
      vector<boost::any> temp1;
      for(auto item1:*statistics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Statistics"] = boost::any(temp1);
    }
    if (totalItems) {
      res["TotalItems"] = boost::any(*totalItems);
    }
    if (totalPages) {
      res["TotalPages"] = boost::any(*totalPages);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      if (typeid(vector<boost::any>) == m["Statistics"].type()) {
        vector<DescribeRecordResolveStatisticsSummaryResponseBodyStatistics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Statistics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRecordResolveStatisticsSummaryResponseBodyStatistics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        statistics = make_shared<vector<DescribeRecordResolveStatisticsSummaryResponseBodyStatistics>>(expect1);
      }
    }
    if (m.find("TotalItems") != m.end() && !m["TotalItems"].empty()) {
      totalItems = make_shared<long>(boost::any_cast<long>(m["TotalItems"]));
    }
    if (m.find("TotalPages") != m.end() && !m["TotalPages"].empty()) {
      totalPages = make_shared<long>(boost::any_cast<long>(m["TotalPages"]));
    }
  }


  virtual ~DescribeRecordResolveStatisticsSummaryResponseBody() = default;
};
class DescribeRecordResolveStatisticsSummaryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRecordResolveStatisticsSummaryResponseBody> body{};

  DescribeRecordResolveStatisticsSummaryResponse() {}

  explicit DescribeRecordResolveStatisticsSummaryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRecordResolveStatisticsSummaryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRecordResolveStatisticsSummaryResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRecordResolveStatisticsSummaryResponse() = default;
};
class DescribeRecordStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> domainType{};
  shared_ptr<string> endDate{};
  shared_ptr<string> lang{};
  shared_ptr<string> rr{};
  shared_ptr<string> startDate{};

  DescribeRecordStatisticsRequest() {}

  explicit DescribeRecordStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainType) {
      res["DomainType"] = boost::any(*domainType);
    }
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (rr) {
      res["Rr"] = boost::any(*rr);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainType") != m.end() && !m["DomainType"].empty()) {
      domainType = make_shared<string>(boost::any_cast<string>(m["DomainType"]));
    }
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Rr") != m.end() && !m["Rr"].empty()) {
      rr = make_shared<string>(boost::any_cast<string>(m["Rr"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
  }


  virtual ~DescribeRecordStatisticsRequest() = default;
};
class DescribeRecordStatisticsResponseBodyStatisticsStatistic : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> timestamp{};

  DescribeRecordStatisticsResponseBodyStatisticsStatistic() {}

  explicit DescribeRecordStatisticsResponseBodyStatisticsStatistic(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
  }


  virtual ~DescribeRecordStatisticsResponseBodyStatisticsStatistic() = default;
};
class DescribeRecordStatisticsResponseBodyStatistics : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRecordStatisticsResponseBodyStatisticsStatistic>> statistic{};

  DescribeRecordStatisticsResponseBodyStatistics() {}

  explicit DescribeRecordStatisticsResponseBodyStatistics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (statistic) {
      vector<boost::any> temp1;
      for(auto item1:*statistic){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Statistic"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Statistic") != m.end() && !m["Statistic"].empty()) {
      if (typeid(vector<boost::any>) == m["Statistic"].type()) {
        vector<DescribeRecordStatisticsResponseBodyStatisticsStatistic> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Statistic"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRecordStatisticsResponseBodyStatisticsStatistic model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        statistic = make_shared<vector<DescribeRecordStatisticsResponseBodyStatisticsStatistic>>(expect1);
      }
    }
  }


  virtual ~DescribeRecordStatisticsResponseBodyStatistics() = default;
};
class DescribeRecordStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeRecordStatisticsResponseBodyStatistics> statistics{};

  DescribeRecordStatisticsResponseBody() {}

  explicit DescribeRecordStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (statistics) {
      res["Statistics"] = statistics ? boost::any(statistics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      if (typeid(map<string, boost::any>) == m["Statistics"].type()) {
        DescribeRecordStatisticsResponseBodyStatistics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Statistics"]));
        statistics = make_shared<DescribeRecordStatisticsResponseBodyStatistics>(model1);
      }
    }
  }


  virtual ~DescribeRecordStatisticsResponseBody() = default;
};
class DescribeRecordStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRecordStatisticsResponseBody> body{};

  DescribeRecordStatisticsResponse() {}

  explicit DescribeRecordStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRecordStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRecordStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRecordStatisticsResponse() = default;
};
class DescribeRecordStatisticsSummaryRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> domainType{};
  shared_ptr<string> endDate{};
  shared_ptr<string> keyword{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchMode{};
  shared_ptr<string> startDate{};
  shared_ptr<long> threshold{};

  DescribeRecordStatisticsSummaryRequest() {}

  explicit DescribeRecordStatisticsSummaryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainType) {
      res["DomainType"] = boost::any(*domainType);
    }
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchMode) {
      res["SearchMode"] = boost::any(*searchMode);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainType") != m.end() && !m["DomainType"].empty()) {
      domainType = make_shared<string>(boost::any_cast<string>(m["DomainType"]));
    }
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchMode") != m.end() && !m["SearchMode"].empty()) {
      searchMode = make_shared<string>(boost::any_cast<string>(m["SearchMode"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<long>(boost::any_cast<long>(m["Threshold"]));
    }
  }


  virtual ~DescribeRecordStatisticsSummaryRequest() = default;
};
class DescribeRecordStatisticsSummaryResponseBodyStatisticsStatistic : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> subDomain{};

  DescribeRecordStatisticsSummaryResponseBodyStatisticsStatistic() {}

  explicit DescribeRecordStatisticsSummaryResponseBodyStatisticsStatistic(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (subDomain) {
      res["SubDomain"] = boost::any(*subDomain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("SubDomain") != m.end() && !m["SubDomain"].empty()) {
      subDomain = make_shared<string>(boost::any_cast<string>(m["SubDomain"]));
    }
  }


  virtual ~DescribeRecordStatisticsSummaryResponseBodyStatisticsStatistic() = default;
};
class DescribeRecordStatisticsSummaryResponseBodyStatistics : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRecordStatisticsSummaryResponseBodyStatisticsStatistic>> statistic{};

  DescribeRecordStatisticsSummaryResponseBodyStatistics() {}

  explicit DescribeRecordStatisticsSummaryResponseBodyStatistics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (statistic) {
      vector<boost::any> temp1;
      for(auto item1:*statistic){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Statistic"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Statistic") != m.end() && !m["Statistic"].empty()) {
      if (typeid(vector<boost::any>) == m["Statistic"].type()) {
        vector<DescribeRecordStatisticsSummaryResponseBodyStatisticsStatistic> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Statistic"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRecordStatisticsSummaryResponseBodyStatisticsStatistic model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        statistic = make_shared<vector<DescribeRecordStatisticsSummaryResponseBodyStatisticsStatistic>>(expect1);
      }
    }
  }


  virtual ~DescribeRecordStatisticsSummaryResponseBodyStatistics() = default;
};
class DescribeRecordStatisticsSummaryResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeRecordStatisticsSummaryResponseBodyStatistics> statistics{};
  shared_ptr<long> totalItems{};
  shared_ptr<long> totalPages{};

  DescribeRecordStatisticsSummaryResponseBody() {}

  explicit DescribeRecordStatisticsSummaryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (statistics) {
      res["Statistics"] = statistics ? boost::any(statistics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalItems) {
      res["TotalItems"] = boost::any(*totalItems);
    }
    if (totalPages) {
      res["TotalPages"] = boost::any(*totalPages);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      if (typeid(map<string, boost::any>) == m["Statistics"].type()) {
        DescribeRecordStatisticsSummaryResponseBodyStatistics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Statistics"]));
        statistics = make_shared<DescribeRecordStatisticsSummaryResponseBodyStatistics>(model1);
      }
    }
    if (m.find("TotalItems") != m.end() && !m["TotalItems"].empty()) {
      totalItems = make_shared<long>(boost::any_cast<long>(m["TotalItems"]));
    }
    if (m.find("TotalPages") != m.end() && !m["TotalPages"].empty()) {
      totalPages = make_shared<long>(boost::any_cast<long>(m["TotalPages"]));
    }
  }


  virtual ~DescribeRecordStatisticsSummaryResponseBody() = default;
};
class DescribeRecordStatisticsSummaryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRecordStatisticsSummaryResponseBody> body{};

  DescribeRecordStatisticsSummaryResponse() {}

  explicit DescribeRecordStatisticsSummaryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRecordStatisticsSummaryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRecordStatisticsSummaryResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRecordStatisticsSummaryResponse() = default;
};
class DescribeSubDomainRecordsRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> lang{};
  shared_ptr<string> line{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> subDomain{};
  shared_ptr<string> type{};
  shared_ptr<string> userClientIp{};

  DescribeSubDomainRecordsRequest() {}

  explicit DescribeSubDomainRecordsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (line) {
      res["Line"] = boost::any(*line);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (subDomain) {
      res["SubDomain"] = boost::any(*subDomain);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (userClientIp) {
      res["UserClientIp"] = boost::any(*userClientIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Line") != m.end() && !m["Line"].empty()) {
      line = make_shared<string>(boost::any_cast<string>(m["Line"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SubDomain") != m.end() && !m["SubDomain"].empty()) {
      subDomain = make_shared<string>(boost::any_cast<string>(m["SubDomain"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UserClientIp") != m.end() && !m["UserClientIp"].empty()) {
      userClientIp = make_shared<string>(boost::any_cast<string>(m["UserClientIp"]));
    }
  }


  virtual ~DescribeSubDomainRecordsRequest() = default;
};
class DescribeSubDomainRecordsResponseBodyDomainRecordsRecord : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> line{};
  shared_ptr<bool> locked{};
  shared_ptr<long> priority{};
  shared_ptr<string> RR{};
  shared_ptr<string> recordId{};
  shared_ptr<string> remark{};
  shared_ptr<string> status{};
  shared_ptr<long> TTL{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};
  shared_ptr<long> weight{};

  DescribeSubDomainRecordsResponseBodyDomainRecordsRecord() {}

  explicit DescribeSubDomainRecordsResponseBodyDomainRecordsRecord(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (line) {
      res["Line"] = boost::any(*line);
    }
    if (locked) {
      res["Locked"] = boost::any(*locked);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (RR) {
      res["RR"] = boost::any(*RR);
    }
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (TTL) {
      res["TTL"] = boost::any(*TTL);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Line") != m.end() && !m["Line"].empty()) {
      line = make_shared<string>(boost::any_cast<string>(m["Line"]));
    }
    if (m.find("Locked") != m.end() && !m["Locked"].empty()) {
      locked = make_shared<bool>(boost::any_cast<bool>(m["Locked"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("RR") != m.end() && !m["RR"].empty()) {
      RR = make_shared<string>(boost::any_cast<string>(m["RR"]));
    }
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<string>(boost::any_cast<string>(m["RecordId"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TTL") != m.end() && !m["TTL"].empty()) {
      TTL = make_shared<long>(boost::any_cast<long>(m["TTL"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~DescribeSubDomainRecordsResponseBodyDomainRecordsRecord() = default;
};
class DescribeSubDomainRecordsResponseBodyDomainRecords : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSubDomainRecordsResponseBodyDomainRecordsRecord>> record{};

  DescribeSubDomainRecordsResponseBodyDomainRecords() {}

  explicit DescribeSubDomainRecordsResponseBodyDomainRecords(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (record) {
      vector<boost::any> temp1;
      for(auto item1:*record){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Record"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Record") != m.end() && !m["Record"].empty()) {
      if (typeid(vector<boost::any>) == m["Record"].type()) {
        vector<DescribeSubDomainRecordsResponseBodyDomainRecordsRecord> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Record"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSubDomainRecordsResponseBodyDomainRecordsRecord model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        record = make_shared<vector<DescribeSubDomainRecordsResponseBodyDomainRecordsRecord>>(expect1);
      }
    }
  }


  virtual ~DescribeSubDomainRecordsResponseBodyDomainRecords() = default;
};
class DescribeSubDomainRecordsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeSubDomainRecordsResponseBodyDomainRecords> domainRecords{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeSubDomainRecordsResponseBody() {}

  explicit DescribeSubDomainRecordsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainRecords) {
      res["DomainRecords"] = domainRecords ? boost::any(domainRecords->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainRecords") != m.end() && !m["DomainRecords"].empty()) {
      if (typeid(map<string, boost::any>) == m["DomainRecords"].type()) {
        DescribeSubDomainRecordsResponseBodyDomainRecords model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DomainRecords"]));
        domainRecords = make_shared<DescribeSubDomainRecordsResponseBodyDomainRecords>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeSubDomainRecordsResponseBody() = default;
};
class DescribeSubDomainRecordsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSubDomainRecordsResponseBody> body{};

  DescribeSubDomainRecordsResponse() {}

  explicit DescribeSubDomainRecordsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSubDomainRecordsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSubDomainRecordsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSubDomainRecordsResponse() = default;
};
class DescribeSupportLinesRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> lang{};
  shared_ptr<string> userClientIp{};

  DescribeSupportLinesRequest() {}

  explicit DescribeSupportLinesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (userClientIp) {
      res["UserClientIp"] = boost::any(*userClientIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("UserClientIp") != m.end() && !m["UserClientIp"].empty()) {
      userClientIp = make_shared<string>(boost::any_cast<string>(m["UserClientIp"]));
    }
  }


  virtual ~DescribeSupportLinesRequest() = default;
};
class DescribeSupportLinesResponseBodyRecordLinesRecordLine : public Darabonba::Model {
public:
  shared_ptr<string> fatherCode{};
  shared_ptr<string> lineCode{};
  shared_ptr<string> lineDisplayName{};
  shared_ptr<string> lineName{};

  DescribeSupportLinesResponseBodyRecordLinesRecordLine() {}

  explicit DescribeSupportLinesResponseBodyRecordLinesRecordLine(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fatherCode) {
      res["FatherCode"] = boost::any(*fatherCode);
    }
    if (lineCode) {
      res["LineCode"] = boost::any(*lineCode);
    }
    if (lineDisplayName) {
      res["LineDisplayName"] = boost::any(*lineDisplayName);
    }
    if (lineName) {
      res["LineName"] = boost::any(*lineName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FatherCode") != m.end() && !m["FatherCode"].empty()) {
      fatherCode = make_shared<string>(boost::any_cast<string>(m["FatherCode"]));
    }
    if (m.find("LineCode") != m.end() && !m["LineCode"].empty()) {
      lineCode = make_shared<string>(boost::any_cast<string>(m["LineCode"]));
    }
    if (m.find("LineDisplayName") != m.end() && !m["LineDisplayName"].empty()) {
      lineDisplayName = make_shared<string>(boost::any_cast<string>(m["LineDisplayName"]));
    }
    if (m.find("LineName") != m.end() && !m["LineName"].empty()) {
      lineName = make_shared<string>(boost::any_cast<string>(m["LineName"]));
    }
  }


  virtual ~DescribeSupportLinesResponseBodyRecordLinesRecordLine() = default;
};
class DescribeSupportLinesResponseBodyRecordLines : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSupportLinesResponseBodyRecordLinesRecordLine>> recordLine{};

  DescribeSupportLinesResponseBodyRecordLines() {}

  explicit DescribeSupportLinesResponseBodyRecordLines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recordLine) {
      vector<boost::any> temp1;
      for(auto item1:*recordLine){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RecordLine"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecordLine") != m.end() && !m["RecordLine"].empty()) {
      if (typeid(vector<boost::any>) == m["RecordLine"].type()) {
        vector<DescribeSupportLinesResponseBodyRecordLinesRecordLine> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RecordLine"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSupportLinesResponseBodyRecordLinesRecordLine model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recordLine = make_shared<vector<DescribeSupportLinesResponseBodyRecordLinesRecordLine>>(expect1);
      }
    }
  }


  virtual ~DescribeSupportLinesResponseBodyRecordLines() = default;
};
class DescribeSupportLinesResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeSupportLinesResponseBodyRecordLines> recordLines{};
  shared_ptr<string> requestId{};

  DescribeSupportLinesResponseBody() {}

  explicit DescribeSupportLinesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recordLines) {
      res["RecordLines"] = recordLines ? boost::any(recordLines->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecordLines") != m.end() && !m["RecordLines"].empty()) {
      if (typeid(map<string, boost::any>) == m["RecordLines"].type()) {
        DescribeSupportLinesResponseBodyRecordLines model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RecordLines"]));
        recordLines = make_shared<DescribeSupportLinesResponseBodyRecordLines>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeSupportLinesResponseBody() = default;
};
class DescribeSupportLinesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSupportLinesResponseBody> body{};

  DescribeSupportLinesResponse() {}

  explicit DescribeSupportLinesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSupportLinesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSupportLinesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSupportLinesResponse() = default;
};
class DescribeTagsRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceType{};

  DescribeTagsRequest() {}

  explicit DescribeTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~DescribeTagsRequest() = default;
};
class DescribeTagsResponseBodyTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<vector<string>> values{};

  DescribeTagsResponseBodyTags() {}

  explicit DescribeTagsResponseBodyTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (values) {
      res["Values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Values"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Values"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      values = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeTagsResponseBodyTags() = default;
};
class DescribeTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeTagsResponseBodyTags>> tags{};
  shared_ptr<long> totalCount{};

  DescribeTagsResponseBody() {}

  explicit DescribeTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<DescribeTagsResponseBodyTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTagsResponseBodyTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<DescribeTagsResponseBodyTags>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeTagsResponseBody() = default;
};
class DescribeTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTagsResponseBody> body{};

  DescribeTagsResponse() {}

  explicit DescribeTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTagsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTagsResponse() = default;
};
class DescribeTransferDomainsRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> fromUserId{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> targetUserId{};
  shared_ptr<string> transferType{};

  DescribeTransferDomainsRequest() {}

  explicit DescribeTransferDomainsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (fromUserId) {
      res["FromUserId"] = boost::any(*fromUserId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (targetUserId) {
      res["TargetUserId"] = boost::any(*targetUserId);
    }
    if (transferType) {
      res["TransferType"] = boost::any(*transferType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("FromUserId") != m.end() && !m["FromUserId"].empty()) {
      fromUserId = make_shared<long>(boost::any_cast<long>(m["FromUserId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TargetUserId") != m.end() && !m["TargetUserId"].empty()) {
      targetUserId = make_shared<long>(boost::any_cast<long>(m["TargetUserId"]));
    }
    if (m.find("TransferType") != m.end() && !m["TransferType"].empty()) {
      transferType = make_shared<string>(boost::any_cast<string>(m["TransferType"]));
    }
  }


  virtual ~DescribeTransferDomainsRequest() = default;
};
class DescribeTransferDomainsResponseBodyDomainTransfersDomainTransfer : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<string> domainName{};
  shared_ptr<long> fromUserId{};
  shared_ptr<long> id{};
  shared_ptr<long> targetUserId{};

  DescribeTransferDomainsResponseBodyDomainTransfersDomainTransfer() {}

  explicit DescribeTransferDomainsResponseBodyDomainTransfersDomainTransfer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (fromUserId) {
      res["FromUserId"] = boost::any(*fromUserId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (targetUserId) {
      res["TargetUserId"] = boost::any(*targetUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("FromUserId") != m.end() && !m["FromUserId"].empty()) {
      fromUserId = make_shared<long>(boost::any_cast<long>(m["FromUserId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("TargetUserId") != m.end() && !m["TargetUserId"].empty()) {
      targetUserId = make_shared<long>(boost::any_cast<long>(m["TargetUserId"]));
    }
  }


  virtual ~DescribeTransferDomainsResponseBodyDomainTransfersDomainTransfer() = default;
};
class DescribeTransferDomainsResponseBodyDomainTransfers : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeTransferDomainsResponseBodyDomainTransfersDomainTransfer>> domainTransfer{};

  DescribeTransferDomainsResponseBodyDomainTransfers() {}

  explicit DescribeTransferDomainsResponseBodyDomainTransfers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainTransfer) {
      vector<boost::any> temp1;
      for(auto item1:*domainTransfer){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainTransfer"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainTransfer") != m.end() && !m["DomainTransfer"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainTransfer"].type()) {
        vector<DescribeTransferDomainsResponseBodyDomainTransfersDomainTransfer> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainTransfer"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTransferDomainsResponseBodyDomainTransfersDomainTransfer model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainTransfer = make_shared<vector<DescribeTransferDomainsResponseBodyDomainTransfersDomainTransfer>>(expect1);
      }
    }
  }


  virtual ~DescribeTransferDomainsResponseBodyDomainTransfers() = default;
};
class DescribeTransferDomainsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeTransferDomainsResponseBodyDomainTransfers> domainTransfers{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeTransferDomainsResponseBody() {}

  explicit DescribeTransferDomainsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainTransfers) {
      res["DomainTransfers"] = domainTransfers ? boost::any(domainTransfers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainTransfers") != m.end() && !m["DomainTransfers"].empty()) {
      if (typeid(map<string, boost::any>) == m["DomainTransfers"].type()) {
        DescribeTransferDomainsResponseBodyDomainTransfers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DomainTransfers"]));
        domainTransfers = make_shared<DescribeTransferDomainsResponseBodyDomainTransfers>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeTransferDomainsResponseBody() = default;
};
class DescribeTransferDomainsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTransferDomainsResponseBody> body{};

  DescribeTransferDomainsResponse() {}

  explicit DescribeTransferDomainsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTransferDomainsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTransferDomainsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTransferDomainsResponse() = default;
};
class ExecuteGtmRecoveryPlanRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> recoveryPlanId{};

  ExecuteGtmRecoveryPlanRequest() {}

  explicit ExecuteGtmRecoveryPlanRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (recoveryPlanId) {
      res["RecoveryPlanId"] = boost::any(*recoveryPlanId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("RecoveryPlanId") != m.end() && !m["RecoveryPlanId"].empty()) {
      recoveryPlanId = make_shared<long>(boost::any_cast<long>(m["RecoveryPlanId"]));
    }
  }


  virtual ~ExecuteGtmRecoveryPlanRequest() = default;
};
class ExecuteGtmRecoveryPlanResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ExecuteGtmRecoveryPlanResponseBody() {}

  explicit ExecuteGtmRecoveryPlanResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ExecuteGtmRecoveryPlanResponseBody() = default;
};
class ExecuteGtmRecoveryPlanResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExecuteGtmRecoveryPlanResponseBody> body{};

  ExecuteGtmRecoveryPlanResponse() {}

  explicit ExecuteGtmRecoveryPlanResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExecuteGtmRecoveryPlanResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExecuteGtmRecoveryPlanResponseBody>(model1);
      }
    }
  }


  virtual ~ExecuteGtmRecoveryPlanResponse() = default;
};
class GetMainDomainNameRequest : public Darabonba::Model {
public:
  shared_ptr<string> inputString{};
  shared_ptr<string> lang{};

  GetMainDomainNameRequest() {}

  explicit GetMainDomainNameRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputString) {
      res["InputString"] = boost::any(*inputString);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputString") != m.end() && !m["InputString"].empty()) {
      inputString = make_shared<string>(boost::any_cast<string>(m["InputString"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~GetMainDomainNameRequest() = default;
};
class GetMainDomainNameResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> domainLevel{};
  shared_ptr<string> domainName{};
  shared_ptr<string> RR{};
  shared_ptr<string> requestId{};

  GetMainDomainNameResponseBody() {}

  explicit GetMainDomainNameResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainLevel) {
      res["DomainLevel"] = boost::any(*domainLevel);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (RR) {
      res["RR"] = boost::any(*RR);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainLevel") != m.end() && !m["DomainLevel"].empty()) {
      domainLevel = make_shared<long>(boost::any_cast<long>(m["DomainLevel"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("RR") != m.end() && !m["RR"].empty()) {
      RR = make_shared<string>(boost::any_cast<string>(m["RR"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetMainDomainNameResponseBody() = default;
};
class GetMainDomainNameResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMainDomainNameResponseBody> body{};

  GetMainDomainNameResponse() {}

  explicit GetMainDomainNameResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMainDomainNameResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMainDomainNameResponseBody>(model1);
      }
    }
  }


  virtual ~GetMainDomainNameResponse() = default;
};
class GetTxtRecordForVerifyRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> lang{};
  shared_ptr<string> type{};

  GetTxtRecordForVerifyRequest() {}

  explicit GetTxtRecordForVerifyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetTxtRecordForVerifyRequest() = default;
};
class GetTxtRecordForVerifyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> parentDomainName{};
  shared_ptr<string> RR{};
  shared_ptr<string> requestId{};
  shared_ptr<string> value{};

  GetTxtRecordForVerifyResponseBody() {}

  explicit GetTxtRecordForVerifyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (parentDomainName) {
      res["ParentDomainName"] = boost::any(*parentDomainName);
    }
    if (RR) {
      res["RR"] = boost::any(*RR);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("ParentDomainName") != m.end() && !m["ParentDomainName"].empty()) {
      parentDomainName = make_shared<string>(boost::any_cast<string>(m["ParentDomainName"]));
    }
    if (m.find("RR") != m.end() && !m["RR"].empty()) {
      RR = make_shared<string>(boost::any_cast<string>(m["RR"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetTxtRecordForVerifyResponseBody() = default;
};
class GetTxtRecordForVerifyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTxtRecordForVerifyResponseBody> body{};

  GetTxtRecordForVerifyResponse() {}

  explicit GetTxtRecordForVerifyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTxtRecordForVerifyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTxtRecordForVerifyResponseBody>(model1);
      }
    }
  }


  virtual ~GetTxtRecordForVerifyResponse() = default;
};
class ListCloudGtmAddressPoolsRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> addressPoolName{};
  shared_ptr<string> addressPoolType{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> enableStatus{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> remark{};

  ListCloudGtmAddressPoolsRequest() {}

  explicit ListCloudGtmAddressPoolsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (addressPoolName) {
      res["AddressPoolName"] = boost::any(*addressPoolName);
    }
    if (addressPoolType) {
      res["AddressPoolType"] = boost::any(*addressPoolType);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (enableStatus) {
      res["EnableStatus"] = boost::any(*enableStatus);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AddressPoolName") != m.end() && !m["AddressPoolName"].empty()) {
      addressPoolName = make_shared<string>(boost::any_cast<string>(m["AddressPoolName"]));
    }
    if (m.find("AddressPoolType") != m.end() && !m["AddressPoolType"].empty()) {
      addressPoolType = make_shared<string>(boost::any_cast<string>(m["AddressPoolType"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("EnableStatus") != m.end() && !m["EnableStatus"].empty()) {
      enableStatus = make_shared<string>(boost::any_cast<string>(m["EnableStatus"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
  }


  virtual ~ListCloudGtmAddressPoolsRequest() = default;
};
class ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressHealthTasksHealthTask : public Darabonba::Model {
public:
  shared_ptr<long> port{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateName{};

  ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressHealthTasksHealthTask() {}

  explicit ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressHealthTasksHealthTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
  }


  virtual ~ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressHealthTasksHealthTask() = default;
};
class ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressHealthTasks : public Darabonba::Model {
public:
  shared_ptr<vector<ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressHealthTasksHealthTask>> healthTask{};

  ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressHealthTasks() {}

  explicit ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressHealthTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (healthTask) {
      vector<boost::any> temp1;
      for(auto item1:*healthTask){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HealthTask"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HealthTask") != m.end() && !m["HealthTask"].empty()) {
      if (typeid(vector<boost::any>) == m["HealthTask"].type()) {
        vector<ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressHealthTasksHealthTask> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HealthTask"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressHealthTasksHealthTask model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        healthTask = make_shared<vector<ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressHealthTasksHealthTask>>(expect1);
      }
    }
  }


  virtual ~ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressHealthTasks() = default;
};
class ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressRequestSource : public Darabonba::Model {
public:
  shared_ptr<vector<string>> requestSource{};

  ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressRequestSource() {}

  explicit ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressRequestSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestSource) {
      res["RequestSource"] = boost::any(*requestSource);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestSource") != m.end() && !m["RequestSource"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RequestSource"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RequestSource"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      requestSource = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressRequestSource() = default;
};
class ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddress : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> addressId{};
  shared_ptr<string> attributeInfo{};
  shared_ptr<string> availableMode{};
  shared_ptr<string> availableStatus{};
  shared_ptr<string> createTime{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<string> enableStatus{};
  shared_ptr<string> healthJudgement{};
  shared_ptr<string> healthStatus{};
  shared_ptr<ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressHealthTasks> healthTasks{};
  shared_ptr<string> manualAvailableStatus{};
  shared_ptr<string> name{};
  shared_ptr<string> remark{};
  shared_ptr<ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressRequestSource> requestSource{};
  shared_ptr<bool> seqNonPreemptiveSchedule{};
  shared_ptr<long> serialNumber{};
  shared_ptr<string> type{};
  shared_ptr<string> updateTime{};
  shared_ptr<long> updateTimestamp{};
  shared_ptr<long> weightValue{};

  ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddress() {}

  explicit ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (addressId) {
      res["AddressId"] = boost::any(*addressId);
    }
    if (attributeInfo) {
      res["AttributeInfo"] = boost::any(*attributeInfo);
    }
    if (availableMode) {
      res["AvailableMode"] = boost::any(*availableMode);
    }
    if (availableStatus) {
      res["AvailableStatus"] = boost::any(*availableStatus);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (enableStatus) {
      res["EnableStatus"] = boost::any(*enableStatus);
    }
    if (healthJudgement) {
      res["HealthJudgement"] = boost::any(*healthJudgement);
    }
    if (healthStatus) {
      res["HealthStatus"] = boost::any(*healthStatus);
    }
    if (healthTasks) {
      res["HealthTasks"] = healthTasks ? boost::any(healthTasks->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (manualAvailableStatus) {
      res["ManualAvailableStatus"] = boost::any(*manualAvailableStatus);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (requestSource) {
      res["RequestSource"] = requestSource ? boost::any(requestSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (seqNonPreemptiveSchedule) {
      res["SeqNonPreemptiveSchedule"] = boost::any(*seqNonPreemptiveSchedule);
    }
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (updateTimestamp) {
      res["UpdateTimestamp"] = boost::any(*updateTimestamp);
    }
    if (weightValue) {
      res["WeightValue"] = boost::any(*weightValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("AddressId") != m.end() && !m["AddressId"].empty()) {
      addressId = make_shared<string>(boost::any_cast<string>(m["AddressId"]));
    }
    if (m.find("AttributeInfo") != m.end() && !m["AttributeInfo"].empty()) {
      attributeInfo = make_shared<string>(boost::any_cast<string>(m["AttributeInfo"]));
    }
    if (m.find("AvailableMode") != m.end() && !m["AvailableMode"].empty()) {
      availableMode = make_shared<string>(boost::any_cast<string>(m["AvailableMode"]));
    }
    if (m.find("AvailableStatus") != m.end() && !m["AvailableStatus"].empty()) {
      availableStatus = make_shared<string>(boost::any_cast<string>(m["AvailableStatus"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("EnableStatus") != m.end() && !m["EnableStatus"].empty()) {
      enableStatus = make_shared<string>(boost::any_cast<string>(m["EnableStatus"]));
    }
    if (m.find("HealthJudgement") != m.end() && !m["HealthJudgement"].empty()) {
      healthJudgement = make_shared<string>(boost::any_cast<string>(m["HealthJudgement"]));
    }
    if (m.find("HealthStatus") != m.end() && !m["HealthStatus"].empty()) {
      healthStatus = make_shared<string>(boost::any_cast<string>(m["HealthStatus"]));
    }
    if (m.find("HealthTasks") != m.end() && !m["HealthTasks"].empty()) {
      if (typeid(map<string, boost::any>) == m["HealthTasks"].type()) {
        ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressHealthTasks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HealthTasks"]));
        healthTasks = make_shared<ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressHealthTasks>(model1);
      }
    }
    if (m.find("ManualAvailableStatus") != m.end() && !m["ManualAvailableStatus"].empty()) {
      manualAvailableStatus = make_shared<string>(boost::any_cast<string>(m["ManualAvailableStatus"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("RequestSource") != m.end() && !m["RequestSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["RequestSource"].type()) {
        ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressRequestSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RequestSource"]));
        requestSource = make_shared<ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressRequestSource>(model1);
      }
    }
    if (m.find("SeqNonPreemptiveSchedule") != m.end() && !m["SeqNonPreemptiveSchedule"].empty()) {
      seqNonPreemptiveSchedule = make_shared<bool>(boost::any_cast<bool>(m["SeqNonPreemptiveSchedule"]));
    }
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<long>(boost::any_cast<long>(m["SerialNumber"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("UpdateTimestamp") != m.end() && !m["UpdateTimestamp"].empty()) {
      updateTimestamp = make_shared<long>(boost::any_cast<long>(m["UpdateTimestamp"]));
    }
    if (m.find("WeightValue") != m.end() && !m["WeightValue"].empty()) {
      weightValue = make_shared<long>(boost::any_cast<long>(m["WeightValue"]));
    }
  }


  virtual ~ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddress() = default;
};
class ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddresses : public Darabonba::Model {
public:
  shared_ptr<vector<ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddress>> address{};

  ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddresses() {}

  explicit ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddresses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      vector<boost::any> temp1;
      for(auto item1:*address){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Address"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      if (typeid(vector<boost::any>) == m["Address"].type()) {
        vector<ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddress> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Address"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddress model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        address = make_shared<vector<ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddress>>(expect1);
      }
    }
  }


  virtual ~ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddresses() = default;
};
class ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPool : public Darabonba::Model {
public:
  shared_ptr<string> addressLbStrategy{};
  shared_ptr<string> addressPoolId{};
  shared_ptr<string> addressPoolName{};
  shared_ptr<string> addressPoolType{};
  shared_ptr<ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddresses> addresses{};
  shared_ptr<string> availableStatus{};
  shared_ptr<string> createTime{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<string> enableStatus{};
  shared_ptr<string> healthJudgement{};
  shared_ptr<string> healthStatus{};
  shared_ptr<string> remark{};
  shared_ptr<string> sequenceLbStrategyMode{};
  shared_ptr<string> updateTime{};
  shared_ptr<long> updateTimestamp{};

  ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPool() {}

  explicit ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPool(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addressLbStrategy) {
      res["AddressLbStrategy"] = boost::any(*addressLbStrategy);
    }
    if (addressPoolId) {
      res["AddressPoolId"] = boost::any(*addressPoolId);
    }
    if (addressPoolName) {
      res["AddressPoolName"] = boost::any(*addressPoolName);
    }
    if (addressPoolType) {
      res["AddressPoolType"] = boost::any(*addressPoolType);
    }
    if (addresses) {
      res["Addresses"] = addresses ? boost::any(addresses->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (availableStatus) {
      res["AvailableStatus"] = boost::any(*availableStatus);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (enableStatus) {
      res["EnableStatus"] = boost::any(*enableStatus);
    }
    if (healthJudgement) {
      res["HealthJudgement"] = boost::any(*healthJudgement);
    }
    if (healthStatus) {
      res["HealthStatus"] = boost::any(*healthStatus);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (sequenceLbStrategyMode) {
      res["SequenceLbStrategyMode"] = boost::any(*sequenceLbStrategyMode);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (updateTimestamp) {
      res["UpdateTimestamp"] = boost::any(*updateTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddressLbStrategy") != m.end() && !m["AddressLbStrategy"].empty()) {
      addressLbStrategy = make_shared<string>(boost::any_cast<string>(m["AddressLbStrategy"]));
    }
    if (m.find("AddressPoolId") != m.end() && !m["AddressPoolId"].empty()) {
      addressPoolId = make_shared<string>(boost::any_cast<string>(m["AddressPoolId"]));
    }
    if (m.find("AddressPoolName") != m.end() && !m["AddressPoolName"].empty()) {
      addressPoolName = make_shared<string>(boost::any_cast<string>(m["AddressPoolName"]));
    }
    if (m.find("AddressPoolType") != m.end() && !m["AddressPoolType"].empty()) {
      addressPoolType = make_shared<string>(boost::any_cast<string>(m["AddressPoolType"]));
    }
    if (m.find("Addresses") != m.end() && !m["Addresses"].empty()) {
      if (typeid(map<string, boost::any>) == m["Addresses"].type()) {
        ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddresses model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Addresses"]));
        addresses = make_shared<ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddresses>(model1);
      }
    }
    if (m.find("AvailableStatus") != m.end() && !m["AvailableStatus"].empty()) {
      availableStatus = make_shared<string>(boost::any_cast<string>(m["AvailableStatus"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("EnableStatus") != m.end() && !m["EnableStatus"].empty()) {
      enableStatus = make_shared<string>(boost::any_cast<string>(m["EnableStatus"]));
    }
    if (m.find("HealthJudgement") != m.end() && !m["HealthJudgement"].empty()) {
      healthJudgement = make_shared<string>(boost::any_cast<string>(m["HealthJudgement"]));
    }
    if (m.find("HealthStatus") != m.end() && !m["HealthStatus"].empty()) {
      healthStatus = make_shared<string>(boost::any_cast<string>(m["HealthStatus"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("SequenceLbStrategyMode") != m.end() && !m["SequenceLbStrategyMode"].empty()) {
      sequenceLbStrategyMode = make_shared<string>(boost::any_cast<string>(m["SequenceLbStrategyMode"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("UpdateTimestamp") != m.end() && !m["UpdateTimestamp"].empty()) {
      updateTimestamp = make_shared<long>(boost::any_cast<long>(m["UpdateTimestamp"]));
    }
  }


  virtual ~ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPool() = default;
};
class ListCloudGtmAddressPoolsResponseBodyAddressPools : public Darabonba::Model {
public:
  shared_ptr<vector<ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPool>> addressPool{};

  ListCloudGtmAddressPoolsResponseBodyAddressPools() {}

  explicit ListCloudGtmAddressPoolsResponseBodyAddressPools(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addressPool) {
      vector<boost::any> temp1;
      for(auto item1:*addressPool){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AddressPool"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddressPool") != m.end() && !m["AddressPool"].empty()) {
      if (typeid(vector<boost::any>) == m["AddressPool"].type()) {
        vector<ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPool> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AddressPool"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPool model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        addressPool = make_shared<vector<ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPool>>(expect1);
      }
    }
  }


  virtual ~ListCloudGtmAddressPoolsResponseBodyAddressPools() = default;
};
class ListCloudGtmAddressPoolsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListCloudGtmAddressPoolsResponseBodyAddressPools> addressPools{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalItems{};
  shared_ptr<long> totalPages{};

  ListCloudGtmAddressPoolsResponseBody() {}

  explicit ListCloudGtmAddressPoolsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addressPools) {
      res["AddressPools"] = addressPools ? boost::any(addressPools->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalItems) {
      res["TotalItems"] = boost::any(*totalItems);
    }
    if (totalPages) {
      res["TotalPages"] = boost::any(*totalPages);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddressPools") != m.end() && !m["AddressPools"].empty()) {
      if (typeid(map<string, boost::any>) == m["AddressPools"].type()) {
        ListCloudGtmAddressPoolsResponseBodyAddressPools model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AddressPools"]));
        addressPools = make_shared<ListCloudGtmAddressPoolsResponseBodyAddressPools>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalItems") != m.end() && !m["TotalItems"].empty()) {
      totalItems = make_shared<long>(boost::any_cast<long>(m["TotalItems"]));
    }
    if (m.find("TotalPages") != m.end() && !m["TotalPages"].empty()) {
      totalPages = make_shared<long>(boost::any_cast<long>(m["TotalPages"]));
    }
  }


  virtual ~ListCloudGtmAddressPoolsResponseBody() = default;
};
class ListCloudGtmAddressPoolsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCloudGtmAddressPoolsResponseBody> body{};

  ListCloudGtmAddressPoolsResponse() {}

  explicit ListCloudGtmAddressPoolsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCloudGtmAddressPoolsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCloudGtmAddressPoolsResponseBody>(model1);
      }
    }
  }


  virtual ~ListCloudGtmAddressPoolsResponse() = default;
};
class ListCloudGtmAddressesRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> address{};
  shared_ptr<string> addressId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> enableStatus{};
  shared_ptr<string> healthStatus{};
  shared_ptr<string> monitorTemplateId{};
  shared_ptr<string> name{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> type{};

  ListCloudGtmAddressesRequest() {}

  explicit ListCloudGtmAddressesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (addressId) {
      res["AddressId"] = boost::any(*addressId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (enableStatus) {
      res["EnableStatus"] = boost::any(*enableStatus);
    }
    if (healthStatus) {
      res["HealthStatus"] = boost::any(*healthStatus);
    }
    if (monitorTemplateId) {
      res["MonitorTemplateId"] = boost::any(*monitorTemplateId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("AddressId") != m.end() && !m["AddressId"].empty()) {
      addressId = make_shared<string>(boost::any_cast<string>(m["AddressId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("EnableStatus") != m.end() && !m["EnableStatus"].empty()) {
      enableStatus = make_shared<string>(boost::any_cast<string>(m["EnableStatus"]));
    }
    if (m.find("HealthStatus") != m.end() && !m["HealthStatus"].empty()) {
      healthStatus = make_shared<string>(boost::any_cast<string>(m["HealthStatus"]));
    }
    if (m.find("MonitorTemplateId") != m.end() && !m["MonitorTemplateId"].empty()) {
      monitorTemplateId = make_shared<string>(boost::any_cast<string>(m["MonitorTemplateId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListCloudGtmAddressesRequest() = default;
};
class ListCloudGtmAddressesResponseBodyAddressesAddressHealthTasksHealthTask : public Darabonba::Model {
public:
  shared_ptr<string> monitorStatus{};
  shared_ptr<long> port{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateName{};

  ListCloudGtmAddressesResponseBodyAddressesAddressHealthTasksHealthTask() {}

  explicit ListCloudGtmAddressesResponseBodyAddressesAddressHealthTasksHealthTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (monitorStatus) {
      res["MonitorStatus"] = boost::any(*monitorStatus);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MonitorStatus") != m.end() && !m["MonitorStatus"].empty()) {
      monitorStatus = make_shared<string>(boost::any_cast<string>(m["MonitorStatus"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
  }


  virtual ~ListCloudGtmAddressesResponseBodyAddressesAddressHealthTasksHealthTask() = default;
};
class ListCloudGtmAddressesResponseBodyAddressesAddressHealthTasks : public Darabonba::Model {
public:
  shared_ptr<vector<ListCloudGtmAddressesResponseBodyAddressesAddressHealthTasksHealthTask>> healthTask{};

  ListCloudGtmAddressesResponseBodyAddressesAddressHealthTasks() {}

  explicit ListCloudGtmAddressesResponseBodyAddressesAddressHealthTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (healthTask) {
      vector<boost::any> temp1;
      for(auto item1:*healthTask){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HealthTask"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HealthTask") != m.end() && !m["HealthTask"].empty()) {
      if (typeid(vector<boost::any>) == m["HealthTask"].type()) {
        vector<ListCloudGtmAddressesResponseBodyAddressesAddressHealthTasksHealthTask> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HealthTask"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCloudGtmAddressesResponseBodyAddressesAddressHealthTasksHealthTask model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        healthTask = make_shared<vector<ListCloudGtmAddressesResponseBodyAddressesAddressHealthTasksHealthTask>>(expect1);
      }
    }
  }


  virtual ~ListCloudGtmAddressesResponseBodyAddressesAddressHealthTasks() = default;
};
class ListCloudGtmAddressesResponseBodyAddressesAddress : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> addressId{};
  shared_ptr<string> attributeInfo{};
  shared_ptr<string> availableMode{};
  shared_ptr<string> availableStatus{};
  shared_ptr<string> createTime{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<string> enableStatus{};
  shared_ptr<string> healthJudgement{};
  shared_ptr<string> healthStatus{};
  shared_ptr<ListCloudGtmAddressesResponseBodyAddressesAddressHealthTasks> healthTasks{};
  shared_ptr<string> manualAvailableStatus{};
  shared_ptr<string> name{};
  shared_ptr<string> remark{};
  shared_ptr<string> type{};
  shared_ptr<string> updateTime{};
  shared_ptr<long> updateTimestamp{};

  ListCloudGtmAddressesResponseBodyAddressesAddress() {}

  explicit ListCloudGtmAddressesResponseBodyAddressesAddress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (addressId) {
      res["AddressId"] = boost::any(*addressId);
    }
    if (attributeInfo) {
      res["AttributeInfo"] = boost::any(*attributeInfo);
    }
    if (availableMode) {
      res["AvailableMode"] = boost::any(*availableMode);
    }
    if (availableStatus) {
      res["AvailableStatus"] = boost::any(*availableStatus);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (enableStatus) {
      res["EnableStatus"] = boost::any(*enableStatus);
    }
    if (healthJudgement) {
      res["HealthJudgement"] = boost::any(*healthJudgement);
    }
    if (healthStatus) {
      res["HealthStatus"] = boost::any(*healthStatus);
    }
    if (healthTasks) {
      res["HealthTasks"] = healthTasks ? boost::any(healthTasks->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (manualAvailableStatus) {
      res["ManualAvailableStatus"] = boost::any(*manualAvailableStatus);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (updateTimestamp) {
      res["UpdateTimestamp"] = boost::any(*updateTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("AddressId") != m.end() && !m["AddressId"].empty()) {
      addressId = make_shared<string>(boost::any_cast<string>(m["AddressId"]));
    }
    if (m.find("AttributeInfo") != m.end() && !m["AttributeInfo"].empty()) {
      attributeInfo = make_shared<string>(boost::any_cast<string>(m["AttributeInfo"]));
    }
    if (m.find("AvailableMode") != m.end() && !m["AvailableMode"].empty()) {
      availableMode = make_shared<string>(boost::any_cast<string>(m["AvailableMode"]));
    }
    if (m.find("AvailableStatus") != m.end() && !m["AvailableStatus"].empty()) {
      availableStatus = make_shared<string>(boost::any_cast<string>(m["AvailableStatus"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("EnableStatus") != m.end() && !m["EnableStatus"].empty()) {
      enableStatus = make_shared<string>(boost::any_cast<string>(m["EnableStatus"]));
    }
    if (m.find("HealthJudgement") != m.end() && !m["HealthJudgement"].empty()) {
      healthJudgement = make_shared<string>(boost::any_cast<string>(m["HealthJudgement"]));
    }
    if (m.find("HealthStatus") != m.end() && !m["HealthStatus"].empty()) {
      healthStatus = make_shared<string>(boost::any_cast<string>(m["HealthStatus"]));
    }
    if (m.find("HealthTasks") != m.end() && !m["HealthTasks"].empty()) {
      if (typeid(map<string, boost::any>) == m["HealthTasks"].type()) {
        ListCloudGtmAddressesResponseBodyAddressesAddressHealthTasks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HealthTasks"]));
        healthTasks = make_shared<ListCloudGtmAddressesResponseBodyAddressesAddressHealthTasks>(model1);
      }
    }
    if (m.find("ManualAvailableStatus") != m.end() && !m["ManualAvailableStatus"].empty()) {
      manualAvailableStatus = make_shared<string>(boost::any_cast<string>(m["ManualAvailableStatus"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("UpdateTimestamp") != m.end() && !m["UpdateTimestamp"].empty()) {
      updateTimestamp = make_shared<long>(boost::any_cast<long>(m["UpdateTimestamp"]));
    }
  }


  virtual ~ListCloudGtmAddressesResponseBodyAddressesAddress() = default;
};
class ListCloudGtmAddressesResponseBodyAddresses : public Darabonba::Model {
public:
  shared_ptr<vector<ListCloudGtmAddressesResponseBodyAddressesAddress>> address{};

  ListCloudGtmAddressesResponseBodyAddresses() {}

  explicit ListCloudGtmAddressesResponseBodyAddresses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      vector<boost::any> temp1;
      for(auto item1:*address){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Address"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      if (typeid(vector<boost::any>) == m["Address"].type()) {
        vector<ListCloudGtmAddressesResponseBodyAddressesAddress> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Address"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCloudGtmAddressesResponseBodyAddressesAddress model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        address = make_shared<vector<ListCloudGtmAddressesResponseBodyAddressesAddress>>(expect1);
      }
    }
  }


  virtual ~ListCloudGtmAddressesResponseBodyAddresses() = default;
};
class ListCloudGtmAddressesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListCloudGtmAddressesResponseBodyAddresses> addresses{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalItems{};
  shared_ptr<long> totalPages{};

  ListCloudGtmAddressesResponseBody() {}

  explicit ListCloudGtmAddressesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addresses) {
      res["Addresses"] = addresses ? boost::any(addresses->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalItems) {
      res["TotalItems"] = boost::any(*totalItems);
    }
    if (totalPages) {
      res["TotalPages"] = boost::any(*totalPages);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Addresses") != m.end() && !m["Addresses"].empty()) {
      if (typeid(map<string, boost::any>) == m["Addresses"].type()) {
        ListCloudGtmAddressesResponseBodyAddresses model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Addresses"]));
        addresses = make_shared<ListCloudGtmAddressesResponseBodyAddresses>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalItems") != m.end() && !m["TotalItems"].empty()) {
      totalItems = make_shared<long>(boost::any_cast<long>(m["TotalItems"]));
    }
    if (m.find("TotalPages") != m.end() && !m["TotalPages"].empty()) {
      totalPages = make_shared<long>(boost::any_cast<long>(m["TotalPages"]));
    }
  }


  virtual ~ListCloudGtmAddressesResponseBody() = default;
};
class ListCloudGtmAddressesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCloudGtmAddressesResponseBody> body{};

  ListCloudGtmAddressesResponse() {}

  explicit ListCloudGtmAddressesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCloudGtmAddressesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCloudGtmAddressesResponseBody>(model1);
      }
    }
  }


  virtual ~ListCloudGtmAddressesResponse() = default;
};
class ListCloudGtmAlertLogsRequest : public Darabonba::Model {
public:
  shared_ptr<string> actionType{};
  shared_ptr<long> endTimestamp{};
  shared_ptr<string> entityType{};
  shared_ptr<string> keyword{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> startTimestamp{};

  ListCloudGtmAlertLogsRequest() {}

  explicit ListCloudGtmAlertLogsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionType) {
      res["ActionType"] = boost::any(*actionType);
    }
    if (endTimestamp) {
      res["EndTimestamp"] = boost::any(*endTimestamp);
    }
    if (entityType) {
      res["EntityType"] = boost::any(*entityType);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTimestamp) {
      res["StartTimestamp"] = boost::any(*startTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionType") != m.end() && !m["ActionType"].empty()) {
      actionType = make_shared<string>(boost::any_cast<string>(m["ActionType"]));
    }
    if (m.find("EndTimestamp") != m.end() && !m["EndTimestamp"].empty()) {
      endTimestamp = make_shared<long>(boost::any_cast<long>(m["EndTimestamp"]));
    }
    if (m.find("EntityType") != m.end() && !m["EntityType"].empty()) {
      entityType = make_shared<string>(boost::any_cast<string>(m["EntityType"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTimestamp") != m.end() && !m["StartTimestamp"].empty()) {
      startTimestamp = make_shared<long>(boost::any_cast<long>(m["StartTimestamp"]));
    }
  }


  virtual ~ListCloudGtmAlertLogsRequest() = default;
};
class ListCloudGtmAlertLogsResponseBodyLogsLog : public Darabonba::Model {
public:
  shared_ptr<string> actionType{};
  shared_ptr<string> content{};
  shared_ptr<string> entityType{};
  shared_ptr<long> timestamp{};

  ListCloudGtmAlertLogsResponseBodyLogsLog() {}

  explicit ListCloudGtmAlertLogsResponseBodyLogsLog(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionType) {
      res["ActionType"] = boost::any(*actionType);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (entityType) {
      res["EntityType"] = boost::any(*entityType);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionType") != m.end() && !m["ActionType"].empty()) {
      actionType = make_shared<string>(boost::any_cast<string>(m["ActionType"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("EntityType") != m.end() && !m["EntityType"].empty()) {
      entityType = make_shared<string>(boost::any_cast<string>(m["EntityType"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
  }


  virtual ~ListCloudGtmAlertLogsResponseBodyLogsLog() = default;
};
class ListCloudGtmAlertLogsResponseBodyLogs : public Darabonba::Model {
public:
  shared_ptr<vector<ListCloudGtmAlertLogsResponseBodyLogsLog>> log{};

  ListCloudGtmAlertLogsResponseBodyLogs() {}

  explicit ListCloudGtmAlertLogsResponseBodyLogs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (log) {
      vector<boost::any> temp1;
      for(auto item1:*log){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Log"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Log") != m.end() && !m["Log"].empty()) {
      if (typeid(vector<boost::any>) == m["Log"].type()) {
        vector<ListCloudGtmAlertLogsResponseBodyLogsLog> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Log"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCloudGtmAlertLogsResponseBodyLogsLog model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        log = make_shared<vector<ListCloudGtmAlertLogsResponseBodyLogsLog>>(expect1);
      }
    }
  }


  virtual ~ListCloudGtmAlertLogsResponseBodyLogs() = default;
};
class ListCloudGtmAlertLogsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListCloudGtmAlertLogsResponseBodyLogs> logs{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalItems{};
  shared_ptr<long> totalPages{};

  ListCloudGtmAlertLogsResponseBody() {}

  explicit ListCloudGtmAlertLogsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logs) {
      res["Logs"] = logs ? boost::any(logs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalItems) {
      res["TotalItems"] = boost::any(*totalItems);
    }
    if (totalPages) {
      res["TotalPages"] = boost::any(*totalPages);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Logs") != m.end() && !m["Logs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Logs"].type()) {
        ListCloudGtmAlertLogsResponseBodyLogs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Logs"]));
        logs = make_shared<ListCloudGtmAlertLogsResponseBodyLogs>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalItems") != m.end() && !m["TotalItems"].empty()) {
      totalItems = make_shared<long>(boost::any_cast<long>(m["TotalItems"]));
    }
    if (m.find("TotalPages") != m.end() && !m["TotalPages"].empty()) {
      totalPages = make_shared<long>(boost::any_cast<long>(m["TotalPages"]));
    }
  }


  virtual ~ListCloudGtmAlertLogsResponseBody() = default;
};
class ListCloudGtmAlertLogsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCloudGtmAlertLogsResponseBody> body{};

  ListCloudGtmAlertLogsResponse() {}

  explicit ListCloudGtmAlertLogsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCloudGtmAlertLogsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCloudGtmAlertLogsResponseBody>(model1);
      }
    }
  }


  virtual ~ListCloudGtmAlertLogsResponse() = default;
};
class ListCloudGtmAvailableAlertGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};

  ListCloudGtmAvailableAlertGroupsRequest() {}

  explicit ListCloudGtmAvailableAlertGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
  }


  virtual ~ListCloudGtmAvailableAlertGroupsRequest() = default;
};
class ListCloudGtmAvailableAlertGroupsResponseBodyAlertGroupsAlertGroup : public Darabonba::Model {
public:
  shared_ptr<string> groupName{};

  ListCloudGtmAvailableAlertGroupsResponseBodyAlertGroupsAlertGroup() {}

  explicit ListCloudGtmAvailableAlertGroupsResponseBodyAlertGroupsAlertGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
  }


  virtual ~ListCloudGtmAvailableAlertGroupsResponseBodyAlertGroupsAlertGroup() = default;
};
class ListCloudGtmAvailableAlertGroupsResponseBodyAlertGroups : public Darabonba::Model {
public:
  shared_ptr<vector<ListCloudGtmAvailableAlertGroupsResponseBodyAlertGroupsAlertGroup>> alertGroup{};

  ListCloudGtmAvailableAlertGroupsResponseBodyAlertGroups() {}

  explicit ListCloudGtmAvailableAlertGroupsResponseBodyAlertGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertGroup) {
      vector<boost::any> temp1;
      for(auto item1:*alertGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlertGroup"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertGroup") != m.end() && !m["AlertGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["AlertGroup"].type()) {
        vector<ListCloudGtmAvailableAlertGroupsResponseBodyAlertGroupsAlertGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlertGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCloudGtmAvailableAlertGroupsResponseBodyAlertGroupsAlertGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alertGroup = make_shared<vector<ListCloudGtmAvailableAlertGroupsResponseBodyAlertGroupsAlertGroup>>(expect1);
      }
    }
  }


  virtual ~ListCloudGtmAvailableAlertGroupsResponseBodyAlertGroups() = default;
};
class ListCloudGtmAvailableAlertGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListCloudGtmAvailableAlertGroupsResponseBodyAlertGroups> alertGroups{};
  shared_ptr<string> requestId{};

  ListCloudGtmAvailableAlertGroupsResponseBody() {}

  explicit ListCloudGtmAvailableAlertGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertGroups) {
      res["AlertGroups"] = alertGroups ? boost::any(alertGroups->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertGroups") != m.end() && !m["AlertGroups"].empty()) {
      if (typeid(map<string, boost::any>) == m["AlertGroups"].type()) {
        ListCloudGtmAvailableAlertGroupsResponseBodyAlertGroups model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AlertGroups"]));
        alertGroups = make_shared<ListCloudGtmAvailableAlertGroupsResponseBodyAlertGroups>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListCloudGtmAvailableAlertGroupsResponseBody() = default;
};
class ListCloudGtmAvailableAlertGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCloudGtmAvailableAlertGroupsResponseBody> body{};

  ListCloudGtmAvailableAlertGroupsResponse() {}

  explicit ListCloudGtmAvailableAlertGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCloudGtmAvailableAlertGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCloudGtmAvailableAlertGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~ListCloudGtmAvailableAlertGroupsResponse() = default;
};
class ListCloudGtmInstanceConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> enableStatus{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> remark{};
  shared_ptr<string> scheduleDomainName{};
  shared_ptr<string> scheduleZoneName{};

  ListCloudGtmInstanceConfigsRequest() {}

  explicit ListCloudGtmInstanceConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (enableStatus) {
      res["EnableStatus"] = boost::any(*enableStatus);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (scheduleDomainName) {
      res["ScheduleDomainName"] = boost::any(*scheduleDomainName);
    }
    if (scheduleZoneName) {
      res["ScheduleZoneName"] = boost::any(*scheduleZoneName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("EnableStatus") != m.end() && !m["EnableStatus"].empty()) {
      enableStatus = make_shared<string>(boost::any_cast<string>(m["EnableStatus"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("ScheduleDomainName") != m.end() && !m["ScheduleDomainName"].empty()) {
      scheduleDomainName = make_shared<string>(boost::any_cast<string>(m["ScheduleDomainName"]));
    }
    if (m.find("ScheduleZoneName") != m.end() && !m["ScheduleZoneName"].empty()) {
      scheduleZoneName = make_shared<string>(boost::any_cast<string>(m["ScheduleZoneName"]));
    }
  }


  virtual ~ListCloudGtmInstanceConfigsRequest() = default;
};
class ListCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPoolsAddressPoolRequestSource : public Darabonba::Model {
public:
  shared_ptr<vector<string>> requestSource{};

  ListCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPoolsAddressPoolRequestSource() {}

  explicit ListCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPoolsAddressPoolRequestSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestSource) {
      res["RequestSource"] = boost::any(*requestSource);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestSource") != m.end() && !m["RequestSource"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RequestSource"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RequestSource"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      requestSource = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPoolsAddressPoolRequestSource() = default;
};
class ListCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPoolsAddressPool : public Darabonba::Model {
public:
  shared_ptr<string> addressLbStrategy{};
  shared_ptr<string> addressPoolId{};
  shared_ptr<string> addressPoolName{};
  shared_ptr<string> addressPoolType{};
  shared_ptr<string> availableStatus{};
  shared_ptr<string> createTime{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<string> enableStatus{};
  shared_ptr<string> healthJudgement{};
  shared_ptr<string> healthStatus{};
  shared_ptr<ListCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPoolsAddressPoolRequestSource> requestSource{};
  shared_ptr<bool> seqNonPreemptiveSchedule{};
  shared_ptr<string> sequenceLbStrategyMode{};
  shared_ptr<long> serialNumber{};
  shared_ptr<string> updateTime{};
  shared_ptr<long> updateTimestamp{};
  shared_ptr<long> weightValue{};

  ListCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPoolsAddressPool() {}

  explicit ListCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPoolsAddressPool(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addressLbStrategy) {
      res["AddressLbStrategy"] = boost::any(*addressLbStrategy);
    }
    if (addressPoolId) {
      res["AddressPoolId"] = boost::any(*addressPoolId);
    }
    if (addressPoolName) {
      res["AddressPoolName"] = boost::any(*addressPoolName);
    }
    if (addressPoolType) {
      res["AddressPoolType"] = boost::any(*addressPoolType);
    }
    if (availableStatus) {
      res["AvailableStatus"] = boost::any(*availableStatus);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (enableStatus) {
      res["EnableStatus"] = boost::any(*enableStatus);
    }
    if (healthJudgement) {
      res["HealthJudgement"] = boost::any(*healthJudgement);
    }
    if (healthStatus) {
      res["HealthStatus"] = boost::any(*healthStatus);
    }
    if (requestSource) {
      res["RequestSource"] = requestSource ? boost::any(requestSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (seqNonPreemptiveSchedule) {
      res["SeqNonPreemptiveSchedule"] = boost::any(*seqNonPreemptiveSchedule);
    }
    if (sequenceLbStrategyMode) {
      res["SequenceLbStrategyMode"] = boost::any(*sequenceLbStrategyMode);
    }
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (updateTimestamp) {
      res["UpdateTimestamp"] = boost::any(*updateTimestamp);
    }
    if (weightValue) {
      res["WeightValue"] = boost::any(*weightValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddressLbStrategy") != m.end() && !m["AddressLbStrategy"].empty()) {
      addressLbStrategy = make_shared<string>(boost::any_cast<string>(m["AddressLbStrategy"]));
    }
    if (m.find("AddressPoolId") != m.end() && !m["AddressPoolId"].empty()) {
      addressPoolId = make_shared<string>(boost::any_cast<string>(m["AddressPoolId"]));
    }
    if (m.find("AddressPoolName") != m.end() && !m["AddressPoolName"].empty()) {
      addressPoolName = make_shared<string>(boost::any_cast<string>(m["AddressPoolName"]));
    }
    if (m.find("AddressPoolType") != m.end() && !m["AddressPoolType"].empty()) {
      addressPoolType = make_shared<string>(boost::any_cast<string>(m["AddressPoolType"]));
    }
    if (m.find("AvailableStatus") != m.end() && !m["AvailableStatus"].empty()) {
      availableStatus = make_shared<string>(boost::any_cast<string>(m["AvailableStatus"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("EnableStatus") != m.end() && !m["EnableStatus"].empty()) {
      enableStatus = make_shared<string>(boost::any_cast<string>(m["EnableStatus"]));
    }
    if (m.find("HealthJudgement") != m.end() && !m["HealthJudgement"].empty()) {
      healthJudgement = make_shared<string>(boost::any_cast<string>(m["HealthJudgement"]));
    }
    if (m.find("HealthStatus") != m.end() && !m["HealthStatus"].empty()) {
      healthStatus = make_shared<string>(boost::any_cast<string>(m["HealthStatus"]));
    }
    if (m.find("RequestSource") != m.end() && !m["RequestSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["RequestSource"].type()) {
        ListCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPoolsAddressPoolRequestSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RequestSource"]));
        requestSource = make_shared<ListCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPoolsAddressPoolRequestSource>(model1);
      }
    }
    if (m.find("SeqNonPreemptiveSchedule") != m.end() && !m["SeqNonPreemptiveSchedule"].empty()) {
      seqNonPreemptiveSchedule = make_shared<bool>(boost::any_cast<bool>(m["SeqNonPreemptiveSchedule"]));
    }
    if (m.find("SequenceLbStrategyMode") != m.end() && !m["SequenceLbStrategyMode"].empty()) {
      sequenceLbStrategyMode = make_shared<string>(boost::any_cast<string>(m["SequenceLbStrategyMode"]));
    }
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<long>(boost::any_cast<long>(m["SerialNumber"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("UpdateTimestamp") != m.end() && !m["UpdateTimestamp"].empty()) {
      updateTimestamp = make_shared<long>(boost::any_cast<long>(m["UpdateTimestamp"]));
    }
    if (m.find("WeightValue") != m.end() && !m["WeightValue"].empty()) {
      weightValue = make_shared<long>(boost::any_cast<long>(m["WeightValue"]));
    }
  }


  virtual ~ListCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPoolsAddressPool() = default;
};
class ListCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPools : public Darabonba::Model {
public:
  shared_ptr<vector<ListCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPoolsAddressPool>> addressPool{};

  ListCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPools() {}

  explicit ListCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPools(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addressPool) {
      vector<boost::any> temp1;
      for(auto item1:*addressPool){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AddressPool"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddressPool") != m.end() && !m["AddressPool"].empty()) {
      if (typeid(vector<boost::any>) == m["AddressPool"].type()) {
        vector<ListCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPoolsAddressPool> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AddressPool"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPoolsAddressPool model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        addressPool = make_shared<vector<ListCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPoolsAddressPool>>(expect1);
      }
    }
  }


  virtual ~ListCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPools() = default;
};
class ListCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfig : public Darabonba::Model {
public:
  shared_ptr<string> addressPoolLbStrategy{};
  shared_ptr<ListCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPools> addressPools{};
  shared_ptr<string> availableStatus{};
  shared_ptr<string> commodityCode{};
  shared_ptr<string> configId{};
  shared_ptr<string> createTime{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<string> enableStatus{};
  shared_ptr<string> healthStatus{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> remark{};
  shared_ptr<string> scheduleDomainName{};
  shared_ptr<string> scheduleHostname{};
  shared_ptr<string> scheduleRrType{};
  shared_ptr<string> scheduleZoneMode{};
  shared_ptr<string> scheduleZoneName{};
  shared_ptr<string> sequenceLbStrategyMode{};
  shared_ptr<long> ttl{};
  shared_ptr<string> updateTime{};
  shared_ptr<long> updateTimestamp{};
  shared_ptr<string> versionCode{};

  ListCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfig() {}

  explicit ListCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addressPoolLbStrategy) {
      res["AddressPoolLbStrategy"] = boost::any(*addressPoolLbStrategy);
    }
    if (addressPools) {
      res["AddressPools"] = addressPools ? boost::any(addressPools->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (availableStatus) {
      res["AvailableStatus"] = boost::any(*availableStatus);
    }
    if (commodityCode) {
      res["CommodityCode"] = boost::any(*commodityCode);
    }
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (enableStatus) {
      res["EnableStatus"] = boost::any(*enableStatus);
    }
    if (healthStatus) {
      res["HealthStatus"] = boost::any(*healthStatus);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (scheduleDomainName) {
      res["ScheduleDomainName"] = boost::any(*scheduleDomainName);
    }
    if (scheduleHostname) {
      res["ScheduleHostname"] = boost::any(*scheduleHostname);
    }
    if (scheduleRrType) {
      res["ScheduleRrType"] = boost::any(*scheduleRrType);
    }
    if (scheduleZoneMode) {
      res["ScheduleZoneMode"] = boost::any(*scheduleZoneMode);
    }
    if (scheduleZoneName) {
      res["ScheduleZoneName"] = boost::any(*scheduleZoneName);
    }
    if (sequenceLbStrategyMode) {
      res["SequenceLbStrategyMode"] = boost::any(*sequenceLbStrategyMode);
    }
    if (ttl) {
      res["Ttl"] = boost::any(*ttl);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (updateTimestamp) {
      res["UpdateTimestamp"] = boost::any(*updateTimestamp);
    }
    if (versionCode) {
      res["VersionCode"] = boost::any(*versionCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddressPoolLbStrategy") != m.end() && !m["AddressPoolLbStrategy"].empty()) {
      addressPoolLbStrategy = make_shared<string>(boost::any_cast<string>(m["AddressPoolLbStrategy"]));
    }
    if (m.find("AddressPools") != m.end() && !m["AddressPools"].empty()) {
      if (typeid(map<string, boost::any>) == m["AddressPools"].type()) {
        ListCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPools model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AddressPools"]));
        addressPools = make_shared<ListCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPools>(model1);
      }
    }
    if (m.find("AvailableStatus") != m.end() && !m["AvailableStatus"].empty()) {
      availableStatus = make_shared<string>(boost::any_cast<string>(m["AvailableStatus"]));
    }
    if (m.find("CommodityCode") != m.end() && !m["CommodityCode"].empty()) {
      commodityCode = make_shared<string>(boost::any_cast<string>(m["CommodityCode"]));
    }
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("EnableStatus") != m.end() && !m["EnableStatus"].empty()) {
      enableStatus = make_shared<string>(boost::any_cast<string>(m["EnableStatus"]));
    }
    if (m.find("HealthStatus") != m.end() && !m["HealthStatus"].empty()) {
      healthStatus = make_shared<string>(boost::any_cast<string>(m["HealthStatus"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("ScheduleDomainName") != m.end() && !m["ScheduleDomainName"].empty()) {
      scheduleDomainName = make_shared<string>(boost::any_cast<string>(m["ScheduleDomainName"]));
    }
    if (m.find("ScheduleHostname") != m.end() && !m["ScheduleHostname"].empty()) {
      scheduleHostname = make_shared<string>(boost::any_cast<string>(m["ScheduleHostname"]));
    }
    if (m.find("ScheduleRrType") != m.end() && !m["ScheduleRrType"].empty()) {
      scheduleRrType = make_shared<string>(boost::any_cast<string>(m["ScheduleRrType"]));
    }
    if (m.find("ScheduleZoneMode") != m.end() && !m["ScheduleZoneMode"].empty()) {
      scheduleZoneMode = make_shared<string>(boost::any_cast<string>(m["ScheduleZoneMode"]));
    }
    if (m.find("ScheduleZoneName") != m.end() && !m["ScheduleZoneName"].empty()) {
      scheduleZoneName = make_shared<string>(boost::any_cast<string>(m["ScheduleZoneName"]));
    }
    if (m.find("SequenceLbStrategyMode") != m.end() && !m["SequenceLbStrategyMode"].empty()) {
      sequenceLbStrategyMode = make_shared<string>(boost::any_cast<string>(m["SequenceLbStrategyMode"]));
    }
    if (m.find("Ttl") != m.end() && !m["Ttl"].empty()) {
      ttl = make_shared<long>(boost::any_cast<long>(m["Ttl"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("UpdateTimestamp") != m.end() && !m["UpdateTimestamp"].empty()) {
      updateTimestamp = make_shared<long>(boost::any_cast<long>(m["UpdateTimestamp"]));
    }
    if (m.find("VersionCode") != m.end() && !m["VersionCode"].empty()) {
      versionCode = make_shared<string>(boost::any_cast<string>(m["VersionCode"]));
    }
  }


  virtual ~ListCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfig() = default;
};
class ListCloudGtmInstanceConfigsResponseBodyInstanceConfigs : public Darabonba::Model {
public:
  shared_ptr<vector<ListCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfig>> instanceConfig{};

  ListCloudGtmInstanceConfigsResponseBodyInstanceConfigs() {}

  explicit ListCloudGtmInstanceConfigsResponseBodyInstanceConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceConfig) {
      vector<boost::any> temp1;
      for(auto item1:*instanceConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceConfig"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceConfig") != m.end() && !m["InstanceConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceConfig"].type()) {
        vector<ListCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceConfig = make_shared<vector<ListCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfig>>(expect1);
      }
    }
  }


  virtual ~ListCloudGtmInstanceConfigsResponseBodyInstanceConfigs() = default;
};
class ListCloudGtmInstanceConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListCloudGtmInstanceConfigsResponseBodyInstanceConfigs> instanceConfigs{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalItems{};
  shared_ptr<long> totalPages{};

  ListCloudGtmInstanceConfigsResponseBody() {}

  explicit ListCloudGtmInstanceConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceConfigs) {
      res["InstanceConfigs"] = instanceConfigs ? boost::any(instanceConfigs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalItems) {
      res["TotalItems"] = boost::any(*totalItems);
    }
    if (totalPages) {
      res["TotalPages"] = boost::any(*totalPages);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceConfigs") != m.end() && !m["InstanceConfigs"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceConfigs"].type()) {
        ListCloudGtmInstanceConfigsResponseBodyInstanceConfigs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceConfigs"]));
        instanceConfigs = make_shared<ListCloudGtmInstanceConfigsResponseBodyInstanceConfigs>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalItems") != m.end() && !m["TotalItems"].empty()) {
      totalItems = make_shared<long>(boost::any_cast<long>(m["TotalItems"]));
    }
    if (m.find("TotalPages") != m.end() && !m["TotalPages"].empty()) {
      totalPages = make_shared<long>(boost::any_cast<long>(m["TotalPages"]));
    }
  }


  virtual ~ListCloudGtmInstanceConfigsResponseBody() = default;
};
class ListCloudGtmInstanceConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCloudGtmInstanceConfigsResponseBody> body{};

  ListCloudGtmInstanceConfigsResponse() {}

  explicit ListCloudGtmInstanceConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCloudGtmInstanceConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCloudGtmInstanceConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~ListCloudGtmInstanceConfigsResponse() = default;
};
class ListCloudGtmInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListCloudGtmInstancesRequest() {}

  explicit ListCloudGtmInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListCloudGtmInstancesRequest() = default;
};
class ListCloudGtmInstancesResponseBodyInstancesInstance : public Darabonba::Model {
public:
  shared_ptr<string> commodityCode{};
  shared_ptr<string> createTime{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<string> expireTime{};
  shared_ptr<long> expireTimestamp{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<long> monitorTaskQuota{};
  shared_ptr<long> monthlyEmailUsed{};
  shared_ptr<long> monthlySmsQuota{};
  shared_ptr<long> monthlySmsUsed{};
  shared_ptr<long> monthlyWebhookUsed{};
  shared_ptr<string> scheduleDomainName{};
  shared_ptr<string> updateTime{};
  shared_ptr<long> updateTimestamp{};
  shared_ptr<string> versionCode{};

  ListCloudGtmInstancesResponseBodyInstancesInstance() {}

  explicit ListCloudGtmInstancesResponseBodyInstancesInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commodityCode) {
      res["CommodityCode"] = boost::any(*commodityCode);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (expireTimestamp) {
      res["ExpireTimestamp"] = boost::any(*expireTimestamp);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (monitorTaskQuota) {
      res["MonitorTaskQuota"] = boost::any(*monitorTaskQuota);
    }
    if (monthlyEmailUsed) {
      res["MonthlyEmailUsed"] = boost::any(*monthlyEmailUsed);
    }
    if (monthlySmsQuota) {
      res["MonthlySmsQuota"] = boost::any(*monthlySmsQuota);
    }
    if (monthlySmsUsed) {
      res["MonthlySmsUsed"] = boost::any(*monthlySmsUsed);
    }
    if (monthlyWebhookUsed) {
      res["MonthlyWebhookUsed"] = boost::any(*monthlyWebhookUsed);
    }
    if (scheduleDomainName) {
      res["ScheduleDomainName"] = boost::any(*scheduleDomainName);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (updateTimestamp) {
      res["UpdateTimestamp"] = boost::any(*updateTimestamp);
    }
    if (versionCode) {
      res["VersionCode"] = boost::any(*versionCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommodityCode") != m.end() && !m["CommodityCode"].empty()) {
      commodityCode = make_shared<string>(boost::any_cast<string>(m["CommodityCode"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("ExpireTimestamp") != m.end() && !m["ExpireTimestamp"].empty()) {
      expireTimestamp = make_shared<long>(boost::any_cast<long>(m["ExpireTimestamp"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("MonitorTaskQuota") != m.end() && !m["MonitorTaskQuota"].empty()) {
      monitorTaskQuota = make_shared<long>(boost::any_cast<long>(m["MonitorTaskQuota"]));
    }
    if (m.find("MonthlyEmailUsed") != m.end() && !m["MonthlyEmailUsed"].empty()) {
      monthlyEmailUsed = make_shared<long>(boost::any_cast<long>(m["MonthlyEmailUsed"]));
    }
    if (m.find("MonthlySmsQuota") != m.end() && !m["MonthlySmsQuota"].empty()) {
      monthlySmsQuota = make_shared<long>(boost::any_cast<long>(m["MonthlySmsQuota"]));
    }
    if (m.find("MonthlySmsUsed") != m.end() && !m["MonthlySmsUsed"].empty()) {
      monthlySmsUsed = make_shared<long>(boost::any_cast<long>(m["MonthlySmsUsed"]));
    }
    if (m.find("MonthlyWebhookUsed") != m.end() && !m["MonthlyWebhookUsed"].empty()) {
      monthlyWebhookUsed = make_shared<long>(boost::any_cast<long>(m["MonthlyWebhookUsed"]));
    }
    if (m.find("ScheduleDomainName") != m.end() && !m["ScheduleDomainName"].empty()) {
      scheduleDomainName = make_shared<string>(boost::any_cast<string>(m["ScheduleDomainName"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("UpdateTimestamp") != m.end() && !m["UpdateTimestamp"].empty()) {
      updateTimestamp = make_shared<long>(boost::any_cast<long>(m["UpdateTimestamp"]));
    }
    if (m.find("VersionCode") != m.end() && !m["VersionCode"].empty()) {
      versionCode = make_shared<string>(boost::any_cast<string>(m["VersionCode"]));
    }
  }


  virtual ~ListCloudGtmInstancesResponseBodyInstancesInstance() = default;
};
class ListCloudGtmInstancesResponseBodyInstances : public Darabonba::Model {
public:
  shared_ptr<vector<ListCloudGtmInstancesResponseBodyInstancesInstance>> instance{};

  ListCloudGtmInstancesResponseBodyInstances() {}

  explicit ListCloudGtmInstancesResponseBodyInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instance) {
      vector<boost::any> temp1;
      for(auto item1:*instance){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Instance"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Instance") != m.end() && !m["Instance"].empty()) {
      if (typeid(vector<boost::any>) == m["Instance"].type()) {
        vector<ListCloudGtmInstancesResponseBodyInstancesInstance> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Instance"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCloudGtmInstancesResponseBodyInstancesInstance model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instance = make_shared<vector<ListCloudGtmInstancesResponseBodyInstancesInstance>>(expect1);
      }
    }
  }


  virtual ~ListCloudGtmInstancesResponseBodyInstances() = default;
};
class ListCloudGtmInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListCloudGtmInstancesResponseBodyInstances> instances{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalItems{};
  shared_ptr<long> totalPages{};

  ListCloudGtmInstancesResponseBody() {}

  explicit ListCloudGtmInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instances) {
      res["Instances"] = instances ? boost::any(instances->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalItems) {
      res["TotalItems"] = boost::any(*totalItems);
    }
    if (totalPages) {
      res["TotalPages"] = boost::any(*totalPages);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      if (typeid(map<string, boost::any>) == m["Instances"].type()) {
        ListCloudGtmInstancesResponseBodyInstances model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Instances"]));
        instances = make_shared<ListCloudGtmInstancesResponseBodyInstances>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalItems") != m.end() && !m["TotalItems"].empty()) {
      totalItems = make_shared<long>(boost::any_cast<long>(m["TotalItems"]));
    }
    if (m.find("TotalPages") != m.end() && !m["TotalPages"].empty()) {
      totalPages = make_shared<long>(boost::any_cast<long>(m["TotalPages"]));
    }
  }


  virtual ~ListCloudGtmInstancesResponseBody() = default;
};
class ListCloudGtmInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCloudGtmInstancesResponseBody> body{};

  ListCloudGtmInstancesResponse() {}

  explicit ListCloudGtmInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCloudGtmInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCloudGtmInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~ListCloudGtmInstancesResponse() = default;
};
class ListCloudGtmMonitorNodesRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};

  ListCloudGtmMonitorNodesRequest() {}

  explicit ListCloudGtmMonitorNodesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
  }


  virtual ~ListCloudGtmMonitorNodesRequest() = default;
};
class ListCloudGtmMonitorNodesResponseBodyIpv4IspCityNodesIpv4IspCityNodeIps : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ip{};

  ListCloudGtmMonitorNodesResponseBodyIpv4IspCityNodesIpv4IspCityNodeIps() {}

  explicit ListCloudGtmMonitorNodesResponseBodyIpv4IspCityNodesIpv4IspCityNodeIps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Ip"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ip"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ip = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListCloudGtmMonitorNodesResponseBodyIpv4IspCityNodesIpv4IspCityNodeIps() = default;
};
class ListCloudGtmMonitorNodesResponseBodyIpv4IspCityNodesIpv4IspCityNode : public Darabonba::Model {
public:
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};
  shared_ptr<string> countryCode{};
  shared_ptr<string> countryName{};
  shared_ptr<bool> defaultSelected{};
  shared_ptr<string> groupName{};
  shared_ptr<string> groupType{};
  shared_ptr<ListCloudGtmMonitorNodesResponseBodyIpv4IspCityNodesIpv4IspCityNodeIps> ips{};
  shared_ptr<string> ispCode{};
  shared_ptr<string> ispName{};
  shared_ptr<string> nodeId{};

  ListCloudGtmMonitorNodesResponseBodyIpv4IspCityNodesIpv4IspCityNode() {}

  explicit ListCloudGtmMonitorNodesResponseBodyIpv4IspCityNodesIpv4IspCityNode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cityCode) {
      res["CityCode"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["CityName"] = boost::any(*cityName);
    }
    if (countryCode) {
      res["CountryCode"] = boost::any(*countryCode);
    }
    if (countryName) {
      res["CountryName"] = boost::any(*countryName);
    }
    if (defaultSelected) {
      res["DefaultSelected"] = boost::any(*defaultSelected);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (groupType) {
      res["GroupType"] = boost::any(*groupType);
    }
    if (ips) {
      res["Ips"] = ips ? boost::any(ips->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ispCode) {
      res["IspCode"] = boost::any(*ispCode);
    }
    if (ispName) {
      res["IspName"] = boost::any(*ispName);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CityCode") != m.end() && !m["CityCode"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["CityCode"]));
    }
    if (m.find("CityName") != m.end() && !m["CityName"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["CityName"]));
    }
    if (m.find("CountryCode") != m.end() && !m["CountryCode"].empty()) {
      countryCode = make_shared<string>(boost::any_cast<string>(m["CountryCode"]));
    }
    if (m.find("CountryName") != m.end() && !m["CountryName"].empty()) {
      countryName = make_shared<string>(boost::any_cast<string>(m["CountryName"]));
    }
    if (m.find("DefaultSelected") != m.end() && !m["DefaultSelected"].empty()) {
      defaultSelected = make_shared<bool>(boost::any_cast<bool>(m["DefaultSelected"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("GroupType") != m.end() && !m["GroupType"].empty()) {
      groupType = make_shared<string>(boost::any_cast<string>(m["GroupType"]));
    }
    if (m.find("Ips") != m.end() && !m["Ips"].empty()) {
      if (typeid(map<string, boost::any>) == m["Ips"].type()) {
        ListCloudGtmMonitorNodesResponseBodyIpv4IspCityNodesIpv4IspCityNodeIps model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Ips"]));
        ips = make_shared<ListCloudGtmMonitorNodesResponseBodyIpv4IspCityNodesIpv4IspCityNodeIps>(model1);
      }
    }
    if (m.find("IspCode") != m.end() && !m["IspCode"].empty()) {
      ispCode = make_shared<string>(boost::any_cast<string>(m["IspCode"]));
    }
    if (m.find("IspName") != m.end() && !m["IspName"].empty()) {
      ispName = make_shared<string>(boost::any_cast<string>(m["IspName"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
  }


  virtual ~ListCloudGtmMonitorNodesResponseBodyIpv4IspCityNodesIpv4IspCityNode() = default;
};
class ListCloudGtmMonitorNodesResponseBodyIpv4IspCityNodes : public Darabonba::Model {
public:
  shared_ptr<vector<ListCloudGtmMonitorNodesResponseBodyIpv4IspCityNodesIpv4IspCityNode>> ipv4IspCityNode{};

  ListCloudGtmMonitorNodesResponseBodyIpv4IspCityNodes() {}

  explicit ListCloudGtmMonitorNodesResponseBodyIpv4IspCityNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipv4IspCityNode) {
      vector<boost::any> temp1;
      for(auto item1:*ipv4IspCityNode){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Ipv4IspCityNode"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ipv4IspCityNode") != m.end() && !m["Ipv4IspCityNode"].empty()) {
      if (typeid(vector<boost::any>) == m["Ipv4IspCityNode"].type()) {
        vector<ListCloudGtmMonitorNodesResponseBodyIpv4IspCityNodesIpv4IspCityNode> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Ipv4IspCityNode"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCloudGtmMonitorNodesResponseBodyIpv4IspCityNodesIpv4IspCityNode model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ipv4IspCityNode = make_shared<vector<ListCloudGtmMonitorNodesResponseBodyIpv4IspCityNodesIpv4IspCityNode>>(expect1);
      }
    }
  }


  virtual ~ListCloudGtmMonitorNodesResponseBodyIpv4IspCityNodes() = default;
};
class ListCloudGtmMonitorNodesResponseBodyIpv6IspCityNodesIpv6IspCityNodeIps : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ip{};

  ListCloudGtmMonitorNodesResponseBodyIpv6IspCityNodesIpv6IspCityNodeIps() {}

  explicit ListCloudGtmMonitorNodesResponseBodyIpv6IspCityNodesIpv6IspCityNodeIps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Ip"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ip"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ip = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListCloudGtmMonitorNodesResponseBodyIpv6IspCityNodesIpv6IspCityNodeIps() = default;
};
class ListCloudGtmMonitorNodesResponseBodyIpv6IspCityNodesIpv6IspCityNode : public Darabonba::Model {
public:
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};
  shared_ptr<string> countryCode{};
  shared_ptr<string> countryName{};
  shared_ptr<bool> defaultSelected{};
  shared_ptr<string> groupName{};
  shared_ptr<string> groupType{};
  shared_ptr<ListCloudGtmMonitorNodesResponseBodyIpv6IspCityNodesIpv6IspCityNodeIps> ips{};
  shared_ptr<string> ispCode{};
  shared_ptr<string> ispName{};
  shared_ptr<string> nodeId{};

  ListCloudGtmMonitorNodesResponseBodyIpv6IspCityNodesIpv6IspCityNode() {}

  explicit ListCloudGtmMonitorNodesResponseBodyIpv6IspCityNodesIpv6IspCityNode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cityCode) {
      res["CityCode"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["CityName"] = boost::any(*cityName);
    }
    if (countryCode) {
      res["CountryCode"] = boost::any(*countryCode);
    }
    if (countryName) {
      res["CountryName"] = boost::any(*countryName);
    }
    if (defaultSelected) {
      res["DefaultSelected"] = boost::any(*defaultSelected);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (groupType) {
      res["GroupType"] = boost::any(*groupType);
    }
    if (ips) {
      res["Ips"] = ips ? boost::any(ips->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ispCode) {
      res["IspCode"] = boost::any(*ispCode);
    }
    if (ispName) {
      res["IspName"] = boost::any(*ispName);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CityCode") != m.end() && !m["CityCode"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["CityCode"]));
    }
    if (m.find("CityName") != m.end() && !m["CityName"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["CityName"]));
    }
    if (m.find("CountryCode") != m.end() && !m["CountryCode"].empty()) {
      countryCode = make_shared<string>(boost::any_cast<string>(m["CountryCode"]));
    }
    if (m.find("CountryName") != m.end() && !m["CountryName"].empty()) {
      countryName = make_shared<string>(boost::any_cast<string>(m["CountryName"]));
    }
    if (m.find("DefaultSelected") != m.end() && !m["DefaultSelected"].empty()) {
      defaultSelected = make_shared<bool>(boost::any_cast<bool>(m["DefaultSelected"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("GroupType") != m.end() && !m["GroupType"].empty()) {
      groupType = make_shared<string>(boost::any_cast<string>(m["GroupType"]));
    }
    if (m.find("Ips") != m.end() && !m["Ips"].empty()) {
      if (typeid(map<string, boost::any>) == m["Ips"].type()) {
        ListCloudGtmMonitorNodesResponseBodyIpv6IspCityNodesIpv6IspCityNodeIps model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Ips"]));
        ips = make_shared<ListCloudGtmMonitorNodesResponseBodyIpv6IspCityNodesIpv6IspCityNodeIps>(model1);
      }
    }
    if (m.find("IspCode") != m.end() && !m["IspCode"].empty()) {
      ispCode = make_shared<string>(boost::any_cast<string>(m["IspCode"]));
    }
    if (m.find("IspName") != m.end() && !m["IspName"].empty()) {
      ispName = make_shared<string>(boost::any_cast<string>(m["IspName"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
  }


  virtual ~ListCloudGtmMonitorNodesResponseBodyIpv6IspCityNodesIpv6IspCityNode() = default;
};
class ListCloudGtmMonitorNodesResponseBodyIpv6IspCityNodes : public Darabonba::Model {
public:
  shared_ptr<vector<ListCloudGtmMonitorNodesResponseBodyIpv6IspCityNodesIpv6IspCityNode>> ipv6IspCityNode{};

  ListCloudGtmMonitorNodesResponseBodyIpv6IspCityNodes() {}

  explicit ListCloudGtmMonitorNodesResponseBodyIpv6IspCityNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipv6IspCityNode) {
      vector<boost::any> temp1;
      for(auto item1:*ipv6IspCityNode){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Ipv6IspCityNode"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ipv6IspCityNode") != m.end() && !m["Ipv6IspCityNode"].empty()) {
      if (typeid(vector<boost::any>) == m["Ipv6IspCityNode"].type()) {
        vector<ListCloudGtmMonitorNodesResponseBodyIpv6IspCityNodesIpv6IspCityNode> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Ipv6IspCityNode"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCloudGtmMonitorNodesResponseBodyIpv6IspCityNodesIpv6IspCityNode model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ipv6IspCityNode = make_shared<vector<ListCloudGtmMonitorNodesResponseBodyIpv6IspCityNodesIpv6IspCityNode>>(expect1);
      }
    }
  }


  virtual ~ListCloudGtmMonitorNodesResponseBodyIpv6IspCityNodes() = default;
};
class ListCloudGtmMonitorNodesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListCloudGtmMonitorNodesResponseBodyIpv4IspCityNodes> ipv4IspCityNodes{};
  shared_ptr<ListCloudGtmMonitorNodesResponseBodyIpv6IspCityNodes> ipv6IspCityNodes{};
  shared_ptr<string> requestId{};

  ListCloudGtmMonitorNodesResponseBody() {}

  explicit ListCloudGtmMonitorNodesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipv4IspCityNodes) {
      res["Ipv4IspCityNodes"] = ipv4IspCityNodes ? boost::any(ipv4IspCityNodes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ipv6IspCityNodes) {
      res["Ipv6IspCityNodes"] = ipv6IspCityNodes ? boost::any(ipv6IspCityNodes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ipv4IspCityNodes") != m.end() && !m["Ipv4IspCityNodes"].empty()) {
      if (typeid(map<string, boost::any>) == m["Ipv4IspCityNodes"].type()) {
        ListCloudGtmMonitorNodesResponseBodyIpv4IspCityNodes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Ipv4IspCityNodes"]));
        ipv4IspCityNodes = make_shared<ListCloudGtmMonitorNodesResponseBodyIpv4IspCityNodes>(model1);
      }
    }
    if (m.find("Ipv6IspCityNodes") != m.end() && !m["Ipv6IspCityNodes"].empty()) {
      if (typeid(map<string, boost::any>) == m["Ipv6IspCityNodes"].type()) {
        ListCloudGtmMonitorNodesResponseBodyIpv6IspCityNodes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Ipv6IspCityNodes"]));
        ipv6IspCityNodes = make_shared<ListCloudGtmMonitorNodesResponseBodyIpv6IspCityNodes>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListCloudGtmMonitorNodesResponseBody() = default;
};
class ListCloudGtmMonitorNodesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCloudGtmMonitorNodesResponseBody> body{};

  ListCloudGtmMonitorNodesResponse() {}

  explicit ListCloudGtmMonitorNodesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCloudGtmMonitorNodesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCloudGtmMonitorNodesResponseBody>(model1);
      }
    }
  }


  virtual ~ListCloudGtmMonitorNodesResponse() = default;
};
class ListCloudGtmMonitorTemplatesRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> ipVersion{};
  shared_ptr<string> name{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> protocol{};

  ListCloudGtmMonitorTemplatesRequest() {}

  explicit ListCloudGtmMonitorTemplatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (ipVersion) {
      res["IpVersion"] = boost::any(*ipVersion);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("IpVersion") != m.end() && !m["IpVersion"].empty()) {
      ipVersion = make_shared<string>(boost::any_cast<string>(m["IpVersion"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
  }


  virtual ~ListCloudGtmMonitorTemplatesRequest() = default;
};
class ListCloudGtmMonitorTemplatesResponseBodyTemplatesTemplateIspCityNodesIspCityNode : public Darabonba::Model {
public:
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};
  shared_ptr<string> countryCode{};
  shared_ptr<string> countryName{};
  shared_ptr<string> groupName{};
  shared_ptr<string> groupType{};
  shared_ptr<string> ispCode{};
  shared_ptr<string> ispName{};

  ListCloudGtmMonitorTemplatesResponseBodyTemplatesTemplateIspCityNodesIspCityNode() {}

  explicit ListCloudGtmMonitorTemplatesResponseBodyTemplatesTemplateIspCityNodesIspCityNode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cityCode) {
      res["CityCode"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["CityName"] = boost::any(*cityName);
    }
    if (countryCode) {
      res["CountryCode"] = boost::any(*countryCode);
    }
    if (countryName) {
      res["CountryName"] = boost::any(*countryName);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (groupType) {
      res["GroupType"] = boost::any(*groupType);
    }
    if (ispCode) {
      res["IspCode"] = boost::any(*ispCode);
    }
    if (ispName) {
      res["IspName"] = boost::any(*ispName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CityCode") != m.end() && !m["CityCode"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["CityCode"]));
    }
    if (m.find("CityName") != m.end() && !m["CityName"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["CityName"]));
    }
    if (m.find("CountryCode") != m.end() && !m["CountryCode"].empty()) {
      countryCode = make_shared<string>(boost::any_cast<string>(m["CountryCode"]));
    }
    if (m.find("CountryName") != m.end() && !m["CountryName"].empty()) {
      countryName = make_shared<string>(boost::any_cast<string>(m["CountryName"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("GroupType") != m.end() && !m["GroupType"].empty()) {
      groupType = make_shared<string>(boost::any_cast<string>(m["GroupType"]));
    }
    if (m.find("IspCode") != m.end() && !m["IspCode"].empty()) {
      ispCode = make_shared<string>(boost::any_cast<string>(m["IspCode"]));
    }
    if (m.find("IspName") != m.end() && !m["IspName"].empty()) {
      ispName = make_shared<string>(boost::any_cast<string>(m["IspName"]));
    }
  }


  virtual ~ListCloudGtmMonitorTemplatesResponseBodyTemplatesTemplateIspCityNodesIspCityNode() = default;
};
class ListCloudGtmMonitorTemplatesResponseBodyTemplatesTemplateIspCityNodes : public Darabonba::Model {
public:
  shared_ptr<vector<ListCloudGtmMonitorTemplatesResponseBodyTemplatesTemplateIspCityNodesIspCityNode>> ispCityNode{};

  ListCloudGtmMonitorTemplatesResponseBodyTemplatesTemplateIspCityNodes() {}

  explicit ListCloudGtmMonitorTemplatesResponseBodyTemplatesTemplateIspCityNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ispCityNode) {
      vector<boost::any> temp1;
      for(auto item1:*ispCityNode){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IspCityNode"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IspCityNode") != m.end() && !m["IspCityNode"].empty()) {
      if (typeid(vector<boost::any>) == m["IspCityNode"].type()) {
        vector<ListCloudGtmMonitorTemplatesResponseBodyTemplatesTemplateIspCityNodesIspCityNode> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IspCityNode"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCloudGtmMonitorTemplatesResponseBodyTemplatesTemplateIspCityNodesIspCityNode model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ispCityNode = make_shared<vector<ListCloudGtmMonitorTemplatesResponseBodyTemplatesTemplateIspCityNodesIspCityNode>>(expect1);
      }
    }
  }


  virtual ~ListCloudGtmMonitorTemplatesResponseBodyTemplatesTemplateIspCityNodes() = default;
};
class ListCloudGtmMonitorTemplatesResponseBodyTemplatesTemplate : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<long> evaluationCount{};
  shared_ptr<string> extendInfo{};
  shared_ptr<long> failureRate{};
  shared_ptr<long> interval{};
  shared_ptr<string> ipVersion{};
  shared_ptr<ListCloudGtmMonitorTemplatesResponseBodyTemplatesTemplateIspCityNodes> ispCityNodes{};
  shared_ptr<string> name{};
  shared_ptr<string> protocol{};
  shared_ptr<string> remark{};
  shared_ptr<string> templateId{};
  shared_ptr<long> timeout{};
  shared_ptr<string> updateTime{};
  shared_ptr<long> updateTimestamp{};

  ListCloudGtmMonitorTemplatesResponseBodyTemplatesTemplate() {}

  explicit ListCloudGtmMonitorTemplatesResponseBodyTemplatesTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (evaluationCount) {
      res["EvaluationCount"] = boost::any(*evaluationCount);
    }
    if (extendInfo) {
      res["ExtendInfo"] = boost::any(*extendInfo);
    }
    if (failureRate) {
      res["FailureRate"] = boost::any(*failureRate);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ipVersion) {
      res["IpVersion"] = boost::any(*ipVersion);
    }
    if (ispCityNodes) {
      res["IspCityNodes"] = ispCityNodes ? boost::any(ispCityNodes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (updateTimestamp) {
      res["UpdateTimestamp"] = boost::any(*updateTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("EvaluationCount") != m.end() && !m["EvaluationCount"].empty()) {
      evaluationCount = make_shared<long>(boost::any_cast<long>(m["EvaluationCount"]));
    }
    if (m.find("ExtendInfo") != m.end() && !m["ExtendInfo"].empty()) {
      extendInfo = make_shared<string>(boost::any_cast<string>(m["ExtendInfo"]));
    }
    if (m.find("FailureRate") != m.end() && !m["FailureRate"].empty()) {
      failureRate = make_shared<long>(boost::any_cast<long>(m["FailureRate"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("IpVersion") != m.end() && !m["IpVersion"].empty()) {
      ipVersion = make_shared<string>(boost::any_cast<string>(m["IpVersion"]));
    }
    if (m.find("IspCityNodes") != m.end() && !m["IspCityNodes"].empty()) {
      if (typeid(map<string, boost::any>) == m["IspCityNodes"].type()) {
        ListCloudGtmMonitorTemplatesResponseBodyTemplatesTemplateIspCityNodes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IspCityNodes"]));
        ispCityNodes = make_shared<ListCloudGtmMonitorTemplatesResponseBodyTemplatesTemplateIspCityNodes>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("UpdateTimestamp") != m.end() && !m["UpdateTimestamp"].empty()) {
      updateTimestamp = make_shared<long>(boost::any_cast<long>(m["UpdateTimestamp"]));
    }
  }


  virtual ~ListCloudGtmMonitorTemplatesResponseBodyTemplatesTemplate() = default;
};
class ListCloudGtmMonitorTemplatesResponseBodyTemplates : public Darabonba::Model {
public:
  shared_ptr<vector<ListCloudGtmMonitorTemplatesResponseBodyTemplatesTemplate>> template_{};

  ListCloudGtmMonitorTemplatesResponseBodyTemplates() {}

  explicit ListCloudGtmMonitorTemplatesResponseBodyTemplates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (template_) {
      vector<boost::any> temp1;
      for(auto item1:*template_){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Template"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      if (typeid(vector<boost::any>) == m["Template"].type()) {
        vector<ListCloudGtmMonitorTemplatesResponseBodyTemplatesTemplate> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Template"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCloudGtmMonitorTemplatesResponseBodyTemplatesTemplate model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        template_ = make_shared<vector<ListCloudGtmMonitorTemplatesResponseBodyTemplatesTemplate>>(expect1);
      }
    }
  }


  virtual ~ListCloudGtmMonitorTemplatesResponseBodyTemplates() = default;
};
class ListCloudGtmMonitorTemplatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<ListCloudGtmMonitorTemplatesResponseBodyTemplates> templates{};
  shared_ptr<long> totalItems{};
  shared_ptr<long> totalPages{};

  ListCloudGtmMonitorTemplatesResponseBody() {}

  explicit ListCloudGtmMonitorTemplatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templates) {
      res["Templates"] = templates ? boost::any(templates->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalItems) {
      res["TotalItems"] = boost::any(*totalItems);
    }
    if (totalPages) {
      res["TotalPages"] = boost::any(*totalPages);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Templates") != m.end() && !m["Templates"].empty()) {
      if (typeid(map<string, boost::any>) == m["Templates"].type()) {
        ListCloudGtmMonitorTemplatesResponseBodyTemplates model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Templates"]));
        templates = make_shared<ListCloudGtmMonitorTemplatesResponseBodyTemplates>(model1);
      }
    }
    if (m.find("TotalItems") != m.end() && !m["TotalItems"].empty()) {
      totalItems = make_shared<long>(boost::any_cast<long>(m["TotalItems"]));
    }
    if (m.find("TotalPages") != m.end() && !m["TotalPages"].empty()) {
      totalPages = make_shared<long>(boost::any_cast<long>(m["TotalPages"]));
    }
  }


  virtual ~ListCloudGtmMonitorTemplatesResponseBody() = default;
};
class ListCloudGtmMonitorTemplatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCloudGtmMonitorTemplatesResponseBody> body{};

  ListCloudGtmMonitorTemplatesResponse() {}

  explicit ListCloudGtmMonitorTemplatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCloudGtmMonitorTemplatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCloudGtmMonitorTemplatesResponseBody>(model1);
      }
    }
  }


  virtual ~ListCloudGtmMonitorTemplatesResponse() = default;
};
class ListTagResourcesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListTagResourcesRequestTag() {}

  explicit ListTagResourcesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListTagResourcesRequestTag() = default;
};
class ListTagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> nextToken{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<ListTagResourcesRequestTag>> tag{};

  ListTagResourcesRequest() {}

  explicit ListTagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<ListTagResourcesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagResourcesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<ListTagResourcesRequestTag>>(expect1);
      }
    }
  }


  virtual ~ListTagResourcesRequest() = default;
};
class ListTagResourcesResponseBodyTagResources : public Darabonba::Model {
public:
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  ListTagResourcesResponseBodyTagResources() {}

  explicit ListTagResourcesResponseBodyTagResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~ListTagResourcesResponseBodyTagResources() = default;
};
class ListTagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListTagResourcesResponseBodyTagResources>> tagResources{};

  ListTagResourcesResponseBody() {}

  explicit ListTagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tagResources) {
      vector<boost::any> temp1;
      for(auto item1:*tagResources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagResources"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TagResources") != m.end() && !m["TagResources"].empty()) {
      if (typeid(vector<boost::any>) == m["TagResources"].type()) {
        vector<ListTagResourcesResponseBodyTagResources> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagResources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagResourcesResponseBodyTagResources model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagResources = make_shared<vector<ListTagResourcesResponseBodyTagResources>>(expect1);
      }
    }
  }


  virtual ~ListTagResourcesResponseBody() = default;
};
class ListTagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTagResourcesResponseBody> body{};

  ListTagResourcesResponse() {}

  explicit ListTagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~ListTagResourcesResponse() = default;
};
class ModifyHichinaDomainDNSRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> lang{};
  shared_ptr<string> userClientIp{};

  ModifyHichinaDomainDNSRequest() {}

  explicit ModifyHichinaDomainDNSRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (userClientIp) {
      res["UserClientIp"] = boost::any(*userClientIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("UserClientIp") != m.end() && !m["UserClientIp"].empty()) {
      userClientIp = make_shared<string>(boost::any_cast<string>(m["UserClientIp"]));
    }
  }


  virtual ~ModifyHichinaDomainDNSRequest() = default;
};
class ModifyHichinaDomainDNSResponseBodyNewDnsServers : public Darabonba::Model {
public:
  shared_ptr<vector<string>> dnsServer{};

  ModifyHichinaDomainDNSResponseBodyNewDnsServers() {}

  explicit ModifyHichinaDomainDNSResponseBodyNewDnsServers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dnsServer) {
      res["DnsServer"] = boost::any(*dnsServer);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DnsServer") != m.end() && !m["DnsServer"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DnsServer"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DnsServer"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dnsServer = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ModifyHichinaDomainDNSResponseBodyNewDnsServers() = default;
};
class ModifyHichinaDomainDNSResponseBodyOriginalDnsServers : public Darabonba::Model {
public:
  shared_ptr<vector<string>> dnsServer{};

  ModifyHichinaDomainDNSResponseBodyOriginalDnsServers() {}

  explicit ModifyHichinaDomainDNSResponseBodyOriginalDnsServers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dnsServer) {
      res["DnsServer"] = boost::any(*dnsServer);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DnsServer") != m.end() && !m["DnsServer"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DnsServer"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DnsServer"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dnsServer = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ModifyHichinaDomainDNSResponseBodyOriginalDnsServers() = default;
};
class ModifyHichinaDomainDNSResponseBody : public Darabonba::Model {
public:
  shared_ptr<ModifyHichinaDomainDNSResponseBodyNewDnsServers> newDnsServers{};
  shared_ptr<ModifyHichinaDomainDNSResponseBodyOriginalDnsServers> originalDnsServers{};
  shared_ptr<string> requestId{};

  ModifyHichinaDomainDNSResponseBody() {}

  explicit ModifyHichinaDomainDNSResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (newDnsServers) {
      res["NewDnsServers"] = newDnsServers ? boost::any(newDnsServers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (originalDnsServers) {
      res["OriginalDnsServers"] = originalDnsServers ? boost::any(originalDnsServers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NewDnsServers") != m.end() && !m["NewDnsServers"].empty()) {
      if (typeid(map<string, boost::any>) == m["NewDnsServers"].type()) {
        ModifyHichinaDomainDNSResponseBodyNewDnsServers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NewDnsServers"]));
        newDnsServers = make_shared<ModifyHichinaDomainDNSResponseBodyNewDnsServers>(model1);
      }
    }
    if (m.find("OriginalDnsServers") != m.end() && !m["OriginalDnsServers"].empty()) {
      if (typeid(map<string, boost::any>) == m["OriginalDnsServers"].type()) {
        ModifyHichinaDomainDNSResponseBodyOriginalDnsServers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OriginalDnsServers"]));
        originalDnsServers = make_shared<ModifyHichinaDomainDNSResponseBodyOriginalDnsServers>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyHichinaDomainDNSResponseBody() = default;
};
class ModifyHichinaDomainDNSResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyHichinaDomainDNSResponseBody> body{};

  ModifyHichinaDomainDNSResponse() {}

  explicit ModifyHichinaDomainDNSResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyHichinaDomainDNSResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyHichinaDomainDNSResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyHichinaDomainDNSResponse() = default;
};
class MoveDomainResourceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> newResourceGroupId{};
  shared_ptr<string> resourceId{};

  MoveDomainResourceGroupRequest() {}

  explicit MoveDomainResourceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (newResourceGroupId) {
      res["NewResourceGroupId"] = boost::any(*newResourceGroupId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("NewResourceGroupId") != m.end() && !m["NewResourceGroupId"].empty()) {
      newResourceGroupId = make_shared<string>(boost::any_cast<string>(m["NewResourceGroupId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
  }


  virtual ~MoveDomainResourceGroupRequest() = default;
};
class MoveDomainResourceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  MoveDomainResourceGroupResponseBody() {}

  explicit MoveDomainResourceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~MoveDomainResourceGroupResponseBody() = default;
};
class MoveDomainResourceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<MoveDomainResourceGroupResponseBody> body{};

  MoveDomainResourceGroupResponse() {}

  explicit MoveDomainResourceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        MoveDomainResourceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<MoveDomainResourceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~MoveDomainResourceGroupResponse() = default;
};
class MoveGtmResourceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> newResourceGroupId{};
  shared_ptr<string> resourceId{};

  MoveGtmResourceGroupRequest() {}

  explicit MoveGtmResourceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (newResourceGroupId) {
      res["NewResourceGroupId"] = boost::any(*newResourceGroupId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("NewResourceGroupId") != m.end() && !m["NewResourceGroupId"].empty()) {
      newResourceGroupId = make_shared<string>(boost::any_cast<string>(m["NewResourceGroupId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
  }


  virtual ~MoveGtmResourceGroupRequest() = default;
};
class MoveGtmResourceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  MoveGtmResourceGroupResponseBody() {}

  explicit MoveGtmResourceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~MoveGtmResourceGroupResponseBody() = default;
};
class MoveGtmResourceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<MoveGtmResourceGroupResponseBody> body{};

  MoveGtmResourceGroupResponse() {}

  explicit MoveGtmResourceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        MoveGtmResourceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<MoveGtmResourceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~MoveGtmResourceGroupResponse() = default;
};
class OperateBatchDomainRequestDomainRecordInfo : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<string> line{};
  shared_ptr<string> newRr{};
  shared_ptr<string> newType{};
  shared_ptr<string> newValue{};
  shared_ptr<long> priority{};
  shared_ptr<string> rr{};
  shared_ptr<long> ttl{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  OperateBatchDomainRequestDomainRecordInfo() {}

  explicit OperateBatchDomainRequestDomainRecordInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (line) {
      res["Line"] = boost::any(*line);
    }
    if (newRr) {
      res["NewRr"] = boost::any(*newRr);
    }
    if (newType) {
      res["NewType"] = boost::any(*newType);
    }
    if (newValue) {
      res["NewValue"] = boost::any(*newValue);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (rr) {
      res["Rr"] = boost::any(*rr);
    }
    if (ttl) {
      res["Ttl"] = boost::any(*ttl);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Line") != m.end() && !m["Line"].empty()) {
      line = make_shared<string>(boost::any_cast<string>(m["Line"]));
    }
    if (m.find("NewRr") != m.end() && !m["NewRr"].empty()) {
      newRr = make_shared<string>(boost::any_cast<string>(m["NewRr"]));
    }
    if (m.find("NewType") != m.end() && !m["NewType"].empty()) {
      newType = make_shared<string>(boost::any_cast<string>(m["NewType"]));
    }
    if (m.find("NewValue") != m.end() && !m["NewValue"].empty()) {
      newValue = make_shared<string>(boost::any_cast<string>(m["NewValue"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("Rr") != m.end() && !m["Rr"].empty()) {
      rr = make_shared<string>(boost::any_cast<string>(m["Rr"]));
    }
    if (m.find("Ttl") != m.end() && !m["Ttl"].empty()) {
      ttl = make_shared<long>(boost::any_cast<long>(m["Ttl"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~OperateBatchDomainRequestDomainRecordInfo() = default;
};
class OperateBatchDomainRequest : public Darabonba::Model {
public:
  shared_ptr<vector<OperateBatchDomainRequestDomainRecordInfo>> domainRecordInfo{};
  shared_ptr<string> lang{};
  shared_ptr<string> type{};

  OperateBatchDomainRequest() {}

  explicit OperateBatchDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainRecordInfo) {
      vector<boost::any> temp1;
      for(auto item1:*domainRecordInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainRecordInfo"] = boost::any(temp1);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainRecordInfo") != m.end() && !m["DomainRecordInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainRecordInfo"].type()) {
        vector<OperateBatchDomainRequestDomainRecordInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainRecordInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            OperateBatchDomainRequestDomainRecordInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainRecordInfo = make_shared<vector<OperateBatchDomainRequestDomainRecordInfo>>(expect1);
      }
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~OperateBatchDomainRequest() = default;
};
class OperateBatchDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> taskId{};

  OperateBatchDomainResponseBody() {}

  explicit OperateBatchDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
  }


  virtual ~OperateBatchDomainResponseBody() = default;
};
class OperateBatchDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OperateBatchDomainResponseBody> body{};

  OperateBatchDomainResponse() {}

  explicit OperateBatchDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OperateBatchDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OperateBatchDomainResponseBody>(model1);
      }
    }
  }


  virtual ~OperateBatchDomainResponse() = default;
};
class PausePdnsServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> serviceType{};

  PausePdnsServiceRequest() {}

  explicit PausePdnsServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (serviceType) {
      res["ServiceType"] = boost::any(*serviceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("ServiceType") != m.end() && !m["ServiceType"].empty()) {
      serviceType = make_shared<string>(boost::any_cast<string>(m["ServiceType"]));
    }
  }


  virtual ~PausePdnsServiceRequest() = default;
};
class PausePdnsServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  PausePdnsServiceResponseBody() {}

  explicit PausePdnsServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~PausePdnsServiceResponseBody() = default;
};
class PausePdnsServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PausePdnsServiceResponseBody> body{};

  PausePdnsServiceResponse() {}

  explicit PausePdnsServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PausePdnsServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PausePdnsServiceResponseBody>(model1);
      }
    }
  }


  virtual ~PausePdnsServiceResponse() = default;
};
class PreviewGtmRecoveryPlanRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> recoveryPlanId{};

  PreviewGtmRecoveryPlanRequest() {}

  explicit PreviewGtmRecoveryPlanRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (recoveryPlanId) {
      res["RecoveryPlanId"] = boost::any(*recoveryPlanId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RecoveryPlanId") != m.end() && !m["RecoveryPlanId"].empty()) {
      recoveryPlanId = make_shared<long>(boost::any_cast<long>(m["RecoveryPlanId"]));
    }
  }


  virtual ~PreviewGtmRecoveryPlanRequest() = default;
};
class PreviewGtmRecoveryPlanResponseBodyPreviewsPreviewSwitchInfosSwitchInfo : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> strategyName{};

  PreviewGtmRecoveryPlanResponseBodyPreviewsPreviewSwitchInfosSwitchInfo() {}

  explicit PreviewGtmRecoveryPlanResponseBodyPreviewsPreviewSwitchInfosSwitchInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (strategyName) {
      res["StrategyName"] = boost::any(*strategyName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("StrategyName") != m.end() && !m["StrategyName"].empty()) {
      strategyName = make_shared<string>(boost::any_cast<string>(m["StrategyName"]));
    }
  }


  virtual ~PreviewGtmRecoveryPlanResponseBodyPreviewsPreviewSwitchInfosSwitchInfo() = default;
};
class PreviewGtmRecoveryPlanResponseBodyPreviewsPreviewSwitchInfos : public Darabonba::Model {
public:
  shared_ptr<vector<PreviewGtmRecoveryPlanResponseBodyPreviewsPreviewSwitchInfosSwitchInfo>> switchInfo{};

  PreviewGtmRecoveryPlanResponseBodyPreviewsPreviewSwitchInfos() {}

  explicit PreviewGtmRecoveryPlanResponseBodyPreviewsPreviewSwitchInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (switchInfo) {
      vector<boost::any> temp1;
      for(auto item1:*switchInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SwitchInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SwitchInfo") != m.end() && !m["SwitchInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["SwitchInfo"].type()) {
        vector<PreviewGtmRecoveryPlanResponseBodyPreviewsPreviewSwitchInfosSwitchInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SwitchInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PreviewGtmRecoveryPlanResponseBodyPreviewsPreviewSwitchInfosSwitchInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        switchInfo = make_shared<vector<PreviewGtmRecoveryPlanResponseBodyPreviewsPreviewSwitchInfosSwitchInfo>>(expect1);
      }
    }
  }


  virtual ~PreviewGtmRecoveryPlanResponseBodyPreviewsPreviewSwitchInfos() = default;
};
class PreviewGtmRecoveryPlanResponseBodyPreviewsPreview : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<PreviewGtmRecoveryPlanResponseBodyPreviewsPreviewSwitchInfos> switchInfos{};
  shared_ptr<string> userDomainName{};

  PreviewGtmRecoveryPlanResponseBodyPreviewsPreview() {}

  explicit PreviewGtmRecoveryPlanResponseBodyPreviewsPreview(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (switchInfos) {
      res["SwitchInfos"] = switchInfos ? boost::any(switchInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userDomainName) {
      res["UserDomainName"] = boost::any(*userDomainName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SwitchInfos") != m.end() && !m["SwitchInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["SwitchInfos"].type()) {
        PreviewGtmRecoveryPlanResponseBodyPreviewsPreviewSwitchInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SwitchInfos"]));
        switchInfos = make_shared<PreviewGtmRecoveryPlanResponseBodyPreviewsPreviewSwitchInfos>(model1);
      }
    }
    if (m.find("UserDomainName") != m.end() && !m["UserDomainName"].empty()) {
      userDomainName = make_shared<string>(boost::any_cast<string>(m["UserDomainName"]));
    }
  }


  virtual ~PreviewGtmRecoveryPlanResponseBodyPreviewsPreview() = default;
};
class PreviewGtmRecoveryPlanResponseBodyPreviews : public Darabonba::Model {
public:
  shared_ptr<vector<PreviewGtmRecoveryPlanResponseBodyPreviewsPreview>> preview{};

  PreviewGtmRecoveryPlanResponseBodyPreviews() {}

  explicit PreviewGtmRecoveryPlanResponseBodyPreviews(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (preview) {
      vector<boost::any> temp1;
      for(auto item1:*preview){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Preview"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Preview") != m.end() && !m["Preview"].empty()) {
      if (typeid(vector<boost::any>) == m["Preview"].type()) {
        vector<PreviewGtmRecoveryPlanResponseBodyPreviewsPreview> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Preview"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PreviewGtmRecoveryPlanResponseBodyPreviewsPreview model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        preview = make_shared<vector<PreviewGtmRecoveryPlanResponseBodyPreviewsPreview>>(expect1);
      }
    }
  }


  virtual ~PreviewGtmRecoveryPlanResponseBodyPreviews() = default;
};
class PreviewGtmRecoveryPlanResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<PreviewGtmRecoveryPlanResponseBodyPreviews> previews{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalItems{};
  shared_ptr<long> totalPages{};

  PreviewGtmRecoveryPlanResponseBody() {}

  explicit PreviewGtmRecoveryPlanResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (previews) {
      res["Previews"] = previews ? boost::any(previews->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalItems) {
      res["TotalItems"] = boost::any(*totalItems);
    }
    if (totalPages) {
      res["TotalPages"] = boost::any(*totalPages);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Previews") != m.end() && !m["Previews"].empty()) {
      if (typeid(map<string, boost::any>) == m["Previews"].type()) {
        PreviewGtmRecoveryPlanResponseBodyPreviews model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Previews"]));
        previews = make_shared<PreviewGtmRecoveryPlanResponseBodyPreviews>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalItems") != m.end() && !m["TotalItems"].empty()) {
      totalItems = make_shared<long>(boost::any_cast<long>(m["TotalItems"]));
    }
    if (m.find("TotalPages") != m.end() && !m["TotalPages"].empty()) {
      totalPages = make_shared<long>(boost::any_cast<long>(m["TotalPages"]));
    }
  }


  virtual ~PreviewGtmRecoveryPlanResponseBody() = default;
};
class PreviewGtmRecoveryPlanResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PreviewGtmRecoveryPlanResponseBody> body{};

  PreviewGtmRecoveryPlanResponse() {}

  explicit PreviewGtmRecoveryPlanResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PreviewGtmRecoveryPlanResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PreviewGtmRecoveryPlanResponseBody>(model1);
      }
    }
  }


  virtual ~PreviewGtmRecoveryPlanResponse() = default;
};
class RemovePdnsAppKeyRequest : public Darabonba::Model {
public:
  shared_ptr<string> appKeyId{};
  shared_ptr<string> lang{};

  RemovePdnsAppKeyRequest() {}

  explicit RemovePdnsAppKeyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appKeyId) {
      res["AppKeyId"] = boost::any(*appKeyId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppKeyId") != m.end() && !m["AppKeyId"].empty()) {
      appKeyId = make_shared<string>(boost::any_cast<string>(m["AppKeyId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~RemovePdnsAppKeyRequest() = default;
};
class RemovePdnsAppKeyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RemovePdnsAppKeyResponseBody() {}

  explicit RemovePdnsAppKeyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemovePdnsAppKeyResponseBody() = default;
};
class RemovePdnsAppKeyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemovePdnsAppKeyResponseBody> body{};

  RemovePdnsAppKeyResponse() {}

  explicit RemovePdnsAppKeyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemovePdnsAppKeyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemovePdnsAppKeyResponseBody>(model1);
      }
    }
  }


  virtual ~RemovePdnsAppKeyResponse() = default;
};
class RemovePdnsUdpIpSegmentRequest : public Darabonba::Model {
public:
  shared_ptr<string> ip{};
  shared_ptr<string> lang{};

  RemovePdnsUdpIpSegmentRequest() {}

  explicit RemovePdnsUdpIpSegmentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~RemovePdnsUdpIpSegmentRequest() = default;
};
class RemovePdnsUdpIpSegmentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RemovePdnsUdpIpSegmentResponseBody() {}

  explicit RemovePdnsUdpIpSegmentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemovePdnsUdpIpSegmentResponseBody() = default;
};
class RemovePdnsUdpIpSegmentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemovePdnsUdpIpSegmentResponseBody> body{};

  RemovePdnsUdpIpSegmentResponse() {}

  explicit RemovePdnsUdpIpSegmentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemovePdnsUdpIpSegmentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemovePdnsUdpIpSegmentResponseBody>(model1);
      }
    }
  }


  virtual ~RemovePdnsUdpIpSegmentResponse() = default;
};
class ReplaceCloudGtmAddressPoolAddressRequestAddresses : public Darabonba::Model {
public:
  shared_ptr<string> addressId{};
  shared_ptr<vector<string>> requestSource{};
  shared_ptr<long> serialNumber{};
  shared_ptr<long> weightValue{};

  ReplaceCloudGtmAddressPoolAddressRequestAddresses() {}

  explicit ReplaceCloudGtmAddressPoolAddressRequestAddresses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addressId) {
      res["AddressId"] = boost::any(*addressId);
    }
    if (requestSource) {
      res["RequestSource"] = boost::any(*requestSource);
    }
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    if (weightValue) {
      res["WeightValue"] = boost::any(*weightValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddressId") != m.end() && !m["AddressId"].empty()) {
      addressId = make_shared<string>(boost::any_cast<string>(m["AddressId"]));
    }
    if (m.find("RequestSource") != m.end() && !m["RequestSource"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RequestSource"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RequestSource"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      requestSource = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<long>(boost::any_cast<long>(m["SerialNumber"]));
    }
    if (m.find("WeightValue") != m.end() && !m["WeightValue"].empty()) {
      weightValue = make_shared<long>(boost::any_cast<long>(m["WeightValue"]));
    }
  }


  virtual ~ReplaceCloudGtmAddressPoolAddressRequestAddresses() = default;
};
class ReplaceCloudGtmAddressPoolAddressRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> addressPoolId{};
  shared_ptr<vector<ReplaceCloudGtmAddressPoolAddressRequestAddresses>> addresses{};
  shared_ptr<string> clientToken{};

  ReplaceCloudGtmAddressPoolAddressRequest() {}

  explicit ReplaceCloudGtmAddressPoolAddressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (addressPoolId) {
      res["AddressPoolId"] = boost::any(*addressPoolId);
    }
    if (addresses) {
      vector<boost::any> temp1;
      for(auto item1:*addresses){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Addresses"] = boost::any(temp1);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AddressPoolId") != m.end() && !m["AddressPoolId"].empty()) {
      addressPoolId = make_shared<string>(boost::any_cast<string>(m["AddressPoolId"]));
    }
    if (m.find("Addresses") != m.end() && !m["Addresses"].empty()) {
      if (typeid(vector<boost::any>) == m["Addresses"].type()) {
        vector<ReplaceCloudGtmAddressPoolAddressRequestAddresses> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Addresses"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ReplaceCloudGtmAddressPoolAddressRequestAddresses model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        addresses = make_shared<vector<ReplaceCloudGtmAddressPoolAddressRequestAddresses>>(expect1);
      }
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
  }


  virtual ~ReplaceCloudGtmAddressPoolAddressRequest() = default;
};
class ReplaceCloudGtmAddressPoolAddressShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> addressPoolId{};
  shared_ptr<string> addressesShrink{};
  shared_ptr<string> clientToken{};

  ReplaceCloudGtmAddressPoolAddressShrinkRequest() {}

  explicit ReplaceCloudGtmAddressPoolAddressShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (addressPoolId) {
      res["AddressPoolId"] = boost::any(*addressPoolId);
    }
    if (addressesShrink) {
      res["Addresses"] = boost::any(*addressesShrink);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AddressPoolId") != m.end() && !m["AddressPoolId"].empty()) {
      addressPoolId = make_shared<string>(boost::any_cast<string>(m["AddressPoolId"]));
    }
    if (m.find("Addresses") != m.end() && !m["Addresses"].empty()) {
      addressesShrink = make_shared<string>(boost::any_cast<string>(m["Addresses"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
  }


  virtual ~ReplaceCloudGtmAddressPoolAddressShrinkRequest() = default;
};
class ReplaceCloudGtmAddressPoolAddressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> addressPoolId{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ReplaceCloudGtmAddressPoolAddressResponseBody() {}

  explicit ReplaceCloudGtmAddressPoolAddressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addressPoolId) {
      res["AddressPoolId"] = boost::any(*addressPoolId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddressPoolId") != m.end() && !m["AddressPoolId"].empty()) {
      addressPoolId = make_shared<string>(boost::any_cast<string>(m["AddressPoolId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ReplaceCloudGtmAddressPoolAddressResponseBody() = default;
};
class ReplaceCloudGtmAddressPoolAddressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ReplaceCloudGtmAddressPoolAddressResponseBody> body{};

  ReplaceCloudGtmAddressPoolAddressResponse() {}

  explicit ReplaceCloudGtmAddressPoolAddressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReplaceCloudGtmAddressPoolAddressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReplaceCloudGtmAddressPoolAddressResponseBody>(model1);
      }
    }
  }


  virtual ~ReplaceCloudGtmAddressPoolAddressResponse() = default;
};
class ReplaceCloudGtmInstanceConfigAddressPoolRequestAddressPools : public Darabonba::Model {
public:
  shared_ptr<string> addressPoolId{};
  shared_ptr<vector<string>> requestSource{};
  shared_ptr<long> serialNumber{};
  shared_ptr<long> weightValue{};

  ReplaceCloudGtmInstanceConfigAddressPoolRequestAddressPools() {}

  explicit ReplaceCloudGtmInstanceConfigAddressPoolRequestAddressPools(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addressPoolId) {
      res["AddressPoolId"] = boost::any(*addressPoolId);
    }
    if (requestSource) {
      res["RequestSource"] = boost::any(*requestSource);
    }
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    if (weightValue) {
      res["WeightValue"] = boost::any(*weightValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddressPoolId") != m.end() && !m["AddressPoolId"].empty()) {
      addressPoolId = make_shared<string>(boost::any_cast<string>(m["AddressPoolId"]));
    }
    if (m.find("RequestSource") != m.end() && !m["RequestSource"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RequestSource"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RequestSource"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      requestSource = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<long>(boost::any_cast<long>(m["SerialNumber"]));
    }
    if (m.find("WeightValue") != m.end() && !m["WeightValue"].empty()) {
      weightValue = make_shared<long>(boost::any_cast<long>(m["WeightValue"]));
    }
  }


  virtual ~ReplaceCloudGtmInstanceConfigAddressPoolRequestAddressPools() = default;
};
class ReplaceCloudGtmInstanceConfigAddressPoolRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<vector<ReplaceCloudGtmInstanceConfigAddressPoolRequestAddressPools>> addressPools{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> configId{};
  shared_ptr<string> instanceId{};

  ReplaceCloudGtmInstanceConfigAddressPoolRequest() {}

  explicit ReplaceCloudGtmInstanceConfigAddressPoolRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (addressPools) {
      vector<boost::any> temp1;
      for(auto item1:*addressPools){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AddressPools"] = boost::any(temp1);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AddressPools") != m.end() && !m["AddressPools"].empty()) {
      if (typeid(vector<boost::any>) == m["AddressPools"].type()) {
        vector<ReplaceCloudGtmInstanceConfigAddressPoolRequestAddressPools> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AddressPools"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ReplaceCloudGtmInstanceConfigAddressPoolRequestAddressPools model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        addressPools = make_shared<vector<ReplaceCloudGtmInstanceConfigAddressPoolRequestAddressPools>>(expect1);
      }
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ReplaceCloudGtmInstanceConfigAddressPoolRequest() = default;
};
class ReplaceCloudGtmInstanceConfigAddressPoolShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> addressPoolsShrink{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> configId{};
  shared_ptr<string> instanceId{};

  ReplaceCloudGtmInstanceConfigAddressPoolShrinkRequest() {}

  explicit ReplaceCloudGtmInstanceConfigAddressPoolShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (addressPoolsShrink) {
      res["AddressPools"] = boost::any(*addressPoolsShrink);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AddressPools") != m.end() && !m["AddressPools"].empty()) {
      addressPoolsShrink = make_shared<string>(boost::any_cast<string>(m["AddressPools"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ReplaceCloudGtmInstanceConfigAddressPoolShrinkRequest() = default;
};
class ReplaceCloudGtmInstanceConfigAddressPoolResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ReplaceCloudGtmInstanceConfigAddressPoolResponseBody() {}

  explicit ReplaceCloudGtmInstanceConfigAddressPoolResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ReplaceCloudGtmInstanceConfigAddressPoolResponseBody() = default;
};
class ReplaceCloudGtmInstanceConfigAddressPoolResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ReplaceCloudGtmInstanceConfigAddressPoolResponseBody> body{};

  ReplaceCloudGtmInstanceConfigAddressPoolResponse() {}

  explicit ReplaceCloudGtmInstanceConfigAddressPoolResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReplaceCloudGtmInstanceConfigAddressPoolResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReplaceCloudGtmInstanceConfigAddressPoolResponseBody>(model1);
      }
    }
  }


  virtual ~ReplaceCloudGtmInstanceConfigAddressPoolResponse() = default;
};
class ResumePdnsServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> serviceType{};

  ResumePdnsServiceRequest() {}

  explicit ResumePdnsServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (serviceType) {
      res["ServiceType"] = boost::any(*serviceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("ServiceType") != m.end() && !m["ServiceType"].empty()) {
      serviceType = make_shared<string>(boost::any_cast<string>(m["ServiceType"]));
    }
  }


  virtual ~ResumePdnsServiceRequest() = default;
};
class ResumePdnsServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ResumePdnsServiceResponseBody() {}

  explicit ResumePdnsServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ResumePdnsServiceResponseBody() = default;
};
class ResumePdnsServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ResumePdnsServiceResponseBody> body{};

  ResumePdnsServiceResponse() {}

  explicit ResumePdnsServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResumePdnsServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResumePdnsServiceResponseBody>(model1);
      }
    }
  }


  virtual ~ResumePdnsServiceResponse() = default;
};
class RetrieveDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> lang{};

  RetrieveDomainRequest() {}

  explicit RetrieveDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~RetrieveDomainRequest() = default;
};
class RetrieveDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RetrieveDomainResponseBody() {}

  explicit RetrieveDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RetrieveDomainResponseBody() = default;
};
class RetrieveDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RetrieveDomainResponseBody> body{};

  RetrieveDomainResponse() {}

  explicit RetrieveDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RetrieveDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RetrieveDomainResponseBody>(model1);
      }
    }
  }


  virtual ~RetrieveDomainResponse() = default;
};
class RollbackGtmRecoveryPlanRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> recoveryPlanId{};

  RollbackGtmRecoveryPlanRequest() {}

  explicit RollbackGtmRecoveryPlanRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (recoveryPlanId) {
      res["RecoveryPlanId"] = boost::any(*recoveryPlanId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("RecoveryPlanId") != m.end() && !m["RecoveryPlanId"].empty()) {
      recoveryPlanId = make_shared<long>(boost::any_cast<long>(m["RecoveryPlanId"]));
    }
  }


  virtual ~RollbackGtmRecoveryPlanRequest() = default;
};
class RollbackGtmRecoveryPlanResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RollbackGtmRecoveryPlanResponseBody() {}

  explicit RollbackGtmRecoveryPlanResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RollbackGtmRecoveryPlanResponseBody() = default;
};
class RollbackGtmRecoveryPlanResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RollbackGtmRecoveryPlanResponseBody> body{};

  RollbackGtmRecoveryPlanResponse() {}

  explicit RollbackGtmRecoveryPlanResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RollbackGtmRecoveryPlanResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RollbackGtmRecoveryPlanResponseBody>(model1);
      }
    }
  }


  virtual ~RollbackGtmRecoveryPlanResponse() = default;
};
class SearchCloudGtmAddressPoolsRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> addressPoolName{};
  shared_ptr<string> addressPoolType{};
  shared_ptr<string> availableStatus{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> enableStatus{};
  shared_ptr<string> healthStatus{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> remark{};

  SearchCloudGtmAddressPoolsRequest() {}

  explicit SearchCloudGtmAddressPoolsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (addressPoolName) {
      res["AddressPoolName"] = boost::any(*addressPoolName);
    }
    if (addressPoolType) {
      res["AddressPoolType"] = boost::any(*addressPoolType);
    }
    if (availableStatus) {
      res["AvailableStatus"] = boost::any(*availableStatus);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (enableStatus) {
      res["EnableStatus"] = boost::any(*enableStatus);
    }
    if (healthStatus) {
      res["HealthStatus"] = boost::any(*healthStatus);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AddressPoolName") != m.end() && !m["AddressPoolName"].empty()) {
      addressPoolName = make_shared<string>(boost::any_cast<string>(m["AddressPoolName"]));
    }
    if (m.find("AddressPoolType") != m.end() && !m["AddressPoolType"].empty()) {
      addressPoolType = make_shared<string>(boost::any_cast<string>(m["AddressPoolType"]));
    }
    if (m.find("AvailableStatus") != m.end() && !m["AvailableStatus"].empty()) {
      availableStatus = make_shared<string>(boost::any_cast<string>(m["AvailableStatus"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("EnableStatus") != m.end() && !m["EnableStatus"].empty()) {
      enableStatus = make_shared<string>(boost::any_cast<string>(m["EnableStatus"]));
    }
    if (m.find("HealthStatus") != m.end() && !m["HealthStatus"].empty()) {
      healthStatus = make_shared<string>(boost::any_cast<string>(m["HealthStatus"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
  }


  virtual ~SearchCloudGtmAddressPoolsRequest() = default;
};
class SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressHealthTasksHealthTask : public Darabonba::Model {
public:
  shared_ptr<long> port{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateName{};

  SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressHealthTasksHealthTask() {}

  explicit SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressHealthTasksHealthTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
  }


  virtual ~SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressHealthTasksHealthTask() = default;
};
class SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressHealthTasks : public Darabonba::Model {
public:
  shared_ptr<vector<SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressHealthTasksHealthTask>> healthTask{};

  SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressHealthTasks() {}

  explicit SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressHealthTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (healthTask) {
      vector<boost::any> temp1;
      for(auto item1:*healthTask){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HealthTask"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HealthTask") != m.end() && !m["HealthTask"].empty()) {
      if (typeid(vector<boost::any>) == m["HealthTask"].type()) {
        vector<SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressHealthTasksHealthTask> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HealthTask"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressHealthTasksHealthTask model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        healthTask = make_shared<vector<SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressHealthTasksHealthTask>>(expect1);
      }
    }
  }


  virtual ~SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressHealthTasks() = default;
};
class SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddress : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> addressId{};
  shared_ptr<string> attributeInfo{};
  shared_ptr<string> availableMode{};
  shared_ptr<string> availableStatus{};
  shared_ptr<string> createTime{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<string> enableStatus{};
  shared_ptr<string> healthJudgement{};
  shared_ptr<string> healthStatus{};
  shared_ptr<SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressHealthTasks> healthTasks{};
  shared_ptr<string> manualAvailableStatus{};
  shared_ptr<string> name{};
  shared_ptr<string> remark{};
  shared_ptr<string> requestSource{};
  shared_ptr<long> serialNumber{};
  shared_ptr<string> type{};
  shared_ptr<string> updateTime{};
  shared_ptr<long> updateTimestamp{};
  shared_ptr<long> weightValue{};

  SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddress() {}

  explicit SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (addressId) {
      res["AddressId"] = boost::any(*addressId);
    }
    if (attributeInfo) {
      res["AttributeInfo"] = boost::any(*attributeInfo);
    }
    if (availableMode) {
      res["AvailableMode"] = boost::any(*availableMode);
    }
    if (availableStatus) {
      res["AvailableStatus"] = boost::any(*availableStatus);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (enableStatus) {
      res["EnableStatus"] = boost::any(*enableStatus);
    }
    if (healthJudgement) {
      res["HealthJudgement"] = boost::any(*healthJudgement);
    }
    if (healthStatus) {
      res["HealthStatus"] = boost::any(*healthStatus);
    }
    if (healthTasks) {
      res["HealthTasks"] = healthTasks ? boost::any(healthTasks->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (manualAvailableStatus) {
      res["ManualAvailableStatus"] = boost::any(*manualAvailableStatus);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (requestSource) {
      res["RequestSource"] = boost::any(*requestSource);
    }
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (updateTimestamp) {
      res["UpdateTimestamp"] = boost::any(*updateTimestamp);
    }
    if (weightValue) {
      res["WeightValue"] = boost::any(*weightValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("AddressId") != m.end() && !m["AddressId"].empty()) {
      addressId = make_shared<string>(boost::any_cast<string>(m["AddressId"]));
    }
    if (m.find("AttributeInfo") != m.end() && !m["AttributeInfo"].empty()) {
      attributeInfo = make_shared<string>(boost::any_cast<string>(m["AttributeInfo"]));
    }
    if (m.find("AvailableMode") != m.end() && !m["AvailableMode"].empty()) {
      availableMode = make_shared<string>(boost::any_cast<string>(m["AvailableMode"]));
    }
    if (m.find("AvailableStatus") != m.end() && !m["AvailableStatus"].empty()) {
      availableStatus = make_shared<string>(boost::any_cast<string>(m["AvailableStatus"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("EnableStatus") != m.end() && !m["EnableStatus"].empty()) {
      enableStatus = make_shared<string>(boost::any_cast<string>(m["EnableStatus"]));
    }
    if (m.find("HealthJudgement") != m.end() && !m["HealthJudgement"].empty()) {
      healthJudgement = make_shared<string>(boost::any_cast<string>(m["HealthJudgement"]));
    }
    if (m.find("HealthStatus") != m.end() && !m["HealthStatus"].empty()) {
      healthStatus = make_shared<string>(boost::any_cast<string>(m["HealthStatus"]));
    }
    if (m.find("HealthTasks") != m.end() && !m["HealthTasks"].empty()) {
      if (typeid(map<string, boost::any>) == m["HealthTasks"].type()) {
        SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressHealthTasks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HealthTasks"]));
        healthTasks = make_shared<SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressHealthTasks>(model1);
      }
    }
    if (m.find("ManualAvailableStatus") != m.end() && !m["ManualAvailableStatus"].empty()) {
      manualAvailableStatus = make_shared<string>(boost::any_cast<string>(m["ManualAvailableStatus"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("RequestSource") != m.end() && !m["RequestSource"].empty()) {
      requestSource = make_shared<string>(boost::any_cast<string>(m["RequestSource"]));
    }
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<long>(boost::any_cast<long>(m["SerialNumber"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("UpdateTimestamp") != m.end() && !m["UpdateTimestamp"].empty()) {
      updateTimestamp = make_shared<long>(boost::any_cast<long>(m["UpdateTimestamp"]));
    }
    if (m.find("WeightValue") != m.end() && !m["WeightValue"].empty()) {
      weightValue = make_shared<long>(boost::any_cast<long>(m["WeightValue"]));
    }
  }


  virtual ~SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddress() = default;
};
class SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddresses : public Darabonba::Model {
public:
  shared_ptr<vector<SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddress>> address{};

  SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddresses() {}

  explicit SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddresses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      vector<boost::any> temp1;
      for(auto item1:*address){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Address"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      if (typeid(vector<boost::any>) == m["Address"].type()) {
        vector<SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddress> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Address"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddress model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        address = make_shared<vector<SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddress>>(expect1);
      }
    }
  }


  virtual ~SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddresses() = default;
};
class SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPool : public Darabonba::Model {
public:
  shared_ptr<string> addressLbStrategy{};
  shared_ptr<string> addressPoolId{};
  shared_ptr<string> addressPoolName{};
  shared_ptr<string> addressPoolType{};
  shared_ptr<SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddresses> addresses{};
  shared_ptr<string> availableStatus{};
  shared_ptr<string> createTime{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<string> enableStatus{};
  shared_ptr<string> healthJudgement{};
  shared_ptr<string> healthStatus{};
  shared_ptr<string> remark{};
  shared_ptr<string> sequenceLbStrategyMode{};
  shared_ptr<string> updateTime{};
  shared_ptr<long> updateTimestamp{};

  SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPool() {}

  explicit SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPool(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addressLbStrategy) {
      res["AddressLbStrategy"] = boost::any(*addressLbStrategy);
    }
    if (addressPoolId) {
      res["AddressPoolId"] = boost::any(*addressPoolId);
    }
    if (addressPoolName) {
      res["AddressPoolName"] = boost::any(*addressPoolName);
    }
    if (addressPoolType) {
      res["AddressPoolType"] = boost::any(*addressPoolType);
    }
    if (addresses) {
      res["Addresses"] = addresses ? boost::any(addresses->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (availableStatus) {
      res["AvailableStatus"] = boost::any(*availableStatus);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (enableStatus) {
      res["EnableStatus"] = boost::any(*enableStatus);
    }
    if (healthJudgement) {
      res["HealthJudgement"] = boost::any(*healthJudgement);
    }
    if (healthStatus) {
      res["HealthStatus"] = boost::any(*healthStatus);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (sequenceLbStrategyMode) {
      res["SequenceLbStrategyMode"] = boost::any(*sequenceLbStrategyMode);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (updateTimestamp) {
      res["UpdateTimestamp"] = boost::any(*updateTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddressLbStrategy") != m.end() && !m["AddressLbStrategy"].empty()) {
      addressLbStrategy = make_shared<string>(boost::any_cast<string>(m["AddressLbStrategy"]));
    }
    if (m.find("AddressPoolId") != m.end() && !m["AddressPoolId"].empty()) {
      addressPoolId = make_shared<string>(boost::any_cast<string>(m["AddressPoolId"]));
    }
    if (m.find("AddressPoolName") != m.end() && !m["AddressPoolName"].empty()) {
      addressPoolName = make_shared<string>(boost::any_cast<string>(m["AddressPoolName"]));
    }
    if (m.find("AddressPoolType") != m.end() && !m["AddressPoolType"].empty()) {
      addressPoolType = make_shared<string>(boost::any_cast<string>(m["AddressPoolType"]));
    }
    if (m.find("Addresses") != m.end() && !m["Addresses"].empty()) {
      if (typeid(map<string, boost::any>) == m["Addresses"].type()) {
        SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddresses model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Addresses"]));
        addresses = make_shared<SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddresses>(model1);
      }
    }
    if (m.find("AvailableStatus") != m.end() && !m["AvailableStatus"].empty()) {
      availableStatus = make_shared<string>(boost::any_cast<string>(m["AvailableStatus"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("EnableStatus") != m.end() && !m["EnableStatus"].empty()) {
      enableStatus = make_shared<string>(boost::any_cast<string>(m["EnableStatus"]));
    }
    if (m.find("HealthJudgement") != m.end() && !m["HealthJudgement"].empty()) {
      healthJudgement = make_shared<string>(boost::any_cast<string>(m["HealthJudgement"]));
    }
    if (m.find("HealthStatus") != m.end() && !m["HealthStatus"].empty()) {
      healthStatus = make_shared<string>(boost::any_cast<string>(m["HealthStatus"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("SequenceLbStrategyMode") != m.end() && !m["SequenceLbStrategyMode"].empty()) {
      sequenceLbStrategyMode = make_shared<string>(boost::any_cast<string>(m["SequenceLbStrategyMode"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("UpdateTimestamp") != m.end() && !m["UpdateTimestamp"].empty()) {
      updateTimestamp = make_shared<long>(boost::any_cast<long>(m["UpdateTimestamp"]));
    }
  }


  virtual ~SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPool() = default;
};
class SearchCloudGtmAddressPoolsResponseBodyAddressPools : public Darabonba::Model {
public:
  shared_ptr<vector<SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPool>> addressPool{};

  SearchCloudGtmAddressPoolsResponseBodyAddressPools() {}

  explicit SearchCloudGtmAddressPoolsResponseBodyAddressPools(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addressPool) {
      vector<boost::any> temp1;
      for(auto item1:*addressPool){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AddressPool"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddressPool") != m.end() && !m["AddressPool"].empty()) {
      if (typeid(vector<boost::any>) == m["AddressPool"].type()) {
        vector<SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPool> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AddressPool"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPool model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        addressPool = make_shared<vector<SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPool>>(expect1);
      }
    }
  }


  virtual ~SearchCloudGtmAddressPoolsResponseBodyAddressPools() = default;
};
class SearchCloudGtmAddressPoolsResponseBody : public Darabonba::Model {
public:
  shared_ptr<SearchCloudGtmAddressPoolsResponseBodyAddressPools> addressPools{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalItems{};
  shared_ptr<long> totalPages{};

  SearchCloudGtmAddressPoolsResponseBody() {}

  explicit SearchCloudGtmAddressPoolsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addressPools) {
      res["AddressPools"] = addressPools ? boost::any(addressPools->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalItems) {
      res["TotalItems"] = boost::any(*totalItems);
    }
    if (totalPages) {
      res["TotalPages"] = boost::any(*totalPages);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddressPools") != m.end() && !m["AddressPools"].empty()) {
      if (typeid(map<string, boost::any>) == m["AddressPools"].type()) {
        SearchCloudGtmAddressPoolsResponseBodyAddressPools model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AddressPools"]));
        addressPools = make_shared<SearchCloudGtmAddressPoolsResponseBodyAddressPools>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalItems") != m.end() && !m["TotalItems"].empty()) {
      totalItems = make_shared<long>(boost::any_cast<long>(m["TotalItems"]));
    }
    if (m.find("TotalPages") != m.end() && !m["TotalPages"].empty()) {
      totalPages = make_shared<long>(boost::any_cast<long>(m["TotalPages"]));
    }
  }


  virtual ~SearchCloudGtmAddressPoolsResponseBody() = default;
};
class SearchCloudGtmAddressPoolsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchCloudGtmAddressPoolsResponseBody> body{};

  SearchCloudGtmAddressPoolsResponse() {}

  explicit SearchCloudGtmAddressPoolsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchCloudGtmAddressPoolsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchCloudGtmAddressPoolsResponseBody>(model1);
      }
    }
  }


  virtual ~SearchCloudGtmAddressPoolsResponse() = default;
};
class SearchCloudGtmAddressesRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> address{};
  shared_ptr<string> addressId{};
  shared_ptr<string> availableStatus{};
  shared_ptr<string> enableStatus{};
  shared_ptr<string> healthStatus{};
  shared_ptr<string> monitorTemplateName{};
  shared_ptr<string> nameSearchCondition{};
  shared_ptr<vector<string>> names{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> remarkSearchCondition{};
  shared_ptr<vector<string>> remarks{};
  shared_ptr<string> type{};

  SearchCloudGtmAddressesRequest() {}

  explicit SearchCloudGtmAddressesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (addressId) {
      res["AddressId"] = boost::any(*addressId);
    }
    if (availableStatus) {
      res["AvailableStatus"] = boost::any(*availableStatus);
    }
    if (enableStatus) {
      res["EnableStatus"] = boost::any(*enableStatus);
    }
    if (healthStatus) {
      res["HealthStatus"] = boost::any(*healthStatus);
    }
    if (monitorTemplateName) {
      res["MonitorTemplateName"] = boost::any(*monitorTemplateName);
    }
    if (nameSearchCondition) {
      res["NameSearchCondition"] = boost::any(*nameSearchCondition);
    }
    if (names) {
      res["Names"] = boost::any(*names);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (remarkSearchCondition) {
      res["RemarkSearchCondition"] = boost::any(*remarkSearchCondition);
    }
    if (remarks) {
      res["Remarks"] = boost::any(*remarks);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("AddressId") != m.end() && !m["AddressId"].empty()) {
      addressId = make_shared<string>(boost::any_cast<string>(m["AddressId"]));
    }
    if (m.find("AvailableStatus") != m.end() && !m["AvailableStatus"].empty()) {
      availableStatus = make_shared<string>(boost::any_cast<string>(m["AvailableStatus"]));
    }
    if (m.find("EnableStatus") != m.end() && !m["EnableStatus"].empty()) {
      enableStatus = make_shared<string>(boost::any_cast<string>(m["EnableStatus"]));
    }
    if (m.find("HealthStatus") != m.end() && !m["HealthStatus"].empty()) {
      healthStatus = make_shared<string>(boost::any_cast<string>(m["HealthStatus"]));
    }
    if (m.find("MonitorTemplateName") != m.end() && !m["MonitorTemplateName"].empty()) {
      monitorTemplateName = make_shared<string>(boost::any_cast<string>(m["MonitorTemplateName"]));
    }
    if (m.find("NameSearchCondition") != m.end() && !m["NameSearchCondition"].empty()) {
      nameSearchCondition = make_shared<string>(boost::any_cast<string>(m["NameSearchCondition"]));
    }
    if (m.find("Names") != m.end() && !m["Names"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Names"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Names"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      names = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RemarkSearchCondition") != m.end() && !m["RemarkSearchCondition"].empty()) {
      remarkSearchCondition = make_shared<string>(boost::any_cast<string>(m["RemarkSearchCondition"]));
    }
    if (m.find("Remarks") != m.end() && !m["Remarks"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Remarks"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Remarks"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      remarks = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SearchCloudGtmAddressesRequest() = default;
};
class SearchCloudGtmAddressesResponseBodyAddressesAddressHealthTasksHealthTask : public Darabonba::Model {
public:
  shared_ptr<string> monitorStatus{};
  shared_ptr<long> port{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateName{};

  SearchCloudGtmAddressesResponseBodyAddressesAddressHealthTasksHealthTask() {}

  explicit SearchCloudGtmAddressesResponseBodyAddressesAddressHealthTasksHealthTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (monitorStatus) {
      res["MonitorStatus"] = boost::any(*monitorStatus);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MonitorStatus") != m.end() && !m["MonitorStatus"].empty()) {
      monitorStatus = make_shared<string>(boost::any_cast<string>(m["MonitorStatus"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
  }


  virtual ~SearchCloudGtmAddressesResponseBodyAddressesAddressHealthTasksHealthTask() = default;
};
class SearchCloudGtmAddressesResponseBodyAddressesAddressHealthTasks : public Darabonba::Model {
public:
  shared_ptr<vector<SearchCloudGtmAddressesResponseBodyAddressesAddressHealthTasksHealthTask>> healthTask{};

  SearchCloudGtmAddressesResponseBodyAddressesAddressHealthTasks() {}

  explicit SearchCloudGtmAddressesResponseBodyAddressesAddressHealthTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (healthTask) {
      vector<boost::any> temp1;
      for(auto item1:*healthTask){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HealthTask"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HealthTask") != m.end() && !m["HealthTask"].empty()) {
      if (typeid(vector<boost::any>) == m["HealthTask"].type()) {
        vector<SearchCloudGtmAddressesResponseBodyAddressesAddressHealthTasksHealthTask> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HealthTask"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchCloudGtmAddressesResponseBodyAddressesAddressHealthTasksHealthTask model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        healthTask = make_shared<vector<SearchCloudGtmAddressesResponseBodyAddressesAddressHealthTasksHealthTask>>(expect1);
      }
    }
  }


  virtual ~SearchCloudGtmAddressesResponseBodyAddressesAddressHealthTasks() = default;
};
class SearchCloudGtmAddressesResponseBodyAddressesAddress : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> addressId{};
  shared_ptr<string> attributeInfo{};
  shared_ptr<string> availableMode{};
  shared_ptr<string> availableStatus{};
  shared_ptr<string> createTime{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<string> enableStatus{};
  shared_ptr<string> healthJudgement{};
  shared_ptr<string> healthStatus{};
  shared_ptr<SearchCloudGtmAddressesResponseBodyAddressesAddressHealthTasks> healthTasks{};
  shared_ptr<string> manualAvailableStatus{};
  shared_ptr<string> name{};
  shared_ptr<string> remark{};
  shared_ptr<string> type{};
  shared_ptr<string> updateTime{};
  shared_ptr<long> updateTimestamp{};

  SearchCloudGtmAddressesResponseBodyAddressesAddress() {}

  explicit SearchCloudGtmAddressesResponseBodyAddressesAddress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (addressId) {
      res["AddressId"] = boost::any(*addressId);
    }
    if (attributeInfo) {
      res["AttributeInfo"] = boost::any(*attributeInfo);
    }
    if (availableMode) {
      res["AvailableMode"] = boost::any(*availableMode);
    }
    if (availableStatus) {
      res["AvailableStatus"] = boost::any(*availableStatus);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (enableStatus) {
      res["EnableStatus"] = boost::any(*enableStatus);
    }
    if (healthJudgement) {
      res["HealthJudgement"] = boost::any(*healthJudgement);
    }
    if (healthStatus) {
      res["HealthStatus"] = boost::any(*healthStatus);
    }
    if (healthTasks) {
      res["HealthTasks"] = healthTasks ? boost::any(healthTasks->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (manualAvailableStatus) {
      res["ManualAvailableStatus"] = boost::any(*manualAvailableStatus);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (updateTimestamp) {
      res["UpdateTimestamp"] = boost::any(*updateTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("AddressId") != m.end() && !m["AddressId"].empty()) {
      addressId = make_shared<string>(boost::any_cast<string>(m["AddressId"]));
    }
    if (m.find("AttributeInfo") != m.end() && !m["AttributeInfo"].empty()) {
      attributeInfo = make_shared<string>(boost::any_cast<string>(m["AttributeInfo"]));
    }
    if (m.find("AvailableMode") != m.end() && !m["AvailableMode"].empty()) {
      availableMode = make_shared<string>(boost::any_cast<string>(m["AvailableMode"]));
    }
    if (m.find("AvailableStatus") != m.end() && !m["AvailableStatus"].empty()) {
      availableStatus = make_shared<string>(boost::any_cast<string>(m["AvailableStatus"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("EnableStatus") != m.end() && !m["EnableStatus"].empty()) {
      enableStatus = make_shared<string>(boost::any_cast<string>(m["EnableStatus"]));
    }
    if (m.find("HealthJudgement") != m.end() && !m["HealthJudgement"].empty()) {
      healthJudgement = make_shared<string>(boost::any_cast<string>(m["HealthJudgement"]));
    }
    if (m.find("HealthStatus") != m.end() && !m["HealthStatus"].empty()) {
      healthStatus = make_shared<string>(boost::any_cast<string>(m["HealthStatus"]));
    }
    if (m.find("HealthTasks") != m.end() && !m["HealthTasks"].empty()) {
      if (typeid(map<string, boost::any>) == m["HealthTasks"].type()) {
        SearchCloudGtmAddressesResponseBodyAddressesAddressHealthTasks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HealthTasks"]));
        healthTasks = make_shared<SearchCloudGtmAddressesResponseBodyAddressesAddressHealthTasks>(model1);
      }
    }
    if (m.find("ManualAvailableStatus") != m.end() && !m["ManualAvailableStatus"].empty()) {
      manualAvailableStatus = make_shared<string>(boost::any_cast<string>(m["ManualAvailableStatus"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("UpdateTimestamp") != m.end() && !m["UpdateTimestamp"].empty()) {
      updateTimestamp = make_shared<long>(boost::any_cast<long>(m["UpdateTimestamp"]));
    }
  }


  virtual ~SearchCloudGtmAddressesResponseBodyAddressesAddress() = default;
};
class SearchCloudGtmAddressesResponseBodyAddresses : public Darabonba::Model {
public:
  shared_ptr<vector<SearchCloudGtmAddressesResponseBodyAddressesAddress>> address{};

  SearchCloudGtmAddressesResponseBodyAddresses() {}

  explicit SearchCloudGtmAddressesResponseBodyAddresses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      vector<boost::any> temp1;
      for(auto item1:*address){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Address"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      if (typeid(vector<boost::any>) == m["Address"].type()) {
        vector<SearchCloudGtmAddressesResponseBodyAddressesAddress> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Address"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchCloudGtmAddressesResponseBodyAddressesAddress model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        address = make_shared<vector<SearchCloudGtmAddressesResponseBodyAddressesAddress>>(expect1);
      }
    }
  }


  virtual ~SearchCloudGtmAddressesResponseBodyAddresses() = default;
};
class SearchCloudGtmAddressesResponseBody : public Darabonba::Model {
public:
  shared_ptr<SearchCloudGtmAddressesResponseBodyAddresses> addresses{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalItems{};
  shared_ptr<long> totalPages{};

  SearchCloudGtmAddressesResponseBody() {}

  explicit SearchCloudGtmAddressesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addresses) {
      res["Addresses"] = addresses ? boost::any(addresses->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalItems) {
      res["TotalItems"] = boost::any(*totalItems);
    }
    if (totalPages) {
      res["TotalPages"] = boost::any(*totalPages);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Addresses") != m.end() && !m["Addresses"].empty()) {
      if (typeid(map<string, boost::any>) == m["Addresses"].type()) {
        SearchCloudGtmAddressesResponseBodyAddresses model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Addresses"]));
        addresses = make_shared<SearchCloudGtmAddressesResponseBodyAddresses>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalItems") != m.end() && !m["TotalItems"].empty()) {
      totalItems = make_shared<long>(boost::any_cast<long>(m["TotalItems"]));
    }
    if (m.find("TotalPages") != m.end() && !m["TotalPages"].empty()) {
      totalPages = make_shared<long>(boost::any_cast<long>(m["TotalPages"]));
    }
  }


  virtual ~SearchCloudGtmAddressesResponseBody() = default;
};
class SearchCloudGtmAddressesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchCloudGtmAddressesResponseBody> body{};

  SearchCloudGtmAddressesResponse() {}

  explicit SearchCloudGtmAddressesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchCloudGtmAddressesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchCloudGtmAddressesResponseBody>(model1);
      }
    }
  }


  virtual ~SearchCloudGtmAddressesResponse() = default;
};
class SearchCloudGtmInstanceConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> availableStatus{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> enableStatus{};
  shared_ptr<string> healthStatus{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> remark{};
  shared_ptr<string> scheduleDomainName{};
  shared_ptr<string> scheduleZoneName{};

  SearchCloudGtmInstanceConfigsRequest() {}

  explicit SearchCloudGtmInstanceConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (availableStatus) {
      res["AvailableStatus"] = boost::any(*availableStatus);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (enableStatus) {
      res["EnableStatus"] = boost::any(*enableStatus);
    }
    if (healthStatus) {
      res["HealthStatus"] = boost::any(*healthStatus);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (scheduleDomainName) {
      res["ScheduleDomainName"] = boost::any(*scheduleDomainName);
    }
    if (scheduleZoneName) {
      res["ScheduleZoneName"] = boost::any(*scheduleZoneName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AvailableStatus") != m.end() && !m["AvailableStatus"].empty()) {
      availableStatus = make_shared<string>(boost::any_cast<string>(m["AvailableStatus"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("EnableStatus") != m.end() && !m["EnableStatus"].empty()) {
      enableStatus = make_shared<string>(boost::any_cast<string>(m["EnableStatus"]));
    }
    if (m.find("HealthStatus") != m.end() && !m["HealthStatus"].empty()) {
      healthStatus = make_shared<string>(boost::any_cast<string>(m["HealthStatus"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("ScheduleDomainName") != m.end() && !m["ScheduleDomainName"].empty()) {
      scheduleDomainName = make_shared<string>(boost::any_cast<string>(m["ScheduleDomainName"]));
    }
    if (m.find("ScheduleZoneName") != m.end() && !m["ScheduleZoneName"].empty()) {
      scheduleZoneName = make_shared<string>(boost::any_cast<string>(m["ScheduleZoneName"]));
    }
  }


  virtual ~SearchCloudGtmInstanceConfigsRequest() = default;
};
class SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPoolsAddressPoolRequestSource : public Darabonba::Model {
public:
  shared_ptr<vector<string>> requestSource{};

  SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPoolsAddressPoolRequestSource() {}

  explicit SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPoolsAddressPoolRequestSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestSource) {
      res["RequestSource"] = boost::any(*requestSource);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestSource") != m.end() && !m["RequestSource"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RequestSource"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RequestSource"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      requestSource = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPoolsAddressPoolRequestSource() = default;
};
class SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPoolsAddressPool : public Darabonba::Model {
public:
  shared_ptr<string> addressLbStrategy{};
  shared_ptr<string> addressPoolId{};
  shared_ptr<string> addressPoolName{};
  shared_ptr<string> addressPoolType{};
  shared_ptr<string> availableStatus{};
  shared_ptr<string> createTime{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<string> enableStatus{};
  shared_ptr<string> healthJudgement{};
  shared_ptr<string> healthStatus{};
  shared_ptr<SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPoolsAddressPoolRequestSource> requestSource{};
  shared_ptr<bool> seqNonPreemptiveSchedule{};
  shared_ptr<string> sequenceLbStrategyMode{};
  shared_ptr<long> serialNumber{};
  shared_ptr<string> updateTime{};
  shared_ptr<long> updateTimestamp{};
  shared_ptr<long> weightValue{};

  SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPoolsAddressPool() {}

  explicit SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPoolsAddressPool(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addressLbStrategy) {
      res["AddressLbStrategy"] = boost::any(*addressLbStrategy);
    }
    if (addressPoolId) {
      res["AddressPoolId"] = boost::any(*addressPoolId);
    }
    if (addressPoolName) {
      res["AddressPoolName"] = boost::any(*addressPoolName);
    }
    if (addressPoolType) {
      res["AddressPoolType"] = boost::any(*addressPoolType);
    }
    if (availableStatus) {
      res["AvailableStatus"] = boost::any(*availableStatus);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (enableStatus) {
      res["EnableStatus"] = boost::any(*enableStatus);
    }
    if (healthJudgement) {
      res["HealthJudgement"] = boost::any(*healthJudgement);
    }
    if (healthStatus) {
      res["HealthStatus"] = boost::any(*healthStatus);
    }
    if (requestSource) {
      res["RequestSource"] = requestSource ? boost::any(requestSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (seqNonPreemptiveSchedule) {
      res["SeqNonPreemptiveSchedule"] = boost::any(*seqNonPreemptiveSchedule);
    }
    if (sequenceLbStrategyMode) {
      res["SequenceLbStrategyMode"] = boost::any(*sequenceLbStrategyMode);
    }
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (updateTimestamp) {
      res["UpdateTimestamp"] = boost::any(*updateTimestamp);
    }
    if (weightValue) {
      res["WeightValue"] = boost::any(*weightValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddressLbStrategy") != m.end() && !m["AddressLbStrategy"].empty()) {
      addressLbStrategy = make_shared<string>(boost::any_cast<string>(m["AddressLbStrategy"]));
    }
    if (m.find("AddressPoolId") != m.end() && !m["AddressPoolId"].empty()) {
      addressPoolId = make_shared<string>(boost::any_cast<string>(m["AddressPoolId"]));
    }
    if (m.find("AddressPoolName") != m.end() && !m["AddressPoolName"].empty()) {
      addressPoolName = make_shared<string>(boost::any_cast<string>(m["AddressPoolName"]));
    }
    if (m.find("AddressPoolType") != m.end() && !m["AddressPoolType"].empty()) {
      addressPoolType = make_shared<string>(boost::any_cast<string>(m["AddressPoolType"]));
    }
    if (m.find("AvailableStatus") != m.end() && !m["AvailableStatus"].empty()) {
      availableStatus = make_shared<string>(boost::any_cast<string>(m["AvailableStatus"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("EnableStatus") != m.end() && !m["EnableStatus"].empty()) {
      enableStatus = make_shared<string>(boost::any_cast<string>(m["EnableStatus"]));
    }
    if (m.find("HealthJudgement") != m.end() && !m["HealthJudgement"].empty()) {
      healthJudgement = make_shared<string>(boost::any_cast<string>(m["HealthJudgement"]));
    }
    if (m.find("HealthStatus") != m.end() && !m["HealthStatus"].empty()) {
      healthStatus = make_shared<string>(boost::any_cast<string>(m["HealthStatus"]));
    }
    if (m.find("RequestSource") != m.end() && !m["RequestSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["RequestSource"].type()) {
        SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPoolsAddressPoolRequestSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RequestSource"]));
        requestSource = make_shared<SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPoolsAddressPoolRequestSource>(model1);
      }
    }
    if (m.find("SeqNonPreemptiveSchedule") != m.end() && !m["SeqNonPreemptiveSchedule"].empty()) {
      seqNonPreemptiveSchedule = make_shared<bool>(boost::any_cast<bool>(m["SeqNonPreemptiveSchedule"]));
    }
    if (m.find("SequenceLbStrategyMode") != m.end() && !m["SequenceLbStrategyMode"].empty()) {
      sequenceLbStrategyMode = make_shared<string>(boost::any_cast<string>(m["SequenceLbStrategyMode"]));
    }
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<long>(boost::any_cast<long>(m["SerialNumber"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("UpdateTimestamp") != m.end() && !m["UpdateTimestamp"].empty()) {
      updateTimestamp = make_shared<long>(boost::any_cast<long>(m["UpdateTimestamp"]));
    }
    if (m.find("WeightValue") != m.end() && !m["WeightValue"].empty()) {
      weightValue = make_shared<long>(boost::any_cast<long>(m["WeightValue"]));
    }
  }


  virtual ~SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPoolsAddressPool() = default;
};
class SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPools : public Darabonba::Model {
public:
  shared_ptr<vector<SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPoolsAddressPool>> addressPool{};

  SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPools() {}

  explicit SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPools(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addressPool) {
      vector<boost::any> temp1;
      for(auto item1:*addressPool){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AddressPool"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddressPool") != m.end() && !m["AddressPool"].empty()) {
      if (typeid(vector<boost::any>) == m["AddressPool"].type()) {
        vector<SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPoolsAddressPool> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AddressPool"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPoolsAddressPool model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        addressPool = make_shared<vector<SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPoolsAddressPool>>(expect1);
      }
    }
  }


  virtual ~SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPools() = default;
};
class SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfig : public Darabonba::Model {
public:
  shared_ptr<string> addressPoolLbStrategy{};
  shared_ptr<SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPools> addressPools{};
  shared_ptr<string> availableStatus{};
  shared_ptr<string> commodityCode{};
  shared_ptr<string> configId{};
  shared_ptr<string> createTime{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<string> enableStatus{};
  shared_ptr<string> healthStatus{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> remark{};
  shared_ptr<string> scheduleDomainName{};
  shared_ptr<string> scheduleHostname{};
  shared_ptr<string> scheduleRrType{};
  shared_ptr<string> scheduleZoneMode{};
  shared_ptr<string> scheduleZoneName{};
  shared_ptr<string> sequenceLbStrategyMode{};
  shared_ptr<long> ttl{};
  shared_ptr<string> updateTime{};
  shared_ptr<long> updateTimestamp{};
  shared_ptr<string> versionCode{};

  SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfig() {}

  explicit SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addressPoolLbStrategy) {
      res["AddressPoolLbStrategy"] = boost::any(*addressPoolLbStrategy);
    }
    if (addressPools) {
      res["AddressPools"] = addressPools ? boost::any(addressPools->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (availableStatus) {
      res["AvailableStatus"] = boost::any(*availableStatus);
    }
    if (commodityCode) {
      res["CommodityCode"] = boost::any(*commodityCode);
    }
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (enableStatus) {
      res["EnableStatus"] = boost::any(*enableStatus);
    }
    if (healthStatus) {
      res["HealthStatus"] = boost::any(*healthStatus);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (scheduleDomainName) {
      res["ScheduleDomainName"] = boost::any(*scheduleDomainName);
    }
    if (scheduleHostname) {
      res["ScheduleHostname"] = boost::any(*scheduleHostname);
    }
    if (scheduleRrType) {
      res["ScheduleRrType"] = boost::any(*scheduleRrType);
    }
    if (scheduleZoneMode) {
      res["ScheduleZoneMode"] = boost::any(*scheduleZoneMode);
    }
    if (scheduleZoneName) {
      res["ScheduleZoneName"] = boost::any(*scheduleZoneName);
    }
    if (sequenceLbStrategyMode) {
      res["SequenceLbStrategyMode"] = boost::any(*sequenceLbStrategyMode);
    }
    if (ttl) {
      res["Ttl"] = boost::any(*ttl);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (updateTimestamp) {
      res["UpdateTimestamp"] = boost::any(*updateTimestamp);
    }
    if (versionCode) {
      res["VersionCode"] = boost::any(*versionCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddressPoolLbStrategy") != m.end() && !m["AddressPoolLbStrategy"].empty()) {
      addressPoolLbStrategy = make_shared<string>(boost::any_cast<string>(m["AddressPoolLbStrategy"]));
    }
    if (m.find("AddressPools") != m.end() && !m["AddressPools"].empty()) {
      if (typeid(map<string, boost::any>) == m["AddressPools"].type()) {
        SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPools model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AddressPools"]));
        addressPools = make_shared<SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPools>(model1);
      }
    }
    if (m.find("AvailableStatus") != m.end() && !m["AvailableStatus"].empty()) {
      availableStatus = make_shared<string>(boost::any_cast<string>(m["AvailableStatus"]));
    }
    if (m.find("CommodityCode") != m.end() && !m["CommodityCode"].empty()) {
      commodityCode = make_shared<string>(boost::any_cast<string>(m["CommodityCode"]));
    }
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("EnableStatus") != m.end() && !m["EnableStatus"].empty()) {
      enableStatus = make_shared<string>(boost::any_cast<string>(m["EnableStatus"]));
    }
    if (m.find("HealthStatus") != m.end() && !m["HealthStatus"].empty()) {
      healthStatus = make_shared<string>(boost::any_cast<string>(m["HealthStatus"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("ScheduleDomainName") != m.end() && !m["ScheduleDomainName"].empty()) {
      scheduleDomainName = make_shared<string>(boost::any_cast<string>(m["ScheduleDomainName"]));
    }
    if (m.find("ScheduleHostname") != m.end() && !m["ScheduleHostname"].empty()) {
      scheduleHostname = make_shared<string>(boost::any_cast<string>(m["ScheduleHostname"]));
    }
    if (m.find("ScheduleRrType") != m.end() && !m["ScheduleRrType"].empty()) {
      scheduleRrType = make_shared<string>(boost::any_cast<string>(m["ScheduleRrType"]));
    }
    if (m.find("ScheduleZoneMode") != m.end() && !m["ScheduleZoneMode"].empty()) {
      scheduleZoneMode = make_shared<string>(boost::any_cast<string>(m["ScheduleZoneMode"]));
    }
    if (m.find("ScheduleZoneName") != m.end() && !m["ScheduleZoneName"].empty()) {
      scheduleZoneName = make_shared<string>(boost::any_cast<string>(m["ScheduleZoneName"]));
    }
    if (m.find("SequenceLbStrategyMode") != m.end() && !m["SequenceLbStrategyMode"].empty()) {
      sequenceLbStrategyMode = make_shared<string>(boost::any_cast<string>(m["SequenceLbStrategyMode"]));
    }
    if (m.find("Ttl") != m.end() && !m["Ttl"].empty()) {
      ttl = make_shared<long>(boost::any_cast<long>(m["Ttl"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("UpdateTimestamp") != m.end() && !m["UpdateTimestamp"].empty()) {
      updateTimestamp = make_shared<long>(boost::any_cast<long>(m["UpdateTimestamp"]));
    }
    if (m.find("VersionCode") != m.end() && !m["VersionCode"].empty()) {
      versionCode = make_shared<string>(boost::any_cast<string>(m["VersionCode"]));
    }
  }


  virtual ~SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfig() = default;
};
class SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigs : public Darabonba::Model {
public:
  shared_ptr<vector<SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfig>> instanceConfig{};

  SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigs() {}

  explicit SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceConfig) {
      vector<boost::any> temp1;
      for(auto item1:*instanceConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceConfig"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceConfig") != m.end() && !m["InstanceConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceConfig"].type()) {
        vector<SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceConfig = make_shared<vector<SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfig>>(expect1);
      }
    }
  }


  virtual ~SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigs() = default;
};
class SearchCloudGtmInstanceConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigs> instanceConfigs{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalItems{};
  shared_ptr<long> totalPages{};

  SearchCloudGtmInstanceConfigsResponseBody() {}

  explicit SearchCloudGtmInstanceConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceConfigs) {
      res["InstanceConfigs"] = instanceConfigs ? boost::any(instanceConfigs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalItems) {
      res["TotalItems"] = boost::any(*totalItems);
    }
    if (totalPages) {
      res["TotalPages"] = boost::any(*totalPages);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceConfigs") != m.end() && !m["InstanceConfigs"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceConfigs"].type()) {
        SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceConfigs"]));
        instanceConfigs = make_shared<SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigs>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalItems") != m.end() && !m["TotalItems"].empty()) {
      totalItems = make_shared<long>(boost::any_cast<long>(m["TotalItems"]));
    }
    if (m.find("TotalPages") != m.end() && !m["TotalPages"].empty()) {
      totalPages = make_shared<long>(boost::any_cast<long>(m["TotalPages"]));
    }
  }


  virtual ~SearchCloudGtmInstanceConfigsResponseBody() = default;
};
class SearchCloudGtmInstanceConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchCloudGtmInstanceConfigsResponseBody> body{};

  SearchCloudGtmInstanceConfigsResponse() {}

  explicit SearchCloudGtmInstanceConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchCloudGtmInstanceConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchCloudGtmInstanceConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~SearchCloudGtmInstanceConfigsResponse() = default;
};
class SearchCloudGtmInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  SearchCloudGtmInstancesRequest() {}

  explicit SearchCloudGtmInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~SearchCloudGtmInstancesRequest() = default;
};
class SearchCloudGtmInstancesResponseBodyInstancesInstance : public Darabonba::Model {
public:
  shared_ptr<string> commodityCode{};
  shared_ptr<string> createTime{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<long> expireTime{};
  shared_ptr<string> expireTimestamp{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<long> monitorTaskQuota{};
  shared_ptr<long> monthlyEmailUsed{};
  shared_ptr<long> monthlySmsQuota{};
  shared_ptr<long> monthlySmsUsed{};
  shared_ptr<long> monthlyWebhookUsed{};
  shared_ptr<string> scheduleDomainName{};
  shared_ptr<string> updateTime{};
  shared_ptr<long> updateTimestamp{};
  shared_ptr<string> versionCode{};

  SearchCloudGtmInstancesResponseBodyInstancesInstance() {}

  explicit SearchCloudGtmInstancesResponseBodyInstancesInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commodityCode) {
      res["CommodityCode"] = boost::any(*commodityCode);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (expireTimestamp) {
      res["ExpireTimestamp"] = boost::any(*expireTimestamp);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (monitorTaskQuota) {
      res["MonitorTaskQuota"] = boost::any(*monitorTaskQuota);
    }
    if (monthlyEmailUsed) {
      res["MonthlyEmailUsed"] = boost::any(*monthlyEmailUsed);
    }
    if (monthlySmsQuota) {
      res["MonthlySmsQuota"] = boost::any(*monthlySmsQuota);
    }
    if (monthlySmsUsed) {
      res["MonthlySmsUsed"] = boost::any(*monthlySmsUsed);
    }
    if (monthlyWebhookUsed) {
      res["MonthlyWebhookUsed"] = boost::any(*monthlyWebhookUsed);
    }
    if (scheduleDomainName) {
      res["ScheduleDomainName"] = boost::any(*scheduleDomainName);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (updateTimestamp) {
      res["UpdateTimestamp"] = boost::any(*updateTimestamp);
    }
    if (versionCode) {
      res["VersionCode"] = boost::any(*versionCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommodityCode") != m.end() && !m["CommodityCode"].empty()) {
      commodityCode = make_shared<string>(boost::any_cast<string>(m["CommodityCode"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<long>(boost::any_cast<long>(m["ExpireTime"]));
    }
    if (m.find("ExpireTimestamp") != m.end() && !m["ExpireTimestamp"].empty()) {
      expireTimestamp = make_shared<string>(boost::any_cast<string>(m["ExpireTimestamp"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("MonitorTaskQuota") != m.end() && !m["MonitorTaskQuota"].empty()) {
      monitorTaskQuota = make_shared<long>(boost::any_cast<long>(m["MonitorTaskQuota"]));
    }
    if (m.find("MonthlyEmailUsed") != m.end() && !m["MonthlyEmailUsed"].empty()) {
      monthlyEmailUsed = make_shared<long>(boost::any_cast<long>(m["MonthlyEmailUsed"]));
    }
    if (m.find("MonthlySmsQuota") != m.end() && !m["MonthlySmsQuota"].empty()) {
      monthlySmsQuota = make_shared<long>(boost::any_cast<long>(m["MonthlySmsQuota"]));
    }
    if (m.find("MonthlySmsUsed") != m.end() && !m["MonthlySmsUsed"].empty()) {
      monthlySmsUsed = make_shared<long>(boost::any_cast<long>(m["MonthlySmsUsed"]));
    }
    if (m.find("MonthlyWebhookUsed") != m.end() && !m["MonthlyWebhookUsed"].empty()) {
      monthlyWebhookUsed = make_shared<long>(boost::any_cast<long>(m["MonthlyWebhookUsed"]));
    }
    if (m.find("ScheduleDomainName") != m.end() && !m["ScheduleDomainName"].empty()) {
      scheduleDomainName = make_shared<string>(boost::any_cast<string>(m["ScheduleDomainName"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("UpdateTimestamp") != m.end() && !m["UpdateTimestamp"].empty()) {
      updateTimestamp = make_shared<long>(boost::any_cast<long>(m["UpdateTimestamp"]));
    }
    if (m.find("VersionCode") != m.end() && !m["VersionCode"].empty()) {
      versionCode = make_shared<string>(boost::any_cast<string>(m["VersionCode"]));
    }
  }


  virtual ~SearchCloudGtmInstancesResponseBodyInstancesInstance() = default;
};
class SearchCloudGtmInstancesResponseBodyInstances : public Darabonba::Model {
public:
  shared_ptr<vector<SearchCloudGtmInstancesResponseBodyInstancesInstance>> instance{};

  SearchCloudGtmInstancesResponseBodyInstances() {}

  explicit SearchCloudGtmInstancesResponseBodyInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instance) {
      vector<boost::any> temp1;
      for(auto item1:*instance){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Instance"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Instance") != m.end() && !m["Instance"].empty()) {
      if (typeid(vector<boost::any>) == m["Instance"].type()) {
        vector<SearchCloudGtmInstancesResponseBodyInstancesInstance> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Instance"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchCloudGtmInstancesResponseBodyInstancesInstance model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instance = make_shared<vector<SearchCloudGtmInstancesResponseBodyInstancesInstance>>(expect1);
      }
    }
  }


  virtual ~SearchCloudGtmInstancesResponseBodyInstances() = default;
};
class SearchCloudGtmInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<SearchCloudGtmInstancesResponseBodyInstances> instances{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalItems{};
  shared_ptr<long> totalPages{};

  SearchCloudGtmInstancesResponseBody() {}

  explicit SearchCloudGtmInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instances) {
      res["Instances"] = instances ? boost::any(instances->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalItems) {
      res["TotalItems"] = boost::any(*totalItems);
    }
    if (totalPages) {
      res["TotalPages"] = boost::any(*totalPages);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      if (typeid(map<string, boost::any>) == m["Instances"].type()) {
        SearchCloudGtmInstancesResponseBodyInstances model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Instances"]));
        instances = make_shared<SearchCloudGtmInstancesResponseBodyInstances>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalItems") != m.end() && !m["TotalItems"].empty()) {
      totalItems = make_shared<long>(boost::any_cast<long>(m["TotalItems"]));
    }
    if (m.find("TotalPages") != m.end() && !m["TotalPages"].empty()) {
      totalPages = make_shared<long>(boost::any_cast<long>(m["TotalPages"]));
    }
  }


  virtual ~SearchCloudGtmInstancesResponseBody() = default;
};
class SearchCloudGtmInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchCloudGtmInstancesResponseBody> body{};

  SearchCloudGtmInstancesResponse() {}

  explicit SearchCloudGtmInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchCloudGtmInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchCloudGtmInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~SearchCloudGtmInstancesResponse() = default;
};
class SearchCloudGtmMonitorTemplatesRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> ipVersion{};
  shared_ptr<string> name{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> protocol{};

  SearchCloudGtmMonitorTemplatesRequest() {}

  explicit SearchCloudGtmMonitorTemplatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (ipVersion) {
      res["IpVersion"] = boost::any(*ipVersion);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("IpVersion") != m.end() && !m["IpVersion"].empty()) {
      ipVersion = make_shared<string>(boost::any_cast<string>(m["IpVersion"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
  }


  virtual ~SearchCloudGtmMonitorTemplatesRequest() = default;
};
class SearchCloudGtmMonitorTemplatesResponseBodyTemplatesTemplateIspCityNodesIspCityNode : public Darabonba::Model {
public:
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};
  shared_ptr<string> countryCode{};
  shared_ptr<string> countryName{};
  shared_ptr<string> groupName{};
  shared_ptr<string> groupType{};
  shared_ptr<string> ispCode{};
  shared_ptr<string> ispName{};

  SearchCloudGtmMonitorTemplatesResponseBodyTemplatesTemplateIspCityNodesIspCityNode() {}

  explicit SearchCloudGtmMonitorTemplatesResponseBodyTemplatesTemplateIspCityNodesIspCityNode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cityCode) {
      res["CityCode"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["CityName"] = boost::any(*cityName);
    }
    if (countryCode) {
      res["CountryCode"] = boost::any(*countryCode);
    }
    if (countryName) {
      res["CountryName"] = boost::any(*countryName);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (groupType) {
      res["GroupType"] = boost::any(*groupType);
    }
    if (ispCode) {
      res["IspCode"] = boost::any(*ispCode);
    }
    if (ispName) {
      res["IspName"] = boost::any(*ispName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CityCode") != m.end() && !m["CityCode"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["CityCode"]));
    }
    if (m.find("CityName") != m.end() && !m["CityName"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["CityName"]));
    }
    if (m.find("CountryCode") != m.end() && !m["CountryCode"].empty()) {
      countryCode = make_shared<string>(boost::any_cast<string>(m["CountryCode"]));
    }
    if (m.find("CountryName") != m.end() && !m["CountryName"].empty()) {
      countryName = make_shared<string>(boost::any_cast<string>(m["CountryName"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("GroupType") != m.end() && !m["GroupType"].empty()) {
      groupType = make_shared<string>(boost::any_cast<string>(m["GroupType"]));
    }
    if (m.find("IspCode") != m.end() && !m["IspCode"].empty()) {
      ispCode = make_shared<string>(boost::any_cast<string>(m["IspCode"]));
    }
    if (m.find("IspName") != m.end() && !m["IspName"].empty()) {
      ispName = make_shared<string>(boost::any_cast<string>(m["IspName"]));
    }
  }


  virtual ~SearchCloudGtmMonitorTemplatesResponseBodyTemplatesTemplateIspCityNodesIspCityNode() = default;
};
class SearchCloudGtmMonitorTemplatesResponseBodyTemplatesTemplateIspCityNodes : public Darabonba::Model {
public:
  shared_ptr<vector<SearchCloudGtmMonitorTemplatesResponseBodyTemplatesTemplateIspCityNodesIspCityNode>> ispCityNode{};

  SearchCloudGtmMonitorTemplatesResponseBodyTemplatesTemplateIspCityNodes() {}

  explicit SearchCloudGtmMonitorTemplatesResponseBodyTemplatesTemplateIspCityNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ispCityNode) {
      vector<boost::any> temp1;
      for(auto item1:*ispCityNode){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IspCityNode"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IspCityNode") != m.end() && !m["IspCityNode"].empty()) {
      if (typeid(vector<boost::any>) == m["IspCityNode"].type()) {
        vector<SearchCloudGtmMonitorTemplatesResponseBodyTemplatesTemplateIspCityNodesIspCityNode> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IspCityNode"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchCloudGtmMonitorTemplatesResponseBodyTemplatesTemplateIspCityNodesIspCityNode model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ispCityNode = make_shared<vector<SearchCloudGtmMonitorTemplatesResponseBodyTemplatesTemplateIspCityNodesIspCityNode>>(expect1);
      }
    }
  }


  virtual ~SearchCloudGtmMonitorTemplatesResponseBodyTemplatesTemplateIspCityNodes() = default;
};
class SearchCloudGtmMonitorTemplatesResponseBodyTemplatesTemplate : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<long> evaluationCount{};
  shared_ptr<string> extendInfo{};
  shared_ptr<long> failureRate{};
  shared_ptr<long> interval{};
  shared_ptr<string> ipVersion{};
  shared_ptr<SearchCloudGtmMonitorTemplatesResponseBodyTemplatesTemplateIspCityNodes> ispCityNodes{};
  shared_ptr<string> name{};
  shared_ptr<string> protocol{};
  shared_ptr<string> remark{};
  shared_ptr<string> templateId{};
  shared_ptr<long> timeout{};
  shared_ptr<string> updateTime{};
  shared_ptr<long> updateTimestamp{};

  SearchCloudGtmMonitorTemplatesResponseBodyTemplatesTemplate() {}

  explicit SearchCloudGtmMonitorTemplatesResponseBodyTemplatesTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (evaluationCount) {
      res["EvaluationCount"] = boost::any(*evaluationCount);
    }
    if (extendInfo) {
      res["ExtendInfo"] = boost::any(*extendInfo);
    }
    if (failureRate) {
      res["FailureRate"] = boost::any(*failureRate);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ipVersion) {
      res["IpVersion"] = boost::any(*ipVersion);
    }
    if (ispCityNodes) {
      res["IspCityNodes"] = ispCityNodes ? boost::any(ispCityNodes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (updateTimestamp) {
      res["UpdateTimestamp"] = boost::any(*updateTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("EvaluationCount") != m.end() && !m["EvaluationCount"].empty()) {
      evaluationCount = make_shared<long>(boost::any_cast<long>(m["EvaluationCount"]));
    }
    if (m.find("ExtendInfo") != m.end() && !m["ExtendInfo"].empty()) {
      extendInfo = make_shared<string>(boost::any_cast<string>(m["ExtendInfo"]));
    }
    if (m.find("FailureRate") != m.end() && !m["FailureRate"].empty()) {
      failureRate = make_shared<long>(boost::any_cast<long>(m["FailureRate"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("IpVersion") != m.end() && !m["IpVersion"].empty()) {
      ipVersion = make_shared<string>(boost::any_cast<string>(m["IpVersion"]));
    }
    if (m.find("IspCityNodes") != m.end() && !m["IspCityNodes"].empty()) {
      if (typeid(map<string, boost::any>) == m["IspCityNodes"].type()) {
        SearchCloudGtmMonitorTemplatesResponseBodyTemplatesTemplateIspCityNodes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IspCityNodes"]));
        ispCityNodes = make_shared<SearchCloudGtmMonitorTemplatesResponseBodyTemplatesTemplateIspCityNodes>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("UpdateTimestamp") != m.end() && !m["UpdateTimestamp"].empty()) {
      updateTimestamp = make_shared<long>(boost::any_cast<long>(m["UpdateTimestamp"]));
    }
  }


  virtual ~SearchCloudGtmMonitorTemplatesResponseBodyTemplatesTemplate() = default;
};
class SearchCloudGtmMonitorTemplatesResponseBodyTemplates : public Darabonba::Model {
public:
  shared_ptr<vector<SearchCloudGtmMonitorTemplatesResponseBodyTemplatesTemplate>> template_{};

  SearchCloudGtmMonitorTemplatesResponseBodyTemplates() {}

  explicit SearchCloudGtmMonitorTemplatesResponseBodyTemplates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (template_) {
      vector<boost::any> temp1;
      for(auto item1:*template_){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Template"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      if (typeid(vector<boost::any>) == m["Template"].type()) {
        vector<SearchCloudGtmMonitorTemplatesResponseBodyTemplatesTemplate> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Template"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchCloudGtmMonitorTemplatesResponseBodyTemplatesTemplate model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        template_ = make_shared<vector<SearchCloudGtmMonitorTemplatesResponseBodyTemplatesTemplate>>(expect1);
      }
    }
  }


  virtual ~SearchCloudGtmMonitorTemplatesResponseBodyTemplates() = default;
};
class SearchCloudGtmMonitorTemplatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<SearchCloudGtmMonitorTemplatesResponseBodyTemplates> templates{};
  shared_ptr<long> totalItems{};
  shared_ptr<long> totalPages{};

  SearchCloudGtmMonitorTemplatesResponseBody() {}

  explicit SearchCloudGtmMonitorTemplatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templates) {
      res["Templates"] = templates ? boost::any(templates->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalItems) {
      res["TotalItems"] = boost::any(*totalItems);
    }
    if (totalPages) {
      res["TotalPages"] = boost::any(*totalPages);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Templates") != m.end() && !m["Templates"].empty()) {
      if (typeid(map<string, boost::any>) == m["Templates"].type()) {
        SearchCloudGtmMonitorTemplatesResponseBodyTemplates model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Templates"]));
        templates = make_shared<SearchCloudGtmMonitorTemplatesResponseBodyTemplates>(model1);
      }
    }
    if (m.find("TotalItems") != m.end() && !m["TotalItems"].empty()) {
      totalItems = make_shared<long>(boost::any_cast<long>(m["TotalItems"]));
    }
    if (m.find("TotalPages") != m.end() && !m["TotalPages"].empty()) {
      totalPages = make_shared<long>(boost::any_cast<long>(m["TotalPages"]));
    }
  }


  virtual ~SearchCloudGtmMonitorTemplatesResponseBody() = default;
};
class SearchCloudGtmMonitorTemplatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchCloudGtmMonitorTemplatesResponseBody> body{};

  SearchCloudGtmMonitorTemplatesResponse() {}

  explicit SearchCloudGtmMonitorTemplatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchCloudGtmMonitorTemplatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchCloudGtmMonitorTemplatesResponseBody>(model1);
      }
    }
  }


  virtual ~SearchCloudGtmMonitorTemplatesResponse() = default;
};
class SetDNSSLBStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> lang{};
  shared_ptr<string> line{};
  shared_ptr<bool> open{};
  shared_ptr<string> subDomain{};
  shared_ptr<string> type{};
  shared_ptr<string> userClientIp{};

  SetDNSSLBStatusRequest() {}

  explicit SetDNSSLBStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (line) {
      res["Line"] = boost::any(*line);
    }
    if (open) {
      res["Open"] = boost::any(*open);
    }
    if (subDomain) {
      res["SubDomain"] = boost::any(*subDomain);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (userClientIp) {
      res["UserClientIp"] = boost::any(*userClientIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Line") != m.end() && !m["Line"].empty()) {
      line = make_shared<string>(boost::any_cast<string>(m["Line"]));
    }
    if (m.find("Open") != m.end() && !m["Open"].empty()) {
      open = make_shared<bool>(boost::any_cast<bool>(m["Open"]));
    }
    if (m.find("SubDomain") != m.end() && !m["SubDomain"].empty()) {
      subDomain = make_shared<string>(boost::any_cast<string>(m["SubDomain"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UserClientIp") != m.end() && !m["UserClientIp"].empty()) {
      userClientIp = make_shared<string>(boost::any_cast<string>(m["UserClientIp"]));
    }
  }


  virtual ~SetDNSSLBStatusRequest() = default;
};
class SetDNSSLBStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> open{};
  shared_ptr<long> recordCount{};
  shared_ptr<string> requestId{};

  SetDNSSLBStatusResponseBody() {}

  explicit SetDNSSLBStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (open) {
      res["Open"] = boost::any(*open);
    }
    if (recordCount) {
      res["RecordCount"] = boost::any(*recordCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Open") != m.end() && !m["Open"].empty()) {
      open = make_shared<bool>(boost::any_cast<bool>(m["Open"]));
    }
    if (m.find("RecordCount") != m.end() && !m["RecordCount"].empty()) {
      recordCount = make_shared<long>(boost::any_cast<long>(m["RecordCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetDNSSLBStatusResponseBody() = default;
};
class SetDNSSLBStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetDNSSLBStatusResponseBody> body{};

  SetDNSSLBStatusResponse() {}

  explicit SetDNSSLBStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetDNSSLBStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetDNSSLBStatusResponseBody>(model1);
      }
    }
  }


  virtual ~SetDNSSLBStatusResponse() = default;
};
class SetDnsGtmAccessModeRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessMode{};
  shared_ptr<string> lang{};
  shared_ptr<string> strategyId{};

  SetDnsGtmAccessModeRequest() {}

  explicit SetDnsGtmAccessModeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessMode) {
      res["AccessMode"] = boost::any(*accessMode);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (strategyId) {
      res["StrategyId"] = boost::any(*strategyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessMode") != m.end() && !m["AccessMode"].empty()) {
      accessMode = make_shared<string>(boost::any_cast<string>(m["AccessMode"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("StrategyId") != m.end() && !m["StrategyId"].empty()) {
      strategyId = make_shared<string>(boost::any_cast<string>(m["StrategyId"]));
    }
  }


  virtual ~SetDnsGtmAccessModeRequest() = default;
};
class SetDnsGtmAccessModeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetDnsGtmAccessModeResponseBody() {}

  explicit SetDnsGtmAccessModeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetDnsGtmAccessModeResponseBody() = default;
};
class SetDnsGtmAccessModeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetDnsGtmAccessModeResponseBody> body{};

  SetDnsGtmAccessModeResponse() {}

  explicit SetDnsGtmAccessModeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetDnsGtmAccessModeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetDnsGtmAccessModeResponseBody>(model1);
      }
    }
  }


  virtual ~SetDnsGtmAccessModeResponse() = default;
};
class SetDnsGtmMonitorStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> monitorConfigId{};
  shared_ptr<string> status{};

  SetDnsGtmMonitorStatusRequest() {}

  explicit SetDnsGtmMonitorStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (monitorConfigId) {
      res["MonitorConfigId"] = boost::any(*monitorConfigId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("MonitorConfigId") != m.end() && !m["MonitorConfigId"].empty()) {
      monitorConfigId = make_shared<string>(boost::any_cast<string>(m["MonitorConfigId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~SetDnsGtmMonitorStatusRequest() = default;
};
class SetDnsGtmMonitorStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetDnsGtmMonitorStatusResponseBody() {}

  explicit SetDnsGtmMonitorStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetDnsGtmMonitorStatusResponseBody() = default;
};
class SetDnsGtmMonitorStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetDnsGtmMonitorStatusResponseBody> body{};

  SetDnsGtmMonitorStatusResponse() {}

  explicit SetDnsGtmMonitorStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetDnsGtmMonitorStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetDnsGtmMonitorStatusResponseBody>(model1);
      }
    }
  }


  virtual ~SetDnsGtmMonitorStatusResponse() = default;
};
class SetDomainDnssecStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> lang{};
  shared_ptr<string> status{};

  SetDomainDnssecStatusRequest() {}

  explicit SetDomainDnssecStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~SetDomainDnssecStatusRequest() = default;
};
class SetDomainDnssecStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetDomainDnssecStatusResponseBody() {}

  explicit SetDomainDnssecStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetDomainDnssecStatusResponseBody() = default;
};
class SetDomainDnssecStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetDomainDnssecStatusResponseBody> body{};

  SetDomainDnssecStatusResponse() {}

  explicit SetDomainDnssecStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetDomainDnssecStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetDomainDnssecStatusResponseBody>(model1);
      }
    }
  }


  virtual ~SetDomainDnssecStatusResponse() = default;
};
class SetDomainRecordStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> recordId{};
  shared_ptr<string> status{};
  shared_ptr<string> userClientIp{};

  SetDomainRecordStatusRequest() {}

  explicit SetDomainRecordStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (userClientIp) {
      res["UserClientIp"] = boost::any(*userClientIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<string>(boost::any_cast<string>(m["RecordId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UserClientIp") != m.end() && !m["UserClientIp"].empty()) {
      userClientIp = make_shared<string>(boost::any_cast<string>(m["UserClientIp"]));
    }
  }


  virtual ~SetDomainRecordStatusRequest() = default;
};
class SetDomainRecordStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> recordId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};

  SetDomainRecordStatusResponseBody() {}

  explicit SetDomainRecordStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<string>(boost::any_cast<string>(m["RecordId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~SetDomainRecordStatusResponseBody() = default;
};
class SetDomainRecordStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetDomainRecordStatusResponseBody> body{};

  SetDomainRecordStatusResponse() {}

  explicit SetDomainRecordStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetDomainRecordStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetDomainRecordStatusResponseBody>(model1);
      }
    }
  }


  virtual ~SetDomainRecordStatusResponse() = default;
};
class SetGtmAccessModeRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessMode{};
  shared_ptr<string> lang{};
  shared_ptr<string> strategyId{};

  SetGtmAccessModeRequest() {}

  explicit SetGtmAccessModeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessMode) {
      res["AccessMode"] = boost::any(*accessMode);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (strategyId) {
      res["StrategyId"] = boost::any(*strategyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessMode") != m.end() && !m["AccessMode"].empty()) {
      accessMode = make_shared<string>(boost::any_cast<string>(m["AccessMode"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("StrategyId") != m.end() && !m["StrategyId"].empty()) {
      strategyId = make_shared<string>(boost::any_cast<string>(m["StrategyId"]));
    }
  }


  virtual ~SetGtmAccessModeRequest() = default;
};
class SetGtmAccessModeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetGtmAccessModeResponseBody() {}

  explicit SetGtmAccessModeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetGtmAccessModeResponseBody() = default;
};
class SetGtmAccessModeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetGtmAccessModeResponseBody> body{};

  SetGtmAccessModeResponse() {}

  explicit SetGtmAccessModeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetGtmAccessModeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetGtmAccessModeResponseBody>(model1);
      }
    }
  }


  virtual ~SetGtmAccessModeResponse() = default;
};
class SetGtmMonitorStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> monitorConfigId{};
  shared_ptr<string> status{};

  SetGtmMonitorStatusRequest() {}

  explicit SetGtmMonitorStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (monitorConfigId) {
      res["MonitorConfigId"] = boost::any(*monitorConfigId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("MonitorConfigId") != m.end() && !m["MonitorConfigId"].empty()) {
      monitorConfigId = make_shared<string>(boost::any_cast<string>(m["MonitorConfigId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~SetGtmMonitorStatusRequest() = default;
};
class SetGtmMonitorStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetGtmMonitorStatusResponseBody() {}

  explicit SetGtmMonitorStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetGtmMonitorStatusResponseBody() = default;
};
class SetGtmMonitorStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetGtmMonitorStatusResponseBody> body{};

  SetGtmMonitorStatusResponse() {}

  explicit SetGtmMonitorStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetGtmMonitorStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetGtmMonitorStatusResponseBody>(model1);
      }
    }
  }


  virtual ~SetGtmMonitorStatusResponse() = default;
};
class SubmitIspFlushCacheTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> domainName{};
  shared_ptr<vector<string>> isp{};
  shared_ptr<string> lang{};

  SubmitIspFlushCacheTaskRequest() {}

  explicit SubmitIspFlushCacheTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Isp"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Isp"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      isp = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~SubmitIspFlushCacheTaskRequest() = default;
};
class SubmitIspFlushCacheTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SubmitIspFlushCacheTaskResponseBody() {}

  explicit SubmitIspFlushCacheTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitIspFlushCacheTaskResponseBody() = default;
};
class SubmitIspFlushCacheTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitIspFlushCacheTaskResponseBody> body{};

  SubmitIspFlushCacheTaskResponse() {}

  explicit SubmitIspFlushCacheTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitIspFlushCacheTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitIspFlushCacheTaskResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitIspFlushCacheTaskResponse() = default;
};
class SwitchDnsGtmInstanceStrategyModeRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> lang{};
  shared_ptr<string> strategyMode{};

  SwitchDnsGtmInstanceStrategyModeRequest() {}

  explicit SwitchDnsGtmInstanceStrategyModeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (strategyMode) {
      res["StrategyMode"] = boost::any(*strategyMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("StrategyMode") != m.end() && !m["StrategyMode"].empty()) {
      strategyMode = make_shared<string>(boost::any_cast<string>(m["StrategyMode"]));
    }
  }


  virtual ~SwitchDnsGtmInstanceStrategyModeRequest() = default;
};
class SwitchDnsGtmInstanceStrategyModeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SwitchDnsGtmInstanceStrategyModeResponseBody() {}

  explicit SwitchDnsGtmInstanceStrategyModeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SwitchDnsGtmInstanceStrategyModeResponseBody() = default;
};
class SwitchDnsGtmInstanceStrategyModeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SwitchDnsGtmInstanceStrategyModeResponseBody> body{};

  SwitchDnsGtmInstanceStrategyModeResponse() {}

  explicit SwitchDnsGtmInstanceStrategyModeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SwitchDnsGtmInstanceStrategyModeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SwitchDnsGtmInstanceStrategyModeResponseBody>(model1);
      }
    }
  }


  virtual ~SwitchDnsGtmInstanceStrategyModeResponse() = default;
};
class TagResourcesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  TagResourcesRequestTag() {}

  explicit TagResourcesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~TagResourcesRequestTag() = default;
};
class TagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<TagResourcesRequestTag>> tag{};

  TagResourcesRequest() {}

  explicit TagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<TagResourcesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TagResourcesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<TagResourcesRequestTag>>(expect1);
      }
    }
  }


  virtual ~TagResourcesRequest() = default;
};
class TagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  TagResourcesResponseBody() {}

  explicit TagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~TagResourcesResponseBody() = default;
};
class TagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TagResourcesResponseBody> body{};

  TagResourcesResponse() {}

  explicit TagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~TagResourcesResponse() = default;
};
class TransferDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainNames{};
  shared_ptr<string> lang{};
  shared_ptr<string> remark{};
  shared_ptr<long> targetUserId{};

  TransferDomainRequest() {}

  explicit TransferDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainNames) {
      res["DomainNames"] = boost::any(*domainNames);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (targetUserId) {
      res["TargetUserId"] = boost::any(*targetUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainNames") != m.end() && !m["DomainNames"].empty()) {
      domainNames = make_shared<string>(boost::any_cast<string>(m["DomainNames"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("TargetUserId") != m.end() && !m["TargetUserId"].empty()) {
      targetUserId = make_shared<long>(boost::any_cast<long>(m["TargetUserId"]));
    }
  }


  virtual ~TransferDomainRequest() = default;
};
class TransferDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> taskId{};

  TransferDomainResponseBody() {}

  explicit TransferDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
  }


  virtual ~TransferDomainResponseBody() = default;
};
class TransferDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TransferDomainResponseBody> body{};

  TransferDomainResponse() {}

  explicit TransferDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TransferDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TransferDomainResponseBody>(model1);
      }
    }
  }


  virtual ~TransferDomainResponse() = default;
};
class UnbindInstanceDomainsRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainNames{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> lang{};

  UnbindInstanceDomainsRequest() {}

  explicit UnbindInstanceDomainsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainNames) {
      res["DomainNames"] = boost::any(*domainNames);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainNames") != m.end() && !m["DomainNames"].empty()) {
      domainNames = make_shared<string>(boost::any_cast<string>(m["DomainNames"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~UnbindInstanceDomainsRequest() = default;
};
class UnbindInstanceDomainsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> failedCount{};
  shared_ptr<string> requestId{};
  shared_ptr<long> successCount{};

  UnbindInstanceDomainsResponseBody() {}

  explicit UnbindInstanceDomainsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failedCount) {
      res["FailedCount"] = boost::any(*failedCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (successCount) {
      res["SuccessCount"] = boost::any(*successCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailedCount") != m.end() && !m["FailedCount"].empty()) {
      failedCount = make_shared<long>(boost::any_cast<long>(m["FailedCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SuccessCount") != m.end() && !m["SuccessCount"].empty()) {
      successCount = make_shared<long>(boost::any_cast<long>(m["SuccessCount"]));
    }
  }


  virtual ~UnbindInstanceDomainsResponseBody() = default;
};
class UnbindInstanceDomainsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnbindInstanceDomainsResponseBody> body{};

  UnbindInstanceDomainsResponse() {}

  explicit UnbindInstanceDomainsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnbindInstanceDomainsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnbindInstanceDomainsResponseBody>(model1);
      }
    }
  }


  virtual ~UnbindInstanceDomainsResponse() = default;
};
class UntagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> all{};
  shared_ptr<string> lang{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<string>> tagKey{};

  UntagResourcesRequest() {}

  explicit UntagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (all) {
      res["All"] = boost::any(*all);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("All") != m.end() && !m["All"].empty()) {
      all = make_shared<bool>(boost::any_cast<bool>(m["All"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TagKey"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TagKey"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tagKey = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UntagResourcesRequest() = default;
};
class UntagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UntagResourcesResponseBody() {}

  explicit UntagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UntagResourcesResponseBody() = default;
};
class UntagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UntagResourcesResponseBody> body{};

  UntagResourcesResponse() {}

  explicit UntagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UntagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UntagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~UntagResourcesResponse() = default;
};
class UpdateAppKeyStateRequest : public Darabonba::Model {
public:
  shared_ptr<string> appKeyId{};
  shared_ptr<string> lang{};
  shared_ptr<string> state{};

  UpdateAppKeyStateRequest() {}

  explicit UpdateAppKeyStateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appKeyId) {
      res["AppKeyId"] = boost::any(*appKeyId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppKeyId") != m.end() && !m["AppKeyId"].empty()) {
      appKeyId = make_shared<string>(boost::any_cast<string>(m["AppKeyId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~UpdateAppKeyStateRequest() = default;
};
class UpdateAppKeyStateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateAppKeyStateResponseBody() {}

  explicit UpdateAppKeyStateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateAppKeyStateResponseBody() = default;
};
class UpdateAppKeyStateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateAppKeyStateResponseBody> body{};

  UpdateAppKeyStateResponse() {}

  explicit UpdateAppKeyStateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAppKeyStateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAppKeyStateResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAppKeyStateResponse() = default;
};
class UpdateCloudGtmAddressRequestHealthTasks : public Darabonba::Model {
public:
  shared_ptr<long> port{};
  shared_ptr<string> templateId{};

  UpdateCloudGtmAddressRequestHealthTasks() {}

  explicit UpdateCloudGtmAddressRequestHealthTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~UpdateCloudGtmAddressRequestHealthTasks() = default;
};
class UpdateCloudGtmAddressRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> address{};
  shared_ptr<string> addressId{};
  shared_ptr<string> attributeInfo{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> healthJudgement{};
  shared_ptr<vector<UpdateCloudGtmAddressRequestHealthTasks>> healthTasks{};
  shared_ptr<string> name{};

  UpdateCloudGtmAddressRequest() {}

  explicit UpdateCloudGtmAddressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (addressId) {
      res["AddressId"] = boost::any(*addressId);
    }
    if (attributeInfo) {
      res["AttributeInfo"] = boost::any(*attributeInfo);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (healthJudgement) {
      res["HealthJudgement"] = boost::any(*healthJudgement);
    }
    if (healthTasks) {
      vector<boost::any> temp1;
      for(auto item1:*healthTasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HealthTasks"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("AddressId") != m.end() && !m["AddressId"].empty()) {
      addressId = make_shared<string>(boost::any_cast<string>(m["AddressId"]));
    }
    if (m.find("AttributeInfo") != m.end() && !m["AttributeInfo"].empty()) {
      attributeInfo = make_shared<string>(boost::any_cast<string>(m["AttributeInfo"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("HealthJudgement") != m.end() && !m["HealthJudgement"].empty()) {
      healthJudgement = make_shared<string>(boost::any_cast<string>(m["HealthJudgement"]));
    }
    if (m.find("HealthTasks") != m.end() && !m["HealthTasks"].empty()) {
      if (typeid(vector<boost::any>) == m["HealthTasks"].type()) {
        vector<UpdateCloudGtmAddressRequestHealthTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HealthTasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateCloudGtmAddressRequestHealthTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        healthTasks = make_shared<vector<UpdateCloudGtmAddressRequestHealthTasks>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~UpdateCloudGtmAddressRequest() = default;
};
class UpdateCloudGtmAddressShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> address{};
  shared_ptr<string> addressId{};
  shared_ptr<string> attributeInfo{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> healthJudgement{};
  shared_ptr<string> healthTasksShrink{};
  shared_ptr<string> name{};

  UpdateCloudGtmAddressShrinkRequest() {}

  explicit UpdateCloudGtmAddressShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (addressId) {
      res["AddressId"] = boost::any(*addressId);
    }
    if (attributeInfo) {
      res["AttributeInfo"] = boost::any(*attributeInfo);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (healthJudgement) {
      res["HealthJudgement"] = boost::any(*healthJudgement);
    }
    if (healthTasksShrink) {
      res["HealthTasks"] = boost::any(*healthTasksShrink);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("AddressId") != m.end() && !m["AddressId"].empty()) {
      addressId = make_shared<string>(boost::any_cast<string>(m["AddressId"]));
    }
    if (m.find("AttributeInfo") != m.end() && !m["AttributeInfo"].empty()) {
      attributeInfo = make_shared<string>(boost::any_cast<string>(m["AttributeInfo"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("HealthJudgement") != m.end() && !m["HealthJudgement"].empty()) {
      healthJudgement = make_shared<string>(boost::any_cast<string>(m["HealthJudgement"]));
    }
    if (m.find("HealthTasks") != m.end() && !m["HealthTasks"].empty()) {
      healthTasksShrink = make_shared<string>(boost::any_cast<string>(m["HealthTasks"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~UpdateCloudGtmAddressShrinkRequest() = default;
};
class UpdateCloudGtmAddressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateCloudGtmAddressResponseBody() {}

  explicit UpdateCloudGtmAddressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateCloudGtmAddressResponseBody() = default;
};
class UpdateCloudGtmAddressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateCloudGtmAddressResponseBody> body{};

  UpdateCloudGtmAddressResponse() {}

  explicit UpdateCloudGtmAddressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateCloudGtmAddressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateCloudGtmAddressResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateCloudGtmAddressResponse() = default;
};
class UpdateCloudGtmAddressEnableStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> addressId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> enableStatus{};

  UpdateCloudGtmAddressEnableStatusRequest() {}

  explicit UpdateCloudGtmAddressEnableStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (addressId) {
      res["AddressId"] = boost::any(*addressId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (enableStatus) {
      res["EnableStatus"] = boost::any(*enableStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AddressId") != m.end() && !m["AddressId"].empty()) {
      addressId = make_shared<string>(boost::any_cast<string>(m["AddressId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("EnableStatus") != m.end() && !m["EnableStatus"].empty()) {
      enableStatus = make_shared<string>(boost::any_cast<string>(m["EnableStatus"]));
    }
  }


  virtual ~UpdateCloudGtmAddressEnableStatusRequest() = default;
};
class UpdateCloudGtmAddressEnableStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateCloudGtmAddressEnableStatusResponseBody() {}

  explicit UpdateCloudGtmAddressEnableStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateCloudGtmAddressEnableStatusResponseBody() = default;
};
class UpdateCloudGtmAddressEnableStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateCloudGtmAddressEnableStatusResponseBody> body{};

  UpdateCloudGtmAddressEnableStatusResponse() {}

  explicit UpdateCloudGtmAddressEnableStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateCloudGtmAddressEnableStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateCloudGtmAddressEnableStatusResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateCloudGtmAddressEnableStatusResponse() = default;
};
class UpdateCloudGtmAddressManualAvailableStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> addressId{};
  shared_ptr<string> availableMode{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> manualAvailableStatus{};

  UpdateCloudGtmAddressManualAvailableStatusRequest() {}

  explicit UpdateCloudGtmAddressManualAvailableStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (addressId) {
      res["AddressId"] = boost::any(*addressId);
    }
    if (availableMode) {
      res["AvailableMode"] = boost::any(*availableMode);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (manualAvailableStatus) {
      res["ManualAvailableStatus"] = boost::any(*manualAvailableStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AddressId") != m.end() && !m["AddressId"].empty()) {
      addressId = make_shared<string>(boost::any_cast<string>(m["AddressId"]));
    }
    if (m.find("AvailableMode") != m.end() && !m["AvailableMode"].empty()) {
      availableMode = make_shared<string>(boost::any_cast<string>(m["AvailableMode"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ManualAvailableStatus") != m.end() && !m["ManualAvailableStatus"].empty()) {
      manualAvailableStatus = make_shared<string>(boost::any_cast<string>(m["ManualAvailableStatus"]));
    }
  }


  virtual ~UpdateCloudGtmAddressManualAvailableStatusRequest() = default;
};
class UpdateCloudGtmAddressManualAvailableStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateCloudGtmAddressManualAvailableStatusResponseBody() {}

  explicit UpdateCloudGtmAddressManualAvailableStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateCloudGtmAddressManualAvailableStatusResponseBody() = default;
};
class UpdateCloudGtmAddressManualAvailableStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateCloudGtmAddressManualAvailableStatusResponseBody> body{};

  UpdateCloudGtmAddressManualAvailableStatusResponse() {}

  explicit UpdateCloudGtmAddressManualAvailableStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateCloudGtmAddressManualAvailableStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateCloudGtmAddressManualAvailableStatusResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateCloudGtmAddressManualAvailableStatusResponse() = default;
};
class UpdateCloudGtmAddressPoolBasicConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> addressPoolId{};
  shared_ptr<string> addressPoolName{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> healthJudgement{};

  UpdateCloudGtmAddressPoolBasicConfigRequest() {}

  explicit UpdateCloudGtmAddressPoolBasicConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (addressPoolId) {
      res["AddressPoolId"] = boost::any(*addressPoolId);
    }
    if (addressPoolName) {
      res["AddressPoolName"] = boost::any(*addressPoolName);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (healthJudgement) {
      res["HealthJudgement"] = boost::any(*healthJudgement);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AddressPoolId") != m.end() && !m["AddressPoolId"].empty()) {
      addressPoolId = make_shared<string>(boost::any_cast<string>(m["AddressPoolId"]));
    }
    if (m.find("AddressPoolName") != m.end() && !m["AddressPoolName"].empty()) {
      addressPoolName = make_shared<string>(boost::any_cast<string>(m["AddressPoolName"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("HealthJudgement") != m.end() && !m["HealthJudgement"].empty()) {
      healthJudgement = make_shared<string>(boost::any_cast<string>(m["HealthJudgement"]));
    }
  }


  virtual ~UpdateCloudGtmAddressPoolBasicConfigRequest() = default;
};
class UpdateCloudGtmAddressPoolBasicConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> addressPoolId{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateCloudGtmAddressPoolBasicConfigResponseBody() {}

  explicit UpdateCloudGtmAddressPoolBasicConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addressPoolId) {
      res["AddressPoolId"] = boost::any(*addressPoolId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddressPoolId") != m.end() && !m["AddressPoolId"].empty()) {
      addressPoolId = make_shared<string>(boost::any_cast<string>(m["AddressPoolId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateCloudGtmAddressPoolBasicConfigResponseBody() = default;
};
class UpdateCloudGtmAddressPoolBasicConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateCloudGtmAddressPoolBasicConfigResponseBody> body{};

  UpdateCloudGtmAddressPoolBasicConfigResponse() {}

  explicit UpdateCloudGtmAddressPoolBasicConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateCloudGtmAddressPoolBasicConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateCloudGtmAddressPoolBasicConfigResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateCloudGtmAddressPoolBasicConfigResponse() = default;
};
class UpdateCloudGtmAddressPoolEnableStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> addressPoolId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> enableStatus{};

  UpdateCloudGtmAddressPoolEnableStatusRequest() {}

  explicit UpdateCloudGtmAddressPoolEnableStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (addressPoolId) {
      res["AddressPoolId"] = boost::any(*addressPoolId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (enableStatus) {
      res["EnableStatus"] = boost::any(*enableStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AddressPoolId") != m.end() && !m["AddressPoolId"].empty()) {
      addressPoolId = make_shared<string>(boost::any_cast<string>(m["AddressPoolId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("EnableStatus") != m.end() && !m["EnableStatus"].empty()) {
      enableStatus = make_shared<string>(boost::any_cast<string>(m["EnableStatus"]));
    }
  }


  virtual ~UpdateCloudGtmAddressPoolEnableStatusRequest() = default;
};
class UpdateCloudGtmAddressPoolEnableStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> addressPoolId{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateCloudGtmAddressPoolEnableStatusResponseBody() {}

  explicit UpdateCloudGtmAddressPoolEnableStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addressPoolId) {
      res["AddressPoolId"] = boost::any(*addressPoolId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddressPoolId") != m.end() && !m["AddressPoolId"].empty()) {
      addressPoolId = make_shared<string>(boost::any_cast<string>(m["AddressPoolId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateCloudGtmAddressPoolEnableStatusResponseBody() = default;
};
class UpdateCloudGtmAddressPoolEnableStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateCloudGtmAddressPoolEnableStatusResponseBody> body{};

  UpdateCloudGtmAddressPoolEnableStatusResponse() {}

  explicit UpdateCloudGtmAddressPoolEnableStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateCloudGtmAddressPoolEnableStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateCloudGtmAddressPoolEnableStatusResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateCloudGtmAddressPoolEnableStatusResponse() = default;
};
class UpdateCloudGtmAddressPoolLbStrategyRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> addressLbStrategy{};
  shared_ptr<string> addressPoolId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> sequenceLbStrategyMode{};

  UpdateCloudGtmAddressPoolLbStrategyRequest() {}

  explicit UpdateCloudGtmAddressPoolLbStrategyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (addressLbStrategy) {
      res["AddressLbStrategy"] = boost::any(*addressLbStrategy);
    }
    if (addressPoolId) {
      res["AddressPoolId"] = boost::any(*addressPoolId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (sequenceLbStrategyMode) {
      res["SequenceLbStrategyMode"] = boost::any(*sequenceLbStrategyMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AddressLbStrategy") != m.end() && !m["AddressLbStrategy"].empty()) {
      addressLbStrategy = make_shared<string>(boost::any_cast<string>(m["AddressLbStrategy"]));
    }
    if (m.find("AddressPoolId") != m.end() && !m["AddressPoolId"].empty()) {
      addressPoolId = make_shared<string>(boost::any_cast<string>(m["AddressPoolId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("SequenceLbStrategyMode") != m.end() && !m["SequenceLbStrategyMode"].empty()) {
      sequenceLbStrategyMode = make_shared<string>(boost::any_cast<string>(m["SequenceLbStrategyMode"]));
    }
  }


  virtual ~UpdateCloudGtmAddressPoolLbStrategyRequest() = default;
};
class UpdateCloudGtmAddressPoolLbStrategyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> addressPoolId{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateCloudGtmAddressPoolLbStrategyResponseBody() {}

  explicit UpdateCloudGtmAddressPoolLbStrategyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addressPoolId) {
      res["AddressPoolId"] = boost::any(*addressPoolId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddressPoolId") != m.end() && !m["AddressPoolId"].empty()) {
      addressPoolId = make_shared<string>(boost::any_cast<string>(m["AddressPoolId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateCloudGtmAddressPoolLbStrategyResponseBody() = default;
};
class UpdateCloudGtmAddressPoolLbStrategyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateCloudGtmAddressPoolLbStrategyResponseBody> body{};

  UpdateCloudGtmAddressPoolLbStrategyResponse() {}

  explicit UpdateCloudGtmAddressPoolLbStrategyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateCloudGtmAddressPoolLbStrategyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateCloudGtmAddressPoolLbStrategyResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateCloudGtmAddressPoolLbStrategyResponse() = default;
};
class UpdateCloudGtmAddressPoolRemarkRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> addressPoolId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> remark{};

  UpdateCloudGtmAddressPoolRemarkRequest() {}

  explicit UpdateCloudGtmAddressPoolRemarkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (addressPoolId) {
      res["AddressPoolId"] = boost::any(*addressPoolId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AddressPoolId") != m.end() && !m["AddressPoolId"].empty()) {
      addressPoolId = make_shared<string>(boost::any_cast<string>(m["AddressPoolId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
  }


  virtual ~UpdateCloudGtmAddressPoolRemarkRequest() = default;
};
class UpdateCloudGtmAddressPoolRemarkResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> addressPoolId{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateCloudGtmAddressPoolRemarkResponseBody() {}

  explicit UpdateCloudGtmAddressPoolRemarkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addressPoolId) {
      res["AddressPoolId"] = boost::any(*addressPoolId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddressPoolId") != m.end() && !m["AddressPoolId"].empty()) {
      addressPoolId = make_shared<string>(boost::any_cast<string>(m["AddressPoolId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateCloudGtmAddressPoolRemarkResponseBody() = default;
};
class UpdateCloudGtmAddressPoolRemarkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateCloudGtmAddressPoolRemarkResponseBody> body{};

  UpdateCloudGtmAddressPoolRemarkResponse() {}

  explicit UpdateCloudGtmAddressPoolRemarkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateCloudGtmAddressPoolRemarkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateCloudGtmAddressPoolRemarkResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateCloudGtmAddressPoolRemarkResponse() = default;
};
class UpdateCloudGtmAddressRemarkRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> addressId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> remark{};

  UpdateCloudGtmAddressRemarkRequest() {}

  explicit UpdateCloudGtmAddressRemarkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (addressId) {
      res["AddressId"] = boost::any(*addressId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AddressId") != m.end() && !m["AddressId"].empty()) {
      addressId = make_shared<string>(boost::any_cast<string>(m["AddressId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
  }


  virtual ~UpdateCloudGtmAddressRemarkRequest() = default;
};
class UpdateCloudGtmAddressRemarkResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateCloudGtmAddressRemarkResponseBody() {}

  explicit UpdateCloudGtmAddressRemarkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateCloudGtmAddressRemarkResponseBody() = default;
};
class UpdateCloudGtmAddressRemarkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateCloudGtmAddressRemarkResponseBody> body{};

  UpdateCloudGtmAddressRemarkResponse() {}

  explicit UpdateCloudGtmAddressRemarkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateCloudGtmAddressRemarkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateCloudGtmAddressRemarkResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateCloudGtmAddressRemarkResponse() = default;
};
class UpdateCloudGtmGlobalAlertRequestAlertConfig : public Darabonba::Model {
public:
  shared_ptr<bool> dingtalkNotice{};
  shared_ptr<bool> emailNotice{};
  shared_ptr<string> noticeType{};
  shared_ptr<bool> smsNotice{};

  UpdateCloudGtmGlobalAlertRequestAlertConfig() {}

  explicit UpdateCloudGtmGlobalAlertRequestAlertConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dingtalkNotice) {
      res["DingtalkNotice"] = boost::any(*dingtalkNotice);
    }
    if (emailNotice) {
      res["EmailNotice"] = boost::any(*emailNotice);
    }
    if (noticeType) {
      res["NoticeType"] = boost::any(*noticeType);
    }
    if (smsNotice) {
      res["SmsNotice"] = boost::any(*smsNotice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DingtalkNotice") != m.end() && !m["DingtalkNotice"].empty()) {
      dingtalkNotice = make_shared<bool>(boost::any_cast<bool>(m["DingtalkNotice"]));
    }
    if (m.find("EmailNotice") != m.end() && !m["EmailNotice"].empty()) {
      emailNotice = make_shared<bool>(boost::any_cast<bool>(m["EmailNotice"]));
    }
    if (m.find("NoticeType") != m.end() && !m["NoticeType"].empty()) {
      noticeType = make_shared<string>(boost::any_cast<string>(m["NoticeType"]));
    }
    if (m.find("SmsNotice") != m.end() && !m["SmsNotice"].empty()) {
      smsNotice = make_shared<bool>(boost::any_cast<bool>(m["SmsNotice"]));
    }
  }


  virtual ~UpdateCloudGtmGlobalAlertRequestAlertConfig() = default;
};
class UpdateCloudGtmGlobalAlertRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<vector<UpdateCloudGtmGlobalAlertRequestAlertConfig>> alertConfig{};
  shared_ptr<vector<string>> alertGroup{};
  shared_ptr<string> clientToken{};

  UpdateCloudGtmGlobalAlertRequest() {}

  explicit UpdateCloudGtmGlobalAlertRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (alertConfig) {
      vector<boost::any> temp1;
      for(auto item1:*alertConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlertConfig"] = boost::any(temp1);
    }
    if (alertGroup) {
      res["AlertGroup"] = boost::any(*alertGroup);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AlertConfig") != m.end() && !m["AlertConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["AlertConfig"].type()) {
        vector<UpdateCloudGtmGlobalAlertRequestAlertConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlertConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateCloudGtmGlobalAlertRequestAlertConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alertConfig = make_shared<vector<UpdateCloudGtmGlobalAlertRequestAlertConfig>>(expect1);
      }
    }
    if (m.find("AlertGroup") != m.end() && !m["AlertGroup"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AlertGroup"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AlertGroup"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      alertGroup = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
  }


  virtual ~UpdateCloudGtmGlobalAlertRequest() = default;
};
class UpdateCloudGtmGlobalAlertShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> alertConfigShrink{};
  shared_ptr<string> alertGroupShrink{};
  shared_ptr<string> clientToken{};

  UpdateCloudGtmGlobalAlertShrinkRequest() {}

  explicit UpdateCloudGtmGlobalAlertShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (alertConfigShrink) {
      res["AlertConfig"] = boost::any(*alertConfigShrink);
    }
    if (alertGroupShrink) {
      res["AlertGroup"] = boost::any(*alertGroupShrink);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AlertConfig") != m.end() && !m["AlertConfig"].empty()) {
      alertConfigShrink = make_shared<string>(boost::any_cast<string>(m["AlertConfig"]));
    }
    if (m.find("AlertGroup") != m.end() && !m["AlertGroup"].empty()) {
      alertGroupShrink = make_shared<string>(boost::any_cast<string>(m["AlertGroup"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
  }


  virtual ~UpdateCloudGtmGlobalAlertShrinkRequest() = default;
};
class UpdateCloudGtmGlobalAlertResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateCloudGtmGlobalAlertResponseBody() {}

  explicit UpdateCloudGtmGlobalAlertResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateCloudGtmGlobalAlertResponseBody() = default;
};
class UpdateCloudGtmGlobalAlertResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateCloudGtmGlobalAlertResponseBody> body{};

  UpdateCloudGtmGlobalAlertResponse() {}

  explicit UpdateCloudGtmGlobalAlertResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateCloudGtmGlobalAlertResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateCloudGtmGlobalAlertResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateCloudGtmGlobalAlertResponse() = default;
};
class UpdateCloudGtmInstanceConfigAlertRequestAlertConfig : public Darabonba::Model {
public:
  shared_ptr<bool> dingtalkNotice{};
  shared_ptr<bool> emailNotice{};
  shared_ptr<string> noticeType{};
  shared_ptr<bool> smsNotice{};

  UpdateCloudGtmInstanceConfigAlertRequestAlertConfig() {}

  explicit UpdateCloudGtmInstanceConfigAlertRequestAlertConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dingtalkNotice) {
      res["DingtalkNotice"] = boost::any(*dingtalkNotice);
    }
    if (emailNotice) {
      res["EmailNotice"] = boost::any(*emailNotice);
    }
    if (noticeType) {
      res["NoticeType"] = boost::any(*noticeType);
    }
    if (smsNotice) {
      res["SmsNotice"] = boost::any(*smsNotice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DingtalkNotice") != m.end() && !m["DingtalkNotice"].empty()) {
      dingtalkNotice = make_shared<bool>(boost::any_cast<bool>(m["DingtalkNotice"]));
    }
    if (m.find("EmailNotice") != m.end() && !m["EmailNotice"].empty()) {
      emailNotice = make_shared<bool>(boost::any_cast<bool>(m["EmailNotice"]));
    }
    if (m.find("NoticeType") != m.end() && !m["NoticeType"].empty()) {
      noticeType = make_shared<string>(boost::any_cast<string>(m["NoticeType"]));
    }
    if (m.find("SmsNotice") != m.end() && !m["SmsNotice"].empty()) {
      smsNotice = make_shared<bool>(boost::any_cast<bool>(m["SmsNotice"]));
    }
  }


  virtual ~UpdateCloudGtmInstanceConfigAlertRequestAlertConfig() = default;
};
class UpdateCloudGtmInstanceConfigAlertRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<vector<UpdateCloudGtmInstanceConfigAlertRequestAlertConfig>> alertConfig{};
  shared_ptr<vector<string>> alertGroup{};
  shared_ptr<string> alertMode{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> configId{};
  shared_ptr<string> instanceId{};

  UpdateCloudGtmInstanceConfigAlertRequest() {}

  explicit UpdateCloudGtmInstanceConfigAlertRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (alertConfig) {
      vector<boost::any> temp1;
      for(auto item1:*alertConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlertConfig"] = boost::any(temp1);
    }
    if (alertGroup) {
      res["AlertGroup"] = boost::any(*alertGroup);
    }
    if (alertMode) {
      res["AlertMode"] = boost::any(*alertMode);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AlertConfig") != m.end() && !m["AlertConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["AlertConfig"].type()) {
        vector<UpdateCloudGtmInstanceConfigAlertRequestAlertConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlertConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateCloudGtmInstanceConfigAlertRequestAlertConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alertConfig = make_shared<vector<UpdateCloudGtmInstanceConfigAlertRequestAlertConfig>>(expect1);
      }
    }
    if (m.find("AlertGroup") != m.end() && !m["AlertGroup"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AlertGroup"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AlertGroup"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      alertGroup = make_shared<vector<string>>(toVec1);
    }
    if (m.find("AlertMode") != m.end() && !m["AlertMode"].empty()) {
      alertMode = make_shared<string>(boost::any_cast<string>(m["AlertMode"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~UpdateCloudGtmInstanceConfigAlertRequest() = default;
};
class UpdateCloudGtmInstanceConfigAlertShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> alertConfigShrink{};
  shared_ptr<string> alertGroupShrink{};
  shared_ptr<string> alertMode{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> configId{};
  shared_ptr<string> instanceId{};

  UpdateCloudGtmInstanceConfigAlertShrinkRequest() {}

  explicit UpdateCloudGtmInstanceConfigAlertShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (alertConfigShrink) {
      res["AlertConfig"] = boost::any(*alertConfigShrink);
    }
    if (alertGroupShrink) {
      res["AlertGroup"] = boost::any(*alertGroupShrink);
    }
    if (alertMode) {
      res["AlertMode"] = boost::any(*alertMode);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AlertConfig") != m.end() && !m["AlertConfig"].empty()) {
      alertConfigShrink = make_shared<string>(boost::any_cast<string>(m["AlertConfig"]));
    }
    if (m.find("AlertGroup") != m.end() && !m["AlertGroup"].empty()) {
      alertGroupShrink = make_shared<string>(boost::any_cast<string>(m["AlertGroup"]));
    }
    if (m.find("AlertMode") != m.end() && !m["AlertMode"].empty()) {
      alertMode = make_shared<string>(boost::any_cast<string>(m["AlertMode"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~UpdateCloudGtmInstanceConfigAlertShrinkRequest() = default;
};
class UpdateCloudGtmInstanceConfigAlertResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateCloudGtmInstanceConfigAlertResponseBody() {}

  explicit UpdateCloudGtmInstanceConfigAlertResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateCloudGtmInstanceConfigAlertResponseBody() = default;
};
class UpdateCloudGtmInstanceConfigAlertResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateCloudGtmInstanceConfigAlertResponseBody> body{};

  UpdateCloudGtmInstanceConfigAlertResponse() {}

  explicit UpdateCloudGtmInstanceConfigAlertResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateCloudGtmInstanceConfigAlertResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateCloudGtmInstanceConfigAlertResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateCloudGtmInstanceConfigAlertResponse() = default;
};
class UpdateCloudGtmInstanceConfigBasicRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> configId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> scheduleHostname{};
  shared_ptr<string> scheduleZoneName{};
  shared_ptr<long> ttl{};

  UpdateCloudGtmInstanceConfigBasicRequest() {}

  explicit UpdateCloudGtmInstanceConfigBasicRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (scheduleHostname) {
      res["ScheduleHostname"] = boost::any(*scheduleHostname);
    }
    if (scheduleZoneName) {
      res["ScheduleZoneName"] = boost::any(*scheduleZoneName);
    }
    if (ttl) {
      res["Ttl"] = boost::any(*ttl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ScheduleHostname") != m.end() && !m["ScheduleHostname"].empty()) {
      scheduleHostname = make_shared<string>(boost::any_cast<string>(m["ScheduleHostname"]));
    }
    if (m.find("ScheduleZoneName") != m.end() && !m["ScheduleZoneName"].empty()) {
      scheduleZoneName = make_shared<string>(boost::any_cast<string>(m["ScheduleZoneName"]));
    }
    if (m.find("Ttl") != m.end() && !m["Ttl"].empty()) {
      ttl = make_shared<long>(boost::any_cast<long>(m["Ttl"]));
    }
  }


  virtual ~UpdateCloudGtmInstanceConfigBasicRequest() = default;
};
class UpdateCloudGtmInstanceConfigBasicResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateCloudGtmInstanceConfigBasicResponseBody() {}

  explicit UpdateCloudGtmInstanceConfigBasicResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateCloudGtmInstanceConfigBasicResponseBody() = default;
};
class UpdateCloudGtmInstanceConfigBasicResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateCloudGtmInstanceConfigBasicResponseBody> body{};

  UpdateCloudGtmInstanceConfigBasicResponse() {}

  explicit UpdateCloudGtmInstanceConfigBasicResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateCloudGtmInstanceConfigBasicResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateCloudGtmInstanceConfigBasicResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateCloudGtmInstanceConfigBasicResponse() = default;
};
class UpdateCloudGtmInstanceConfigEnableStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> configId{};
  shared_ptr<string> enableStatus{};
  shared_ptr<string> instanceId{};

  UpdateCloudGtmInstanceConfigEnableStatusRequest() {}

  explicit UpdateCloudGtmInstanceConfigEnableStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (enableStatus) {
      res["EnableStatus"] = boost::any(*enableStatus);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("EnableStatus") != m.end() && !m["EnableStatus"].empty()) {
      enableStatus = make_shared<string>(boost::any_cast<string>(m["EnableStatus"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~UpdateCloudGtmInstanceConfigEnableStatusRequest() = default;
};
class UpdateCloudGtmInstanceConfigEnableStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateCloudGtmInstanceConfigEnableStatusResponseBody() {}

  explicit UpdateCloudGtmInstanceConfigEnableStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateCloudGtmInstanceConfigEnableStatusResponseBody() = default;
};
class UpdateCloudGtmInstanceConfigEnableStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateCloudGtmInstanceConfigEnableStatusResponseBody> body{};

  UpdateCloudGtmInstanceConfigEnableStatusResponse() {}

  explicit UpdateCloudGtmInstanceConfigEnableStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateCloudGtmInstanceConfigEnableStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateCloudGtmInstanceConfigEnableStatusResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateCloudGtmInstanceConfigEnableStatusResponse() = default;
};
class UpdateCloudGtmInstanceConfigLbStrategyRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> addressPoolLbStrategy{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> configId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> sequenceLbStrategyMode{};

  UpdateCloudGtmInstanceConfigLbStrategyRequest() {}

  explicit UpdateCloudGtmInstanceConfigLbStrategyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (addressPoolLbStrategy) {
      res["AddressPoolLbStrategy"] = boost::any(*addressPoolLbStrategy);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (sequenceLbStrategyMode) {
      res["SequenceLbStrategyMode"] = boost::any(*sequenceLbStrategyMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AddressPoolLbStrategy") != m.end() && !m["AddressPoolLbStrategy"].empty()) {
      addressPoolLbStrategy = make_shared<string>(boost::any_cast<string>(m["AddressPoolLbStrategy"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SequenceLbStrategyMode") != m.end() && !m["SequenceLbStrategyMode"].empty()) {
      sequenceLbStrategyMode = make_shared<string>(boost::any_cast<string>(m["SequenceLbStrategyMode"]));
    }
  }


  virtual ~UpdateCloudGtmInstanceConfigLbStrategyRequest() = default;
};
class UpdateCloudGtmInstanceConfigLbStrategyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateCloudGtmInstanceConfigLbStrategyResponseBody() {}

  explicit UpdateCloudGtmInstanceConfigLbStrategyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateCloudGtmInstanceConfigLbStrategyResponseBody() = default;
};
class UpdateCloudGtmInstanceConfigLbStrategyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateCloudGtmInstanceConfigLbStrategyResponseBody> body{};

  UpdateCloudGtmInstanceConfigLbStrategyResponse() {}

  explicit UpdateCloudGtmInstanceConfigLbStrategyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateCloudGtmInstanceConfigLbStrategyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateCloudGtmInstanceConfigLbStrategyResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateCloudGtmInstanceConfigLbStrategyResponse() = default;
};
class UpdateCloudGtmInstanceConfigRemarkRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> configId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> remark{};

  UpdateCloudGtmInstanceConfigRemarkRequest() {}

  explicit UpdateCloudGtmInstanceConfigRemarkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
  }


  virtual ~UpdateCloudGtmInstanceConfigRemarkRequest() = default;
};
class UpdateCloudGtmInstanceConfigRemarkResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateCloudGtmInstanceConfigRemarkResponseBody() {}

  explicit UpdateCloudGtmInstanceConfigRemarkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateCloudGtmInstanceConfigRemarkResponseBody() = default;
};
class UpdateCloudGtmInstanceConfigRemarkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateCloudGtmInstanceConfigRemarkResponseBody> body{};

  UpdateCloudGtmInstanceConfigRemarkResponse() {}

  explicit UpdateCloudGtmInstanceConfigRemarkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateCloudGtmInstanceConfigRemarkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateCloudGtmInstanceConfigRemarkResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateCloudGtmInstanceConfigRemarkResponse() = default;
};
class UpdateCloudGtmInstanceNameRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};

  UpdateCloudGtmInstanceNameRequest() {}

  explicit UpdateCloudGtmInstanceNameRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
  }


  virtual ~UpdateCloudGtmInstanceNameRequest() = default;
};
class UpdateCloudGtmInstanceNameResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateCloudGtmInstanceNameResponseBody() {}

  explicit UpdateCloudGtmInstanceNameResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateCloudGtmInstanceNameResponseBody() = default;
};
class UpdateCloudGtmInstanceNameResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateCloudGtmInstanceNameResponseBody> body{};

  UpdateCloudGtmInstanceNameResponse() {}

  explicit UpdateCloudGtmInstanceNameResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateCloudGtmInstanceNameResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateCloudGtmInstanceNameResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateCloudGtmInstanceNameResponse() = default;
};
class UpdateCloudGtmMonitorTemplateRequestIspCityNodes : public Darabonba::Model {
public:
  shared_ptr<string> cityCode{};
  shared_ptr<string> ispCode{};

  UpdateCloudGtmMonitorTemplateRequestIspCityNodes() {}

  explicit UpdateCloudGtmMonitorTemplateRequestIspCityNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cityCode) {
      res["CityCode"] = boost::any(*cityCode);
    }
    if (ispCode) {
      res["IspCode"] = boost::any(*ispCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CityCode") != m.end() && !m["CityCode"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["CityCode"]));
    }
    if (m.find("IspCode") != m.end() && !m["IspCode"].empty()) {
      ispCode = make_shared<string>(boost::any_cast<string>(m["IspCode"]));
    }
  }


  virtual ~UpdateCloudGtmMonitorTemplateRequestIspCityNodes() = default;
};
class UpdateCloudGtmMonitorTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> clientToken{};
  shared_ptr<long> evaluationCount{};
  shared_ptr<string> extendInfo{};
  shared_ptr<long> failureRate{};
  shared_ptr<long> interval{};
  shared_ptr<vector<UpdateCloudGtmMonitorTemplateRequestIspCityNodes>> ispCityNodes{};
  shared_ptr<string> name{};
  shared_ptr<string> templateId{};
  shared_ptr<long> timeout{};

  UpdateCloudGtmMonitorTemplateRequest() {}

  explicit UpdateCloudGtmMonitorTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (evaluationCount) {
      res["EvaluationCount"] = boost::any(*evaluationCount);
    }
    if (extendInfo) {
      res["ExtendInfo"] = boost::any(*extendInfo);
    }
    if (failureRate) {
      res["FailureRate"] = boost::any(*failureRate);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ispCityNodes) {
      vector<boost::any> temp1;
      for(auto item1:*ispCityNodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IspCityNodes"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("EvaluationCount") != m.end() && !m["EvaluationCount"].empty()) {
      evaluationCount = make_shared<long>(boost::any_cast<long>(m["EvaluationCount"]));
    }
    if (m.find("ExtendInfo") != m.end() && !m["ExtendInfo"].empty()) {
      extendInfo = make_shared<string>(boost::any_cast<string>(m["ExtendInfo"]));
    }
    if (m.find("FailureRate") != m.end() && !m["FailureRate"].empty()) {
      failureRate = make_shared<long>(boost::any_cast<long>(m["FailureRate"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("IspCityNodes") != m.end() && !m["IspCityNodes"].empty()) {
      if (typeid(vector<boost::any>) == m["IspCityNodes"].type()) {
        vector<UpdateCloudGtmMonitorTemplateRequestIspCityNodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IspCityNodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateCloudGtmMonitorTemplateRequestIspCityNodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ispCityNodes = make_shared<vector<UpdateCloudGtmMonitorTemplateRequestIspCityNodes>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
  }


  virtual ~UpdateCloudGtmMonitorTemplateRequest() = default;
};
class UpdateCloudGtmMonitorTemplateShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> clientToken{};
  shared_ptr<long> evaluationCount{};
  shared_ptr<string> extendInfo{};
  shared_ptr<long> failureRate{};
  shared_ptr<long> interval{};
  shared_ptr<string> ispCityNodesShrink{};
  shared_ptr<string> name{};
  shared_ptr<string> templateId{};
  shared_ptr<long> timeout{};

  UpdateCloudGtmMonitorTemplateShrinkRequest() {}

  explicit UpdateCloudGtmMonitorTemplateShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (evaluationCount) {
      res["EvaluationCount"] = boost::any(*evaluationCount);
    }
    if (extendInfo) {
      res["ExtendInfo"] = boost::any(*extendInfo);
    }
    if (failureRate) {
      res["FailureRate"] = boost::any(*failureRate);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ispCityNodesShrink) {
      res["IspCityNodes"] = boost::any(*ispCityNodesShrink);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("EvaluationCount") != m.end() && !m["EvaluationCount"].empty()) {
      evaluationCount = make_shared<long>(boost::any_cast<long>(m["EvaluationCount"]));
    }
    if (m.find("ExtendInfo") != m.end() && !m["ExtendInfo"].empty()) {
      extendInfo = make_shared<string>(boost::any_cast<string>(m["ExtendInfo"]));
    }
    if (m.find("FailureRate") != m.end() && !m["FailureRate"].empty()) {
      failureRate = make_shared<long>(boost::any_cast<long>(m["FailureRate"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("IspCityNodes") != m.end() && !m["IspCityNodes"].empty()) {
      ispCityNodesShrink = make_shared<string>(boost::any_cast<string>(m["IspCityNodes"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
  }


  virtual ~UpdateCloudGtmMonitorTemplateShrinkRequest() = default;
};
class UpdateCloudGtmMonitorTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateCloudGtmMonitorTemplateResponseBody() {}

  explicit UpdateCloudGtmMonitorTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateCloudGtmMonitorTemplateResponseBody() = default;
};
class UpdateCloudGtmMonitorTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateCloudGtmMonitorTemplateResponseBody> body{};

  UpdateCloudGtmMonitorTemplateResponse() {}

  explicit UpdateCloudGtmMonitorTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateCloudGtmMonitorTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateCloudGtmMonitorTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateCloudGtmMonitorTemplateResponse() = default;
};
class UpdateCloudGtmMonitorTemplateRemarkRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> remark{};
  shared_ptr<string> templateId{};

  UpdateCloudGtmMonitorTemplateRemarkRequest() {}

  explicit UpdateCloudGtmMonitorTemplateRemarkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~UpdateCloudGtmMonitorTemplateRemarkRequest() = default;
};
class UpdateCloudGtmMonitorTemplateRemarkResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateCloudGtmMonitorTemplateRemarkResponseBody() {}

  explicit UpdateCloudGtmMonitorTemplateRemarkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateCloudGtmMonitorTemplateRemarkResponseBody() = default;
};
class UpdateCloudGtmMonitorTemplateRemarkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateCloudGtmMonitorTemplateRemarkResponseBody> body{};

  UpdateCloudGtmMonitorTemplateRemarkResponse() {}

  explicit UpdateCloudGtmMonitorTemplateRemarkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateCloudGtmMonitorTemplateRemarkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateCloudGtmMonitorTemplateRemarkResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateCloudGtmMonitorTemplateRemarkResponse() = default;
};
class UpdateCustomLineRequestIpSegment : public Darabonba::Model {
public:
  shared_ptr<string> endIp{};
  shared_ptr<string> startIp{};

  UpdateCustomLineRequestIpSegment() {}

  explicit UpdateCustomLineRequestIpSegment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endIp) {
      res["EndIp"] = boost::any(*endIp);
    }
    if (startIp) {
      res["StartIp"] = boost::any(*startIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndIp") != m.end() && !m["EndIp"].empty()) {
      endIp = make_shared<string>(boost::any_cast<string>(m["EndIp"]));
    }
    if (m.find("StartIp") != m.end() && !m["StartIp"].empty()) {
      startIp = make_shared<string>(boost::any_cast<string>(m["StartIp"]));
    }
  }


  virtual ~UpdateCustomLineRequestIpSegment() = default;
};
class UpdateCustomLineRequest : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateCustomLineRequestIpSegment>> ipSegment{};
  shared_ptr<string> lang{};
  shared_ptr<long> lineId{};
  shared_ptr<string> lineName{};

  UpdateCustomLineRequest() {}

  explicit UpdateCustomLineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipSegment) {
      vector<boost::any> temp1;
      for(auto item1:*ipSegment){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IpSegment"] = boost::any(temp1);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (lineId) {
      res["LineId"] = boost::any(*lineId);
    }
    if (lineName) {
      res["LineName"] = boost::any(*lineName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpSegment") != m.end() && !m["IpSegment"].empty()) {
      if (typeid(vector<boost::any>) == m["IpSegment"].type()) {
        vector<UpdateCustomLineRequestIpSegment> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IpSegment"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateCustomLineRequestIpSegment model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ipSegment = make_shared<vector<UpdateCustomLineRequestIpSegment>>(expect1);
      }
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("LineId") != m.end() && !m["LineId"].empty()) {
      lineId = make_shared<long>(boost::any_cast<long>(m["LineId"]));
    }
    if (m.find("LineName") != m.end() && !m["LineName"].empty()) {
      lineName = make_shared<string>(boost::any_cast<string>(m["LineName"]));
    }
  }


  virtual ~UpdateCustomLineRequest() = default;
};
class UpdateCustomLineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateCustomLineResponseBody() {}

  explicit UpdateCustomLineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateCustomLineResponseBody() = default;
};
class UpdateCustomLineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateCustomLineResponseBody> body{};

  UpdateCustomLineResponse() {}

  explicit UpdateCustomLineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateCustomLineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateCustomLineResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateCustomLineResponse() = default;
};
class UpdateDNSSLBWeightRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> recordId{};
  shared_ptr<string> userClientIp{};
  shared_ptr<long> weight{};

  UpdateDNSSLBWeightRequest() {}

  explicit UpdateDNSSLBWeightRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (userClientIp) {
      res["UserClientIp"] = boost::any(*userClientIp);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<string>(boost::any_cast<string>(m["RecordId"]));
    }
    if (m.find("UserClientIp") != m.end() && !m["UserClientIp"].empty()) {
      userClientIp = make_shared<string>(boost::any_cast<string>(m["UserClientIp"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~UpdateDNSSLBWeightRequest() = default;
};
class UpdateDNSSLBWeightResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> recordId{};
  shared_ptr<string> requestId{};
  shared_ptr<long> weight{};

  UpdateDNSSLBWeightResponseBody() {}

  explicit UpdateDNSSLBWeightResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<string>(boost::any_cast<string>(m["RecordId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~UpdateDNSSLBWeightResponseBody() = default;
};
class UpdateDNSSLBWeightResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDNSSLBWeightResponseBody> body{};

  UpdateDNSSLBWeightResponse() {}

  explicit UpdateDNSSLBWeightResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDNSSLBWeightResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDNSSLBWeightResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDNSSLBWeightResponse() = default;
};
class UpdateDnsCacheDomainRequestSourceDnsServer : public Darabonba::Model {
public:
  shared_ptr<string> host{};
  shared_ptr<string> port{};

  UpdateDnsCacheDomainRequestSourceDnsServer() {}

  explicit UpdateDnsCacheDomainRequestSourceDnsServer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
  }


  virtual ~UpdateDnsCacheDomainRequestSourceDnsServer() = default;
};
class UpdateDnsCacheDomainRequest : public Darabonba::Model {
public:
  shared_ptr<long> cacheTtlMax{};
  shared_ptr<long> cacheTtlMin{};
  shared_ptr<string> domainName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> lang{};
  shared_ptr<vector<UpdateDnsCacheDomainRequestSourceDnsServer>> sourceDnsServer{};
  shared_ptr<string> sourceEdns{};
  shared_ptr<string> sourceProtocol{};

  UpdateDnsCacheDomainRequest() {}

  explicit UpdateDnsCacheDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cacheTtlMax) {
      res["CacheTtlMax"] = boost::any(*cacheTtlMax);
    }
    if (cacheTtlMin) {
      res["CacheTtlMin"] = boost::any(*cacheTtlMin);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (sourceDnsServer) {
      vector<boost::any> temp1;
      for(auto item1:*sourceDnsServer){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SourceDnsServer"] = boost::any(temp1);
    }
    if (sourceEdns) {
      res["SourceEdns"] = boost::any(*sourceEdns);
    }
    if (sourceProtocol) {
      res["SourceProtocol"] = boost::any(*sourceProtocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CacheTtlMax") != m.end() && !m["CacheTtlMax"].empty()) {
      cacheTtlMax = make_shared<long>(boost::any_cast<long>(m["CacheTtlMax"]));
    }
    if (m.find("CacheTtlMin") != m.end() && !m["CacheTtlMin"].empty()) {
      cacheTtlMin = make_shared<long>(boost::any_cast<long>(m["CacheTtlMin"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("SourceDnsServer") != m.end() && !m["SourceDnsServer"].empty()) {
      if (typeid(vector<boost::any>) == m["SourceDnsServer"].type()) {
        vector<UpdateDnsCacheDomainRequestSourceDnsServer> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SourceDnsServer"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateDnsCacheDomainRequestSourceDnsServer model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sourceDnsServer = make_shared<vector<UpdateDnsCacheDomainRequestSourceDnsServer>>(expect1);
      }
    }
    if (m.find("SourceEdns") != m.end() && !m["SourceEdns"].empty()) {
      sourceEdns = make_shared<string>(boost::any_cast<string>(m["SourceEdns"]));
    }
    if (m.find("SourceProtocol") != m.end() && !m["SourceProtocol"].empty()) {
      sourceProtocol = make_shared<string>(boost::any_cast<string>(m["SourceProtocol"]));
    }
  }


  virtual ~UpdateDnsCacheDomainRequest() = default;
};
class UpdateDnsCacheDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateDnsCacheDomainResponseBody() {}

  explicit UpdateDnsCacheDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateDnsCacheDomainResponseBody() = default;
};
class UpdateDnsCacheDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDnsCacheDomainResponseBody> body{};

  UpdateDnsCacheDomainResponse() {}

  explicit UpdateDnsCacheDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDnsCacheDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDnsCacheDomainResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDnsCacheDomainResponse() = default;
};
class UpdateDnsCacheDomainRemarkRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> lang{};
  shared_ptr<string> remark{};

  UpdateDnsCacheDomainRemarkRequest() {}

  explicit UpdateDnsCacheDomainRemarkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
  }


  virtual ~UpdateDnsCacheDomainRemarkRequest() = default;
};
class UpdateDnsCacheDomainRemarkResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateDnsCacheDomainRemarkResponseBody() {}

  explicit UpdateDnsCacheDomainRemarkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateDnsCacheDomainRemarkResponseBody() = default;
};
class UpdateDnsCacheDomainRemarkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDnsCacheDomainRemarkResponseBody> body{};

  UpdateDnsCacheDomainRemarkResponse() {}

  explicit UpdateDnsCacheDomainRemarkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDnsCacheDomainRemarkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDnsCacheDomainRemarkResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDnsCacheDomainRemarkResponse() = default;
};
class UpdateDnsGtmAccessStrategyRequestDefaultAddrPool : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<long> lbaWeight{};

  UpdateDnsGtmAccessStrategyRequestDefaultAddrPool() {}

  explicit UpdateDnsGtmAccessStrategyRequestDefaultAddrPool(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (lbaWeight) {
      res["LbaWeight"] = boost::any(*lbaWeight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("LbaWeight") != m.end() && !m["LbaWeight"].empty()) {
      lbaWeight = make_shared<long>(boost::any_cast<long>(m["LbaWeight"]));
    }
  }


  virtual ~UpdateDnsGtmAccessStrategyRequestDefaultAddrPool() = default;
};
class UpdateDnsGtmAccessStrategyRequestFailoverAddrPool : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<long> lbaWeight{};

  UpdateDnsGtmAccessStrategyRequestFailoverAddrPool() {}

  explicit UpdateDnsGtmAccessStrategyRequestFailoverAddrPool(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (lbaWeight) {
      res["LbaWeight"] = boost::any(*lbaWeight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("LbaWeight") != m.end() && !m["LbaWeight"].empty()) {
      lbaWeight = make_shared<long>(boost::any_cast<long>(m["LbaWeight"]));
    }
  }


  virtual ~UpdateDnsGtmAccessStrategyRequestFailoverAddrPool() = default;
};
class UpdateDnsGtmAccessStrategyRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessMode{};
  shared_ptr<vector<UpdateDnsGtmAccessStrategyRequestDefaultAddrPool>> defaultAddrPool{};
  shared_ptr<string> defaultAddrPoolType{};
  shared_ptr<string> defaultLatencyOptimization{};
  shared_ptr<string> defaultLbaStrategy{};
  shared_ptr<long> defaultMaxReturnAddrNum{};
  shared_ptr<long> defaultMinAvailableAddrNum{};
  shared_ptr<vector<UpdateDnsGtmAccessStrategyRequestFailoverAddrPool>> failoverAddrPool{};
  shared_ptr<string> failoverAddrPoolType{};
  shared_ptr<string> failoverLatencyOptimization{};
  shared_ptr<string> failoverLbaStrategy{};
  shared_ptr<long> failoverMaxReturnAddrNum{};
  shared_ptr<long> failoverMinAvailableAddrNum{};
  shared_ptr<string> lang{};
  shared_ptr<string> lines{};
  shared_ptr<string> strategyId{};
  shared_ptr<string> strategyName{};

  UpdateDnsGtmAccessStrategyRequest() {}

  explicit UpdateDnsGtmAccessStrategyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessMode) {
      res["AccessMode"] = boost::any(*accessMode);
    }
    if (defaultAddrPool) {
      vector<boost::any> temp1;
      for(auto item1:*defaultAddrPool){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DefaultAddrPool"] = boost::any(temp1);
    }
    if (defaultAddrPoolType) {
      res["DefaultAddrPoolType"] = boost::any(*defaultAddrPoolType);
    }
    if (defaultLatencyOptimization) {
      res["DefaultLatencyOptimization"] = boost::any(*defaultLatencyOptimization);
    }
    if (defaultLbaStrategy) {
      res["DefaultLbaStrategy"] = boost::any(*defaultLbaStrategy);
    }
    if (defaultMaxReturnAddrNum) {
      res["DefaultMaxReturnAddrNum"] = boost::any(*defaultMaxReturnAddrNum);
    }
    if (defaultMinAvailableAddrNum) {
      res["DefaultMinAvailableAddrNum"] = boost::any(*defaultMinAvailableAddrNum);
    }
    if (failoverAddrPool) {
      vector<boost::any> temp1;
      for(auto item1:*failoverAddrPool){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FailoverAddrPool"] = boost::any(temp1);
    }
    if (failoverAddrPoolType) {
      res["FailoverAddrPoolType"] = boost::any(*failoverAddrPoolType);
    }
    if (failoverLatencyOptimization) {
      res["FailoverLatencyOptimization"] = boost::any(*failoverLatencyOptimization);
    }
    if (failoverLbaStrategy) {
      res["FailoverLbaStrategy"] = boost::any(*failoverLbaStrategy);
    }
    if (failoverMaxReturnAddrNum) {
      res["FailoverMaxReturnAddrNum"] = boost::any(*failoverMaxReturnAddrNum);
    }
    if (failoverMinAvailableAddrNum) {
      res["FailoverMinAvailableAddrNum"] = boost::any(*failoverMinAvailableAddrNum);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (lines) {
      res["Lines"] = boost::any(*lines);
    }
    if (strategyId) {
      res["StrategyId"] = boost::any(*strategyId);
    }
    if (strategyName) {
      res["StrategyName"] = boost::any(*strategyName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessMode") != m.end() && !m["AccessMode"].empty()) {
      accessMode = make_shared<string>(boost::any_cast<string>(m["AccessMode"]));
    }
    if (m.find("DefaultAddrPool") != m.end() && !m["DefaultAddrPool"].empty()) {
      if (typeid(vector<boost::any>) == m["DefaultAddrPool"].type()) {
        vector<UpdateDnsGtmAccessStrategyRequestDefaultAddrPool> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DefaultAddrPool"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateDnsGtmAccessStrategyRequestDefaultAddrPool model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        defaultAddrPool = make_shared<vector<UpdateDnsGtmAccessStrategyRequestDefaultAddrPool>>(expect1);
      }
    }
    if (m.find("DefaultAddrPoolType") != m.end() && !m["DefaultAddrPoolType"].empty()) {
      defaultAddrPoolType = make_shared<string>(boost::any_cast<string>(m["DefaultAddrPoolType"]));
    }
    if (m.find("DefaultLatencyOptimization") != m.end() && !m["DefaultLatencyOptimization"].empty()) {
      defaultLatencyOptimization = make_shared<string>(boost::any_cast<string>(m["DefaultLatencyOptimization"]));
    }
    if (m.find("DefaultLbaStrategy") != m.end() && !m["DefaultLbaStrategy"].empty()) {
      defaultLbaStrategy = make_shared<string>(boost::any_cast<string>(m["DefaultLbaStrategy"]));
    }
    if (m.find("DefaultMaxReturnAddrNum") != m.end() && !m["DefaultMaxReturnAddrNum"].empty()) {
      defaultMaxReturnAddrNum = make_shared<long>(boost::any_cast<long>(m["DefaultMaxReturnAddrNum"]));
    }
    if (m.find("DefaultMinAvailableAddrNum") != m.end() && !m["DefaultMinAvailableAddrNum"].empty()) {
      defaultMinAvailableAddrNum = make_shared<long>(boost::any_cast<long>(m["DefaultMinAvailableAddrNum"]));
    }
    if (m.find("FailoverAddrPool") != m.end() && !m["FailoverAddrPool"].empty()) {
      if (typeid(vector<boost::any>) == m["FailoverAddrPool"].type()) {
        vector<UpdateDnsGtmAccessStrategyRequestFailoverAddrPool> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FailoverAddrPool"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateDnsGtmAccessStrategyRequestFailoverAddrPool model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        failoverAddrPool = make_shared<vector<UpdateDnsGtmAccessStrategyRequestFailoverAddrPool>>(expect1);
      }
    }
    if (m.find("FailoverAddrPoolType") != m.end() && !m["FailoverAddrPoolType"].empty()) {
      failoverAddrPoolType = make_shared<string>(boost::any_cast<string>(m["FailoverAddrPoolType"]));
    }
    if (m.find("FailoverLatencyOptimization") != m.end() && !m["FailoverLatencyOptimization"].empty()) {
      failoverLatencyOptimization = make_shared<string>(boost::any_cast<string>(m["FailoverLatencyOptimization"]));
    }
    if (m.find("FailoverLbaStrategy") != m.end() && !m["FailoverLbaStrategy"].empty()) {
      failoverLbaStrategy = make_shared<string>(boost::any_cast<string>(m["FailoverLbaStrategy"]));
    }
    if (m.find("FailoverMaxReturnAddrNum") != m.end() && !m["FailoverMaxReturnAddrNum"].empty()) {
      failoverMaxReturnAddrNum = make_shared<long>(boost::any_cast<long>(m["FailoverMaxReturnAddrNum"]));
    }
    if (m.find("FailoverMinAvailableAddrNum") != m.end() && !m["FailoverMinAvailableAddrNum"].empty()) {
      failoverMinAvailableAddrNum = make_shared<long>(boost::any_cast<long>(m["FailoverMinAvailableAddrNum"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Lines") != m.end() && !m["Lines"].empty()) {
      lines = make_shared<string>(boost::any_cast<string>(m["Lines"]));
    }
    if (m.find("StrategyId") != m.end() && !m["StrategyId"].empty()) {
      strategyId = make_shared<string>(boost::any_cast<string>(m["StrategyId"]));
    }
    if (m.find("StrategyName") != m.end() && !m["StrategyName"].empty()) {
      strategyName = make_shared<string>(boost::any_cast<string>(m["StrategyName"]));
    }
  }


  virtual ~UpdateDnsGtmAccessStrategyRequest() = default;
};
class UpdateDnsGtmAccessStrategyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> strategyId{};

  UpdateDnsGtmAccessStrategyResponseBody() {}

  explicit UpdateDnsGtmAccessStrategyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (strategyId) {
      res["StrategyId"] = boost::any(*strategyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StrategyId") != m.end() && !m["StrategyId"].empty()) {
      strategyId = make_shared<string>(boost::any_cast<string>(m["StrategyId"]));
    }
  }


  virtual ~UpdateDnsGtmAccessStrategyResponseBody() = default;
};
class UpdateDnsGtmAccessStrategyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDnsGtmAccessStrategyResponseBody> body{};

  UpdateDnsGtmAccessStrategyResponse() {}

  explicit UpdateDnsGtmAccessStrategyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDnsGtmAccessStrategyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDnsGtmAccessStrategyResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDnsGtmAccessStrategyResponse() = default;
};
class UpdateDnsGtmAddressPoolRequestAddr : public Darabonba::Model {
public:
  shared_ptr<string> addr{};
  shared_ptr<string> attributeInfo{};
  shared_ptr<long> lbaWeight{};
  shared_ptr<string> mode{};
  shared_ptr<string> remark{};

  UpdateDnsGtmAddressPoolRequestAddr() {}

  explicit UpdateDnsGtmAddressPoolRequestAddr(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addr) {
      res["Addr"] = boost::any(*addr);
    }
    if (attributeInfo) {
      res["AttributeInfo"] = boost::any(*attributeInfo);
    }
    if (lbaWeight) {
      res["LbaWeight"] = boost::any(*lbaWeight);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Addr") != m.end() && !m["Addr"].empty()) {
      addr = make_shared<string>(boost::any_cast<string>(m["Addr"]));
    }
    if (m.find("AttributeInfo") != m.end() && !m["AttributeInfo"].empty()) {
      attributeInfo = make_shared<string>(boost::any_cast<string>(m["AttributeInfo"]));
    }
    if (m.find("LbaWeight") != m.end() && !m["LbaWeight"].empty()) {
      lbaWeight = make_shared<long>(boost::any_cast<long>(m["LbaWeight"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
  }


  virtual ~UpdateDnsGtmAddressPoolRequestAddr() = default;
};
class UpdateDnsGtmAddressPoolRequest : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateDnsGtmAddressPoolRequestAddr>> addr{};
  shared_ptr<string> addrPoolId{};
  shared_ptr<string> lang{};
  shared_ptr<string> lbaStrategy{};
  shared_ptr<string> name{};

  UpdateDnsGtmAddressPoolRequest() {}

  explicit UpdateDnsGtmAddressPoolRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addr) {
      vector<boost::any> temp1;
      for(auto item1:*addr){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Addr"] = boost::any(temp1);
    }
    if (addrPoolId) {
      res["AddrPoolId"] = boost::any(*addrPoolId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (lbaStrategy) {
      res["LbaStrategy"] = boost::any(*lbaStrategy);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Addr") != m.end() && !m["Addr"].empty()) {
      if (typeid(vector<boost::any>) == m["Addr"].type()) {
        vector<UpdateDnsGtmAddressPoolRequestAddr> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Addr"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateDnsGtmAddressPoolRequestAddr model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        addr = make_shared<vector<UpdateDnsGtmAddressPoolRequestAddr>>(expect1);
      }
    }
    if (m.find("AddrPoolId") != m.end() && !m["AddrPoolId"].empty()) {
      addrPoolId = make_shared<string>(boost::any_cast<string>(m["AddrPoolId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("LbaStrategy") != m.end() && !m["LbaStrategy"].empty()) {
      lbaStrategy = make_shared<string>(boost::any_cast<string>(m["LbaStrategy"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~UpdateDnsGtmAddressPoolRequest() = default;
};
class UpdateDnsGtmAddressPoolResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateDnsGtmAddressPoolResponseBody() {}

  explicit UpdateDnsGtmAddressPoolResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateDnsGtmAddressPoolResponseBody() = default;
};
class UpdateDnsGtmAddressPoolResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDnsGtmAddressPoolResponseBody> body{};

  UpdateDnsGtmAddressPoolResponse() {}

  explicit UpdateDnsGtmAddressPoolResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDnsGtmAddressPoolResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDnsGtmAddressPoolResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDnsGtmAddressPoolResponse() = default;
};
class UpdateDnsGtmInstanceGlobalConfigRequestAlertConfig : public Darabonba::Model {
public:
  shared_ptr<bool> dingtalkNotice{};
  shared_ptr<bool> emailNotice{};
  shared_ptr<string> noticeType{};
  shared_ptr<bool> smsNotice{};

  UpdateDnsGtmInstanceGlobalConfigRequestAlertConfig() {}

  explicit UpdateDnsGtmInstanceGlobalConfigRequestAlertConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dingtalkNotice) {
      res["DingtalkNotice"] = boost::any(*dingtalkNotice);
    }
    if (emailNotice) {
      res["EmailNotice"] = boost::any(*emailNotice);
    }
    if (noticeType) {
      res["NoticeType"] = boost::any(*noticeType);
    }
    if (smsNotice) {
      res["SmsNotice"] = boost::any(*smsNotice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DingtalkNotice") != m.end() && !m["DingtalkNotice"].empty()) {
      dingtalkNotice = make_shared<bool>(boost::any_cast<bool>(m["DingtalkNotice"]));
    }
    if (m.find("EmailNotice") != m.end() && !m["EmailNotice"].empty()) {
      emailNotice = make_shared<bool>(boost::any_cast<bool>(m["EmailNotice"]));
    }
    if (m.find("NoticeType") != m.end() && !m["NoticeType"].empty()) {
      noticeType = make_shared<string>(boost::any_cast<string>(m["NoticeType"]));
    }
    if (m.find("SmsNotice") != m.end() && !m["SmsNotice"].empty()) {
      smsNotice = make_shared<bool>(boost::any_cast<bool>(m["SmsNotice"]));
    }
  }


  virtual ~UpdateDnsGtmInstanceGlobalConfigRequestAlertConfig() = default;
};
class UpdateDnsGtmInstanceGlobalConfigRequest : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateDnsGtmInstanceGlobalConfigRequestAlertConfig>> alertConfig{};
  shared_ptr<string> alertGroup{};
  shared_ptr<string> cnameType{};
  shared_ptr<bool> forceUpdate{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> lang{};
  shared_ptr<string> publicCnameMode{};
  shared_ptr<string> publicRr{};
  shared_ptr<string> publicUserDomainName{};
  shared_ptr<string> publicZoneName{};
  shared_ptr<long> ttl{};

  UpdateDnsGtmInstanceGlobalConfigRequest() {}

  explicit UpdateDnsGtmInstanceGlobalConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertConfig) {
      vector<boost::any> temp1;
      for(auto item1:*alertConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlertConfig"] = boost::any(temp1);
    }
    if (alertGroup) {
      res["AlertGroup"] = boost::any(*alertGroup);
    }
    if (cnameType) {
      res["CnameType"] = boost::any(*cnameType);
    }
    if (forceUpdate) {
      res["ForceUpdate"] = boost::any(*forceUpdate);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (publicCnameMode) {
      res["PublicCnameMode"] = boost::any(*publicCnameMode);
    }
    if (publicRr) {
      res["PublicRr"] = boost::any(*publicRr);
    }
    if (publicUserDomainName) {
      res["PublicUserDomainName"] = boost::any(*publicUserDomainName);
    }
    if (publicZoneName) {
      res["PublicZoneName"] = boost::any(*publicZoneName);
    }
    if (ttl) {
      res["Ttl"] = boost::any(*ttl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertConfig") != m.end() && !m["AlertConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["AlertConfig"].type()) {
        vector<UpdateDnsGtmInstanceGlobalConfigRequestAlertConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlertConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateDnsGtmInstanceGlobalConfigRequestAlertConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alertConfig = make_shared<vector<UpdateDnsGtmInstanceGlobalConfigRequestAlertConfig>>(expect1);
      }
    }
    if (m.find("AlertGroup") != m.end() && !m["AlertGroup"].empty()) {
      alertGroup = make_shared<string>(boost::any_cast<string>(m["AlertGroup"]));
    }
    if (m.find("CnameType") != m.end() && !m["CnameType"].empty()) {
      cnameType = make_shared<string>(boost::any_cast<string>(m["CnameType"]));
    }
    if (m.find("ForceUpdate") != m.end() && !m["ForceUpdate"].empty()) {
      forceUpdate = make_shared<bool>(boost::any_cast<bool>(m["ForceUpdate"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PublicCnameMode") != m.end() && !m["PublicCnameMode"].empty()) {
      publicCnameMode = make_shared<string>(boost::any_cast<string>(m["PublicCnameMode"]));
    }
    if (m.find("PublicRr") != m.end() && !m["PublicRr"].empty()) {
      publicRr = make_shared<string>(boost::any_cast<string>(m["PublicRr"]));
    }
    if (m.find("PublicUserDomainName") != m.end() && !m["PublicUserDomainName"].empty()) {
      publicUserDomainName = make_shared<string>(boost::any_cast<string>(m["PublicUserDomainName"]));
    }
    if (m.find("PublicZoneName") != m.end() && !m["PublicZoneName"].empty()) {
      publicZoneName = make_shared<string>(boost::any_cast<string>(m["PublicZoneName"]));
    }
    if (m.find("Ttl") != m.end() && !m["Ttl"].empty()) {
      ttl = make_shared<long>(boost::any_cast<long>(m["Ttl"]));
    }
  }


  virtual ~UpdateDnsGtmInstanceGlobalConfigRequest() = default;
};
class UpdateDnsGtmInstanceGlobalConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateDnsGtmInstanceGlobalConfigResponseBody() {}

  explicit UpdateDnsGtmInstanceGlobalConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateDnsGtmInstanceGlobalConfigResponseBody() = default;
};
class UpdateDnsGtmInstanceGlobalConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDnsGtmInstanceGlobalConfigResponseBody> body{};

  UpdateDnsGtmInstanceGlobalConfigResponse() {}

  explicit UpdateDnsGtmInstanceGlobalConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDnsGtmInstanceGlobalConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDnsGtmInstanceGlobalConfigResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDnsGtmInstanceGlobalConfigResponse() = default;
};
class UpdateDnsGtmMonitorRequestIspCityNode : public Darabonba::Model {
public:
  shared_ptr<string> cityCode{};
  shared_ptr<string> ispCode{};

  UpdateDnsGtmMonitorRequestIspCityNode() {}

  explicit UpdateDnsGtmMonitorRequestIspCityNode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cityCode) {
      res["CityCode"] = boost::any(*cityCode);
    }
    if (ispCode) {
      res["IspCode"] = boost::any(*ispCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CityCode") != m.end() && !m["CityCode"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["CityCode"]));
    }
    if (m.find("IspCode") != m.end() && !m["IspCode"].empty()) {
      ispCode = make_shared<string>(boost::any_cast<string>(m["IspCode"]));
    }
  }


  virtual ~UpdateDnsGtmMonitorRequestIspCityNode() = default;
};
class UpdateDnsGtmMonitorRequest : public Darabonba::Model {
public:
  shared_ptr<long> evaluationCount{};
  shared_ptr<long> interval{};
  shared_ptr<vector<UpdateDnsGtmMonitorRequestIspCityNode>> ispCityNode{};
  shared_ptr<string> lang{};
  shared_ptr<string> monitorConfigId{};
  shared_ptr<string> monitorExtendInfo{};
  shared_ptr<string> protocolType{};
  shared_ptr<long> timeout{};

  UpdateDnsGtmMonitorRequest() {}

  explicit UpdateDnsGtmMonitorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (evaluationCount) {
      res["EvaluationCount"] = boost::any(*evaluationCount);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ispCityNode) {
      vector<boost::any> temp1;
      for(auto item1:*ispCityNode){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IspCityNode"] = boost::any(temp1);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (monitorConfigId) {
      res["MonitorConfigId"] = boost::any(*monitorConfigId);
    }
    if (monitorExtendInfo) {
      res["MonitorExtendInfo"] = boost::any(*monitorExtendInfo);
    }
    if (protocolType) {
      res["ProtocolType"] = boost::any(*protocolType);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EvaluationCount") != m.end() && !m["EvaluationCount"].empty()) {
      evaluationCount = make_shared<long>(boost::any_cast<long>(m["EvaluationCount"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("IspCityNode") != m.end() && !m["IspCityNode"].empty()) {
      if (typeid(vector<boost::any>) == m["IspCityNode"].type()) {
        vector<UpdateDnsGtmMonitorRequestIspCityNode> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IspCityNode"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateDnsGtmMonitorRequestIspCityNode model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ispCityNode = make_shared<vector<UpdateDnsGtmMonitorRequestIspCityNode>>(expect1);
      }
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("MonitorConfigId") != m.end() && !m["MonitorConfigId"].empty()) {
      monitorConfigId = make_shared<string>(boost::any_cast<string>(m["MonitorConfigId"]));
    }
    if (m.find("MonitorExtendInfo") != m.end() && !m["MonitorExtendInfo"].empty()) {
      monitorExtendInfo = make_shared<string>(boost::any_cast<string>(m["MonitorExtendInfo"]));
    }
    if (m.find("ProtocolType") != m.end() && !m["ProtocolType"].empty()) {
      protocolType = make_shared<string>(boost::any_cast<string>(m["ProtocolType"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
  }


  virtual ~UpdateDnsGtmMonitorRequest() = default;
};
class UpdateDnsGtmMonitorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateDnsGtmMonitorResponseBody() {}

  explicit UpdateDnsGtmMonitorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateDnsGtmMonitorResponseBody() = default;
};
class UpdateDnsGtmMonitorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDnsGtmMonitorResponseBody> body{};

  UpdateDnsGtmMonitorResponse() {}

  explicit UpdateDnsGtmMonitorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDnsGtmMonitorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDnsGtmMonitorResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDnsGtmMonitorResponse() = default;
};
class UpdateDomainGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> lang{};

  UpdateDomainGroupRequest() {}

  explicit UpdateDomainGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~UpdateDomainGroupRequest() = default;
};
class UpdateDomainGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> requestId{};

  UpdateDomainGroupResponseBody() {}

  explicit UpdateDomainGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateDomainGroupResponseBody() = default;
};
class UpdateDomainGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDomainGroupResponseBody> body{};

  UpdateDomainGroupResponse() {}

  explicit UpdateDomainGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDomainGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDomainGroupResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDomainGroupResponse() = default;
};
class UpdateDomainRecordRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> line{};
  shared_ptr<long> priority{};
  shared_ptr<string> RR{};
  shared_ptr<string> recordId{};
  shared_ptr<long> TTL{};
  shared_ptr<string> type{};
  shared_ptr<string> userClientIp{};
  shared_ptr<string> value{};

  UpdateDomainRecordRequest() {}

  explicit UpdateDomainRecordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (line) {
      res["Line"] = boost::any(*line);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (RR) {
      res["RR"] = boost::any(*RR);
    }
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (TTL) {
      res["TTL"] = boost::any(*TTL);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (userClientIp) {
      res["UserClientIp"] = boost::any(*userClientIp);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Line") != m.end() && !m["Line"].empty()) {
      line = make_shared<string>(boost::any_cast<string>(m["Line"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("RR") != m.end() && !m["RR"].empty()) {
      RR = make_shared<string>(boost::any_cast<string>(m["RR"]));
    }
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<string>(boost::any_cast<string>(m["RecordId"]));
    }
    if (m.find("TTL") != m.end() && !m["TTL"].empty()) {
      TTL = make_shared<long>(boost::any_cast<long>(m["TTL"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UserClientIp") != m.end() && !m["UserClientIp"].empty()) {
      userClientIp = make_shared<string>(boost::any_cast<string>(m["UserClientIp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UpdateDomainRecordRequest() = default;
};
class UpdateDomainRecordResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> recordId{};
  shared_ptr<string> requestId{};

  UpdateDomainRecordResponseBody() {}

  explicit UpdateDomainRecordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<string>(boost::any_cast<string>(m["RecordId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateDomainRecordResponseBody() = default;
};
class UpdateDomainRecordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDomainRecordResponseBody> body{};

  UpdateDomainRecordResponse() {}

  explicit UpdateDomainRecordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDomainRecordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDomainRecordResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDomainRecordResponse() = default;
};
class UpdateDomainRecordRemarkRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> recordId{};
  shared_ptr<string> remark{};
  shared_ptr<string> userClientIp{};

  UpdateDomainRecordRemarkRequest() {}

  explicit UpdateDomainRecordRemarkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (userClientIp) {
      res["UserClientIp"] = boost::any(*userClientIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<string>(boost::any_cast<string>(m["RecordId"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("UserClientIp") != m.end() && !m["UserClientIp"].empty()) {
      userClientIp = make_shared<string>(boost::any_cast<string>(m["UserClientIp"]));
    }
  }


  virtual ~UpdateDomainRecordRemarkRequest() = default;
};
class UpdateDomainRecordRemarkResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateDomainRecordRemarkResponseBody() {}

  explicit UpdateDomainRecordRemarkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateDomainRecordRemarkResponseBody() = default;
};
class UpdateDomainRecordRemarkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDomainRecordRemarkResponseBody> body{};

  UpdateDomainRecordRemarkResponse() {}

  explicit UpdateDomainRecordRemarkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDomainRecordRemarkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDomainRecordRemarkResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDomainRecordRemarkResponse() = default;
};
class UpdateDomainRemarkRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> lang{};
  shared_ptr<string> remark{};

  UpdateDomainRemarkRequest() {}

  explicit UpdateDomainRemarkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
  }


  virtual ~UpdateDomainRemarkRequest() = default;
};
class UpdateDomainRemarkResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateDomainRemarkResponseBody() {}

  explicit UpdateDomainRemarkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateDomainRemarkResponseBody() = default;
};
class UpdateDomainRemarkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDomainRemarkResponseBody> body{};

  UpdateDomainRemarkResponse() {}

  explicit UpdateDomainRemarkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDomainRemarkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDomainRemarkResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDomainRemarkResponse() = default;
};
class UpdateGtmAccessStrategyRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessLines{};
  shared_ptr<string> defaultAddrPoolId{};
  shared_ptr<string> failoverAddrPoolId{};
  shared_ptr<string> lang{};
  shared_ptr<string> strategyId{};
  shared_ptr<string> strategyName{};

  UpdateGtmAccessStrategyRequest() {}

  explicit UpdateGtmAccessStrategyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessLines) {
      res["AccessLines"] = boost::any(*accessLines);
    }
    if (defaultAddrPoolId) {
      res["DefaultAddrPoolId"] = boost::any(*defaultAddrPoolId);
    }
    if (failoverAddrPoolId) {
      res["FailoverAddrPoolId"] = boost::any(*failoverAddrPoolId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (strategyId) {
      res["StrategyId"] = boost::any(*strategyId);
    }
    if (strategyName) {
      res["StrategyName"] = boost::any(*strategyName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessLines") != m.end() && !m["AccessLines"].empty()) {
      accessLines = make_shared<string>(boost::any_cast<string>(m["AccessLines"]));
    }
    if (m.find("DefaultAddrPoolId") != m.end() && !m["DefaultAddrPoolId"].empty()) {
      defaultAddrPoolId = make_shared<string>(boost::any_cast<string>(m["DefaultAddrPoolId"]));
    }
    if (m.find("FailoverAddrPoolId") != m.end() && !m["FailoverAddrPoolId"].empty()) {
      failoverAddrPoolId = make_shared<string>(boost::any_cast<string>(m["FailoverAddrPoolId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("StrategyId") != m.end() && !m["StrategyId"].empty()) {
      strategyId = make_shared<string>(boost::any_cast<string>(m["StrategyId"]));
    }
    if (m.find("StrategyName") != m.end() && !m["StrategyName"].empty()) {
      strategyName = make_shared<string>(boost::any_cast<string>(m["StrategyName"]));
    }
  }


  virtual ~UpdateGtmAccessStrategyRequest() = default;
};
class UpdateGtmAccessStrategyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateGtmAccessStrategyResponseBody() {}

  explicit UpdateGtmAccessStrategyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateGtmAccessStrategyResponseBody() = default;
};
class UpdateGtmAccessStrategyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateGtmAccessStrategyResponseBody> body{};

  UpdateGtmAccessStrategyResponse() {}

  explicit UpdateGtmAccessStrategyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateGtmAccessStrategyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateGtmAccessStrategyResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateGtmAccessStrategyResponse() = default;
};
class UpdateGtmAddressPoolRequestAddr : public Darabonba::Model {
public:
  shared_ptr<long> lbaWeight{};
  shared_ptr<string> mode{};
  shared_ptr<string> value{};

  UpdateGtmAddressPoolRequestAddr() {}

  explicit UpdateGtmAddressPoolRequestAddr(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lbaWeight) {
      res["LbaWeight"] = boost::any(*lbaWeight);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LbaWeight") != m.end() && !m["LbaWeight"].empty()) {
      lbaWeight = make_shared<long>(boost::any_cast<long>(m["LbaWeight"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UpdateGtmAddressPoolRequestAddr() = default;
};
class UpdateGtmAddressPoolRequest : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateGtmAddressPoolRequestAddr>> addr{};
  shared_ptr<string> addrPoolId{};
  shared_ptr<string> lang{};
  shared_ptr<long> minAvailableAddrNum{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};

  UpdateGtmAddressPoolRequest() {}

  explicit UpdateGtmAddressPoolRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addr) {
      vector<boost::any> temp1;
      for(auto item1:*addr){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Addr"] = boost::any(temp1);
    }
    if (addrPoolId) {
      res["AddrPoolId"] = boost::any(*addrPoolId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (minAvailableAddrNum) {
      res["MinAvailableAddrNum"] = boost::any(*minAvailableAddrNum);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Addr") != m.end() && !m["Addr"].empty()) {
      if (typeid(vector<boost::any>) == m["Addr"].type()) {
        vector<UpdateGtmAddressPoolRequestAddr> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Addr"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateGtmAddressPoolRequestAddr model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        addr = make_shared<vector<UpdateGtmAddressPoolRequestAddr>>(expect1);
      }
    }
    if (m.find("AddrPoolId") != m.end() && !m["AddrPoolId"].empty()) {
      addrPoolId = make_shared<string>(boost::any_cast<string>(m["AddrPoolId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("MinAvailableAddrNum") != m.end() && !m["MinAvailableAddrNum"].empty()) {
      minAvailableAddrNum = make_shared<long>(boost::any_cast<long>(m["MinAvailableAddrNum"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateGtmAddressPoolRequest() = default;
};
class UpdateGtmAddressPoolResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateGtmAddressPoolResponseBody() {}

  explicit UpdateGtmAddressPoolResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateGtmAddressPoolResponseBody() = default;
};
class UpdateGtmAddressPoolResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateGtmAddressPoolResponseBody> body{};

  UpdateGtmAddressPoolResponse() {}

  explicit UpdateGtmAddressPoolResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateGtmAddressPoolResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateGtmAddressPoolResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateGtmAddressPoolResponse() = default;
};
class UpdateGtmInstanceGlobalConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> alertGroup{};
  shared_ptr<string> cnameCustomDomainName{};
  shared_ptr<string> cnameMode{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> lang{};
  shared_ptr<string> lbaStrategy{};
  shared_ptr<long> ttl{};
  shared_ptr<string> userDomainName{};

  UpdateGtmInstanceGlobalConfigRequest() {}

  explicit UpdateGtmInstanceGlobalConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertGroup) {
      res["AlertGroup"] = boost::any(*alertGroup);
    }
    if (cnameCustomDomainName) {
      res["CnameCustomDomainName"] = boost::any(*cnameCustomDomainName);
    }
    if (cnameMode) {
      res["CnameMode"] = boost::any(*cnameMode);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (lbaStrategy) {
      res["LbaStrategy"] = boost::any(*lbaStrategy);
    }
    if (ttl) {
      res["Ttl"] = boost::any(*ttl);
    }
    if (userDomainName) {
      res["UserDomainName"] = boost::any(*userDomainName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertGroup") != m.end() && !m["AlertGroup"].empty()) {
      alertGroup = make_shared<string>(boost::any_cast<string>(m["AlertGroup"]));
    }
    if (m.find("CnameCustomDomainName") != m.end() && !m["CnameCustomDomainName"].empty()) {
      cnameCustomDomainName = make_shared<string>(boost::any_cast<string>(m["CnameCustomDomainName"]));
    }
    if (m.find("CnameMode") != m.end() && !m["CnameMode"].empty()) {
      cnameMode = make_shared<string>(boost::any_cast<string>(m["CnameMode"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("LbaStrategy") != m.end() && !m["LbaStrategy"].empty()) {
      lbaStrategy = make_shared<string>(boost::any_cast<string>(m["LbaStrategy"]));
    }
    if (m.find("Ttl") != m.end() && !m["Ttl"].empty()) {
      ttl = make_shared<long>(boost::any_cast<long>(m["Ttl"]));
    }
    if (m.find("UserDomainName") != m.end() && !m["UserDomainName"].empty()) {
      userDomainName = make_shared<string>(boost::any_cast<string>(m["UserDomainName"]));
    }
  }


  virtual ~UpdateGtmInstanceGlobalConfigRequest() = default;
};
class UpdateGtmInstanceGlobalConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateGtmInstanceGlobalConfigResponseBody() {}

  explicit UpdateGtmInstanceGlobalConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateGtmInstanceGlobalConfigResponseBody() = default;
};
class UpdateGtmInstanceGlobalConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateGtmInstanceGlobalConfigResponseBody> body{};

  UpdateGtmInstanceGlobalConfigResponse() {}

  explicit UpdateGtmInstanceGlobalConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateGtmInstanceGlobalConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateGtmInstanceGlobalConfigResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateGtmInstanceGlobalConfigResponse() = default;
};
class UpdateGtmMonitorRequestIspCityNode : public Darabonba::Model {
public:
  shared_ptr<string> cityCode{};
  shared_ptr<string> ispCode{};

  UpdateGtmMonitorRequestIspCityNode() {}

  explicit UpdateGtmMonitorRequestIspCityNode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cityCode) {
      res["CityCode"] = boost::any(*cityCode);
    }
    if (ispCode) {
      res["IspCode"] = boost::any(*ispCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CityCode") != m.end() && !m["CityCode"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["CityCode"]));
    }
    if (m.find("IspCode") != m.end() && !m["IspCode"].empty()) {
      ispCode = make_shared<string>(boost::any_cast<string>(m["IspCode"]));
    }
  }


  virtual ~UpdateGtmMonitorRequestIspCityNode() = default;
};
class UpdateGtmMonitorRequest : public Darabonba::Model {
public:
  shared_ptr<long> evaluationCount{};
  shared_ptr<long> interval{};
  shared_ptr<vector<UpdateGtmMonitorRequestIspCityNode>> ispCityNode{};
  shared_ptr<string> lang{};
  shared_ptr<string> monitorConfigId{};
  shared_ptr<string> monitorExtendInfo{};
  shared_ptr<string> protocolType{};
  shared_ptr<long> timeout{};

  UpdateGtmMonitorRequest() {}

  explicit UpdateGtmMonitorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (evaluationCount) {
      res["EvaluationCount"] = boost::any(*evaluationCount);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ispCityNode) {
      vector<boost::any> temp1;
      for(auto item1:*ispCityNode){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IspCityNode"] = boost::any(temp1);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (monitorConfigId) {
      res["MonitorConfigId"] = boost::any(*monitorConfigId);
    }
    if (monitorExtendInfo) {
      res["MonitorExtendInfo"] = boost::any(*monitorExtendInfo);
    }
    if (protocolType) {
      res["ProtocolType"] = boost::any(*protocolType);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EvaluationCount") != m.end() && !m["EvaluationCount"].empty()) {
      evaluationCount = make_shared<long>(boost::any_cast<long>(m["EvaluationCount"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("IspCityNode") != m.end() && !m["IspCityNode"].empty()) {
      if (typeid(vector<boost::any>) == m["IspCityNode"].type()) {
        vector<UpdateGtmMonitorRequestIspCityNode> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IspCityNode"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateGtmMonitorRequestIspCityNode model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ispCityNode = make_shared<vector<UpdateGtmMonitorRequestIspCityNode>>(expect1);
      }
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("MonitorConfigId") != m.end() && !m["MonitorConfigId"].empty()) {
      monitorConfigId = make_shared<string>(boost::any_cast<string>(m["MonitorConfigId"]));
    }
    if (m.find("MonitorExtendInfo") != m.end() && !m["MonitorExtendInfo"].empty()) {
      monitorExtendInfo = make_shared<string>(boost::any_cast<string>(m["MonitorExtendInfo"]));
    }
    if (m.find("ProtocolType") != m.end() && !m["ProtocolType"].empty()) {
      protocolType = make_shared<string>(boost::any_cast<string>(m["ProtocolType"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
  }


  virtual ~UpdateGtmMonitorRequest() = default;
};
class UpdateGtmMonitorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateGtmMonitorResponseBody() {}

  explicit UpdateGtmMonitorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateGtmMonitorResponseBody() = default;
};
class UpdateGtmMonitorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateGtmMonitorResponseBody> body{};

  UpdateGtmMonitorResponse() {}

  explicit UpdateGtmMonitorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateGtmMonitorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateGtmMonitorResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateGtmMonitorResponse() = default;
};
class UpdateGtmRecoveryPlanRequest : public Darabonba::Model {
public:
  shared_ptr<string> faultAddrPool{};
  shared_ptr<string> lang{};
  shared_ptr<string> name{};
  shared_ptr<long> recoveryPlanId{};
  shared_ptr<string> remark{};

  UpdateGtmRecoveryPlanRequest() {}

  explicit UpdateGtmRecoveryPlanRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (faultAddrPool) {
      res["FaultAddrPool"] = boost::any(*faultAddrPool);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (recoveryPlanId) {
      res["RecoveryPlanId"] = boost::any(*recoveryPlanId);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FaultAddrPool") != m.end() && !m["FaultAddrPool"].empty()) {
      faultAddrPool = make_shared<string>(boost::any_cast<string>(m["FaultAddrPool"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RecoveryPlanId") != m.end() && !m["RecoveryPlanId"].empty()) {
      recoveryPlanId = make_shared<long>(boost::any_cast<long>(m["RecoveryPlanId"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
  }


  virtual ~UpdateGtmRecoveryPlanRequest() = default;
};
class UpdateGtmRecoveryPlanResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateGtmRecoveryPlanResponseBody() {}

  explicit UpdateGtmRecoveryPlanResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateGtmRecoveryPlanResponseBody() = default;
};
class UpdateGtmRecoveryPlanResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateGtmRecoveryPlanResponseBody> body{};

  UpdateGtmRecoveryPlanResponse() {}

  explicit UpdateGtmRecoveryPlanResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateGtmRecoveryPlanResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateGtmRecoveryPlanResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateGtmRecoveryPlanResponse() = default;
};
class UpdateIspFlushCacheInstanceConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> lang{};

  UpdateIspFlushCacheInstanceConfigRequest() {}

  explicit UpdateIspFlushCacheInstanceConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~UpdateIspFlushCacheInstanceConfigRequest() = default;
};
class UpdateIspFlushCacheInstanceConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateIspFlushCacheInstanceConfigResponseBody() {}

  explicit UpdateIspFlushCacheInstanceConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateIspFlushCacheInstanceConfigResponseBody() = default;
};
class UpdateIspFlushCacheInstanceConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateIspFlushCacheInstanceConfigResponseBody> body{};

  UpdateIspFlushCacheInstanceConfigResponse() {}

  explicit UpdateIspFlushCacheInstanceConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateIspFlushCacheInstanceConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateIspFlushCacheInstanceConfigResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateIspFlushCacheInstanceConfigResponse() = default;
};
class ValidateDnsGtmCnameRrCanUseRequest : public Darabonba::Model {
public:
  shared_ptr<string> cnameMode{};
  shared_ptr<string> cnameRr{};
  shared_ptr<string> cnameType{};
  shared_ptr<string> cnameZone{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> lang{};

  ValidateDnsGtmCnameRrCanUseRequest() {}

  explicit ValidateDnsGtmCnameRrCanUseRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cnameMode) {
      res["CnameMode"] = boost::any(*cnameMode);
    }
    if (cnameRr) {
      res["CnameRr"] = boost::any(*cnameRr);
    }
    if (cnameType) {
      res["CnameType"] = boost::any(*cnameType);
    }
    if (cnameZone) {
      res["CnameZone"] = boost::any(*cnameZone);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CnameMode") != m.end() && !m["CnameMode"].empty()) {
      cnameMode = make_shared<string>(boost::any_cast<string>(m["CnameMode"]));
    }
    if (m.find("CnameRr") != m.end() && !m["CnameRr"].empty()) {
      cnameRr = make_shared<string>(boost::any_cast<string>(m["CnameRr"]));
    }
    if (m.find("CnameType") != m.end() && !m["CnameType"].empty()) {
      cnameType = make_shared<string>(boost::any_cast<string>(m["CnameType"]));
    }
    if (m.find("CnameZone") != m.end() && !m["CnameZone"].empty()) {
      cnameZone = make_shared<string>(boost::any_cast<string>(m["CnameZone"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~ValidateDnsGtmCnameRrCanUseRequest() = default;
};
class ValidateDnsGtmCnameRrCanUseResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ValidateDnsGtmCnameRrCanUseResponseBody() {}

  explicit ValidateDnsGtmCnameRrCanUseResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ValidateDnsGtmCnameRrCanUseResponseBody() = default;
};
class ValidateDnsGtmCnameRrCanUseResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ValidateDnsGtmCnameRrCanUseResponseBody> body{};

  ValidateDnsGtmCnameRrCanUseResponse() {}

  explicit ValidateDnsGtmCnameRrCanUseResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ValidateDnsGtmCnameRrCanUseResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ValidateDnsGtmCnameRrCanUseResponseBody>(model1);
      }
    }
  }


  virtual ~ValidateDnsGtmCnameRrCanUseResponse() = default;
};
class ValidatePdnsUdpIpSegmentRequest : public Darabonba::Model {
public:
  shared_ptr<string> ip{};
  shared_ptr<string> ipToken{};
  shared_ptr<string> lang{};

  ValidatePdnsUdpIpSegmentRequest() {}

  explicit ValidatePdnsUdpIpSegmentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (ipToken) {
      res["IpToken"] = boost::any(*ipToken);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("IpToken") != m.end() && !m["IpToken"].empty()) {
      ipToken = make_shared<string>(boost::any_cast<string>(m["IpToken"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~ValidatePdnsUdpIpSegmentRequest() = default;
};
class ValidatePdnsUdpIpSegmentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ValidatePdnsUdpIpSegmentResponseBody() {}

  explicit ValidatePdnsUdpIpSegmentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ValidatePdnsUdpIpSegmentResponseBody() = default;
};
class ValidatePdnsUdpIpSegmentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ValidatePdnsUdpIpSegmentResponseBody> body{};

  ValidatePdnsUdpIpSegmentResponse() {}

  explicit ValidatePdnsUdpIpSegmentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ValidatePdnsUdpIpSegmentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ValidatePdnsUdpIpSegmentResponseBody>(model1);
      }
    }
  }


  virtual ~ValidatePdnsUdpIpSegmentResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AddCustomLineResponse addCustomLineWithOptions(shared_ptr<AddCustomLineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddCustomLineResponse addCustomLine(shared_ptr<AddCustomLineRequest> request);
  AddDnsCacheDomainResponse addDnsCacheDomainWithOptions(shared_ptr<AddDnsCacheDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddDnsCacheDomainResponse addDnsCacheDomain(shared_ptr<AddDnsCacheDomainRequest> request);
  AddDnsGtmAccessStrategyResponse addDnsGtmAccessStrategyWithOptions(shared_ptr<AddDnsGtmAccessStrategyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddDnsGtmAccessStrategyResponse addDnsGtmAccessStrategy(shared_ptr<AddDnsGtmAccessStrategyRequest> request);
  AddDnsGtmAddressPoolResponse addDnsGtmAddressPoolWithOptions(shared_ptr<AddDnsGtmAddressPoolRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddDnsGtmAddressPoolResponse addDnsGtmAddressPool(shared_ptr<AddDnsGtmAddressPoolRequest> request);
  AddDnsGtmMonitorResponse addDnsGtmMonitorWithOptions(shared_ptr<AddDnsGtmMonitorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddDnsGtmMonitorResponse addDnsGtmMonitor(shared_ptr<AddDnsGtmMonitorRequest> request);
  AddDomainResponse addDomainWithOptions(shared_ptr<AddDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddDomainResponse addDomain(shared_ptr<AddDomainRequest> request);
  AddDomainBackupResponse addDomainBackupWithOptions(shared_ptr<AddDomainBackupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddDomainBackupResponse addDomainBackup(shared_ptr<AddDomainBackupRequest> request);
  AddDomainGroupResponse addDomainGroupWithOptions(shared_ptr<AddDomainGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddDomainGroupResponse addDomainGroup(shared_ptr<AddDomainGroupRequest> request);
  AddDomainRecordResponse addDomainRecordWithOptions(shared_ptr<AddDomainRecordRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddDomainRecordResponse addDomainRecord(shared_ptr<AddDomainRecordRequest> request);
  AddGtmAccessStrategyResponse addGtmAccessStrategyWithOptions(shared_ptr<AddGtmAccessStrategyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddGtmAccessStrategyResponse addGtmAccessStrategy(shared_ptr<AddGtmAccessStrategyRequest> request);
  AddGtmAddressPoolResponse addGtmAddressPoolWithOptions(shared_ptr<AddGtmAddressPoolRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddGtmAddressPoolResponse addGtmAddressPool(shared_ptr<AddGtmAddressPoolRequest> request);
  AddGtmMonitorResponse addGtmMonitorWithOptions(shared_ptr<AddGtmMonitorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddGtmMonitorResponse addGtmMonitor(shared_ptr<AddGtmMonitorRequest> request);
  AddGtmRecoveryPlanResponse addGtmRecoveryPlanWithOptions(shared_ptr<AddGtmRecoveryPlanRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddGtmRecoveryPlanResponse addGtmRecoveryPlan(shared_ptr<AddGtmRecoveryPlanRequest> request);
  BindInstanceDomainsResponse bindInstanceDomainsWithOptions(shared_ptr<BindInstanceDomainsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BindInstanceDomainsResponse bindInstanceDomains(shared_ptr<BindInstanceDomainsRequest> request);
  ChangeDomainGroupResponse changeDomainGroupWithOptions(shared_ptr<ChangeDomainGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ChangeDomainGroupResponse changeDomainGroup(shared_ptr<ChangeDomainGroupRequest> request);
  ChangeDomainOfDnsProductResponse changeDomainOfDnsProductWithOptions(shared_ptr<ChangeDomainOfDnsProductRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ChangeDomainOfDnsProductResponse changeDomainOfDnsProduct(shared_ptr<ChangeDomainOfDnsProductRequest> request);
  CopyGtmConfigResponse copyGtmConfigWithOptions(shared_ptr<CopyGtmConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CopyGtmConfigResponse copyGtmConfig(shared_ptr<CopyGtmConfigRequest> request);
  CreateCloudGtmAddressResponse createCloudGtmAddressWithOptions(shared_ptr<CreateCloudGtmAddressRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCloudGtmAddressResponse createCloudGtmAddress(shared_ptr<CreateCloudGtmAddressRequest> request);
  CreateCloudGtmAddressPoolResponse createCloudGtmAddressPoolWithOptions(shared_ptr<CreateCloudGtmAddressPoolRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCloudGtmAddressPoolResponse createCloudGtmAddressPool(shared_ptr<CreateCloudGtmAddressPoolRequest> request);
  CreateCloudGtmInstanceConfigResponse createCloudGtmInstanceConfigWithOptions(shared_ptr<CreateCloudGtmInstanceConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCloudGtmInstanceConfigResponse createCloudGtmInstanceConfig(shared_ptr<CreateCloudGtmInstanceConfigRequest> request);
  CreateCloudGtmMonitorTemplateResponse createCloudGtmMonitorTemplateWithOptions(shared_ptr<CreateCloudGtmMonitorTemplateRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCloudGtmMonitorTemplateResponse createCloudGtmMonitorTemplate(shared_ptr<CreateCloudGtmMonitorTemplateRequest> request);
  CreatePdnsAppKeyResponse createPdnsAppKeyWithOptions(shared_ptr<CreatePdnsAppKeyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreatePdnsAppKeyResponse createPdnsAppKey(shared_ptr<CreatePdnsAppKeyRequest> request);
  CreatePdnsUdpIpSegmentResponse createPdnsUdpIpSegmentWithOptions(shared_ptr<CreatePdnsUdpIpSegmentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreatePdnsUdpIpSegmentResponse createPdnsUdpIpSegment(shared_ptr<CreatePdnsUdpIpSegmentRequest> request);
  DeleteCloudGtmAddressResponse deleteCloudGtmAddressWithOptions(shared_ptr<DeleteCloudGtmAddressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCloudGtmAddressResponse deleteCloudGtmAddress(shared_ptr<DeleteCloudGtmAddressRequest> request);
  DeleteCloudGtmAddressPoolResponse deleteCloudGtmAddressPoolWithOptions(shared_ptr<DeleteCloudGtmAddressPoolRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCloudGtmAddressPoolResponse deleteCloudGtmAddressPool(shared_ptr<DeleteCloudGtmAddressPoolRequest> request);
  DeleteCloudGtmInstanceConfigResponse deleteCloudGtmInstanceConfigWithOptions(shared_ptr<DeleteCloudGtmInstanceConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCloudGtmInstanceConfigResponse deleteCloudGtmInstanceConfig(shared_ptr<DeleteCloudGtmInstanceConfigRequest> request);
  DeleteCloudGtmMonitorTemplateResponse deleteCloudGtmMonitorTemplateWithOptions(shared_ptr<DeleteCloudGtmMonitorTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCloudGtmMonitorTemplateResponse deleteCloudGtmMonitorTemplate(shared_ptr<DeleteCloudGtmMonitorTemplateRequest> request);
  DeleteCustomLinesResponse deleteCustomLinesWithOptions(shared_ptr<DeleteCustomLinesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCustomLinesResponse deleteCustomLines(shared_ptr<DeleteCustomLinesRequest> request);
  DeleteDnsCacheDomainResponse deleteDnsCacheDomainWithOptions(shared_ptr<DeleteDnsCacheDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDnsCacheDomainResponse deleteDnsCacheDomain(shared_ptr<DeleteDnsCacheDomainRequest> request);
  DeleteDnsGtmAccessStrategyResponse deleteDnsGtmAccessStrategyWithOptions(shared_ptr<DeleteDnsGtmAccessStrategyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDnsGtmAccessStrategyResponse deleteDnsGtmAccessStrategy(shared_ptr<DeleteDnsGtmAccessStrategyRequest> request);
  DeleteDnsGtmAddressPoolResponse deleteDnsGtmAddressPoolWithOptions(shared_ptr<DeleteDnsGtmAddressPoolRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDnsGtmAddressPoolResponse deleteDnsGtmAddressPool(shared_ptr<DeleteDnsGtmAddressPoolRequest> request);
  DeleteDomainResponse deleteDomainWithOptions(shared_ptr<DeleteDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDomainResponse deleteDomain(shared_ptr<DeleteDomainRequest> request);
  DeleteDomainGroupResponse deleteDomainGroupWithOptions(shared_ptr<DeleteDomainGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDomainGroupResponse deleteDomainGroup(shared_ptr<DeleteDomainGroupRequest> request);
  DeleteDomainRecordResponse deleteDomainRecordWithOptions(shared_ptr<DeleteDomainRecordRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDomainRecordResponse deleteDomainRecord(shared_ptr<DeleteDomainRecordRequest> request);
  DeleteGtmAccessStrategyResponse deleteGtmAccessStrategyWithOptions(shared_ptr<DeleteGtmAccessStrategyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteGtmAccessStrategyResponse deleteGtmAccessStrategy(shared_ptr<DeleteGtmAccessStrategyRequest> request);
  DeleteGtmAddressPoolResponse deleteGtmAddressPoolWithOptions(shared_ptr<DeleteGtmAddressPoolRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteGtmAddressPoolResponse deleteGtmAddressPool(shared_ptr<DeleteGtmAddressPoolRequest> request);
  DeleteGtmRecoveryPlanResponse deleteGtmRecoveryPlanWithOptions(shared_ptr<DeleteGtmRecoveryPlanRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteGtmRecoveryPlanResponse deleteGtmRecoveryPlan(shared_ptr<DeleteGtmRecoveryPlanRequest> request);
  DeleteSubDomainRecordsResponse deleteSubDomainRecordsWithOptions(shared_ptr<DeleteSubDomainRecordsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSubDomainRecordsResponse deleteSubDomainRecords(shared_ptr<DeleteSubDomainRecordsRequest> request);
  DescribeBatchResultCountResponse describeBatchResultCountWithOptions(shared_ptr<DescribeBatchResultCountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBatchResultCountResponse describeBatchResultCount(shared_ptr<DescribeBatchResultCountRequest> request);
  DescribeBatchResultDetailResponse describeBatchResultDetailWithOptions(shared_ptr<DescribeBatchResultDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBatchResultDetailResponse describeBatchResultDetail(shared_ptr<DescribeBatchResultDetailRequest> request);
  DescribeCloudGtmAddressResponse describeCloudGtmAddressWithOptions(shared_ptr<DescribeCloudGtmAddressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCloudGtmAddressResponse describeCloudGtmAddress(shared_ptr<DescribeCloudGtmAddressRequest> request);
  DescribeCloudGtmAddressPoolResponse describeCloudGtmAddressPoolWithOptions(shared_ptr<DescribeCloudGtmAddressPoolRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCloudGtmAddressPoolResponse describeCloudGtmAddressPool(shared_ptr<DescribeCloudGtmAddressPoolRequest> request);
  DescribeCloudGtmAddressPoolReferenceResponse describeCloudGtmAddressPoolReferenceWithOptions(shared_ptr<DescribeCloudGtmAddressPoolReferenceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCloudGtmAddressPoolReferenceResponse describeCloudGtmAddressPoolReference(shared_ptr<DescribeCloudGtmAddressPoolReferenceRequest> request);
  DescribeCloudGtmAddressReferenceResponse describeCloudGtmAddressReferenceWithOptions(shared_ptr<DescribeCloudGtmAddressReferenceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCloudGtmAddressReferenceResponse describeCloudGtmAddressReference(shared_ptr<DescribeCloudGtmAddressReferenceRequest> request);
  DescribeCloudGtmGlobalAlertResponse describeCloudGtmGlobalAlertWithOptions(shared_ptr<DescribeCloudGtmGlobalAlertRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCloudGtmGlobalAlertResponse describeCloudGtmGlobalAlert(shared_ptr<DescribeCloudGtmGlobalAlertRequest> request);
  DescribeCloudGtmInstanceConfigAlertResponse describeCloudGtmInstanceConfigAlertWithOptions(shared_ptr<DescribeCloudGtmInstanceConfigAlertRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCloudGtmInstanceConfigAlertResponse describeCloudGtmInstanceConfigAlert(shared_ptr<DescribeCloudGtmInstanceConfigAlertRequest> request);
  DescribeCloudGtmInstanceConfigFullInfoResponse describeCloudGtmInstanceConfigFullInfoWithOptions(shared_ptr<DescribeCloudGtmInstanceConfigFullInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCloudGtmInstanceConfigFullInfoResponse describeCloudGtmInstanceConfigFullInfo(shared_ptr<DescribeCloudGtmInstanceConfigFullInfoRequest> request);
  DescribeCloudGtmMonitorTemplateResponse describeCloudGtmMonitorTemplateWithOptions(shared_ptr<DescribeCloudGtmMonitorTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCloudGtmMonitorTemplateResponse describeCloudGtmMonitorTemplate(shared_ptr<DescribeCloudGtmMonitorTemplateRequest> request);
  DescribeCloudGtmSummaryResponse describeCloudGtmSummaryWithOptions(shared_ptr<DescribeCloudGtmSummaryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCloudGtmSummaryResponse describeCloudGtmSummary(shared_ptr<DescribeCloudGtmSummaryRequest> request);
  DescribeCloudGtmSystemLinesResponse describeCloudGtmSystemLinesWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCloudGtmSystemLinesResponse describeCloudGtmSystemLines();
  DescribeCustomLineResponse describeCustomLineWithOptions(shared_ptr<DescribeCustomLineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCustomLineResponse describeCustomLine(shared_ptr<DescribeCustomLineRequest> request);
  DescribeCustomLinesResponse describeCustomLinesWithOptions(shared_ptr<DescribeCustomLinesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCustomLinesResponse describeCustomLines(shared_ptr<DescribeCustomLinesRequest> request);
  DescribeDNSSLBSubDomainsResponse describeDNSSLBSubDomainsWithOptions(shared_ptr<DescribeDNSSLBSubDomainsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDNSSLBSubDomainsResponse describeDNSSLBSubDomains(shared_ptr<DescribeDNSSLBSubDomainsRequest> request);
  DescribeDnsCacheDomainsResponse describeDnsCacheDomainsWithOptions(shared_ptr<DescribeDnsCacheDomainsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDnsCacheDomainsResponse describeDnsCacheDomains(shared_ptr<DescribeDnsCacheDomainsRequest> request);
  DescribeDnsGtmAccessStrategiesResponse describeDnsGtmAccessStrategiesWithOptions(shared_ptr<DescribeDnsGtmAccessStrategiesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDnsGtmAccessStrategiesResponse describeDnsGtmAccessStrategies(shared_ptr<DescribeDnsGtmAccessStrategiesRequest> request);
  DescribeDnsGtmAccessStrategyResponse describeDnsGtmAccessStrategyWithOptions(shared_ptr<DescribeDnsGtmAccessStrategyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDnsGtmAccessStrategyResponse describeDnsGtmAccessStrategy(shared_ptr<DescribeDnsGtmAccessStrategyRequest> request);
  DescribeDnsGtmAccessStrategyAvailableConfigResponse describeDnsGtmAccessStrategyAvailableConfigWithOptions(shared_ptr<DescribeDnsGtmAccessStrategyAvailableConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDnsGtmAccessStrategyAvailableConfigResponse describeDnsGtmAccessStrategyAvailableConfig(shared_ptr<DescribeDnsGtmAccessStrategyAvailableConfigRequest> request);
  DescribeDnsGtmAddrAttributeInfoResponse describeDnsGtmAddrAttributeInfoWithOptions(shared_ptr<DescribeDnsGtmAddrAttributeInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDnsGtmAddrAttributeInfoResponse describeDnsGtmAddrAttributeInfo(shared_ptr<DescribeDnsGtmAddrAttributeInfoRequest> request);
  DescribeDnsGtmAddressPoolAvailableConfigResponse describeDnsGtmAddressPoolAvailableConfigWithOptions(shared_ptr<DescribeDnsGtmAddressPoolAvailableConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDnsGtmAddressPoolAvailableConfigResponse describeDnsGtmAddressPoolAvailableConfig(shared_ptr<DescribeDnsGtmAddressPoolAvailableConfigRequest> request);
  DescribeDnsGtmAvailableAlertGroupResponse describeDnsGtmAvailableAlertGroupWithOptions(shared_ptr<DescribeDnsGtmAvailableAlertGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDnsGtmAvailableAlertGroupResponse describeDnsGtmAvailableAlertGroup(shared_ptr<DescribeDnsGtmAvailableAlertGroupRequest> request);
  DescribeDnsGtmInstanceResponse describeDnsGtmInstanceWithOptions(shared_ptr<DescribeDnsGtmInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDnsGtmInstanceResponse describeDnsGtmInstance(shared_ptr<DescribeDnsGtmInstanceRequest> request);
  DescribeDnsGtmInstanceAddressPoolResponse describeDnsGtmInstanceAddressPoolWithOptions(shared_ptr<DescribeDnsGtmInstanceAddressPoolRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDnsGtmInstanceAddressPoolResponse describeDnsGtmInstanceAddressPool(shared_ptr<DescribeDnsGtmInstanceAddressPoolRequest> request);
  DescribeDnsGtmInstanceAddressPoolsResponse describeDnsGtmInstanceAddressPoolsWithOptions(shared_ptr<DescribeDnsGtmInstanceAddressPoolsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDnsGtmInstanceAddressPoolsResponse describeDnsGtmInstanceAddressPools(shared_ptr<DescribeDnsGtmInstanceAddressPoolsRequest> request);
  DescribeDnsGtmInstanceStatusResponse describeDnsGtmInstanceStatusWithOptions(shared_ptr<DescribeDnsGtmInstanceStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDnsGtmInstanceStatusResponse describeDnsGtmInstanceStatus(shared_ptr<DescribeDnsGtmInstanceStatusRequest> request);
  DescribeDnsGtmInstanceSystemCnameResponse describeDnsGtmInstanceSystemCnameWithOptions(shared_ptr<DescribeDnsGtmInstanceSystemCnameRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDnsGtmInstanceSystemCnameResponse describeDnsGtmInstanceSystemCname(shared_ptr<DescribeDnsGtmInstanceSystemCnameRequest> request);
  DescribeDnsGtmInstancesResponse describeDnsGtmInstancesWithOptions(shared_ptr<DescribeDnsGtmInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDnsGtmInstancesResponse describeDnsGtmInstances(shared_ptr<DescribeDnsGtmInstancesRequest> request);
  DescribeDnsGtmLogsResponse describeDnsGtmLogsWithOptions(shared_ptr<DescribeDnsGtmLogsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDnsGtmLogsResponse describeDnsGtmLogs(shared_ptr<DescribeDnsGtmLogsRequest> request);
  DescribeDnsGtmMonitorAvailableConfigResponse describeDnsGtmMonitorAvailableConfigWithOptions(shared_ptr<DescribeDnsGtmMonitorAvailableConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDnsGtmMonitorAvailableConfigResponse describeDnsGtmMonitorAvailableConfig(shared_ptr<DescribeDnsGtmMonitorAvailableConfigRequest> request);
  DescribeDnsGtmMonitorConfigResponse describeDnsGtmMonitorConfigWithOptions(shared_ptr<DescribeDnsGtmMonitorConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDnsGtmMonitorConfigResponse describeDnsGtmMonitorConfig(shared_ptr<DescribeDnsGtmMonitorConfigRequest> request);
  DescribeDnsProductInstanceResponse describeDnsProductInstanceWithOptions(shared_ptr<DescribeDnsProductInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDnsProductInstanceResponse describeDnsProductInstance(shared_ptr<DescribeDnsProductInstanceRequest> request);
  DescribeDnsProductInstancesResponse describeDnsProductInstancesWithOptions(shared_ptr<DescribeDnsProductInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDnsProductInstancesResponse describeDnsProductInstances(shared_ptr<DescribeDnsProductInstancesRequest> request);
  DescribeDohAccountStatisticsResponse describeDohAccountStatisticsWithOptions(shared_ptr<DescribeDohAccountStatisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDohAccountStatisticsResponse describeDohAccountStatistics(shared_ptr<DescribeDohAccountStatisticsRequest> request);
  DescribeDohDomainStatisticsResponse describeDohDomainStatisticsWithOptions(shared_ptr<DescribeDohDomainStatisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDohDomainStatisticsResponse describeDohDomainStatistics(shared_ptr<DescribeDohDomainStatisticsRequest> request);
  DescribeDohDomainStatisticsSummaryResponse describeDohDomainStatisticsSummaryWithOptions(shared_ptr<DescribeDohDomainStatisticsSummaryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDohDomainStatisticsSummaryResponse describeDohDomainStatisticsSummary(shared_ptr<DescribeDohDomainStatisticsSummaryRequest> request);
  DescribeDohSubDomainStatisticsResponse describeDohSubDomainStatisticsWithOptions(shared_ptr<DescribeDohSubDomainStatisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDohSubDomainStatisticsResponse describeDohSubDomainStatistics(shared_ptr<DescribeDohSubDomainStatisticsRequest> request);
  DescribeDohSubDomainStatisticsSummaryResponse describeDohSubDomainStatisticsSummaryWithOptions(shared_ptr<DescribeDohSubDomainStatisticsSummaryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDohSubDomainStatisticsSummaryResponse describeDohSubDomainStatisticsSummary(shared_ptr<DescribeDohSubDomainStatisticsSummaryRequest> request);
  DescribeDohUserInfoResponse describeDohUserInfoWithOptions(shared_ptr<DescribeDohUserInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDohUserInfoResponse describeDohUserInfo(shared_ptr<DescribeDohUserInfoRequest> request);
  DescribeDomainDnssecInfoResponse describeDomainDnssecInfoWithOptions(shared_ptr<DescribeDomainDnssecInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainDnssecInfoResponse describeDomainDnssecInfo(shared_ptr<DescribeDomainDnssecInfoRequest> request);
  DescribeDomainGroupsResponse describeDomainGroupsWithOptions(shared_ptr<DescribeDomainGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainGroupsResponse describeDomainGroups(shared_ptr<DescribeDomainGroupsRequest> request);
  DescribeDomainInfoResponse describeDomainInfoWithOptions(shared_ptr<DescribeDomainInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainInfoResponse describeDomainInfo(shared_ptr<DescribeDomainInfoRequest> request);
  DescribeDomainLogsResponse describeDomainLogsWithOptions(shared_ptr<DescribeDomainLogsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainLogsResponse describeDomainLogs(shared_ptr<DescribeDomainLogsRequest> request);
  DescribeDomainNsResponse describeDomainNsWithOptions(shared_ptr<DescribeDomainNsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainNsResponse describeDomainNs(shared_ptr<DescribeDomainNsRequest> request);
  DescribeDomainRecordInfoResponse describeDomainRecordInfoWithOptions(shared_ptr<DescribeDomainRecordInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainRecordInfoResponse describeDomainRecordInfo(shared_ptr<DescribeDomainRecordInfoRequest> request);
  DescribeDomainRecordsResponse describeDomainRecordsWithOptions(shared_ptr<DescribeDomainRecordsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainRecordsResponse describeDomainRecords(shared_ptr<DescribeDomainRecordsRequest> request);
  DescribeDomainResolveStatisticsSummaryResponse describeDomainResolveStatisticsSummaryWithOptions(shared_ptr<DescribeDomainResolveStatisticsSummaryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainResolveStatisticsSummaryResponse describeDomainResolveStatisticsSummary(shared_ptr<DescribeDomainResolveStatisticsSummaryRequest> request);
  DescribeDomainStatisticsResponse describeDomainStatisticsWithOptions(shared_ptr<DescribeDomainStatisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainStatisticsResponse describeDomainStatistics(shared_ptr<DescribeDomainStatisticsRequest> request);
  DescribeDomainStatisticsSummaryResponse describeDomainStatisticsSummaryWithOptions(shared_ptr<DescribeDomainStatisticsSummaryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainStatisticsSummaryResponse describeDomainStatisticsSummary(shared_ptr<DescribeDomainStatisticsSummaryRequest> request);
  DescribeDomainsResponse describeDomainsWithOptions(shared_ptr<DescribeDomainsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainsResponse describeDomains(shared_ptr<DescribeDomainsRequest> request);
  DescribeGtmAccessStrategiesResponse describeGtmAccessStrategiesWithOptions(shared_ptr<DescribeGtmAccessStrategiesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeGtmAccessStrategiesResponse describeGtmAccessStrategies(shared_ptr<DescribeGtmAccessStrategiesRequest> request);
  DescribeGtmAccessStrategyResponse describeGtmAccessStrategyWithOptions(shared_ptr<DescribeGtmAccessStrategyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeGtmAccessStrategyResponse describeGtmAccessStrategy(shared_ptr<DescribeGtmAccessStrategyRequest> request);
  DescribeGtmAccessStrategyAvailableConfigResponse describeGtmAccessStrategyAvailableConfigWithOptions(shared_ptr<DescribeGtmAccessStrategyAvailableConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeGtmAccessStrategyAvailableConfigResponse describeGtmAccessStrategyAvailableConfig(shared_ptr<DescribeGtmAccessStrategyAvailableConfigRequest> request);
  DescribeGtmAvailableAlertGroupResponse describeGtmAvailableAlertGroupWithOptions(shared_ptr<DescribeGtmAvailableAlertGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeGtmAvailableAlertGroupResponse describeGtmAvailableAlertGroup(shared_ptr<DescribeGtmAvailableAlertGroupRequest> request);
  DescribeGtmInstanceResponse describeGtmInstanceWithOptions(shared_ptr<DescribeGtmInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeGtmInstanceResponse describeGtmInstance(shared_ptr<DescribeGtmInstanceRequest> request);
  DescribeGtmInstanceAddressPoolResponse describeGtmInstanceAddressPoolWithOptions(shared_ptr<DescribeGtmInstanceAddressPoolRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeGtmInstanceAddressPoolResponse describeGtmInstanceAddressPool(shared_ptr<DescribeGtmInstanceAddressPoolRequest> request);
  DescribeGtmInstanceAddressPoolsResponse describeGtmInstanceAddressPoolsWithOptions(shared_ptr<DescribeGtmInstanceAddressPoolsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeGtmInstanceAddressPoolsResponse describeGtmInstanceAddressPools(shared_ptr<DescribeGtmInstanceAddressPoolsRequest> request);
  DescribeGtmInstanceStatusResponse describeGtmInstanceStatusWithOptions(shared_ptr<DescribeGtmInstanceStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeGtmInstanceStatusResponse describeGtmInstanceStatus(shared_ptr<DescribeGtmInstanceStatusRequest> request);
  DescribeGtmInstanceSystemCnameResponse describeGtmInstanceSystemCnameWithOptions(shared_ptr<DescribeGtmInstanceSystemCnameRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeGtmInstanceSystemCnameResponse describeGtmInstanceSystemCname(shared_ptr<DescribeGtmInstanceSystemCnameRequest> request);
  DescribeGtmInstancesResponse describeGtmInstancesWithOptions(shared_ptr<DescribeGtmInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeGtmInstancesResponse describeGtmInstances(shared_ptr<DescribeGtmInstancesRequest> request);
  DescribeGtmLogsResponse describeGtmLogsWithOptions(shared_ptr<DescribeGtmLogsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeGtmLogsResponse describeGtmLogs(shared_ptr<DescribeGtmLogsRequest> request);
  DescribeGtmMonitorAvailableConfigResponse describeGtmMonitorAvailableConfigWithOptions(shared_ptr<DescribeGtmMonitorAvailableConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeGtmMonitorAvailableConfigResponse describeGtmMonitorAvailableConfig(shared_ptr<DescribeGtmMonitorAvailableConfigRequest> request);
  DescribeGtmMonitorConfigResponse describeGtmMonitorConfigWithOptions(shared_ptr<DescribeGtmMonitorConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeGtmMonitorConfigResponse describeGtmMonitorConfig(shared_ptr<DescribeGtmMonitorConfigRequest> request);
  DescribeGtmRecoveryPlanResponse describeGtmRecoveryPlanWithOptions(shared_ptr<DescribeGtmRecoveryPlanRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeGtmRecoveryPlanResponse describeGtmRecoveryPlan(shared_ptr<DescribeGtmRecoveryPlanRequest> request);
  DescribeGtmRecoveryPlanAvailableConfigResponse describeGtmRecoveryPlanAvailableConfigWithOptions(shared_ptr<DescribeGtmRecoveryPlanAvailableConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeGtmRecoveryPlanAvailableConfigResponse describeGtmRecoveryPlanAvailableConfig(shared_ptr<DescribeGtmRecoveryPlanAvailableConfigRequest> request);
  DescribeGtmRecoveryPlansResponse describeGtmRecoveryPlansWithOptions(shared_ptr<DescribeGtmRecoveryPlansRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeGtmRecoveryPlansResponse describeGtmRecoveryPlans(shared_ptr<DescribeGtmRecoveryPlansRequest> request);
  DescribeInstanceDomainsResponse describeInstanceDomainsWithOptions(shared_ptr<DescribeInstanceDomainsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceDomainsResponse describeInstanceDomains(shared_ptr<DescribeInstanceDomainsRequest> request);
  DescribeInternetDnsLogsResponse describeInternetDnsLogsWithOptions(shared_ptr<DescribeInternetDnsLogsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInternetDnsLogsResponse describeInternetDnsLogs(shared_ptr<DescribeInternetDnsLogsRequest> request);
  DescribeIspFlushCacheInstancesResponse describeIspFlushCacheInstancesWithOptions(shared_ptr<DescribeIspFlushCacheInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeIspFlushCacheInstancesResponse describeIspFlushCacheInstances(shared_ptr<DescribeIspFlushCacheInstancesRequest> request);
  DescribeIspFlushCacheRemainQuotaResponse describeIspFlushCacheRemainQuotaWithOptions(shared_ptr<DescribeIspFlushCacheRemainQuotaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeIspFlushCacheRemainQuotaResponse describeIspFlushCacheRemainQuota(shared_ptr<DescribeIspFlushCacheRemainQuotaRequest> request);
  DescribeIspFlushCacheTaskResponse describeIspFlushCacheTaskWithOptions(shared_ptr<DescribeIspFlushCacheTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeIspFlushCacheTaskResponse describeIspFlushCacheTask(shared_ptr<DescribeIspFlushCacheTaskRequest> request);
  DescribeIspFlushCacheTasksResponse describeIspFlushCacheTasksWithOptions(shared_ptr<DescribeIspFlushCacheTasksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeIspFlushCacheTasksResponse describeIspFlushCacheTasks(shared_ptr<DescribeIspFlushCacheTasksRequest> request);
  DescribePdnsAccountSummaryResponse describePdnsAccountSummaryWithOptions(shared_ptr<DescribePdnsAccountSummaryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePdnsAccountSummaryResponse describePdnsAccountSummary(shared_ptr<DescribePdnsAccountSummaryRequest> request);
  DescribePdnsAppKeyResponse describePdnsAppKeyWithOptions(shared_ptr<DescribePdnsAppKeyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePdnsAppKeyResponse describePdnsAppKey(shared_ptr<DescribePdnsAppKeyRequest> request);
  DescribePdnsAppKeysResponse describePdnsAppKeysWithOptions(shared_ptr<DescribePdnsAppKeysRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePdnsAppKeysResponse describePdnsAppKeys(shared_ptr<DescribePdnsAppKeysRequest> request);
  DescribePdnsOperateLogsResponse describePdnsOperateLogsWithOptions(shared_ptr<DescribePdnsOperateLogsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePdnsOperateLogsResponse describePdnsOperateLogs(shared_ptr<DescribePdnsOperateLogsRequest> request);
  DescribePdnsRequestStatisticResponse describePdnsRequestStatisticWithOptions(shared_ptr<DescribePdnsRequestStatisticRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePdnsRequestStatisticResponse describePdnsRequestStatistic(shared_ptr<DescribePdnsRequestStatisticRequest> request);
  DescribePdnsRequestStatisticsResponse describePdnsRequestStatisticsWithOptions(shared_ptr<DescribePdnsRequestStatisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePdnsRequestStatisticsResponse describePdnsRequestStatistics(shared_ptr<DescribePdnsRequestStatisticsRequest> request);
  DescribePdnsThreatLogsResponse describePdnsThreatLogsWithOptions(shared_ptr<DescribePdnsThreatLogsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePdnsThreatLogsResponse describePdnsThreatLogs(shared_ptr<DescribePdnsThreatLogsRequest> request);
  DescribePdnsThreatStatisticResponse describePdnsThreatStatisticWithOptions(shared_ptr<DescribePdnsThreatStatisticRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePdnsThreatStatisticResponse describePdnsThreatStatistic(shared_ptr<DescribePdnsThreatStatisticRequest> request);
  DescribePdnsThreatStatisticsResponse describePdnsThreatStatisticsWithOptions(shared_ptr<DescribePdnsThreatStatisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePdnsThreatStatisticsResponse describePdnsThreatStatistics(shared_ptr<DescribePdnsThreatStatisticsRequest> request);
  DescribePdnsUdpIpSegmentsResponse describePdnsUdpIpSegmentsWithOptions(shared_ptr<DescribePdnsUdpIpSegmentsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePdnsUdpIpSegmentsResponse describePdnsUdpIpSegments(shared_ptr<DescribePdnsUdpIpSegmentsRequest> request);
  DescribePdnsUserInfoResponse describePdnsUserInfoWithOptions(shared_ptr<DescribePdnsUserInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePdnsUserInfoResponse describePdnsUserInfo(shared_ptr<DescribePdnsUserInfoRequest> request);
  DescribeRecordLogsResponse describeRecordLogsWithOptions(shared_ptr<DescribeRecordLogsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRecordLogsResponse describeRecordLogs(shared_ptr<DescribeRecordLogsRequest> request);
  DescribeRecordResolveStatisticsSummaryResponse describeRecordResolveStatisticsSummaryWithOptions(shared_ptr<DescribeRecordResolveStatisticsSummaryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRecordResolveStatisticsSummaryResponse describeRecordResolveStatisticsSummary(shared_ptr<DescribeRecordResolveStatisticsSummaryRequest> request);
  DescribeRecordStatisticsResponse describeRecordStatisticsWithOptions(shared_ptr<DescribeRecordStatisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRecordStatisticsResponse describeRecordStatistics(shared_ptr<DescribeRecordStatisticsRequest> request);
  DescribeRecordStatisticsSummaryResponse describeRecordStatisticsSummaryWithOptions(shared_ptr<DescribeRecordStatisticsSummaryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRecordStatisticsSummaryResponse describeRecordStatisticsSummary(shared_ptr<DescribeRecordStatisticsSummaryRequest> request);
  DescribeSubDomainRecordsResponse describeSubDomainRecordsWithOptions(shared_ptr<DescribeSubDomainRecordsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSubDomainRecordsResponse describeSubDomainRecords(shared_ptr<DescribeSubDomainRecordsRequest> request);
  DescribeSupportLinesResponse describeSupportLinesWithOptions(shared_ptr<DescribeSupportLinesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSupportLinesResponse describeSupportLines(shared_ptr<DescribeSupportLinesRequest> request);
  DescribeTagsResponse describeTagsWithOptions(shared_ptr<DescribeTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTagsResponse describeTags(shared_ptr<DescribeTagsRequest> request);
  DescribeTransferDomainsResponse describeTransferDomainsWithOptions(shared_ptr<DescribeTransferDomainsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTransferDomainsResponse describeTransferDomains(shared_ptr<DescribeTransferDomainsRequest> request);
  ExecuteGtmRecoveryPlanResponse executeGtmRecoveryPlanWithOptions(shared_ptr<ExecuteGtmRecoveryPlanRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExecuteGtmRecoveryPlanResponse executeGtmRecoveryPlan(shared_ptr<ExecuteGtmRecoveryPlanRequest> request);
  GetMainDomainNameResponse getMainDomainNameWithOptions(shared_ptr<GetMainDomainNameRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMainDomainNameResponse getMainDomainName(shared_ptr<GetMainDomainNameRequest> request);
  GetTxtRecordForVerifyResponse getTxtRecordForVerifyWithOptions(shared_ptr<GetTxtRecordForVerifyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTxtRecordForVerifyResponse getTxtRecordForVerify(shared_ptr<GetTxtRecordForVerifyRequest> request);
  ListCloudGtmAddressPoolsResponse listCloudGtmAddressPoolsWithOptions(shared_ptr<ListCloudGtmAddressPoolsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCloudGtmAddressPoolsResponse listCloudGtmAddressPools(shared_ptr<ListCloudGtmAddressPoolsRequest> request);
  ListCloudGtmAddressesResponse listCloudGtmAddressesWithOptions(shared_ptr<ListCloudGtmAddressesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCloudGtmAddressesResponse listCloudGtmAddresses(shared_ptr<ListCloudGtmAddressesRequest> request);
  ListCloudGtmAlertLogsResponse listCloudGtmAlertLogsWithOptions(shared_ptr<ListCloudGtmAlertLogsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCloudGtmAlertLogsResponse listCloudGtmAlertLogs(shared_ptr<ListCloudGtmAlertLogsRequest> request);
  ListCloudGtmAvailableAlertGroupsResponse listCloudGtmAvailableAlertGroupsWithOptions(shared_ptr<ListCloudGtmAvailableAlertGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCloudGtmAvailableAlertGroupsResponse listCloudGtmAvailableAlertGroups(shared_ptr<ListCloudGtmAvailableAlertGroupsRequest> request);
  ListCloudGtmInstanceConfigsResponse listCloudGtmInstanceConfigsWithOptions(shared_ptr<ListCloudGtmInstanceConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCloudGtmInstanceConfigsResponse listCloudGtmInstanceConfigs(shared_ptr<ListCloudGtmInstanceConfigsRequest> request);
  ListCloudGtmInstancesResponse listCloudGtmInstancesWithOptions(shared_ptr<ListCloudGtmInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCloudGtmInstancesResponse listCloudGtmInstances(shared_ptr<ListCloudGtmInstancesRequest> request);
  ListCloudGtmMonitorNodesResponse listCloudGtmMonitorNodesWithOptions(shared_ptr<ListCloudGtmMonitorNodesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCloudGtmMonitorNodesResponse listCloudGtmMonitorNodes(shared_ptr<ListCloudGtmMonitorNodesRequest> request);
  ListCloudGtmMonitorTemplatesResponse listCloudGtmMonitorTemplatesWithOptions(shared_ptr<ListCloudGtmMonitorTemplatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCloudGtmMonitorTemplatesResponse listCloudGtmMonitorTemplates(shared_ptr<ListCloudGtmMonitorTemplatesRequest> request);
  ListTagResourcesResponse listTagResourcesWithOptions(shared_ptr<ListTagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTagResourcesResponse listTagResources(shared_ptr<ListTagResourcesRequest> request);
  ModifyHichinaDomainDNSResponse modifyHichinaDomainDNSWithOptions(shared_ptr<ModifyHichinaDomainDNSRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyHichinaDomainDNSResponse modifyHichinaDomainDNS(shared_ptr<ModifyHichinaDomainDNSRequest> request);
  MoveDomainResourceGroupResponse moveDomainResourceGroupWithOptions(shared_ptr<MoveDomainResourceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  MoveDomainResourceGroupResponse moveDomainResourceGroup(shared_ptr<MoveDomainResourceGroupRequest> request);
  MoveGtmResourceGroupResponse moveGtmResourceGroupWithOptions(shared_ptr<MoveGtmResourceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  MoveGtmResourceGroupResponse moveGtmResourceGroup(shared_ptr<MoveGtmResourceGroupRequest> request);
  OperateBatchDomainResponse operateBatchDomainWithOptions(shared_ptr<OperateBatchDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OperateBatchDomainResponse operateBatchDomain(shared_ptr<OperateBatchDomainRequest> request);
  PausePdnsServiceResponse pausePdnsServiceWithOptions(shared_ptr<PausePdnsServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PausePdnsServiceResponse pausePdnsService(shared_ptr<PausePdnsServiceRequest> request);
  PreviewGtmRecoveryPlanResponse previewGtmRecoveryPlanWithOptions(shared_ptr<PreviewGtmRecoveryPlanRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PreviewGtmRecoveryPlanResponse previewGtmRecoveryPlan(shared_ptr<PreviewGtmRecoveryPlanRequest> request);
  RemovePdnsAppKeyResponse removePdnsAppKeyWithOptions(shared_ptr<RemovePdnsAppKeyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemovePdnsAppKeyResponse removePdnsAppKey(shared_ptr<RemovePdnsAppKeyRequest> request);
  RemovePdnsUdpIpSegmentResponse removePdnsUdpIpSegmentWithOptions(shared_ptr<RemovePdnsUdpIpSegmentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemovePdnsUdpIpSegmentResponse removePdnsUdpIpSegment(shared_ptr<RemovePdnsUdpIpSegmentRequest> request);
  ReplaceCloudGtmAddressPoolAddressResponse replaceCloudGtmAddressPoolAddressWithOptions(shared_ptr<ReplaceCloudGtmAddressPoolAddressRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReplaceCloudGtmAddressPoolAddressResponse replaceCloudGtmAddressPoolAddress(shared_ptr<ReplaceCloudGtmAddressPoolAddressRequest> request);
  ReplaceCloudGtmInstanceConfigAddressPoolResponse replaceCloudGtmInstanceConfigAddressPoolWithOptions(shared_ptr<ReplaceCloudGtmInstanceConfigAddressPoolRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReplaceCloudGtmInstanceConfigAddressPoolResponse replaceCloudGtmInstanceConfigAddressPool(shared_ptr<ReplaceCloudGtmInstanceConfigAddressPoolRequest> request);
  ResumePdnsServiceResponse resumePdnsServiceWithOptions(shared_ptr<ResumePdnsServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResumePdnsServiceResponse resumePdnsService(shared_ptr<ResumePdnsServiceRequest> request);
  RetrieveDomainResponse retrieveDomainWithOptions(shared_ptr<RetrieveDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RetrieveDomainResponse retrieveDomain(shared_ptr<RetrieveDomainRequest> request);
  RollbackGtmRecoveryPlanResponse rollbackGtmRecoveryPlanWithOptions(shared_ptr<RollbackGtmRecoveryPlanRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RollbackGtmRecoveryPlanResponse rollbackGtmRecoveryPlan(shared_ptr<RollbackGtmRecoveryPlanRequest> request);
  SearchCloudGtmAddressPoolsResponse searchCloudGtmAddressPoolsWithOptions(shared_ptr<SearchCloudGtmAddressPoolsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchCloudGtmAddressPoolsResponse searchCloudGtmAddressPools(shared_ptr<SearchCloudGtmAddressPoolsRequest> request);
  SearchCloudGtmAddressesResponse searchCloudGtmAddressesWithOptions(shared_ptr<SearchCloudGtmAddressesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchCloudGtmAddressesResponse searchCloudGtmAddresses(shared_ptr<SearchCloudGtmAddressesRequest> request);
  SearchCloudGtmInstanceConfigsResponse searchCloudGtmInstanceConfigsWithOptions(shared_ptr<SearchCloudGtmInstanceConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchCloudGtmInstanceConfigsResponse searchCloudGtmInstanceConfigs(shared_ptr<SearchCloudGtmInstanceConfigsRequest> request);
  SearchCloudGtmInstancesResponse searchCloudGtmInstancesWithOptions(shared_ptr<SearchCloudGtmInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchCloudGtmInstancesResponse searchCloudGtmInstances(shared_ptr<SearchCloudGtmInstancesRequest> request);
  SearchCloudGtmMonitorTemplatesResponse searchCloudGtmMonitorTemplatesWithOptions(shared_ptr<SearchCloudGtmMonitorTemplatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchCloudGtmMonitorTemplatesResponse searchCloudGtmMonitorTemplates(shared_ptr<SearchCloudGtmMonitorTemplatesRequest> request);
  SetDNSSLBStatusResponse setDNSSLBStatusWithOptions(shared_ptr<SetDNSSLBStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetDNSSLBStatusResponse setDNSSLBStatus(shared_ptr<SetDNSSLBStatusRequest> request);
  SetDnsGtmAccessModeResponse setDnsGtmAccessModeWithOptions(shared_ptr<SetDnsGtmAccessModeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetDnsGtmAccessModeResponse setDnsGtmAccessMode(shared_ptr<SetDnsGtmAccessModeRequest> request);
  SetDnsGtmMonitorStatusResponse setDnsGtmMonitorStatusWithOptions(shared_ptr<SetDnsGtmMonitorStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetDnsGtmMonitorStatusResponse setDnsGtmMonitorStatus(shared_ptr<SetDnsGtmMonitorStatusRequest> request);
  SetDomainDnssecStatusResponse setDomainDnssecStatusWithOptions(shared_ptr<SetDomainDnssecStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetDomainDnssecStatusResponse setDomainDnssecStatus(shared_ptr<SetDomainDnssecStatusRequest> request);
  SetDomainRecordStatusResponse setDomainRecordStatusWithOptions(shared_ptr<SetDomainRecordStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetDomainRecordStatusResponse setDomainRecordStatus(shared_ptr<SetDomainRecordStatusRequest> request);
  SetGtmAccessModeResponse setGtmAccessModeWithOptions(shared_ptr<SetGtmAccessModeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetGtmAccessModeResponse setGtmAccessMode(shared_ptr<SetGtmAccessModeRequest> request);
  SetGtmMonitorStatusResponse setGtmMonitorStatusWithOptions(shared_ptr<SetGtmMonitorStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetGtmMonitorStatusResponse setGtmMonitorStatus(shared_ptr<SetGtmMonitorStatusRequest> request);
  SubmitIspFlushCacheTaskResponse submitIspFlushCacheTaskWithOptions(shared_ptr<SubmitIspFlushCacheTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitIspFlushCacheTaskResponse submitIspFlushCacheTask(shared_ptr<SubmitIspFlushCacheTaskRequest> request);
  SwitchDnsGtmInstanceStrategyModeResponse switchDnsGtmInstanceStrategyModeWithOptions(shared_ptr<SwitchDnsGtmInstanceStrategyModeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SwitchDnsGtmInstanceStrategyModeResponse switchDnsGtmInstanceStrategyMode(shared_ptr<SwitchDnsGtmInstanceStrategyModeRequest> request);
  TagResourcesResponse tagResourcesWithOptions(shared_ptr<TagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TagResourcesResponse tagResources(shared_ptr<TagResourcesRequest> request);
  TransferDomainResponse transferDomainWithOptions(shared_ptr<TransferDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TransferDomainResponse transferDomain(shared_ptr<TransferDomainRequest> request);
  UnbindInstanceDomainsResponse unbindInstanceDomainsWithOptions(shared_ptr<UnbindInstanceDomainsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnbindInstanceDomainsResponse unbindInstanceDomains(shared_ptr<UnbindInstanceDomainsRequest> request);
  UntagResourcesResponse untagResourcesWithOptions(shared_ptr<UntagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UntagResourcesResponse untagResources(shared_ptr<UntagResourcesRequest> request);
  UpdateAppKeyStateResponse updateAppKeyStateWithOptions(shared_ptr<UpdateAppKeyStateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAppKeyStateResponse updateAppKeyState(shared_ptr<UpdateAppKeyStateRequest> request);
  UpdateCloudGtmAddressResponse updateCloudGtmAddressWithOptions(shared_ptr<UpdateCloudGtmAddressRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateCloudGtmAddressResponse updateCloudGtmAddress(shared_ptr<UpdateCloudGtmAddressRequest> request);
  UpdateCloudGtmAddressEnableStatusResponse updateCloudGtmAddressEnableStatusWithOptions(shared_ptr<UpdateCloudGtmAddressEnableStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateCloudGtmAddressEnableStatusResponse updateCloudGtmAddressEnableStatus(shared_ptr<UpdateCloudGtmAddressEnableStatusRequest> request);
  UpdateCloudGtmAddressManualAvailableStatusResponse updateCloudGtmAddressManualAvailableStatusWithOptions(shared_ptr<UpdateCloudGtmAddressManualAvailableStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateCloudGtmAddressManualAvailableStatusResponse updateCloudGtmAddressManualAvailableStatus(shared_ptr<UpdateCloudGtmAddressManualAvailableStatusRequest> request);
  UpdateCloudGtmAddressPoolBasicConfigResponse updateCloudGtmAddressPoolBasicConfigWithOptions(shared_ptr<UpdateCloudGtmAddressPoolBasicConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateCloudGtmAddressPoolBasicConfigResponse updateCloudGtmAddressPoolBasicConfig(shared_ptr<UpdateCloudGtmAddressPoolBasicConfigRequest> request);
  UpdateCloudGtmAddressPoolEnableStatusResponse updateCloudGtmAddressPoolEnableStatusWithOptions(shared_ptr<UpdateCloudGtmAddressPoolEnableStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateCloudGtmAddressPoolEnableStatusResponse updateCloudGtmAddressPoolEnableStatus(shared_ptr<UpdateCloudGtmAddressPoolEnableStatusRequest> request);
  UpdateCloudGtmAddressPoolLbStrategyResponse updateCloudGtmAddressPoolLbStrategyWithOptions(shared_ptr<UpdateCloudGtmAddressPoolLbStrategyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateCloudGtmAddressPoolLbStrategyResponse updateCloudGtmAddressPoolLbStrategy(shared_ptr<UpdateCloudGtmAddressPoolLbStrategyRequest> request);
  UpdateCloudGtmAddressPoolRemarkResponse updateCloudGtmAddressPoolRemarkWithOptions(shared_ptr<UpdateCloudGtmAddressPoolRemarkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateCloudGtmAddressPoolRemarkResponse updateCloudGtmAddressPoolRemark(shared_ptr<UpdateCloudGtmAddressPoolRemarkRequest> request);
  UpdateCloudGtmAddressRemarkResponse updateCloudGtmAddressRemarkWithOptions(shared_ptr<UpdateCloudGtmAddressRemarkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateCloudGtmAddressRemarkResponse updateCloudGtmAddressRemark(shared_ptr<UpdateCloudGtmAddressRemarkRequest> request);
  UpdateCloudGtmGlobalAlertResponse updateCloudGtmGlobalAlertWithOptions(shared_ptr<UpdateCloudGtmGlobalAlertRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateCloudGtmGlobalAlertResponse updateCloudGtmGlobalAlert(shared_ptr<UpdateCloudGtmGlobalAlertRequest> request);
  UpdateCloudGtmInstanceConfigAlertResponse updateCloudGtmInstanceConfigAlertWithOptions(shared_ptr<UpdateCloudGtmInstanceConfigAlertRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateCloudGtmInstanceConfigAlertResponse updateCloudGtmInstanceConfigAlert(shared_ptr<UpdateCloudGtmInstanceConfigAlertRequest> request);
  UpdateCloudGtmInstanceConfigBasicResponse updateCloudGtmInstanceConfigBasicWithOptions(shared_ptr<UpdateCloudGtmInstanceConfigBasicRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateCloudGtmInstanceConfigBasicResponse updateCloudGtmInstanceConfigBasic(shared_ptr<UpdateCloudGtmInstanceConfigBasicRequest> request);
  UpdateCloudGtmInstanceConfigEnableStatusResponse updateCloudGtmInstanceConfigEnableStatusWithOptions(shared_ptr<UpdateCloudGtmInstanceConfigEnableStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateCloudGtmInstanceConfigEnableStatusResponse updateCloudGtmInstanceConfigEnableStatus(shared_ptr<UpdateCloudGtmInstanceConfigEnableStatusRequest> request);
  UpdateCloudGtmInstanceConfigLbStrategyResponse updateCloudGtmInstanceConfigLbStrategyWithOptions(shared_ptr<UpdateCloudGtmInstanceConfigLbStrategyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateCloudGtmInstanceConfigLbStrategyResponse updateCloudGtmInstanceConfigLbStrategy(shared_ptr<UpdateCloudGtmInstanceConfigLbStrategyRequest> request);
  UpdateCloudGtmInstanceConfigRemarkResponse updateCloudGtmInstanceConfigRemarkWithOptions(shared_ptr<UpdateCloudGtmInstanceConfigRemarkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateCloudGtmInstanceConfigRemarkResponse updateCloudGtmInstanceConfigRemark(shared_ptr<UpdateCloudGtmInstanceConfigRemarkRequest> request);
  UpdateCloudGtmInstanceNameResponse updateCloudGtmInstanceNameWithOptions(shared_ptr<UpdateCloudGtmInstanceNameRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateCloudGtmInstanceNameResponse updateCloudGtmInstanceName(shared_ptr<UpdateCloudGtmInstanceNameRequest> request);
  UpdateCloudGtmMonitorTemplateResponse updateCloudGtmMonitorTemplateWithOptions(shared_ptr<UpdateCloudGtmMonitorTemplateRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateCloudGtmMonitorTemplateResponse updateCloudGtmMonitorTemplate(shared_ptr<UpdateCloudGtmMonitorTemplateRequest> request);
  UpdateCloudGtmMonitorTemplateRemarkResponse updateCloudGtmMonitorTemplateRemarkWithOptions(shared_ptr<UpdateCloudGtmMonitorTemplateRemarkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateCloudGtmMonitorTemplateRemarkResponse updateCloudGtmMonitorTemplateRemark(shared_ptr<UpdateCloudGtmMonitorTemplateRemarkRequest> request);
  UpdateCustomLineResponse updateCustomLineWithOptions(shared_ptr<UpdateCustomLineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateCustomLineResponse updateCustomLine(shared_ptr<UpdateCustomLineRequest> request);
  UpdateDNSSLBWeightResponse updateDNSSLBWeightWithOptions(shared_ptr<UpdateDNSSLBWeightRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDNSSLBWeightResponse updateDNSSLBWeight(shared_ptr<UpdateDNSSLBWeightRequest> request);
  UpdateDnsCacheDomainResponse updateDnsCacheDomainWithOptions(shared_ptr<UpdateDnsCacheDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDnsCacheDomainResponse updateDnsCacheDomain(shared_ptr<UpdateDnsCacheDomainRequest> request);
  UpdateDnsCacheDomainRemarkResponse updateDnsCacheDomainRemarkWithOptions(shared_ptr<UpdateDnsCacheDomainRemarkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDnsCacheDomainRemarkResponse updateDnsCacheDomainRemark(shared_ptr<UpdateDnsCacheDomainRemarkRequest> request);
  UpdateDnsGtmAccessStrategyResponse updateDnsGtmAccessStrategyWithOptions(shared_ptr<UpdateDnsGtmAccessStrategyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDnsGtmAccessStrategyResponse updateDnsGtmAccessStrategy(shared_ptr<UpdateDnsGtmAccessStrategyRequest> request);
  UpdateDnsGtmAddressPoolResponse updateDnsGtmAddressPoolWithOptions(shared_ptr<UpdateDnsGtmAddressPoolRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDnsGtmAddressPoolResponse updateDnsGtmAddressPool(shared_ptr<UpdateDnsGtmAddressPoolRequest> request);
  UpdateDnsGtmInstanceGlobalConfigResponse updateDnsGtmInstanceGlobalConfigWithOptions(shared_ptr<UpdateDnsGtmInstanceGlobalConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDnsGtmInstanceGlobalConfigResponse updateDnsGtmInstanceGlobalConfig(shared_ptr<UpdateDnsGtmInstanceGlobalConfigRequest> request);
  UpdateDnsGtmMonitorResponse updateDnsGtmMonitorWithOptions(shared_ptr<UpdateDnsGtmMonitorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDnsGtmMonitorResponse updateDnsGtmMonitor(shared_ptr<UpdateDnsGtmMonitorRequest> request);
  UpdateDomainGroupResponse updateDomainGroupWithOptions(shared_ptr<UpdateDomainGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDomainGroupResponse updateDomainGroup(shared_ptr<UpdateDomainGroupRequest> request);
  UpdateDomainRecordResponse updateDomainRecordWithOptions(shared_ptr<UpdateDomainRecordRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDomainRecordResponse updateDomainRecord(shared_ptr<UpdateDomainRecordRequest> request);
  UpdateDomainRecordRemarkResponse updateDomainRecordRemarkWithOptions(shared_ptr<UpdateDomainRecordRemarkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDomainRecordRemarkResponse updateDomainRecordRemark(shared_ptr<UpdateDomainRecordRemarkRequest> request);
  UpdateDomainRemarkResponse updateDomainRemarkWithOptions(shared_ptr<UpdateDomainRemarkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDomainRemarkResponse updateDomainRemark(shared_ptr<UpdateDomainRemarkRequest> request);
  UpdateGtmAccessStrategyResponse updateGtmAccessStrategyWithOptions(shared_ptr<UpdateGtmAccessStrategyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateGtmAccessStrategyResponse updateGtmAccessStrategy(shared_ptr<UpdateGtmAccessStrategyRequest> request);
  UpdateGtmAddressPoolResponse updateGtmAddressPoolWithOptions(shared_ptr<UpdateGtmAddressPoolRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateGtmAddressPoolResponse updateGtmAddressPool(shared_ptr<UpdateGtmAddressPoolRequest> request);
  UpdateGtmInstanceGlobalConfigResponse updateGtmInstanceGlobalConfigWithOptions(shared_ptr<UpdateGtmInstanceGlobalConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateGtmInstanceGlobalConfigResponse updateGtmInstanceGlobalConfig(shared_ptr<UpdateGtmInstanceGlobalConfigRequest> request);
  UpdateGtmMonitorResponse updateGtmMonitorWithOptions(shared_ptr<UpdateGtmMonitorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateGtmMonitorResponse updateGtmMonitor(shared_ptr<UpdateGtmMonitorRequest> request);
  UpdateGtmRecoveryPlanResponse updateGtmRecoveryPlanWithOptions(shared_ptr<UpdateGtmRecoveryPlanRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateGtmRecoveryPlanResponse updateGtmRecoveryPlan(shared_ptr<UpdateGtmRecoveryPlanRequest> request);
  UpdateIspFlushCacheInstanceConfigResponse updateIspFlushCacheInstanceConfigWithOptions(shared_ptr<UpdateIspFlushCacheInstanceConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateIspFlushCacheInstanceConfigResponse updateIspFlushCacheInstanceConfig(shared_ptr<UpdateIspFlushCacheInstanceConfigRequest> request);
  ValidateDnsGtmCnameRrCanUseResponse validateDnsGtmCnameRrCanUseWithOptions(shared_ptr<ValidateDnsGtmCnameRrCanUseRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ValidateDnsGtmCnameRrCanUseResponse validateDnsGtmCnameRrCanUse(shared_ptr<ValidateDnsGtmCnameRrCanUseRequest> request);
  ValidatePdnsUdpIpSegmentResponse validatePdnsUdpIpSegmentWithOptions(shared_ptr<ValidatePdnsUdpIpSegmentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ValidatePdnsUdpIpSegmentResponse validatePdnsUdpIpSegment(shared_ptr<ValidatePdnsUdpIpSegmentRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Alidns20150109

#endif
